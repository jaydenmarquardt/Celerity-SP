"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pnpmSyncCopyAsync = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
/**
 * For each library project that acts as an injected dependency of other consuming projects
 * within a PNPM workspace, this operation should be invoked whenever that library is rebuilt.
 * It will copy the latest build output into the `node_modules` installation folder.
 *
 * @remarks
 * This operation reads the `.npm-sync.json` file which should have been prepared after
 * `pnpm install` by calling the {@link pnpmSyncPrepareAsync} function.
 *
 * @param pnpmSyncJsonPath - optionally customizes the location of the `.pnpm-sync.json` file
 *
 * @beta
 */
async function pnpmSyncCopyAsync({ pnpmSyncJsonPath = '', getPackageIncludedFiles, forEachAsyncWithConcurrency, ensureFolder }) {
    if (pnpmSyncJsonPath === '') {
        // if user does not input .pnpm-sync.json file path
        // then we assume .pnpm-sync.json is always under node_modules folder
        pnpmSyncJsonPath = 'node_modules/.pnpm-sync.json';
    }
    let pnpmSyncJsonContents;
    try {
        pnpmSyncJsonContents = (await fs_1.default.promises.readFile(pnpmSyncJsonPath)).toString();
    }
    catch (e) {
        if (e.code === 'ENOENT') {
            console.warn('You are executing pnpm-sync for a package, but we can not find the .pnpm-sync.json inside node_modules folder');
            return;
        }
        else {
            throw e;
        }
    }
    //read the .pnpm-sync.json
    const pnpmSyncJson = JSON.parse(pnpmSyncJsonContents);
    const { sourceFolder, targetFolders } = pnpmSyncJson.postbuildInjectedCopy;
    const sourcePath = path_1.default.resolve(pnpmSyncJsonPath, sourceFolder);
    //get npmPackFiles
    const npmPackFiles = await getPackageIncludedFiles(sourcePath);
    console.time(`pnpm-sync => ${sourcePath}, total ${npmPackFiles.length} files`);
    //clear the destination folder first
    for (const targetFolder of targetFolders) {
        const destinationPath = path_1.default.resolve(pnpmSyncJsonPath, targetFolder.folderPath);
        await fs_1.default.promises.rm(destinationPath, { recursive: true, force: true });
    }
    await forEachAsyncWithConcurrency(npmPackFiles, async (npmPackFile) => {
        for (const targetFolder of targetFolders) {
            const destinationPath = path_1.default.resolve(pnpmSyncJsonPath, targetFolder.folderPath);
            const copySourcePath = path_1.default.join(sourcePath, npmPackFile);
            const copyDestinationPath = path_1.default.join(destinationPath, npmPackFile);
            await ensureFolder(path_1.default.dirname(copyDestinationPath));
            // create a hard link to the destination path
            await fs_1.default.promises.link(copySourcePath, copyDestinationPath);
        }
    }, {
        concurrency: 10
    });
    console.timeEnd(`pnpm-sync => ${sourcePath}, total ${npmPackFiles.length} files`);
}
exports.pnpmSyncCopyAsync = pnpmSyncCopyAsync;
//# sourceMappingURL=pnpmSyncCopy.js.map