"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pnpmSyncPrepareAsync = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const process_1 = require("process");
/**
 * For each workspace project has injected dependencies in a PNPM workspace, this API
 * should be invoked to prepare its `pnpm-sync.json` file.  While building projects,
 * that file will be used by {@link pnpmSyncCopyAsync} to recopy the build outputs into
 * injected dependency installation folders under the `node_modules` folder.
 *
 * @param lockfile - the path to the `pnpm-lock.yaml` file
 * @param store - the path to the PNPM store folder
 *
 * @beta
 */
async function pnpmSyncPrepareAsync({ lockfilePath, storePath, readPnpmLockfile }) {
    var _a;
    console.log('Generate pnpm-sync.json ...');
    // get the pnpm-lock.yaml path
    lockfilePath = path_1.default.resolve((0, process_1.cwd)(), lockfilePath);
    storePath = path_1.default.resolve((0, process_1.cwd)(), storePath);
    console.log('The pnpm-lock.yaml file path =>', lockfilePath);
    console.log('The .pnpm folder path =>', storePath);
    if (!fs_1.default.existsSync(lockfilePath)) {
        throw Error('The input pnpm-lock.yaml path is not correct!');
    }
    console.time(`pnpm-sync prepare`);
    // read the pnpm-lock.yaml
    const pnpmLockfile = await readPnpmLockfile(lockfilePath, {
        ignoreIncompatible: true
    });
    // find injected dependency and all its available versions
    const injectedDependencyToVersion = getInjectedDependencyToVersion(pnpmLockfile);
    // get pnpm-lock.yaml folder path
    const pnpmLockFolder = lockfilePath.slice(0, lockfilePath.length - 'pnpm-lock.yaml'.length);
    // generate a map, where key is the actual path of the injectedDependency, value is all available paths in .pnpm folder
    const injectedDependencyToFilePathSet = new Map();
    for (const [injectedDependency, injectedDependencyVersionSet] of injectedDependencyToVersion) {
        for (const injectedDependencyVersion of injectedDependencyVersionSet) {
            // this logic is heavily depends on pnpm-lock formate
            // the current logic is for pnpm v8
            // for example: file:../../libraries/lib1(react@16.0.0) -> ../../libraries/lib1
            let injectedDependencyPath = injectedDependencyVersion.split('(')[0].slice('file:'.length);
            injectedDependencyPath = path_1.default.resolve(pnpmLockFolder, injectedDependencyPath);
            if (!injectedDependencyToFilePathSet.has(injectedDependencyPath)) {
                injectedDependencyToFilePathSet.set(injectedDependencyPath, new Set());
            }
            (_a = injectedDependencyToFilePathSet
                .get(injectedDependencyPath)) === null || _a === void 0 ? void 0 : _a.add(transferFilePathToPnpmStorePath(injectedDependencyVersion, injectedDependency, storePath));
        }
    }
    // now, we have everything we need to generate the the pnpm-sync.json
    // console.log('injectedDependencyToFilePathSet =>', injectedDependencyToFilePathSet);
    for (const [projectFolder, targetFolderSet] of injectedDependencyToFilePathSet) {
        if (targetFolderSet.size === 0) {
            continue;
        }
        // make sure the node_modules folder exists
        if (!fs_1.default.existsSync(`${projectFolder}/node_modules`)) {
            continue;
        }
        const pnpmSyncJsonPath = `${projectFolder}/node_modules/.pnpm-sync.json`;
        let pnpmSyncJsonFile = {
            postbuildInjectedCopy: {
                sourceFolder: '../..',
                targetFolders: []
            }
        };
        // if .pnpm-sync.json already exists, read it first
        if (fs_1.default.existsSync(pnpmSyncJsonPath)) {
            pnpmSyncJsonFile = JSON.parse(fs_1.default.readFileSync(pnpmSyncJsonPath).toString());
        }
        const existingTargetFolderSet = new Set();
        for (const targetFolder of pnpmSyncJsonFile.postbuildInjectedCopy.targetFolders) {
            existingTargetFolderSet.add(targetFolder.folderPath);
        }
        for (const targetFolder of targetFolderSet) {
            const relativePath = path_1.default.relative(pnpmSyncJsonPath, targetFolder);
            if (!existingTargetFolderSet.has(relativePath)) {
                pnpmSyncJsonFile.postbuildInjectedCopy.targetFolders.push({
                    folderPath: relativePath
                });
            }
        }
        fs_1.default.writeFileSync(pnpmSyncJsonPath, JSON.stringify(pnpmSyncJsonFile, null, 2));
    }
    console.timeEnd(`pnpm-sync prepare`);
}
exports.pnpmSyncPrepareAsync = pnpmSyncPrepareAsync;
function transferFilePathToPnpmStorePath(rawFilePath, dependencyName, storePath) {
    // this logic is heavily depends on pnpm-lock format
    // the current logic is for pnpm v8
    // an example, file:../../libraries/lib1(react@16.0.0) -> file+..+..+libraries+lib1_react@16.9.0
    // 1. replace ':' with '+'
    rawFilePath = rawFilePath.replaceAll(':', '+');
    // 2. replace '/' with '+'
    rawFilePath = rawFilePath.replaceAll('/', '+');
    // 3. replace '(' with '_'
    rawFilePath = rawFilePath.replaceAll('(', '_');
    // 4. remove ')'
    rawFilePath = rawFilePath.replaceAll(')', '');
    // 5. add dependencyName
    rawFilePath = rawFilePath + `/node_modules/${dependencyName}`;
    rawFilePath = storePath + '/' + rawFilePath;
    return rawFilePath;
}
// process dependencies and devDependencies to generate injectedDependencyToFilePath
function getInjectedDependencyToVersion(pnpmLockfile) {
    var _a, _b, _c, _d, _e, _f;
    const injectedDependencyToVersion = new Map();
    for (const importerKey in pnpmLockfile === null || pnpmLockfile === void 0 ? void 0 : pnpmLockfile.importers) {
        if (!((_a = pnpmLockfile === null || pnpmLockfile === void 0 ? void 0 : pnpmLockfile.importers[importerKey]) === null || _a === void 0 ? void 0 : _a.dependenciesMeta)) {
            continue;
        }
        const dependenciesMeta = (_b = pnpmLockfile === null || pnpmLockfile === void 0 ? void 0 : pnpmLockfile.importers[importerKey]) === null || _b === void 0 ? void 0 : _b.dependenciesMeta;
        for (const dependency in dependenciesMeta) {
            if ((_c = dependenciesMeta[dependency]) === null || _c === void 0 ? void 0 : _c.injected) {
                if (!injectedDependencyToVersion.has(dependency)) {
                    injectedDependencyToVersion.set(dependency, new Set());
                }
            }
        }
        // based on https://pnpm.io/package_json#dependenciesmeta
        // the injected dependencies could available inside dependencies, optionalDependencies, and devDependencies.
        processDependencies((_d = pnpmLockfile === null || pnpmLockfile === void 0 ? void 0 : pnpmLockfile.importers[importerKey]) === null || _d === void 0 ? void 0 : _d.dependencies, injectedDependencyToVersion);
        processDependencies((_e = pnpmLockfile === null || pnpmLockfile === void 0 ? void 0 : pnpmLockfile.importers[importerKey]) === null || _e === void 0 ? void 0 : _e.devDependencies, injectedDependencyToVersion);
        processDependencies((_f = pnpmLockfile === null || pnpmLockfile === void 0 ? void 0 : pnpmLockfile.importers[importerKey]) === null || _f === void 0 ? void 0 : _f.optionalDependencies, injectedDependencyToVersion);
    }
    return injectedDependencyToVersion;
}
function processDependencies(dependencies, injectedDependencyToVersion) {
    var _a;
    if (dependencies) {
        for (const [dependency, specifier] of Object.entries(dependencies)) {
            if (injectedDependencyToVersion.has(dependency)) {
                const specifierToUse = typeof specifier === 'string' ? specifier : specifier.version;
                (_a = injectedDependencyToVersion.get(dependency)) === null || _a === void 0 ? void 0 : _a.add(specifierToUse);
            }
        }
    }
}
//# sourceMappingURL=pnpmSyncPrepare.js.map