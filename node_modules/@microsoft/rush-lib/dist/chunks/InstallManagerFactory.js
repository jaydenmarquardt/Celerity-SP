"use strict";
exports.id = "InstallManagerFactory";
exports.ids = ["InstallManagerFactory"];
exports.modules = {

/***/ 171208:
/*!*****************************************************!*\
  !*** ./lib-esnext/logic/ApprovedPackagesChecker.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ApprovedPackagesChecker": () => (/* binding */ ApprovedPackagesChecker)
/* harmony export */ });
/* harmony import */ var _DependencySpecifier__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DependencySpecifier */ 68654);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

class ApprovedPackagesChecker {
    constructor(rushConfiguration) {
        this._rushConfiguration = rushConfiguration;
        this._approvedPackagesPolicy = this._rushConfiguration.approvedPackagesPolicy;
        this._filesAreOutOfDate = false;
        if (this._approvedPackagesPolicy.enabled) {
            this._updateApprovedPackagesPolicy();
        }
    }
    /**
     * If true, the files on disk are out of date.
     */
    get approvedPackagesFilesAreOutOfDate() {
        return this._filesAreOutOfDate;
    }
    /**
     * Examines the current dependencies for the projects specified in RushConfiguration,
     * and then adds them to the 'browser-approved-packages.json' and
     * 'nonbrowser-approved-packages.json' config files.  If these files don't exist,
     * they will be created.
     *
     * If the "approvedPackagesPolicy" feature is not enabled, then no action is taken.
     */
    rewriteConfigFiles() {
        const approvedPackagesPolicy = this._rushConfiguration.approvedPackagesPolicy;
        if (approvedPackagesPolicy.enabled) {
            approvedPackagesPolicy.browserApprovedPackages.saveToFile();
            approvedPackagesPolicy.nonbrowserApprovedPackages.saveToFile();
        }
    }
    _updateApprovedPackagesPolicy() {
        for (const rushProject of this._rushConfiguration.projects) {
            const packageJson = rushProject.packageJson;
            this._collectDependencies(packageJson.dependencies, this._approvedPackagesPolicy, rushProject);
            this._collectDependencies(packageJson.devDependencies, this._approvedPackagesPolicy, rushProject);
            this._collectDependencies(packageJson.peerDependencies, this._approvedPackagesPolicy, rushProject);
            this._collectDependencies(packageJson.optionalDependencies, this._approvedPackagesPolicy, rushProject);
        }
    }
    _collectDependencies(dependencies, approvedPackagesPolicy, rushProject) {
        if (dependencies) {
            for (const packageName of Object.keys(dependencies)) {
                let referencedPackageName = packageName;
                // Special handling for NPM package aliases such as this:
                //
                // "dependencies": {
                //   "alias-name": "npm:target-name@^1.2.3"
                // }
                const dependencySpecifier = new _DependencySpecifier__WEBPACK_IMPORTED_MODULE_0__.DependencySpecifier(packageName, dependencies[packageName]);
                if (dependencySpecifier.aliasTarget) {
                    // Use "target-name" instead of "alias-name"
                    referencedPackageName = dependencySpecifier.aliasTarget.packageName;
                }
                const scope = this._rushConfiguration.packageNameParser.getScope(referencedPackageName);
                // Make sure the scope isn't something like "@types" which should be ignored
                if (!approvedPackagesPolicy.ignoredNpmScopes.has(scope) && rushProject.reviewCategory) {
                    // Yes, add it to the list if it's not already there
                    let updated = false;
                    // By default we put everything in the browser file.  But if it already appears in the
                    // non-browser file, then use that instead.
                    if (approvedPackagesPolicy.nonbrowserApprovedPackages.getItemByName(referencedPackageName)) {
                        updated = approvedPackagesPolicy.nonbrowserApprovedPackages.addOrUpdatePackage(referencedPackageName, rushProject.reviewCategory);
                    }
                    else {
                        updated = approvedPackagesPolicy.browserApprovedPackages.addOrUpdatePackage(referencedPackageName, rushProject.reviewCategory);
                    }
                    this._filesAreOutOfDate = this._filesAreOutOfDate || updated;
                }
            }
        }
    }
}
//# sourceMappingURL=ApprovedPackagesChecker.js.map

/***/ }),

/***/ 611779:
/*!***************************************************!*\
  !*** ./lib-esnext/logic/InstallManagerFactory.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InstallManagerFactory": () => (/* binding */ InstallManagerFactory)
/* harmony export */ });
/* harmony import */ var _installManager_WorkspaceInstallManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./installManager/WorkspaceInstallManager */ 8735);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

class InstallManagerFactory {
    static async getInstallManagerAsync(rushConfiguration, rushGlobalFolder, purgeManager, options) {
        if (rushConfiguration.packageManager === 'pnpm' &&
            rushConfiguration.pnpmOptions &&
            rushConfiguration.pnpmOptions.useWorkspaces) {
            return new _installManager_WorkspaceInstallManager__WEBPACK_IMPORTED_MODULE_0__.WorkspaceInstallManager(rushConfiguration, rushGlobalFolder, purgeManager, options);
        }
        const rushInstallManagerModule = await Promise.all(/*! import() | RushInstallManager */[__webpack_require__.e("LinkManagerFactory"), __webpack_require__.e("RushInstallManager")]).then(__webpack_require__.bind(__webpack_require__, /*! ./installManager/RushInstallManager */ 108860));
        return new rushInstallManagerModule.RushInstallManager(rushConfiguration, rushGlobalFolder, purgeManager, options);
    }
}
//# sourceMappingURL=InstallManagerFactory.js.map

/***/ }),

/***/ 311000:
/*!*********************************************************!*\
  !*** ./lib-esnext/logic/ProjectImpactGraphGenerator.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ProjectImpactGraphGenerator": () => (/* binding */ ProjectImpactGraphGenerator)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var js_yaml__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! js-yaml */ 119793);
/* harmony import */ var js_yaml__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(js_yaml__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utilities_Stopwatch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utilities/Stopwatch */ 314318);
/* harmony import */ var _RushConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RushConstants */ 951904);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rushstack/terminal */ 569956);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_2__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.





/**
 * Default global excluded globs
 * Only used if the `<repository_root>/.mergequeueignore` does not exist
 */
const DEFAULT_GLOBAL_EXCLUDED_GLOBS = ['common/autoinstallers/**'];
async function tryReadFileLinesAsync(filePath) {
    let fileContents;
    try {
        fileContents = await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.readFileAsync(filePath);
    }
    catch (error) {
        if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.isNotExistError(error)) {
            throw error;
        }
    }
    if (fileContents) {
        return _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.Text.convertToLf(fileContents).split('\n');
    }
}
class ProjectImpactGraphGenerator {
    /**
     * Get repositoryRoot and load projects within the rush.json
     */
    constructor(terminal, rushConfiguration) {
        this._terminal = terminal;
        this._rushConfiguration = rushConfiguration;
        const { rushJsonFolder } = rushConfiguration;
        this._repositoryRoot = rushJsonFolder;
        this._projectImpactGraphFilePath = `${rushJsonFolder}/${_RushConstants__WEBPACK_IMPORTED_MODULE_3__.RushConstants.projectImpactGraphFilename}`;
    }
    /**
     * Load global excluded globs
     */
    async _loadGlobalExcludedGlobsAsync() {
        const filePath = `${this._repositoryRoot}/${_RushConstants__WEBPACK_IMPORTED_MODULE_3__.RushConstants.mergeQueueIgnoreFileName}`;
        return await tryReadFileLinesAsync(filePath);
    }
    /**
     * Load project excluded globs
     * @param projectRootRelativePath - project root relative path
     */
    async _tryLoadProjectExcludedGlobsAsync(projectRootRelativePath) {
        const filePath = `${this._repositoryRoot}/${projectRootRelativePath}/${_RushConstants__WEBPACK_IMPORTED_MODULE_3__.RushConstants.mergeQueueIgnoreFileName}`;
        const globs = await tryReadFileLinesAsync(filePath);
        if (globs) {
            for (let i = 0; i < globs.length; i++) {
                globs[i] = `${projectRootRelativePath}/${globs[i]}`;
            }
            return globs;
        }
    }
    /**
     * Core Logic: generate project-impact-graph.yaml
     */
    async generateAsync() {
        const stopwatch = _utilities_Stopwatch__WEBPACK_IMPORTED_MODULE_4__.Stopwatch.start();
        const [globalExcludedGlobs = DEFAULT_GLOBAL_EXCLUDED_GLOBS, projectEntries] = await Promise.all([
            this._loadGlobalExcludedGlobsAsync(),
            _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.Async.mapAsync(this._rushConfiguration.projects, async ({ packageName, consumingProjects, projectRelativeFolder }) => {
                const dependentList = [packageName];
                for (const consumingProject of consumingProjects) {
                    dependentList.push(consumingProject.packageName);
                }
                const projectImpactGraphProjectConfiguration = {
                    includedGlobs: [`${projectRelativeFolder}/**`],
                    dependentProjects: dependentList.sort()
                };
                const projectExcludedGlobs = await this._tryLoadProjectExcludedGlobsAsync(projectRelativeFolder);
                if (projectExcludedGlobs) {
                    projectImpactGraphProjectConfiguration.excludedGlobs = projectExcludedGlobs;
                }
                return [packageName, projectImpactGraphProjectConfiguration];
            }, { concurrency: 50 })
        ]);
        projectEntries.sort(([aName], [bName]) => aName.localeCompare(bName));
        const projects = Object.fromEntries(projectEntries);
        const content = { globalExcludedGlobs, projects };
        await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.writeFileAsync(this._projectImpactGraphFilePath, js_yaml__WEBPACK_IMPORTED_MODULE_1___default().safeDump(content));
        stopwatch.stop();
        this._terminal.writeLine();
        this._terminal.writeLine(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_2__.Colorize.green(`Generate project impact graph successfully. (${stopwatch.toString()})`));
    }
    async validateAsync() {
        // TODO: More validation other than just existence
        return await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.existsAsync(this._projectImpactGraphFilePath);
    }
}
//# sourceMappingURL=ProjectImpactGraphGenerator.js.map

/***/ }),

/***/ 876149:
/*!*****************************************************!*\
  !*** ./lib-esnext/logic/base/BaseInstallManager.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseInstallManager": () => (/* binding */ BaseInstallManager),
/* harmony export */   "pnpmIgnoreCompatibilityDbParameter": () => (/* binding */ pnpmIgnoreCompatibilityDbParameter)
/* harmony export */ });
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! os */ 822037);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! crypto */ 706113);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! semver */ 710912);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @rushstack/terminal */ 569956);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _ApprovedPackagesChecker__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../ApprovedPackagesChecker */ 171208);
/* harmony import */ var _api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../../api/EnvironmentConfiguration */ 382806);
/* harmony import */ var _Git__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../Git */ 668229);
/* harmony import */ var _api_LastInstallFlag__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../api/LastInstallFlag */ 919846);
/* harmony import */ var _api_LastLinkFlag__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../api/LastLinkFlag */ 986208);
/* harmony import */ var _api_Rush__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../../api/Rush */ 465002);
/* harmony import */ var _RushConstants__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../RushConstants */ 951904);
/* harmony import */ var _ShrinkwrapFileFactory__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../ShrinkwrapFileFactory */ 819779);
/* harmony import */ var _utilities_Utilities__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../utilities/Utilities */ 827501);
/* harmony import */ var _installManager_InstallHelpers__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../installManager/InstallHelpers */ 741340);
/* harmony import */ var _policy_PolicyValidator__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../policy/PolicyValidator */ 999291);
/* harmony import */ var _utilities_WebClient__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../../utilities/WebClient */ 618105);
/* harmony import */ var _setup_SetupPackageRegistry__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../setup/SetupPackageRegistry */ 555992);
/* harmony import */ var _pnpm_PnpmfileConfiguration__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../pnpm/PnpmfileConfiguration */ 238032);
/* harmony import */ var _utilities_npmrcUtilities__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../../utilities/npmrcUtilities */ 679877);
/* harmony import */ var _pnpm_SubspacePnpmfileConfiguration__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../pnpm/SubspacePnpmfileConfiguration */ 878898);
/* harmony import */ var _api_SubspacesConfiguration__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../api/SubspacesConfiguration */ 520090);
/* harmony import */ var _ProjectImpactGraphGenerator__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../ProjectImpactGraphGenerator */ 311000);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
























/**
 * Pnpm don't support --ignore-compatibility-db, so use --config.ignoreCompatibilityDb for now.
 */
const pnpmIgnoreCompatibilityDbParameter = '--config.ignoreCompatibilityDb';
const pnpmCacheDirParameter = '--config.cacheDir';
const pnpmStateDirParameter = '--config.stateDir';
const gitLfsHooks = new Set(['post-checkout', 'post-commit', 'post-merge', 'pre-push']);
/**
 * This class implements common logic between "rush install" and "rush update".
 */
class BaseInstallManager {
    constructor(rushConfiguration, rushGlobalFolder, purgeManager, options) {
        this._npmSetupValidated = false;
        this._syncNpmrcAlreadyCalled = false;
        this.rushConfiguration = rushConfiguration;
        this.rushGlobalFolder = rushGlobalFolder;
        this.installRecycler = purgeManager.commonTempFolderRecycler;
        this.options = options;
        this._commonTempLinkFlag = _api_LastLinkFlag__WEBPACK_IMPORTED_MODULE_6__.LastLinkFlagFactory.getCommonTempFlag(options.subspace);
        this.subspaceInstallFlags = new Map();
        if (rushConfiguration.subspacesFeatureEnabled) {
            for (const subspace of rushConfiguration.subspaces) {
                this.subspaceInstallFlags.set(subspace.subspaceName, _api_LastInstallFlag__WEBPACK_IMPORTED_MODULE_7__.LastInstallFlagFactory.getCommonTempFlag(rushConfiguration, subspace));
            }
        }
        this._terminalProvider = new _rushstack_terminal__WEBPACK_IMPORTED_MODULE_5__.ConsoleTerminalProvider();
        this._terminal = new _rushstack_terminal__WEBPACK_IMPORTED_MODULE_5__.Terminal(this._terminalProvider);
    }
    async doInstallAsync() {
        const { allowShrinkwrapUpdates } = this.options;
        const isFilteredInstall = this.options.pnpmFilterArguments.length > 0;
        const useWorkspaces = this.rushConfiguration.pnpmOptions && this.rushConfiguration.pnpmOptions.useWorkspaces;
        // Prevent filtered installs when workspaces is disabled
        if (isFilteredInstall && !useWorkspaces) {
            // eslint-disable-next-line no-console
            console.log();
            // eslint-disable-next-line no-console
            console.log(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_5__.Colorize.red('Project filtering arguments can only be used when running in a workspace environment. Run the ' +
                'command again without specifying these arguments.'));
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.AlreadyReportedError();
        }
        // Prevent update when using a filter, as modifications to the shrinkwrap shouldn't be saved
        if (allowShrinkwrapUpdates && isFilteredInstall) {
            // Allow partial update when there are subspace projects
            if (!this.rushConfiguration.subspacesFeatureEnabled) {
                // eslint-disable-next-line no-console
                console.log();
                // eslint-disable-next-line no-console
                console.log(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_5__.Colorize.red('Project filtering arguments cannot be used when running "rush update". Run the command again ' +
                    'without specifying these arguments.'));
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.AlreadyReportedError();
            }
        }
        const subspace = this.options.subspace;
        const projectImpactGraphGenerator = this.rushConfiguration
            .experimentsConfiguration.configuration.generateProjectImpactGraphDuringRushUpdate
            ? new _ProjectImpactGraphGenerator__WEBPACK_IMPORTED_MODULE_8__.ProjectImpactGraphGenerator(this._terminal, this.rushConfiguration)
            : undefined;
        const { shrinkwrapIsUpToDate, npmrcHash, projectImpactGraphIsUpToDate } = await this.prepareAsync(subspace, projectImpactGraphGenerator);
        if (this.options.checkOnly) {
            return;
        }
        // eslint-disable-next-line no-console
        console.log('\n' + _rushstack_terminal__WEBPACK_IMPORTED_MODULE_5__.Colorize.bold(`Checking installation in "${subspace.getSubspaceTempFolder()}"`));
        // This marker file indicates that the last "rush install" completed successfully.
        // Always perform a clean install if filter flags were provided. Additionally, if
        // "--purge" was specified, or if the last install was interrupted, then we will
        // need to perform a clean install.  Otherwise, we can do an incremental install.
        const commonTempInstallFlag = _api_LastInstallFlag__WEBPACK_IMPORTED_MODULE_7__.LastInstallFlagFactory.getCommonTempFlag(this.rushConfiguration, subspace, { npmrcHash: npmrcHash || '<NO NPMRC>' });
        const optionsToIgnore = !this.rushConfiguration.experimentsConfiguration
            .configuration.cleanInstallAfterNpmrcChanges
            ? ['npmrcHash'] // If the "cleanInstallAfterNpmrcChanges" experiment is disabled, ignore the npmrcHash
            : undefined;
        const cleanInstall = isFilteredInstall ||
            !commonTempInstallFlag.checkValidAndReportStoreIssues({
                rushVerb: allowShrinkwrapUpdates ? 'update' : 'install',
                statePropertiesToIgnore: optionsToIgnore
            });
        // Allow us to defer the file read until we need it
        const canSkipInstall = () => {
            // Based on timestamps, can we skip this install entirely?
            const outputStats = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.getStatistics(commonTempInstallFlag.path);
            return this.canSkipInstall(outputStats.mtime, subspace);
        };
        if (cleanInstall || !shrinkwrapIsUpToDate || !canSkipInstall() || !projectImpactGraphIsUpToDate) {
            // eslint-disable-next-line no-console
            console.log();
            await this.validateNpmSetup();
            let publishedRelease;
            try {
                publishedRelease = await this._checkIfReleaseIsPublished();
            }
            catch (_a) {
                // If the user is working in an environment that can't reach the registry,
                // don't bother them with errors.
            }
            if (publishedRelease === false) {
                // eslint-disable-next-line no-console
                console.log(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_5__.Colorize.yellow('Warning: This release of the Rush tool was unpublished; it may be unstable.'));
            }
            // Delete the successful install file to indicate the install transaction has started
            commonTempInstallFlag.clear();
            // Since we're going to be tampering with common/node_modules, delete the "rush link" flag file if it exists;
            // this ensures that a full "rush link" is required next time
            this._commonTempLinkFlag.clear();
            // Give plugins an opportunity to act before invoking the installation process
            if (this.options.beforeInstallAsync !== undefined) {
                await this.options.beforeInstallAsync();
            }
            await Promise.all([
                // Perform the actual install
                this.installAsync(cleanInstall, subspace),
                // If allowed, generate the project impact graph
                allowShrinkwrapUpdates ? projectImpactGraphGenerator === null || projectImpactGraphGenerator === void 0 ? void 0 : projectImpactGraphGenerator.generateAsync() : undefined
            ]);
            if (this.options.allowShrinkwrapUpdates && !shrinkwrapIsUpToDate) {
                // Copy (or delete) common\temp\pnpm-lock.yaml --> common\config\rush\pnpm-lock.yaml
                _utilities_Utilities__WEBPACK_IMPORTED_MODULE_9__.Utilities.syncFile(subspace.getTempShrinkwrapFilename(), subspace.getCommittedShrinkwrapFilename());
            }
            else {
                // TODO: Validate whether the package manager updated it in a nontrivial way
            }
            // Always update the state file if running "rush update"
            if (this.options.allowShrinkwrapUpdates) {
                if (subspace.getRepoState().refreshState(this.rushConfiguration, subspace)) {
                    // eslint-disable-next-line no-console
                    console.log(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_5__.Colorize.yellow(`${_RushConstants__WEBPACK_IMPORTED_MODULE_10__.RushConstants.repoStateFilename} has been modified and must be committed to source control.`));
                }
            }
        }
        else {
            // eslint-disable-next-line no-console
            console.log('Installation is already up-to-date.');
        }
        // Create the marker file to indicate a successful install if it's not a filtered install
        if (!isFilteredInstall) {
            commonTempInstallFlag.create();
        }
        // Perform any post-install work the install manager requires
        await this.postInstallAsync(subspace);
        // eslint-disable-next-line no-console
        console.log('');
    }
    canSkipInstall(lastModifiedDate, subspace) {
        // Based on timestamps, can we skip this install entirely?
        const potentiallyChangedFiles = [];
        // Consider the timestamp on the node_modules folder; if someone tampered with it
        // or deleted it entirely, then we can't skip this install
        potentiallyChangedFiles.push(path__WEBPACK_IMPORTED_MODULE_1__.join(subspace.getSubspaceTempFolder(), _RushConstants__WEBPACK_IMPORTED_MODULE_10__.RushConstants.nodeModulesFolderName));
        // Additionally, if they pulled an updated shrinkwrap file from Git,
        // then we can't skip this install
        potentiallyChangedFiles.push(subspace.getCommittedShrinkwrapFilename());
        // Add common-versions.json file to the potentially changed files list.
        potentiallyChangedFiles.push(subspace.getCommonVersionsFilePath());
        if (this.rushConfiguration.packageManager === 'pnpm') {
            // If the repo is using pnpmfile.js, consider that also
            const pnpmFileFilename = subspace.getPnpmfilePath();
            if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.exists(pnpmFileFilename)) {
                potentiallyChangedFiles.push(pnpmFileFilename);
            }
        }
        return _utilities_Utilities__WEBPACK_IMPORTED_MODULE_9__.Utilities.isFileTimestampCurrent(lastModifiedDate, potentiallyChangedFiles);
    }
    async prepareAsync(subspace, projectImpactGraphGenerator) {
        var _a, _b;
        const { allowShrinkwrapUpdates } = this.options;
        // Check the policies
        await _policy_PolicyValidator__WEBPACK_IMPORTED_MODULE_11__.validatePolicyAsync(this.rushConfiguration, subspace, this.options);
        this._installGitHooks();
        const approvedPackagesChecker = new _ApprovedPackagesChecker__WEBPACK_IMPORTED_MODULE_12__.ApprovedPackagesChecker(this.rushConfiguration);
        if (approvedPackagesChecker.approvedPackagesFilesAreOutOfDate) {
            approvedPackagesChecker.rewriteConfigFiles();
            if (allowShrinkwrapUpdates) {
                // eslint-disable-next-line no-console
                console.log(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_5__.Colorize.yellow('Approved package files have been updated. These updates should be committed to source control'));
            }
            else {
                throw new Error(`Approved packages files are out-of date. Run "rush update" to update them.`);
            }
        }
        // Ensure that the package manager is installed
        await _installManager_InstallHelpers__WEBPACK_IMPORTED_MODULE_13__.InstallHelpers.ensureLocalPackageManager(this.rushConfiguration, this.rushGlobalFolder, this.options.maxInstallAttempts);
        let shrinkwrapFile = undefined;
        // (If it's a full update, then we ignore the shrinkwrap from Git since it will be overwritten)
        if (!this.options.fullUpgrade) {
            const committedShrinkwrapFileName = subspace.getCommittedShrinkwrapFilename();
            try {
                shrinkwrapFile = _ShrinkwrapFileFactory__WEBPACK_IMPORTED_MODULE_14__.ShrinkwrapFileFactory.getShrinkwrapFile(this.rushConfiguration.packageManager, this.rushConfiguration.packageManagerOptions, committedShrinkwrapFileName);
            }
            catch (ex) {
                // eslint-disable-next-line no-console
                console.log();
                // eslint-disable-next-line no-console
                console.log(`Unable to load the ${this.rushConfiguration.shrinkwrapFilePhrase}: ${ex.message}`);
                if (!allowShrinkwrapUpdates) {
                    // eslint-disable-next-line no-console
                    console.log();
                    // eslint-disable-next-line no-console
                    console.log(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_5__.Colorize.red('You need to run "rush update" to fix this problem'));
                    throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.AlreadyReportedError();
                }
                shrinkwrapFile = undefined;
            }
        }
        const extraNpmrcLines = [];
        if (this.rushConfiguration.subspacesFeatureEnabled) {
            const subspaceEnvironmentVariable = _api_SubspacesConfiguration__WEBPACK_IMPORTED_MODULE_15__.SubspacesConfiguration._convertNameToEnvironmentVariable(subspace.subspaceName, (_b = (_a = this.rushConfiguration.subspacesConfiguration) === null || _a === void 0 ? void 0 : _a.splitWorkspaceCompatibility) !== null && _b !== void 0 ? _b : false);
            // Look for a global .npmrc-global file
            const globalNpmrcPath = `${this.rushConfiguration.commonRushConfigFolder}/.npmrc-global`;
            if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.exists(globalNpmrcPath)) {
                const globalNpmrcFileLines = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.readFile(globalNpmrcPath).toString().split('\n');
                extraNpmrcLines.push(...globalNpmrcFileLines);
            }
            // _RUSH_SUBSPACE_TEMP_FOLDER is used in .npmrc for subspaces.
            process.env[subspaceEnvironmentVariable] = subspace.getSubspaceTempFolder();
            extraNpmrcLines.push(`global-pnpmfile=\${${subspaceEnvironmentVariable}}/${_RushConstants__WEBPACK_IMPORTED_MODULE_10__.RushConstants.pnpmfileGlobalFilename}`);
        }
        // Also copy down the committed .npmrc file, if there is one
        // "common\config\rush\.npmrc" --> "common\temp\.npmrc"
        // Also ensure that we remove any old one that may be hanging around
        const npmrcText = _utilities_Utilities__WEBPACK_IMPORTED_MODULE_9__.Utilities.syncNpmrc(subspace.getSubspaceConfigFolder(), subspace.getSubspaceTempFolder(), undefined, undefined, extraNpmrcLines);
        this._syncNpmrcAlreadyCalled = true;
        const npmrcHash = npmrcText
            ? crypto__WEBPACK_IMPORTED_MODULE_2__.createHash('sha1').update(npmrcText).digest('hex')
            : undefined;
        if (this.rushConfiguration.packageManager === 'pnpm') {
            // Copy the committed patches folder if using pnpm
            const commonTempPnpmPatchesFolder = `${subspace.getSubspaceTempFolder()}/${_RushConstants__WEBPACK_IMPORTED_MODULE_10__.RushConstants.pnpmPatchesFolderName}`;
            const rushPnpmPatchesFolder = `${this.rushConfiguration.commonFolder}/${_RushConstants__WEBPACK_IMPORTED_MODULE_10__.RushConstants.pnpmPatchesCommonFolderName}`;
            let rushPnpmPatches;
            try {
                rushPnpmPatches = await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.readFolderItemsAsync(rushPnpmPatchesFolder);
            }
            catch (e) {
                if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.isNotExistError(e)) {
                    throw e;
                }
            }
            if (rushPnpmPatches) {
                await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.ensureFolderAsync(commonTempPnpmPatchesFolder);
                const existingPatches = await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.readFolderItemsAsync(commonTempPnpmPatchesFolder);
                const copiedPatchNames = new Set();
                await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.Async.forEachAsync(rushPnpmPatches, async (patch) => {
                    const name = patch.name;
                    const sourcePath = `${rushPnpmPatchesFolder}/${name}`;
                    if (patch.isFile()) {
                        await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.copyFileAsync({
                            sourcePath,
                            destinationPath: `${commonTempPnpmPatchesFolder}/${name}`
                        });
                        copiedPatchNames.add(name);
                    }
                    else {
                        throw new Error(`Unexpected non-file item found in ${rushPnpmPatchesFolder}: ${sourcePath}`);
                    }
                }, { concurrency: 50 });
                await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.Async.forEachAsync(existingPatches, async (patch) => {
                    const name = patch.name;
                    if (!copiedPatchNames.has(name)) {
                        await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.deleteFileAsync(`${commonTempPnpmPatchesFolder}/${name}`);
                    }
                }, { concurrency: 50 });
            }
            else {
                await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.deleteFolderAsync(commonTempPnpmPatchesFolder);
            }
        }
        // Shim support for pnpmfile in.
        // Additionally when in workspaces, the shim implements support for common versions.
        if (this.rushConfiguration.packageManager === 'pnpm') {
            await _pnpm_PnpmfileConfiguration__WEBPACK_IMPORTED_MODULE_16__.PnpmfileConfiguration.writeCommonTempPnpmfileShimAsync(this.rushConfiguration, subspace.getSubspaceTempFolder(), subspace);
            if (this.rushConfiguration.subspacesFeatureEnabled) {
                await _pnpm_SubspacePnpmfileConfiguration__WEBPACK_IMPORTED_MODULE_17__.SubspacePnpmfileConfiguration.writeCommonTempSubspaceGlobalPnpmfileAsync(this.rushConfiguration, subspace);
            }
        }
        // eslint-disable-next-line prefer-const
        let [{ shrinkwrapIsUpToDate, shrinkwrapWarnings }, projectImpactGraphIsUpToDate = true] = await Promise.all([
            // Allow for package managers to do their own preparation and check that the shrinkwrap is up to date
            this.prepareCommonTempAsync(subspace, shrinkwrapFile),
            projectImpactGraphGenerator === null || projectImpactGraphGenerator === void 0 ? void 0 : projectImpactGraphGenerator.validateAsync()
        ]);
        shrinkwrapIsUpToDate = shrinkwrapIsUpToDate && !this.options.recheckShrinkwrap;
        this._syncTempShrinkwrap(subspace, shrinkwrapFile);
        // Write out the reported warnings
        if (shrinkwrapWarnings.length > 0) {
            // eslint-disable-next-line no-console
            console.log();
            // eslint-disable-next-line no-console
            console.log(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_5__.Colorize.yellow(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_5__.PrintUtilities.wrapWords(`The ${this.rushConfiguration.shrinkwrapFilePhrase} contains the following issues:`)));
            for (const shrinkwrapWarning of shrinkwrapWarnings) {
                // eslint-disable-next-line no-console
                console.log(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_5__.Colorize.yellow('  ' + shrinkwrapWarning));
            }
            // eslint-disable-next-line no-console
            console.log();
        }
        let hasErrors = false;
        // Force update if the shrinkwrap is out of date
        if (!shrinkwrapIsUpToDate && !allowShrinkwrapUpdates) {
            this._terminal.writeErrorLine();
            this._terminal.writeErrorLine(`The ${this.rushConfiguration.shrinkwrapFilePhrase} is out of date. You need to run "rush update".`);
            hasErrors = true;
        }
        if (!projectImpactGraphIsUpToDate && !allowShrinkwrapUpdates) {
            hasErrors = true;
            this._terminal.writeErrorLine();
            this._terminal.writeErrorLine(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_5__.Colorize.red(`The ${_RushConstants__WEBPACK_IMPORTED_MODULE_10__.RushConstants.projectImpactGraphFilename} file is missing or out of date. You need to run "rush update".`));
        }
        if (hasErrors) {
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.AlreadyReportedError();
        }
        return { shrinkwrapIsUpToDate, npmrcHash, projectImpactGraphIsUpToDate };
    }
    /**
     * Git hooks are only installed if the repo opts in by including files in /common/git-hooks
     */
    _installGitHooks() {
        const hookSource = path__WEBPACK_IMPORTED_MODULE_1__.join(this.rushConfiguration.commonFolder, 'git-hooks');
        const git = new _Git__WEBPACK_IMPORTED_MODULE_18__.Git(this.rushConfiguration);
        const hookDestination = git.getHooksFolder();
        if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.exists(hookSource) && hookDestination) {
            const allHookFilenames = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.readFolderItemNames(hookSource);
            // Ignore the ".sample" file(s) in this folder.
            const hookFilenames = allHookFilenames.filter((x) => !/\.sample$/.test(x));
            if (hookFilenames.length > 0) {
                // eslint-disable-next-line no-console
                console.log('\n' + _rushstack_terminal__WEBPACK_IMPORTED_MODULE_5__.Colorize.bold('Found files in the "common/git-hooks" folder.'));
                if (!git.isHooksPathDefault()) {
                    const color = this.options.bypassPolicy ? _rushstack_terminal__WEBPACK_IMPORTED_MODULE_5__.Colorize.yellow : _rushstack_terminal__WEBPACK_IMPORTED_MODULE_5__.Colorize.red;
                    // eslint-disable-next-line no-console
                    console.error(color([
                        ' ',
                        `Rush cannot install the "common/git-hooks" scripts because your Git configuration `,
                        `specifies "core.hooksPath=${git.getConfigHooksPath()}". You can remove the setting by running:`,
                        ' ',
                        '    git config --unset core.hooksPath',
                        ' '
                    ].join('\n')));
                    if (this.options.bypassPolicy) {
                        // If "--bypass-policy" is specified, skip installation of hooks because Rush doesn't
                        // own the hooks folder
                        return;
                    }
                    // eslint-disable-next-line no-console
                    console.error(color([
                        '(Or, to temporarily ignore this problem, invoke Rush with the ' +
                            `"${_RushConstants__WEBPACK_IMPORTED_MODULE_10__.RushConstants.bypassPolicyFlagLongName}" option.)`,
                        ' '
                    ].join('\n')));
                    throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.AlreadyReportedError();
                }
                // Clear the currently installed git hooks and install fresh copies
                _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.ensureEmptyFolder(hookDestination);
                // Find the relative path from Git hooks directory to the directory storing the actual scripts.
                const hookRelativePath = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.Path.convertToSlashes(path__WEBPACK_IMPORTED_MODULE_1__.relative(hookDestination, hookSource));
                // Only copy files that look like Git hook names
                const filteredHookFilenames = hookFilenames.filter((x) => /^[a-z\-]+/.test(x));
                for (const filename of filteredHookFilenames) {
                    const hookFilePath = `${hookSource}/${filename}`;
                    // Make sure the actual script in the hookSource directory has correct Linux compatible line endings
                    const originalHookFileContent = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.readFile(hookFilePath);
                    _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.writeFile(hookFilePath, originalHookFileContent, {
                        convertLineEndings: _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.NewlineKind.Lf
                    });
                    // Make sure the actual script in the hookSource directory has required permission bits
                    const originalPosixModeBits = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.getPosixModeBits(hookFilePath);
                    _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.changePosixModeBits(hookFilePath, 
                    // eslint-disable-next-line no-bitwise
                    originalPosixModeBits | _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.PosixModeBits.UserRead | _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.PosixModeBits.UserExecute);
                    const gitLfsHookHandling = gitLfsHooks.has(filename)
                        ? `
# Inspired by https://github.com/git-lfs/git-lfs/issues/2865#issuecomment-365742940
if command -v git-lfs &> /dev/null; then
  git lfs ${filename} "$@"
fi
`
                        : '';
                    const hookFileContent = `#!/bin/bash
set -e
SCRIPT_DIR="$( cd "$( dirname "\${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
SCRIPT_IMPLEMENTATION_PATH="$SCRIPT_DIR/${hookRelativePath}/${filename}"

if [[ -f "$SCRIPT_IMPLEMENTATION_PATH" ]]; then
  "$SCRIPT_IMPLEMENTATION_PATH" $@
else
  echo "The ${filename} Git hook no longer exists in your version of the repo. Run 'rush install' or 'rush update' to refresh your installed Git hooks." >&2
fi
${gitLfsHookHandling}
`;
                    // Create the hook file.  Important: For Bash scripts, the EOL must not be CRLF.
                    _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.writeFile(path__WEBPACK_IMPORTED_MODULE_1__.join(hookDestination, filename), hookFileContent, {
                        convertLineEndings: _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.NewlineKind.Lf
                    });
                    _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.changePosixModeBits(path__WEBPACK_IMPORTED_MODULE_1__.join(hookDestination, filename), 
                    // eslint-disable-next-line no-bitwise
                    _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.PosixModeBits.UserRead | _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.PosixModeBits.UserExecute);
                }
                // eslint-disable-next-line no-console
                console.log('Successfully installed these Git hook scripts: ' + filteredHookFilenames.join(', ') + '\n');
            }
        }
    }
    /**
     * Used when invoking the NPM tool.  Appends the common configuration options
     * to the command-line.
     */
    pushConfigurationArgs(args, options, subspace) {
        if (options.offline && this.rushConfiguration.packageManager !== 'pnpm') {
            throw new Error('The "--offline" parameter is only supported when using the PNPM package manager.');
        }
        if (this.rushConfiguration.packageManager === 'npm') {
            if (semver__WEBPACK_IMPORTED_MODULE_3__.lt(this.rushConfiguration.packageManagerToolVersion, '5.0.0')) {
                // NOTE:
                //
                // When using an npm version older than v5.0.0, we do NOT install optional dependencies for
                // Rush, because npm does not generate the shrinkwrap file consistently across platforms.
                //
                // Consider the "fsevents" package. This is a Mac specific package
                // which is an optional second-order dependency. Optional dependencies work by attempting to install
                // the package, but removes the package if the install failed.
                // This means that someone running generate on a Mac WILL have fsevents included in their shrinkwrap.
                // When someone using Windows attempts to install from the shrinkwrap, the install will fail.
                //
                // If someone generates the shrinkwrap using Windows, then fsevents will NOT be listed in the shrinkwrap.
                // When someone using Mac attempts to install from the shrinkwrap, they will NOT have the
                // optional dependency installed.
                //
                // This issue has been fixed as of npm v5.0.0: https://github.com/npm/npm/releases/tag/v5.0.0
                //
                // For more context, see https://github.com/microsoft/rushstack/issues/761#issuecomment-428689600
                args.push('--no-optional');
            }
            args.push('--cache', this.rushConfiguration.npmCacheFolder);
            args.push('--tmp', this.rushConfiguration.npmTmpFolder);
            if (options.collectLogFile) {
                args.push('--verbose');
            }
        }
        else if (this.rushConfiguration.packageManager === 'pnpm') {
            // Only explicitly define the store path if `pnpmStore` is using the default, or has been set to
            // 'local'.  If `pnpmStore` = 'global', then allow PNPM to use the system's default
            // path.  In all cases, this will be overridden by RUSH_PNPM_STORE_PATH
            if (this.rushConfiguration.pnpmOptions.pnpmStore === 'local' ||
                _api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_19__.EnvironmentConfiguration.pnpmStorePathOverride) {
                args.push('--store', this.rushConfiguration.pnpmOptions.pnpmStorePath);
                if (semver__WEBPACK_IMPORTED_MODULE_3__.gte(this.rushConfiguration.packageManagerToolVersion, '6.10.0')) {
                    args.push(`${pnpmCacheDirParameter}=${this.rushConfiguration.pnpmOptions.pnpmStorePath}`);
                    args.push(`${pnpmStateDirParameter}=${this.rushConfiguration.pnpmOptions.pnpmStorePath}`);
                }
            }
            const { pnpmVerifyStoreIntegrity } = _api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_19__.EnvironmentConfiguration;
            if (pnpmVerifyStoreIntegrity !== undefined) {
                args.push(`--verify-store-integrity`, `${pnpmVerifyStoreIntegrity}`);
            }
            const { configuration: experiments } = this.rushConfiguration.experimentsConfiguration;
            if (experiments.usePnpmFrozenLockfileForRushInstall && !options.allowShrinkwrapUpdates) {
                args.push('--frozen-lockfile');
                if (options.pnpmFilterArguments.length > 0 &&
                    Number.parseInt(this.rushConfiguration.packageManagerToolVersion, 10) >= 8 // PNPM Major version 8+
                ) {
                    // On pnpm@8, disable the "dedupe-peer-dependents" feature when doing a filtered CI install so that filters take effect.
                    args.push('--config.dedupe-peer-dependents=false');
                }
            }
            else if (experiments.usePnpmPreferFrozenLockfileForRushUpdate) {
                // In workspaces, we want to avoid unnecessary lockfile churn
                args.push('--prefer-frozen-lockfile');
            }
            else {
                // Ensure that Rush's tarball dependencies get synchronized properly with the pnpm-lock.yaml file.
                // See this GitHub issue: https://github.com/pnpm/pnpm/issues/1342
                args.push('--no-prefer-frozen-lockfile');
            }
            if (options.onlyShrinkwrap) {
                args.push(`--lockfile-only`);
            }
            if (options.collectLogFile) {
                args.push('--reporter', 'ndjson');
            }
            if (options.networkConcurrency) {
                args.push('--network-concurrency', options.networkConcurrency.toString());
            }
            if (options.offline) {
                args.push('--offline');
            }
            if (this.rushConfiguration.pnpmOptions.strictPeerDependencies === false) {
                args.push('--no-strict-peer-dependencies');
            }
            else {
                args.push('--strict-peer-dependencies');
            }
            /*
              If user set auto-install-peers in pnpm-config.json only, use the value in pnpm-config.json
              If user set auto-install-peers in pnpm-config.json and .npmrc, use the value in pnpm-config.json
              If user set auto-install-peers in .npmrc only, do nothing, let pnpm handle it
              If user does not set auto-install-peers in both pnpm-config.json and .npmrc, rush will default it to "false"
            */
            const isAutoInstallPeersInNpmrc = (0,_utilities_npmrcUtilities__WEBPACK_IMPORTED_MODULE_20__.isVariableSetInNpmrcFile)(subspace.getSubspaceConfigFolder(), 'auto-install-peers');
            let autoInstallPeers = this.rushConfiguration.pnpmOptions.autoInstallPeers;
            if (autoInstallPeers !== undefined) {
                if (isAutoInstallPeersInNpmrc) {
                    this._terminal.writeWarningLine(`Warning: PNPM's auto-install-peers is specified in both .npmrc and pnpm-config.json. ` +
                        `The value in pnpm-config.json will take precedence.`);
                }
            }
            else if (!isAutoInstallPeersInNpmrc) {
                // if auto-install-peers isn't specified in either .npmrc or pnpm-config.json,
                // then rush will default it to "false"
                autoInstallPeers = false;
            }
            if (autoInstallPeers !== undefined) {
                args.push(`--config.auto-install-peers=${autoInstallPeers}`);
            }
            /*
              If user set resolution-mode in pnpm-config.json only, use the value in pnpm-config.json
              If user set resolution-mode in pnpm-config.json and .npmrc, use the value in pnpm-config.json
              If user set resolution-mode in .npmrc only, do nothing, let pnpm handle it
              If user does not set resolution-mode in pnpm-config.json and .npmrc, rush will default it to "highest"
            */
            const isResolutionModeInNpmrc = (0,_utilities_npmrcUtilities__WEBPACK_IMPORTED_MODULE_20__.isVariableSetInNpmrcFile)(subspace.getSubspaceConfigFolder(), 'resolution-mode');
            let resolutionMode = this.rushConfiguration.pnpmOptions.resolutionMode;
            if (resolutionMode) {
                if (isResolutionModeInNpmrc) {
                    this._terminal.writeWarningLine(`Warning: PNPM's resolution-mode is specified in both .npmrc and pnpm-config.json. ` +
                        `The value in pnpm-config.json will take precedence.`);
                }
            }
            else if (!isResolutionModeInNpmrc) {
                // if resolution-mode isn't specified in either .npmrc or pnpm-config.json,
                // then rush will default it to "highest"
                resolutionMode = 'highest';
            }
            if (resolutionMode) {
                args.push(`--config.resolutionMode=${resolutionMode}`);
            }
            if (semver__WEBPACK_IMPORTED_MODULE_3__.satisfies(this.rushConfiguration.packageManagerToolVersion, '6.32.12 - 6.33.x || 7.0.1 - 7.8.x')) {
                this._terminal.writeWarningLine(`Warning: Your ${_RushConstants__WEBPACK_IMPORTED_MODULE_10__.RushConstants.rushJsonFilename} specifies a pnpmVersion with a known issue ` +
                    'that may cause unintended version selections.' +
                    " It's recommended to upgrade to PNPM >=6.34.0 or >=7.9.0. " +
                    'For details see: https://rushjs.io/link/pnpm-issue-5132');
            }
            if (semver__WEBPACK_IMPORTED_MODULE_3__.gte(this.rushConfiguration.packageManagerToolVersion, '7.9.0') ||
                semver__WEBPACK_IMPORTED_MODULE_3__.satisfies(this.rushConfiguration.packageManagerToolVersion, '^6.34.0')) {
                args.push(pnpmIgnoreCompatibilityDbParameter);
            }
        }
        else if (this.rushConfiguration.packageManager === 'yarn') {
            args.push('--link-folder', 'yarn-link');
            args.push('--cache-folder', this.rushConfiguration.yarnCacheFolder);
            // Without this option, Yarn will sometimes stop and ask for user input on STDIN
            // (e.g. "Which command would you like to run?").
            args.push('--non-interactive');
            if (options.networkConcurrency) {
                args.push('--network-concurrency', options.networkConcurrency.toString());
            }
            if (this.rushConfiguration.yarnOptions.ignoreEngines) {
                args.push('--ignore-engines');
            }
            if (options.collectLogFile) {
                args.push('--verbose');
            }
        }
    }
    async _checkIfReleaseIsPublished() {
        const lastCheckFile = path__WEBPACK_IMPORTED_MODULE_1__.join(this.rushGlobalFolder.nodeSpecificPath, 'rush-' + _api_Rush__WEBPACK_IMPORTED_MODULE_21__.Rush.version, 'last-check.flag');
        if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.exists(lastCheckFile)) {
            let cachedResult = undefined;
            try {
                // NOTE: mtimeMs is not supported yet in Node.js 6.x
                const nowMs = new Date().getTime();
                const ageMs = nowMs - _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.getStatistics(lastCheckFile).mtime.getTime();
                const HOUR = 60 * 60 * 1000;
                // Is the cache too old?
                if (ageMs < 24 * HOUR) {
                    // No, read the cached result
                    cachedResult = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.JsonFile.load(lastCheckFile);
                }
            }
            catch (e) {
                // Unable to parse file
            }
            if (cachedResult === 'error') {
                throw new Error('Unable to contact server');
            }
            if (cachedResult === true || cachedResult === false) {
                return cachedResult;
            }
        }
        // Before we start the network operation, record a failed state.  If the process exits for some reason,
        // this will record the error.  It will also update the timestamp to prevent other Rush instances
        // from attempting to update the file.
        await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.JsonFile.saveAsync('error', lastCheckFile, { ensureFolderExists: true });
        try {
            // For this check we use the official registry, not the private registry
            const publishedRelease = await this._queryIfReleaseIsPublishedAsync('https://registry.npmjs.org:443');
            // Cache the result
            await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.JsonFile.saveAsync(publishedRelease, lastCheckFile, { ensureFolderExists: true });
            return publishedRelease;
        }
        catch (error) {
            await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.JsonFile.saveAsync('error', lastCheckFile, { ensureFolderExists: true });
            throw error;
        }
    }
    // Helper for checkIfReleaseIsPublished()
    async _queryIfReleaseIsPublishedAsync(registryUrl) {
        let queryUrl = registryUrl;
        if (queryUrl[-1] !== '/') {
            queryUrl += '/';
        }
        // Note that the "@" symbol does not normally get URL-encoded
        queryUrl += _RushConstants__WEBPACK_IMPORTED_MODULE_10__.RushConstants.rushPackageName.replace('/', '%2F');
        const webClient = new _utilities_WebClient__WEBPACK_IMPORTED_MODULE_22__.WebClient();
        webClient.userAgent = `pnpm/? npm/? node/${process.version} ${os__WEBPACK_IMPORTED_MODULE_0__.platform()} ${os__WEBPACK_IMPORTED_MODULE_0__.arch()}`;
        webClient.accept = 'application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8, */*';
        const response = await webClient.fetchAsync(queryUrl);
        if (!response.ok) {
            throw new Error('Failed to query');
        }
        const data = await response.json();
        let url;
        try {
            if (!data.versions[_api_Rush__WEBPACK_IMPORTED_MODULE_21__.Rush.version]) {
                // Version was not published
                return false;
            }
            url = data.versions[_api_Rush__WEBPACK_IMPORTED_MODULE_21__.Rush.version].dist.tarball;
            if (!url) {
                throw new Error(`URL not found`);
            }
        }
        catch (e) {
            throw new Error('Error parsing response');
        }
        // Make sure the tarball wasn't deleted from the CDN
        webClient.accept = '*/*';
        const response2 = await webClient.fetchAsync(url);
        if (!response2.ok) {
            if (response2.status === 404) {
                return false;
            }
            else {
                throw new Error('Failed to fetch');
            }
        }
        return true;
    }
    _syncTempShrinkwrap(subspace, shrinkwrapFile) {
        const commitedShrinkwrapFileName = subspace.getCommittedShrinkwrapFilename();
        if (shrinkwrapFile) {
            _utilities_Utilities__WEBPACK_IMPORTED_MODULE_9__.Utilities.syncFile(commitedShrinkwrapFileName, subspace.getTempShrinkwrapFilename());
            _utilities_Utilities__WEBPACK_IMPORTED_MODULE_9__.Utilities.syncFile(commitedShrinkwrapFileName, subspace.getTempShrinkwrapPreinstallFilename());
        }
        else {
            // Otherwise delete the temporary file
            _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.deleteFile(subspace.getTempShrinkwrapFilename());
            if (this.rushConfiguration.packageManager === 'pnpm') {
                // Workaround for https://github.com/pnpm/pnpm/issues/1890
                //
                // When "rush update --full" is run, Rush deletes "common/temp/pnpm-lock.yaml"
                // so that a new lockfile will be generated. However "pnpm install" by design will try to recover
                // "pnpm-lock.yaml" from "common/temp/node_modules/.pnpm/lock.yaml", which may prevent a full upgrade.
                // Deleting both files ensures that a new lockfile will always be generated.
                const pnpmPackageManager = this.rushConfiguration
                    .packageManagerWrapper;
                _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.deleteFile(path__WEBPACK_IMPORTED_MODULE_1__.join(subspace.getSubspaceTempFolder(), pnpmPackageManager.internalShrinkwrapRelativePath));
            }
        }
    }
    async validateNpmSetup() {
        if (this._npmSetupValidated) {
            return;
        }
        if (!this.options.bypassPolicy) {
            const setupPackageRegistry = new _setup_SetupPackageRegistry__WEBPACK_IMPORTED_MODULE_23__.SetupPackageRegistry({
                rushConfiguration: this.rushConfiguration,
                isDebug: this.options.debug,
                syncNpmrcAlreadyCalled: this._syncNpmrcAlreadyCalled
            });
            const valid = await setupPackageRegistry.checkOnly();
            if (!valid) {
                // eslint-disable-next-line no-console
                console.error();
                // eslint-disable-next-line no-console
                console.error(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_5__.Colorize.red('ERROR: NPM credentials are missing or expired'));
                // eslint-disable-next-line no-console
                console.error();
                // eslint-disable-next-line no-console
                console.error(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_5__.Colorize.bold('==> Please run "rush setup" to update your NPM token. ' +
                    `(Or append "${_RushConstants__WEBPACK_IMPORTED_MODULE_10__.RushConstants.bypassPolicyFlagLongName}" to proceed anyway.)`));
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.AlreadyReportedError();
            }
        }
        this._npmSetupValidated = true;
    }
}
//# sourceMappingURL=BaseInstallManager.js.map

/***/ }),

/***/ 896704:
/*!****************************************************!*\
  !*** ./lib-esnext/logic/base/BaseWorkspaceFile.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseWorkspaceFile": () => (/* binding */ BaseWorkspaceFile)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

/**
 * This class is a parser for pnpm's pnpm-workspace.yaml file format.
 */
class BaseWorkspaceFile {
    constructor() {
        this._alreadyWarnedSpecs = new Set();
    }
    /**
     * Serializes and saves the workspace file to specified location
     */
    save(filePath, options) {
        // Do we need to read the previous file contents?
        let oldBuffer = undefined;
        if (options.onlyIfChanged && _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.exists(filePath)) {
            try {
                oldBuffer = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.readFileToBuffer(filePath);
            }
            catch (error) {
                // Ignore this error, and try writing a new file.  If that fails, then we should report that
                // error instead.
            }
        }
        const newYaml = this.serialize();
        const newBuffer = Buffer.from(newYaml); // utf8 encoding happens here
        if (options.onlyIfChanged) {
            // Has the file changed?
            if (oldBuffer && Buffer.compare(newBuffer, oldBuffer) === 0) {
                // Nothing has changed, so don't touch the file
                return;
            }
        }
        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.writeFile(filePath, newBuffer.toString(), {
            ensureFolderExists: options.ensureFolderExists
        });
    }
}
//# sourceMappingURL=BaseWorkspaceFile.js.map

/***/ }),

/***/ 8735:
/*!********************************************************************!*\
  !*** ./lib-esnext/logic/installManager/WorkspaceInstallManager.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WorkspaceInstallManager": () => (/* binding */ WorkspaceInstallManager)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! semver */ 710912);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _base_BaseInstallManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../base/BaseInstallManager */ 876149);
/* harmony import */ var _DependencySpecifier__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../DependencySpecifier */ 68654);
/* harmony import */ var _api_PackageJsonEditor__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../api/PackageJsonEditor */ 73666);
/* harmony import */ var _pnpm_PnpmWorkspaceFile__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../pnpm/PnpmWorkspaceFile */ 688477);
/* harmony import */ var _logic_RushConstants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../logic/RushConstants */ 951904);
/* harmony import */ var _utilities_Utilities__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../utilities/Utilities */ 827501);
/* harmony import */ var _InstallHelpers__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./InstallHelpers */ 741340);
/* harmony import */ var _api_LastLinkFlag__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../api/LastLinkFlag */ 986208);
/* harmony import */ var _api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../api/EnvironmentConfiguration */ 382806);
/* harmony import */ var _ShrinkwrapFileFactory__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../ShrinkwrapFileFactory */ 819779);
/* harmony import */ var _base_BaseProjectShrinkwrapFile__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../base/BaseProjectShrinkwrapFile */ 894306);
/* harmony import */ var _api_CustomTipsConfiguration__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../api/CustomTipsConfiguration */ 268756);
/* harmony import */ var _pnpm_PnpmShrinkwrapFile__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../pnpm/PnpmShrinkwrapFile */ 930997);
/* harmony import */ var _utilities_objectUtilities__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../utilities/objectUtilities */ 569609);
/* harmony import */ var pnpm_sync_lib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! pnpm-sync-lib */ 804988);
/* harmony import */ var pnpm_sync_lib__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(pnpm_sync_lib__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @rushstack/terminal */ 569956);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_4__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.



















/**
 * This class implements common logic between "rush install" and "rush update".
 */
class WorkspaceInstallManager extends _base_BaseInstallManager__WEBPACK_IMPORTED_MODULE_5__.BaseInstallManager {
    /**
     * @override
     */
    async doInstallAsync() {
        // TODO: Remove when "rush link" and "rush unlink" are deprecated
        if (this.options.noLink) {
            // eslint-disable-next-line no-console
            console.log(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_4__.Colorize.red('The "--no-link" option was provided but is not supported when using workspaces. Run the command again ' +
                'without specifying this argument.'));
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.AlreadyReportedError();
        }
        await super.doInstallAsync();
    }
    /**
     * Regenerates the common/temp/package.json and related workspace files.
     * If shrinkwrapFile is provided, this function also validates whether it contains
     * everything we need to install and returns true if so; in all other cases,
     * the return value is false.
     *
     * @override
     */
    async prepareCommonTempAsync(subspace, shrinkwrapFile) {
        // Block use of the RUSH_TEMP_FOLDER environment variable
        if (_api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_6__.EnvironmentConfiguration.rushTempFolderOverride !== undefined) {
            throw new Error('The RUSH_TEMP_FOLDER environment variable is not compatible with workspace installs. If attempting ' +
                'to move the PNPM store path, see the `RUSH_PNPM_STORE_PATH` environment variable.');
        }
        // eslint-disable-next-line no-console
        console.log('\n' + _rushstack_terminal__WEBPACK_IMPORTED_MODULE_4__.Colorize.bold('Updating workspace files in ' + subspace.getSubspaceTempFolder()));
        const shrinkwrapWarnings = [];
        // We will start with the assumption that it's valid, and then set it to false if
        // any of the checks fail
        let shrinkwrapIsUpToDate = true;
        if (!shrinkwrapFile) {
            shrinkwrapIsUpToDate = false;
        }
        else {
            if (!shrinkwrapFile.isWorkspaceCompatible && !this.options.fullUpgrade) {
                // eslint-disable-next-line no-console
                console.log();
                // eslint-disable-next-line no-console
                console.log(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_4__.Colorize.red('The shrinkwrap file has not been updated to support workspaces. Run "rush update --full" to update ' +
                    'the shrinkwrap file.'));
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.AlreadyReportedError();
            }
            // If there are orphaned projects, we need to update
            const orphanedProjects = shrinkwrapFile.findOrphanedProjects(this.rushConfiguration, subspace);
            if (orphanedProjects.length > 0) {
                for (const orphanedProject of orphanedProjects) {
                    shrinkwrapWarnings.push(`Your ${this.rushConfiguration.shrinkwrapFilePhrase} references "${orphanedProject}" ` +
                        `which was not found in ${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_7__.RushConstants.rushJsonFilename}`);
                }
                shrinkwrapIsUpToDate = false;
            }
        }
        // If preferred versions have been updated, or if the repo-state.json is invalid,
        // we can't be certain of the state of the shrinkwrap
        const repoState = subspace.getRepoState();
        if (!repoState.isValid) {
            shrinkwrapWarnings.push(`The ${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_7__.RushConstants.repoStateFilename} file is invalid. There may be a merge conflict marker in the file.`);
            shrinkwrapIsUpToDate = false;
        }
        else {
            const commonVersions = subspace.getCommonVersions();
            if (repoState.preferredVersionsHash !== commonVersions.getPreferredVersionsHash()) {
                shrinkwrapWarnings.push(`Preferred versions from ${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_7__.RushConstants.commonVersionsFilename} have been modified.`);
                shrinkwrapIsUpToDate = false;
            }
        }
        // To generate the workspace file, we will add each project to the file as we loop through and validate
        const workspaceFile = new _pnpm_PnpmWorkspaceFile__WEBPACK_IMPORTED_MODULE_8__.PnpmWorkspaceFile(path__WEBPACK_IMPORTED_MODULE_0__.join(subspace.getSubspaceTempFolder(), 'pnpm-workspace.yaml'));
        // For pnpm pacakge manager, we need to handle dependenciesMeta changes in package.json. See more: https://pnpm.io/package_json#dependenciesmeta
        // If dependenciesMeta settings is different between package.json and pnpm-lock.yaml, then shrinkwrapIsUpToDate return false.
        // Build a object for dependenciesMeta settings in projects' package.jsons
        // key is the package path, value is the dependenciesMeta info for that package
        const expectedDependenciesMetaByProjectRelativePath = {};
        const commonTempFolder = this.rushConfiguration.commonTempFolder;
        const rushJsonFolder = this.rushConfiguration.rushJsonFolder;
        // get the relative path from common temp folder to repo root folder
        const relativeFromTempFolderToRootFolder = path__WEBPACK_IMPORTED_MODULE_0__.relative(commonTempFolder, rushJsonFolder);
        // Loop through the projects and add them to the workspace file. While we're at it, also validate that
        // referenced workspace projects are valid, and check if the shrinkwrap file is already up-to-date.
        for (const rushProject of this.rushConfiguration.projects) {
            if (!subspace.contains(rushProject)) {
                // skip processing any project that isn't in this subspace
                continue;
            }
            const packageJson = rushProject.packageJsonEditor;
            workspaceFile.addPackage(rushProject.projectFolder);
            for (const { name, version, dependencyType } of [
                ...packageJson.dependencyList,
                ...packageJson.devDependencyList
            ]) {
                // Allow the package manager to handle peer dependency resolution, since this is simply a constraint
                // enforced by the package manager. Additionally, peer dependencies are simply a version constraint
                // and do not need to be converted to workspaces protocol.
                if (dependencyType === _api_PackageJsonEditor__WEBPACK_IMPORTED_MODULE_9__.DependencyType.Peer) {
                    continue;
                }
                const dependencySpecifier = new _DependencySpecifier__WEBPACK_IMPORTED_MODULE_10__.DependencySpecifier(name, version);
                // Is there a locally built Rush project that could satisfy this dependency?
                const referencedLocalProject = this.rushConfiguration.getProjectByName(name);
                // Validate that local projects are referenced with workspace notation. If not, and it is not a
                // cyclic dependency, then it needs to be updated to specify `workspace:*` explicitly. Currently only
                // supporting versions and version ranges for specifying a local project.
                if ((dependencySpecifier.specifierType === _DependencySpecifier__WEBPACK_IMPORTED_MODULE_10__.DependencySpecifierType.Version ||
                    dependencySpecifier.specifierType === _DependencySpecifier__WEBPACK_IMPORTED_MODULE_10__.DependencySpecifierType.Range) &&
                    referencedLocalProject &&
                    !rushProject.decoupledLocalDependencies.has(name)) {
                    // Make sure that this version is intended to target a local package. If not, then we will fail since it
                    // is not explicitly specified as a cyclic dependency.
                    if (!semver__WEBPACK_IMPORTED_MODULE_1__.satisfies(referencedLocalProject.packageJsonEditor.version, dependencySpecifier.versionSpecifier)) {
                        // eslint-disable-next-line no-console
                        console.log();
                        // eslint-disable-next-line no-console
                        console.log(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_4__.Colorize.red(`"${rushProject.packageName}" depends on package "${name}" (${version}) which exists ` +
                            'within the workspace but cannot be fulfilled with the specified version range. Either ' +
                            'specify a valid version range, or add the package as a cyclic dependency.'));
                        throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.AlreadyReportedError();
                    }
                    if (!this.options.allowShrinkwrapUpdates) {
                        // eslint-disable-next-line no-console
                        console.log();
                        // eslint-disable-next-line no-console
                        console.log(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_4__.Colorize.red(`"${rushProject.packageName}" depends on package "${name}" (${version}) which exists within ` +
                            'the workspace. Run "rush update" to update workspace references for this package.'));
                        throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.AlreadyReportedError();
                    }
                    if (this.options.fullUpgrade) {
                        // We will update to `workspace` notation. If the version specified is a range, then use the provided range.
                        // Otherwise, use `workspace:*` to ensure we're always using the workspace package.
                        const workspaceRange = !!semver__WEBPACK_IMPORTED_MODULE_1__.validRange(dependencySpecifier.versionSpecifier) &&
                            !semver__WEBPACK_IMPORTED_MODULE_1__.valid(dependencySpecifier.versionSpecifier)
                            ? dependencySpecifier.versionSpecifier
                            : '*';
                        packageJson.addOrUpdateDependency(name, `workspace:${workspaceRange}`, dependencyType);
                        shrinkwrapIsUpToDate = false;
                        continue;
                    }
                }
                else if (dependencySpecifier.specifierType === _DependencySpecifier__WEBPACK_IMPORTED_MODULE_10__.DependencySpecifierType.Workspace) {
                    // Already specified as a local project. Allow the package manager to validate this
                    continue;
                }
            }
            // Save the package.json if we modified the version references and warn that the package.json was modified
            if (packageJson.saveIfModified()) {
                // eslint-disable-next-line no-console
                console.log(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_4__.Colorize.yellow(`"${rushProject.packageName}" depends on one or more workspace packages which did not use "workspace:" ` +
                    'notation. The package.json has been modified and must be committed to source control.'));
            }
            // Now validate that the shrinkwrap file matches what is in the package.json
            if (await (shrinkwrapFile === null || shrinkwrapFile === void 0 ? void 0 : shrinkwrapFile.isWorkspaceProjectModifiedAsync(rushProject, subspace))) {
                shrinkwrapWarnings.push(`Dependencies of project "${rushProject.packageName}" do not match the current shrinkwrap.`);
                shrinkwrapIsUpToDate = false;
            }
            const dependencyMetaList = packageJson.dependencyMetaList;
            if (dependencyMetaList.length !== 0) {
                const dependenciesMeta = {};
                for (const dependencyMeta of dependencyMetaList) {
                    dependenciesMeta[dependencyMeta.name] = {
                        injected: dependencyMeta.injected
                    };
                }
                // get the relative path from common temp folder to package folder, to align with the value in pnpm-lock.yaml
                const relativePathFromTempFolderToPackageFolder = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.Path.convertToSlashes(`${relativeFromTempFolderToRootFolder}/${rushProject.projectRelativeFolder}`);
                expectedDependenciesMetaByProjectRelativePath[relativePathFromTempFolderToPackageFolder] =
                    dependenciesMeta;
            }
        }
        // Build a object for dependenciesMeta settings in pnpm-lock.yaml
        // key is the package path, value is the dependenciesMeta info for that package
        const lockfileDependenciesMetaByProjectRelativePath = {};
        if ((shrinkwrapFile === null || shrinkwrapFile === void 0 ? void 0 : shrinkwrapFile.importers) !== undefined) {
            for (const [key, value] of shrinkwrapFile === null || shrinkwrapFile === void 0 ? void 0 : shrinkwrapFile.importers) {
                if (value.dependenciesMeta !== undefined) {
                    lockfileDependenciesMetaByProjectRelativePath[_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.Path.convertToSlashes(key)] = value.dependenciesMeta;
                }
            }
        }
        // Now, we compare these two objects to see if they are equal or not
        const dependenciesMetaAreEqual = (0,_utilities_objectUtilities__WEBPACK_IMPORTED_MODULE_11__.objectsAreDeepEqual)(expectedDependenciesMetaByProjectRelativePath, lockfileDependenciesMetaByProjectRelativePath);
        if (!dependenciesMetaAreEqual) {
            shrinkwrapWarnings.push("The dependenciesMeta settings in one or more package.json don't match the current shrinkwrap.");
            shrinkwrapIsUpToDate = false;
        }
        // Write the common package.json
        _InstallHelpers__WEBPACK_IMPORTED_MODULE_12__.InstallHelpers.generateCommonPackageJson(this.rushConfiguration, subspace, undefined);
        // Save the generated workspace file. Don't update the file timestamp unless the content has changed,
        // since "rush install" will consider this timestamp
        workspaceFile.save(workspaceFile.workspaceFilename, { onlyIfChanged: true });
        return { shrinkwrapIsUpToDate, shrinkwrapWarnings };
    }
    canSkipInstall(lastModifiedDate, subspace) {
        if (!super.canSkipInstall(lastModifiedDate, subspace)) {
            return false;
        }
        const potentiallyChangedFiles = [];
        if (this.rushConfiguration.packageManager === 'pnpm') {
            // Add workspace file. This file is only modified when workspace packages change.
            const pnpmWorkspaceFilename = path__WEBPACK_IMPORTED_MODULE_0__.join(subspace.getSubspaceTempFolder(), 'pnpm-workspace.yaml');
            if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.exists(pnpmWorkspaceFilename)) {
                potentiallyChangedFiles.push(pnpmWorkspaceFilename);
            }
        }
        // Also consider timestamps for all the project node_modules folders, as well as the package.json
        // files
        // Example: [ "C:\MyRepo\projects\projectA\node_modules", "C:\MyRepo\projects\projectA\package.json" ]
        potentiallyChangedFiles.push(...this.rushConfiguration.projects.map((project) => {
            return path__WEBPACK_IMPORTED_MODULE_0__.join(project.projectFolder, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_7__.RushConstants.nodeModulesFolderName);
        }), ...this.rushConfiguration.projects.map((project) => {
            return path__WEBPACK_IMPORTED_MODULE_0__.join(project.projectFolder, _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileConstants.PackageJson);
        }));
        // NOTE: If any of the potentiallyChangedFiles does not exist, then isFileTimestampCurrent()
        // returns false.
        return _utilities_Utilities__WEBPACK_IMPORTED_MODULE_13__.Utilities.isFileTimestampCurrent(lastModifiedDate, potentiallyChangedFiles);
    }
    /**
     * Runs "pnpm install" in the common folder.
     */
    async installAsync(cleanInstall, subspace) {
        // Example: "C:\MyRepo\common\temp\npm-local\node_modules\.bin\npm"
        const packageManagerFilename = this.rushConfiguration.packageManagerToolFilename;
        const packageManagerEnv = _InstallHelpers__WEBPACK_IMPORTED_MODULE_12__.InstallHelpers.getPackageManagerEnvironment(this.rushConfiguration, this.options);
        if (_rushstack_terminal__WEBPACK_IMPORTED_MODULE_4__.ConsoleTerminalProvider.supportsColor) {
            packageManagerEnv.FORCE_COLOR = '1';
        }
        const commonNodeModulesFolder = path__WEBPACK_IMPORTED_MODULE_0__.join(subspace.getSubspaceTempFolder(), _logic_RushConstants__WEBPACK_IMPORTED_MODULE_7__.RushConstants.nodeModulesFolderName);
        // Is there an existing "node_modules" folder to consider?
        if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.exists(commonNodeModulesFolder)) {
            // Should we delete the entire "node_modules" folder?
            if (cleanInstall) {
                // YES: Delete "node_modules"
                // Explain to the user why we are hosing their node_modules folder
                // eslint-disable-next-line no-console
                console.log('Deleting files from ' + commonNodeModulesFolder);
                this.installRecycler.moveFolder(commonNodeModulesFolder);
                _utilities_Utilities__WEBPACK_IMPORTED_MODULE_13__.Utilities.createFolderWithRetry(commonNodeModulesFolder);
            }
        }
        const doInstallInternalAsync = async (options) => {
            // Run "npm install" in the common folder
            // To ensure that the output is always colored, set the option "--color=always", even when it's piped.
            // Without this argument, certain text that should be colored (such as red) will appear white.
            const installArgs = ['install'];
            this.pushConfigurationArgs(installArgs, options, subspace);
            // eslint-disable-next-line no-console
            console.log('\n' +
                _rushstack_terminal__WEBPACK_IMPORTED_MODULE_4__.Colorize.bold(`Running "${this.rushConfiguration.packageManager} install" in` +
                    ` ${subspace.getSubspaceTempFolder()}`) +
                '\n');
            // If any diagnostic options were specified, then show the full command-line
            if (this.options.debug ||
                this.options.collectLogFile ||
                this.options.networkConcurrency ||
                this.options.onlyShrinkwrap) {
                // eslint-disable-next-line no-console
                console.log('\n' +
                    _rushstack_terminal__WEBPACK_IMPORTED_MODULE_4__.Colorize.green('Invoking package manager: ') +
                    _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.getRealPath(packageManagerFilename) +
                    ' ' +
                    installArgs.join(' ') +
                    '\n');
            }
            // Store the tip IDs that should be printed.
            // They will be printed all at once *after* the install
            const tipIDsToBePrinted = new Set();
            const pnpmTips = [];
            for (const [customTipId, customTip] of Object.entries(_api_CustomTipsConfiguration__WEBPACK_IMPORTED_MODULE_14__.PNPM_CUSTOM_TIPS)) {
                if (this.rushConfiguration.customTipsConfiguration.providedCustomTipsByTipId.has(customTipId)) {
                    pnpmTips.push(customTip);
                }
            }
            const onPnpmStdoutChunk = pnpmTips.length > 0
                ? (chunk) => {
                    // Iterate over the supported custom tip metadata and try to match the chunk.
                    for (const { isMatch, tipId } of pnpmTips) {
                        if (isMatch === null || isMatch === void 0 ? void 0 : isMatch(chunk)) {
                            tipIDsToBePrinted.add(tipId);
                        }
                    }
                }
                : undefined;
            try {
                await _utilities_Utilities__WEBPACK_IMPORTED_MODULE_13__.Utilities.executeCommandAndProcessOutputWithRetryAsync({
                    command: packageManagerFilename,
                    args: installArgs,
                    workingDirectory: subspace.getSubspaceTempFolder(),
                    environment: packageManagerEnv,
                    suppressOutput: false
                }, this.options.maxInstallAttempts, onPnpmStdoutChunk, () => {
                    if (this.rushConfiguration.packageManager === 'pnpm') {
                        this._terminal.writeWarningLine(`Deleting the "node_modules" folder`);
                        this.installRecycler.moveFolder(commonNodeModulesFolder);
                        // Leave the pnpm-store as is for the retry. This ensures that packages that have already
                        // been downloaded need not be downloaded again, thereby potentially increasing the chances
                        // of a subsequent successful install.
                        _utilities_Utilities__WEBPACK_IMPORTED_MODULE_13__.Utilities.createFolderWithRetry(commonNodeModulesFolder);
                    }
                });
            }
            finally {
                // The try-finally is to avoid the tips NOT being printed if the install fails.
                // NOT catching the error because we want to keep the other behaviors (i.e., the error will be caught and handle in upper layers).
                if (tipIDsToBePrinted.size > 0) {
                    this._terminal.writeLine();
                    for (const tipID of tipIDsToBePrinted) {
                        this.rushConfiguration.customTipsConfiguration._showTip(this._terminal, tipID);
                    }
                }
            }
        };
        const { configuration: experiments } = this.rushConfiguration.experimentsConfiguration;
        if (this.options.allowShrinkwrapUpdates &&
            experiments.usePnpmLockfileOnlyThenFrozenLockfileForRushUpdate) {
            await doInstallInternalAsync(Object.assign(Object.assign({}, this.options), { onlyShrinkwrap: true }));
            await doInstallInternalAsync(Object.assign(Object.assign({}, this.options), { allowShrinkwrapUpdates: false }));
        }
        else {
            await doInstallInternalAsync(this.options);
        }
        // if usePnpmSyncForInjectedDependencies is true
        // the pnpm-sync will generate the pnpm-sync.json based on lockfile
        if (this.rushConfiguration.packageManager === 'pnpm' && (experiments === null || experiments === void 0 ? void 0 : experiments.usePnpmSyncForInjectedDependencies)) {
            const pnpmLockfilePath = subspace.getTempShrinkwrapFilename();
            const pnpmStorePath = `${this.rushConfiguration.commonTempFolder}/node_modules/.pnpm`;
            await (0,pnpm_sync_lib__WEBPACK_IMPORTED_MODULE_3__.pnpmSyncPrepareAsync)({
                lockfilePath: pnpmLockfilePath,
                storePath: pnpmStorePath,
                readPnpmLockfile: async (lockfilePath) => {
                    const wantedPnpmLockfile = await _pnpm_PnpmShrinkwrapFile__WEBPACK_IMPORTED_MODULE_15__.PnpmShrinkwrapFile.loadFromFile(lockfilePath, { withCaching: true });
                    if (!wantedPnpmLockfile) {
                        return undefined;
                    }
                    else {
                        const result = {
                            importers: Object.fromEntries(wantedPnpmLockfile.importers.entries())
                        };
                        return result;
                    }
                }
            });
        }
        // If all attempts fail we just terminate. No special handling needed.
        // Ensure that node_modules folders exist after install, since the timestamps on these folders are used
        // to determine if the install can be skipped
        const projectNodeModulesFolders = [
            path__WEBPACK_IMPORTED_MODULE_0__.join(subspace.getSubspaceTempFolder(), _logic_RushConstants__WEBPACK_IMPORTED_MODULE_7__.RushConstants.nodeModulesFolderName),
            ...this.rushConfiguration.projects.map((project) => {
                return path__WEBPACK_IMPORTED_MODULE_0__.join(project.projectFolder, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_7__.RushConstants.nodeModulesFolderName);
            })
        ];
        for (const nodeModulesFolder of projectNodeModulesFolders) {
            _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.ensureFolder(nodeModulesFolder);
        }
        // eslint-disable-next-line no-console
        console.log('');
    }
    async postInstallAsync(subspace) {
        var _a;
        // Grab the temp shrinkwrap, as this was the most recently completed install. It may also be
        // more up-to-date than the checked-in shrinkwrap since filtered installs are not written back.
        // Note that if there are no projects, or if we're in PNPM workspace mode and there are no
        // projects with dependencies, a lockfile won't be generated.
        const tempShrinkwrapFile = _ShrinkwrapFileFactory__WEBPACK_IMPORTED_MODULE_16__.ShrinkwrapFileFactory.getShrinkwrapFile(this.rushConfiguration.packageManager, this.rushConfiguration.pnpmOptions, subspace.getTempShrinkwrapFilename());
        if (tempShrinkwrapFile) {
            // Write or delete all project shrinkwraps related to the install
            await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.Async.forEachAsync(subspace.getProjects(), async (project) => {
                var _a;
                await ((_a = tempShrinkwrapFile.getProjectShrinkwrap(project)) === null || _a === void 0 ? void 0 : _a.updateProjectShrinkwrapAsync());
            }, { concurrency: 10 });
        }
        else if (this.rushConfiguration.packageManager === 'pnpm' &&
            ((_a = this.rushConfiguration.pnpmOptions) === null || _a === void 0 ? void 0 : _a.useWorkspaces)) {
            // If we're in PNPM workspace mode and PNPM didn't create a shrinkwrap file,
            // there are no dependencies. Generate empty shrinkwrap files for all projects.
            await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.Async.forEachAsync(subspace.getProjects(), async (project) => {
                await _base_BaseProjectShrinkwrapFile__WEBPACK_IMPORTED_MODULE_17__.BaseProjectShrinkwrapFile.saveEmptyProjectShrinkwrapFileAsync(project);
            }, { concurrency: 10 });
        }
        else {
            // This is an unexpected case
            throw new Error('A shrinkwrap file does not exist after after successful installation. This probably indicates a ' +
                'bug in the package manager.');
        }
        // TODO: Remove when "rush link" and "rush unlink" are deprecated
        _api_LastLinkFlag__WEBPACK_IMPORTED_MODULE_18__.LastLinkFlagFactory.getCommonTempFlag(subspace).create();
    }
    /**
     * Used when invoking the NPM tool.  Appends the common configuration options
     * to the command-line.
     */
    pushConfigurationArgs(args, options, subspace) {
        super.pushConfigurationArgs(args, options, subspace);
        // Add workspace-specific args
        if (this.rushConfiguration.packageManager === 'pnpm') {
            args.push('--recursive');
            args.push('--link-workspace-packages', 'false');
            if (process.stdout.isTTY) {
                // If we're on a TTY console and something else didn't set a `--reporter` parameter,
                // explicitly set the default reporter. This fixes an issue where, when the pnpm
                // output is being monitored to match custom tips, pnpm will detect a non-TTY
                // stdout stream and use the `append-only` reporter.
                //
                // See docs here: https://pnpm.io/cli/install#--reportername
                let includesReporterArg = false;
                for (const arg of args) {
                    if (arg.startsWith('--reporter')) {
                        includesReporterArg = true;
                        break;
                    }
                }
                if (!includesReporterArg) {
                    args.push('--reporter', 'default');
                }
            }
            for (const arg of this.options.pnpmFilterArguments) {
                args.push(arg);
            }
        }
    }
}
//# sourceMappingURL=WorkspaceInstallManager.js.map

/***/ }),

/***/ 688477:
/*!****************************************************!*\
  !*** ./lib-esnext/logic/pnpm/PnpmWorkspaceFile.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PnpmWorkspaceFile": () => (/* binding */ PnpmWorkspaceFile)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _base_BaseWorkspaceFile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/BaseWorkspaceFile */ 896704);
/* harmony import */ var _PnpmYamlCommon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PnpmYamlCommon */ 730862);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.




const yamlModule = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Import.lazy('js-yaml', require);
const globEscape = __webpack_require__(/*! glob-escape */ 475376); // No @types/glob-escape package exists
class PnpmWorkspaceFile extends _base_BaseWorkspaceFile__WEBPACK_IMPORTED_MODULE_2__.BaseWorkspaceFile {
    /**
     * The PNPM workspace file is used to specify the location of workspaces relative to the root
     * of your PNPM install.
     */
    constructor(workspaceYamlFilename) {
        super();
        this.workspaceFilename = workspaceYamlFilename;
        // Ignore any existing file since this file is generated and we need to handle deleting packages
        // If we need to support manual customization, that should be an additional parameter for "base file"
        this._workspacePackages = new Set();
    }
    /** @override */
    addPackage(packagePath) {
        // Ensure the path is relative to the pnpm-workspace.yaml file
        if (path__WEBPACK_IMPORTED_MODULE_0__.isAbsolute(packagePath)) {
            packagePath = path__WEBPACK_IMPORTED_MODULE_0__.relative(path__WEBPACK_IMPORTED_MODULE_0__.dirname(this.workspaceFilename), packagePath);
        }
        // Glob can't handle Windows paths
        const globPath = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Path.convertToSlashes(packagePath);
        this._workspacePackages.add(globEscape(globPath));
    }
    /** @override */
    serialize() {
        // Ensure stable sort order when serializing
        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Sort.sortSet(this._workspacePackages);
        const workspaceYaml = {
            packages: Array.from(this._workspacePackages)
        };
        return yamlModule.safeDump(workspaceYaml, _PnpmYamlCommon__WEBPACK_IMPORTED_MODULE_3__.PNPM_SHRINKWRAP_YAML_FORMAT);
    }
}
//# sourceMappingURL=PnpmWorkspaceFile.js.map

/***/ }),

/***/ 878898:
/*!****************************************************************!*\
  !*** ./lib-esnext/logic/pnpm/SubspacePnpmfileConfiguration.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SubspacePnpmfileConfiguration": () => (/* binding */ SubspacePnpmfileConfiguration)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utilities_PathConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utilities/PathConstants */ 287644);
/* harmony import */ var _RushConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../RushConstants */ 951904);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.




/**
 * Loads PNPM's pnpmfile.js configuration, and invokes it to preprocess package.json files,
 * optionally utilizing a pnpmfile shim to inject preferred versions.
 */
class SubspacePnpmfileConfiguration {
    /**
     * Split workspace use global pnpmfile, because in split workspace, user may set `shared-workspace-lockfile=false`.
     * That means each project owns their individual pnpmfile under project folder. While the global pnpmfile could be
     * under the common/temp-split/ folder and be used by all split workspace projects.
     */
    static async writeCommonTempSubspaceGlobalPnpmfileAsync(rushConfiguration, subspace) {
        if (rushConfiguration.packageManager !== 'pnpm') {
            throw new Error(`PnpmfileConfiguration cannot be used with package manager "${rushConfiguration.packageManager}"`);
        }
        const targetDir = subspace.getSubspaceTempFolder();
        const subspaceGlobalPnpmfilePath = path__WEBPACK_IMPORTED_MODULE_0__.join(targetDir, _RushConstants__WEBPACK_IMPORTED_MODULE_2__.RushConstants.pnpmfileGlobalFilename);
        // Write the shim itself
        await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.copyFileAsync({
            sourcePath: `${_utilities_PathConstants__WEBPACK_IMPORTED_MODULE_3__.scriptsFolderPath}/${_utilities_PathConstants__WEBPACK_IMPORTED_MODULE_3__.subspacePnpmfileShimFilename}`,
            destinationPath: subspaceGlobalPnpmfilePath
        });
        const subspaceGlobalPnpmfileShimSettings = SubspacePnpmfileConfiguration._getSubspacePnpmfileShimSettings(rushConfiguration, subspace);
        // Write the settings file used by the shim
        await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.JsonFile.saveAsync(subspaceGlobalPnpmfileShimSettings, path__WEBPACK_IMPORTED_MODULE_0__.join(targetDir, 'pnpmfileSettings.json'), {
            ensureFolderExists: true
        });
    }
    static _getSubspacePnpmfileShimSettings(rushConfiguration, subspace) {
        const workspaceProjects = {};
        const subspaceProjects = {};
        for (const project of rushConfiguration.projects) {
            const { packageName, projectRelativeFolder, packageJson } = project;
            const workspaceProjectInfo = {
                packageName,
                projectRelativeFolder,
                packageVersion: packageJson.version
            };
            (subspace.contains(project) ? subspaceProjects : workspaceProjects)[packageName] = workspaceProjectInfo;
        }
        const settings = {
            workspaceProjects,
            subspaceProjects,
            semverPath: _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Import.resolveModule({ modulePath: 'semver', baseFolderPath: __dirname })
        };
        // common/config/rush/.pnpmfile-split-workspace.cjs
        const userPnpmfilePath = path__WEBPACK_IMPORTED_MODULE_0__.join(subspace.getSubspaceConfigFolder(), rushConfiguration.packageManagerWrapper.subspacePnpmfileFilename);
        if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.exists(userPnpmfilePath)) {
            settings.userPnpmfilePath = userPnpmfilePath;
        }
        return settings;
    }
}
//# sourceMappingURL=SubspacePnpmfileConfiguration.js.map

/***/ })

};
;
//# sourceMappingURL=InstallManagerFactory.js.map