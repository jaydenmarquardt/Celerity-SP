"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getChildrenGapStyles: function() {
        return getChildrenGapStyles;
    },
    parseGap: function() {
        return parseGap;
    },
    parsePadding: function() {
        return parsePadding;
    }
});
const _react = require("@fluentui/react");
// Helper function that converts a themed spacing key (if given) to the corresponding themed spacing value.
const getThemedSpacing = (space, theme)=>{
    if (theme.spacing.hasOwnProperty(space)) {
        return theme.spacing[space];
    }
    return space;
};
// Helper function that takes a gap as a string and converts it into a { value, unit } representation.
const getValueUnitGap = (gap)=>{
    const numericalPart = parseFloat(gap);
    const numericalValue = isNaN(numericalPart) ? 0 : numericalPart;
    const numericalString = isNaN(numericalPart) ? '' : numericalPart.toString();
    const unitPart = gap.substring(numericalString.toString().length);
    return {
        value: numericalValue,
        unit: unitPart || 'px'
    };
};
const parseGap = (gap, theme)=>{
    if (gap === undefined || gap === '') {
        return {
            rowGap: {
                value: 0,
                unit: 'px'
            },
            columnGap: {
                value: 0,
                unit: 'px'
            }
        };
    }
    if (typeof gap === 'number') {
        return {
            rowGap: {
                value: gap,
                unit: 'px'
            },
            columnGap: {
                value: gap,
                unit: 'px'
            }
        };
    }
    const splitGap = gap.split(' ');
    // If the array has more than two values, then return 0px.
    if (splitGap.length > 2) {
        return {
            rowGap: {
                value: 0,
                unit: 'px'
            },
            columnGap: {
                value: 0,
                unit: 'px'
            }
        };
    }
    // If the array has two values, then parse each one.
    if (splitGap.length === 2) {
        return {
            rowGap: getValueUnitGap(getThemedSpacing(splitGap[0], theme)),
            columnGap: getValueUnitGap(getThemedSpacing(splitGap[1], theme))
        };
    }
    // Else, parse the numerical value and pass it as both the vertical and horizontal gap.
    const calculatedGap = getValueUnitGap(getThemedSpacing(gap, theme));
    return {
        rowGap: calculatedGap,
        columnGap: calculatedGap
    };
};
const parsePadding = (padding, theme)=>{
    if (padding === undefined || typeof padding === 'number' || padding === '') {
        return padding;
    }
    const paddingValues = padding.split(' ');
    if (paddingValues.length < 2) {
        return getThemedSpacing(padding, theme);
    }
    return paddingValues.reduce((padding1, padding2)=>{
        return getThemedSpacing(padding1, theme) + ' ' + getThemedSpacing(padding2, theme);
    });
};
const getChildrenGapStyles = (props)=>{
    const theme = (0, _react.getTheme)();
    const { horizontal, reversed } = props;
    const tokens = {
        ...props.tokens
    };
    const { rowGap, columnGap } = parseGap(tokens.childrenGap, theme);
    const horizontalMargin = `${-0.5 * columnGap.value}${columnGap.unit}`;
    const verticalMargin = `${-0.5 * rowGap.value}${rowGap.unit}`;
    return {
        root: [
            reversed && horizontal && {
                '> *:not(:last-child)': {
                    marginLeft: `${columnGap.value}${columnGap.unit}`
                }
            },
            reversed && !horizontal && {
                '> *:not(:last-child)': {
                    marginTop: `${rowGap.value}${rowGap.unit}`
                }
            },
            !reversed && horizontal && {
                '> *:not(:first-child)': {
                    marginLeft: `${columnGap.value}${columnGap.unit}`
                }
            },
            !reversed && !horizontal && {
                '> *:not(:first-child)': {
                    marginTop: `${rowGap.value}${rowGap.unit}`
                }
            }
        ],
        inner: [
            {
                marginLeft: horizontalMargin,
                marginRight: horizontalMargin,
                marginTop: verticalMargin,
                marginBottom: verticalMargin,
                width: columnGap.value === 0 ? '100%' : `calc(100% + ${columnGap.value}${columnGap.unit})`,
                '> *': {
                    margin: `${0.5 * rowGap.value}${rowGap.unit} ${0.5 * columnGap.value}${columnGap.unit}`
                }
            },
            horizontal && {
                height: rowGap.value === 0 ? '100%' : `calc(100% + ${rowGap.value}${rowGap.unit})`,
                '> *': {
                    maxWidth: columnGap.value === 0 ? '100%' : `calc(100% - ${columnGap.value}${columnGap.unit})`
                }
            },
            !horizontal && {
                height: `calc(100% + ${rowGap.value}${rowGap.unit})`,
                '> *': {
                    maxHeight: rowGap.value === 0 ? '100%' : `calc(100% - ${rowGap.value}${rowGap.unit})`
                }
            }
        ]
    };
};
