"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "StackShim", {
    enumerable: true,
    get: function() {
        return StackShim;
    }
});
const _interop_require_wildcard = require("@swc/helpers/_/_interop_require_wildcard");
const _react = require("@griffel/react");
const _react1 = require("@fluentui/react");
const _react2 = /*#__PURE__*/ _interop_require_wildcard._(require("react"));
const _stackUtils = require("./stackUtils");
const _StackShimstyles = require("./StackShim.styles");
const stackClassNames = {
    root: 'ms-Stack',
    inner: 'ms-Stack-inner'
};
const getClassNames = (0, _react1.classNamesFunction)();
const StackShim = (props)=>{
    const styles = (0, _StackShimstyles.useStackStyles)();
    const alignItemsFlexStyles = (0, _StackShimstyles.useFlexAlignItemsStyles)();
    const justifyContentFlexStyles = (0, _StackShimstyles.useFlexJustifyContentStyles)();
    const growFlexStyles = (0, _StackShimstyles.useFlexGrowStyles)();
    const { as: RootType = 'div', verticalFill, horizontal, reversed, grow, wrap, horizontalAlign, verticalAlign, disableShrink, className } = props;
    const tokens = {
        ...props.tokens
    };
    let tokensRootStyles = {};
    let tokensInnerStyles = {};
    let childrenGapClassName;
    if (tokens) {
        tokensRootStyles = {
            padding: !wrap ? tokens.padding : undefined,
            maxHeight: tokens.maxHeight,
            maxWidth: tokens.maxWidth
        };
        tokensInnerStyles = {
            padding: wrap ? tokens.padding : undefined
        };
        if (tokens.childrenGap) {
            childrenGapClassName = getClassNames(_stackUtils.getChildrenGapStyles, {
                horizontal,
                reversed,
                tokens
            });
        }
    }
    const stackStyles = [
        wrap ? styles.wrap : styles.root,
        horizontal && styles.horizontal,
        verticalFill && styles.verticalFill
    ];
    const stackInnerStyles = [
        styles.inner,
        horizontal && styles.horizontal,
        (!tokens || !tokens.childrenGap) && styles.innerWidth
    ];
    let stackChildren = _react2.Children.toArray(props.children);
    if (stackChildren.length === 1 && /*#__PURE__*/ _react2.isValidElement(stackChildren[0]) && stackChildren[0].type === _react2.Fragment) {
        stackChildren = stackChildren[0].props.children;
    }
    stackChildren = _react2.Children.map(stackChildren, (child)=>{
        if (!child) {
            return null;
        }
        if (child.type && child.type.name === 'StackItemShim') {
            const defaultItemProps = {
                shrink: !disableShrink
            };
            return /*#__PURE__*/ _react2.cloneElement(child, {
                ...defaultItemProps,
                ...child.props
            });
        }
        return child;
    });
    if (reversed) {
        if (horizontal) {
            stackStyles.push(styles.reversedHorizontal);
            stackInnerStyles.push(styles.reversedHorizontal);
        } else {
            stackStyles.push(styles.reversedVertical);
            stackInnerStyles.push(styles.reversedVertical);
        }
    }
    if (grow) {
        const flexGrow = grow === true ? growFlexStyles[1] : growFlexStyles[grow];
        stackStyles.push(flexGrow);
    }
    if (disableShrink) {
        stackStyles.push(styles.disableShrink);
    }
    if (horizontalAlign) {
        if (horizontal) {
            stackStyles.push(justifyContentFlexStyles[horizontalAlign]);
            stackInnerStyles.push(justifyContentFlexStyles[horizontalAlign]);
        } else {
            stackStyles.push(alignItemsFlexStyles[horizontalAlign]);
            stackInnerStyles.push(alignItemsFlexStyles[horizontalAlign]);
        }
    }
    if (verticalAlign) {
        if (horizontal) {
            stackStyles.push(alignItemsFlexStyles[verticalAlign]);
            stackInnerStyles.push(alignItemsFlexStyles[verticalAlign]);
        } else {
            stackStyles.push(justifyContentFlexStyles[verticalAlign]);
            stackInnerStyles.push(justifyContentFlexStyles[verticalAlign]);
        }
    }
    const rootClass = (0, _react.mergeClasses)(stackClassNames.root, ...stackStyles, childrenGapClassName && !wrap && childrenGapClassName.root, className);
    const innerClass = (0, _react.mergeClasses)(stackClassNames.inner, ...stackInnerStyles, childrenGapClassName && wrap && childrenGapClassName.inner);
    return wrap ? /*#__PURE__*/ _react2.createElement(RootType, {
        className: rootClass,
        style: tokensRootStyles
    }, /*#__PURE__*/ _react2.createElement("div", {
        className: innerClass,
        style: tokensInnerStyles
    }, stackChildren)) : /*#__PURE__*/ _react2.createElement(RootType, {
        className: rootClass,
        style: tokensRootStyles
    }, stackChildren);
};
