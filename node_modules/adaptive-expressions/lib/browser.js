(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.AEL = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

function __export(m) {
  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
__export(require("./expressionFunctions"));
__export(require("./constant"));
__export(require("./expression"));
__export(require("./expressionEvaluator"));
__export(require("./expressionType"));
__export(require("./extensions"));
__export(require("./timeZoneConverter"));
__export(require("./generated"));
__export(require("./commonRegex"));
__export(require("./options"));
__export(require("./parser"));
__export(require("./memory"));
__export(require("./regexErrorListener"));
__export(require("./datetimeFormatConverter"));
__export(require("./functionTable"));
__export(require("./converters"));
__export(require("./expressionProperties"));
var builtinFunctions_1 = require("./builtinFunctions");
exports.NumberTransformEvaluator = builtinFunctions_1.NumberTransformEvaluator;
exports.NumericEvaluator = builtinFunctions_1.NumericEvaluator;
exports.StringTransformEvaluator = builtinFunctions_1.StringTransformEvaluator;
exports.ComparisonEvaluator = builtinFunctions_1.ComparisonEvaluator;
exports.MultivariateNumericEvaluator = builtinFunctions_1.MultivariateNumericEvaluator;
exports.TimeTransformEvaluator = builtinFunctions_1.TimeTransformEvaluator;
__export(require("./functionUtils"));
__export(require("./returnType"));
__export(require("./localeInfo"));
__export(require("./triggerTrees"));

},{"./builtinFunctions":68,"./commonRegex":166,"./constant":167,"./converters":172,"./datetimeFormatConverter":178,"./expression":179,"./expressionEvaluator":180,"./expressionFunctions":181,"./expressionProperties":186,"./expressionType":192,"./extensions":193,"./functionTable":194,"./functionUtils":196,"./generated":199,"./localeInfo":200,"./memory":201,"./options":204,"./parser":209,"./regexErrorListener":212,"./returnType":213,"./timeZoneConverter":214,"./triggerTrees":216}],2:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionType_1 = require("../expressionType");
var numberTransformEvaluator_1 = require("./numberTransformEvaluator");
/**
 * Returns the absolute value of the specified number.
 */
var Abs = /*#__PURE__*/function (_numberTransformEvalu) {
  (0, _inherits2.default)(Abs, _numberTransformEvalu);
  var _super = _createSuper(Abs);
  /**
   * Initializes a new instance of the [Floor](xref:adaptive-expressions.Abs) class.
   */
  function Abs() {
    (0, _classCallCheck2.default)(this, Abs);
    return _super.call(this, expressionType_1.ExpressionType.Abs, Abs.func);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Abs, null, [{
    key: "func",
    value: function func(args) {
      return Math.abs(args[0]);
    }
  }]);
  return Abs;
}(numberTransformEvaluator_1.NumberTransformEvaluator);
exports.Abs = Abs;

},{"../expressionType":192,"./numberTransformEvaluator":107,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],3:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var simpleObjectMemory_1 = require("../memory/simpleObjectMemory");
var returnType_1 = require("../returnType");
/**
 * Used to access the variable value corresponding to the path.
 */
var Accessor = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Accessor, _expressionEvaluator_);
  var _super = _createSuper(Accessor);
  /**
   * Initializes a new instance of the [Accessor](xref:adaptive-expressions.Accessor) class.
   */
  function Accessor() {
    (0, _classCallCheck2.default)(this, Accessor);
    return _super.call(this, expressionType_1.ExpressionType.Accessor, Accessor.evaluator, returnType_1.ReturnType.Object, Accessor.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Accessor, null, [{
    key: "evaluator",
    value: function evaluator(expression, state, options) {
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.tryAccumulatePath(expression, state, options),
        path = _functionUtils_1$Func.path,
        left = _functionUtils_1$Func.left,
        error = _functionUtils_1$Func.error;
      if (error) {
        return {
          value: undefined,
          error: error
        };
      }
      if (left == null) {
        // fully converted to path, so we just delegate to memory scope
        return {
          value: functionUtils_internal_1.InternalFunctionUtils.wrapGetValue(state, path, options),
          error: undefined
        };
      } else {
        var _left$tryEvaluate = left.tryEvaluate(state, options),
          newScope = _left$tryEvaluate.value,
          err = _left$tryEvaluate.error;
        if (err) {
          return {
            value: undefined,
            error: err
          };
        }
        return {
          value: functionUtils_internal_1.InternalFunctionUtils.wrapGetValue(new simpleObjectMemory_1.SimpleObjectMemory(newScope), path, options),
          error: undefined
        };
      }
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      var children = expression.children;
      if (children.length === 0 || children[0].type !== expressionType_1.ExpressionType.Constant || children[0].returnType !== returnType_1.ReturnType.String) {
        throw new Error("".concat(expression, " must have a string as first argument."));
      }
      if (children.length > 2) {
        throw new Error("".concat(expression, " has more than 2 children."));
      }
      if (children.length === 2 && (children[1].returnType & returnType_1.ReturnType.Object) === 0) {
        throw new Error("".concat(expression, " must have an object as its second argument."));
      }
    }
  }]);
  return Accessor;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Accessor = Accessor;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../memory/simpleObjectMemory":202,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],4:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.number.max-safe-integer.js");
require("core-js/modules/es.number.constructor.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Return the result from adding two or more numbers (pure number case) or concatting two or more strings (other case).
 */
var Add = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Add, _expressionEvaluator_);
  var _super = _createSuper(Add);
  /**
   * Initializes a new instance of the [Add](xref:adaptive-expressions.Add) class.
   */
  function Add() {
    (0, _classCallCheck2.default)(this, Add);
    return _super.call(this, expressionType_1.ExpressionType.Add, Add.evaluator(), returnType_1.ReturnType.String | returnType_1.ReturnType.Number, Add.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Add, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.applySequenceWithError(function (args) {
        var value;
        var error;
        var stringConcat = !functionUtils_1.FunctionUtils.isNumber(args[0]) || !functionUtils_1.FunctionUtils.isNumber(args[1]);
        if (args[0] == null && functionUtils_1.FunctionUtils.isNumber(args[1]) || args[1] == null && functionUtils_1.FunctionUtils.isNumber(args[0])) {
          error = "Operator '+' or add cannot be applied to operands of type 'number' and null object.";
        } else if (stringConcat) {
          if (args[0] == null && args[1] == null) {
            value = '';
          } else if (args[0] == null) {
            value = args[1].toString();
          } else if (args[1] == null) {
            value = args[0].toString();
          } else {
            value = args[0].toString() + args[1].toString();
          }
        } else {
          value = args[0] + args[1];
        }
        return {
          value: value,
          error: error
        };
      }, functionUtils_1.FunctionUtils.verifyNumberOrStringOrNull);
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateArityAndAnyType(expression, 2, Number.MAX_SAFE_INTEGER, returnType_1.ReturnType.String | returnType_1.ReturnType.Number);
    }
  }]);
  return Add;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Add = Add;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.number.max-safe-integer.js":597,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.to-string.js":620}],5:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionType_1 = require("../expressionType");
var timeTransformEvaluator_1 = require("./timeTransformEvaluator");
/**
 * Add a number of days to a timestamp.
 */
var AddDays = /*#__PURE__*/function (_timeTransformEvaluat) {
  (0, _inherits2.default)(AddDays, _timeTransformEvaluat);
  var _super = _createSuper(AddDays);
  /**
   * Initializes a new instance of the [AddDays](xref:adaptive-expressions.AddDays) class.
   */
  function AddDays() {
    (0, _classCallCheck2.default)(this, AddDays);
    return _super.call(this, expressionType_1.ExpressionType.AddDays, function (ts, num) {
      var newDate = new Date(ts);
      newDate.setDate(ts.getDate() + num);
      return newDate;
    });
  }
  return (0, _createClass2.default)(AddDays);
}(timeTransformEvaluator_1.TimeTransformEvaluator);
exports.AddDays = AddDays;

},{"../expressionType":192,"./timeTransformEvaluator":145,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],6:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionType_1 = require("../expressionType");
var timeTransformEvaluator_1 = require("./timeTransformEvaluator");
/**
 * Add a number of hours to a timestamp.
 */
var AddHours = /*#__PURE__*/function (_timeTransformEvaluat) {
  (0, _inherits2.default)(AddHours, _timeTransformEvaluat);
  var _super = _createSuper(AddHours);
  /**
   * Initializes a new instance of the [AddHours](xref:adaptive-expressions.AddHours) class.
   */
  function AddHours() {
    (0, _classCallCheck2.default)(this, AddHours);
    return _super.call(this, expressionType_1.ExpressionType.AddHours, function (ts, num) {
      var newDate = new Date(ts);
      newDate.setHours(ts.getHours() + num);
      return newDate;
    });
  }
  return (0, _createClass2.default)(AddHours);
}(timeTransformEvaluator_1.TimeTransformEvaluator);
exports.AddHours = AddHours;

},{"../expressionType":192,"./timeTransformEvaluator":145,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],7:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionType_1 = require("../expressionType");
var timeTransformEvaluator_1 = require("./timeTransformEvaluator");
/**
 * Add a number of minutes to a timestamp.
 */
var AddMinutes = /*#__PURE__*/function (_timeTransformEvaluat) {
  (0, _inherits2.default)(AddMinutes, _timeTransformEvaluat);
  var _super = _createSuper(AddMinutes);
  /**
   * Initializes a new instance of the [AddMinutes](xref:adaptive-expressions.AddMinutes) class.
   */
  function AddMinutes() {
    (0, _classCallCheck2.default)(this, AddMinutes);
    return _super.call(this, expressionType_1.ExpressionType.AddMinutes, function (ts, num) {
      var newDate = new Date(ts);
      newDate.setMinutes(ts.getMinutes() + num);
      return newDate;
    });
  }
  return (0, _createClass2.default)(AddMinutes);
}(timeTransformEvaluator_1.TimeTransformEvaluator);
exports.AddMinutes = AddMinutes;

},{"../expressionType":192,"./timeTransformEvaluator":145,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],8:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Return the ordinal number of the input number.
 */
var AddOrdinal = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(AddOrdinal, _expressionEvaluator_);
  var _super = _createSuper(AddOrdinal);
  /**
   * Initializes a new instance of the [AddOrdinal](xref:adaptive-expressions.AddOrdinal) class.
   */
  function AddOrdinal() {
    (0, _classCallCheck2.default)(this, AddOrdinal);
    return _super.call(this, expressionType_1.ExpressionType.AddOrdinal, AddOrdinal.evaluator(), returnType_1.ReturnType.String, AddOrdinal.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(AddOrdinal, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        return AddOrdinal.evalAddOrdinal(args[0]);
      }, functionUtils_1.FunctionUtils.verifyInteger);
    }
    /**
     * @private
     */
  }, {
    key: "evalAddOrdinal",
    value: function evalAddOrdinal(num) {
      var hasResult = false;
      var ordinalResult = num.toString();
      if (num > 0) {
        switch (num % 100) {
          case 11:
          case 12:
          case 13:
            ordinalResult += 'th';
            hasResult = true;
            break;
          default:
            break;
        }
        if (!hasResult) {
          switch (num % 10) {
            case 1:
              ordinalResult += 'st';
              break;
            case 2:
              ordinalResult += 'nd';
              break;
            case 3:
              ordinalResult += 'rd';
              break;
            default:
              ordinalResult += 'th';
              break;
          }
        }
      }
      return ordinalResult;
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateArityAndAnyType(expression, 1, 1, returnType_1.ReturnType.Number);
    }
  }]);
  return AddOrdinal;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.AddOrdinal = AddOrdinal;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.to-string.js":620}],9:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Add a property and its value, or name-value pair, to a JSON object, and return the updated object.
 * If the object already exists at runtime the function throws an error.
 */
var AddProperty = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(AddProperty, _expressionEvaluator_);
  var _super = _createSuper(AddProperty);
  /**
   * Initializes a new instance of the [AddProperty](xref:adaptive-expressions.AddProperty) class.
   */
  function AddProperty() {
    (0, _classCallCheck2.default)(this, AddProperty);
    return _super.call(this, expressionType_1.ExpressionType.AddProperty, AddProperty.evaluator(), returnType_1.ReturnType.Object, AddProperty.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(AddProperty, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.applyWithError(function (args) {
        var error;
        var temp = args[0];
        var prop = String(args[1]);
        if (prop in temp) {
          error = "".concat(prop, " already exists");
        } else {
          temp[String(args[1])] = args[2];
        }
        return {
          value: temp,
          error: error
        };
      });
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateOrder(expression, undefined, returnType_1.ReturnType.Object, returnType_1.ReturnType.String, returnType_1.ReturnType.Object);
    }
  }]);
  return AddProperty;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.AddProperty = AddProperty;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],10:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionType_1 = require("../expressionType");
var timeTransformEvaluator_1 = require("./timeTransformEvaluator");
/**
 * Add a number of seconds to a timestamp.
 */
var AddSeconds = /*#__PURE__*/function (_timeTransformEvaluat) {
  (0, _inherits2.default)(AddSeconds, _timeTransformEvaluat);
  var _super = _createSuper(AddSeconds);
  /**
   * Initializes a new instance of the [AddSeconds](xref:adaptive-expressions.AddSeconds) class.
   */
  function AddSeconds() {
    (0, _classCallCheck2.default)(this, AddSeconds);
    return _super.call(this, expressionType_1.ExpressionType.AddSeconds, function (ts, num) {
      var newDate = new Date(ts);
      newDate.setSeconds(ts.getSeconds() + num);
      return newDate;
    });
  }
  return (0, _createClass2.default)(AddSeconds);
}(timeTransformEvaluator_1.TimeTransformEvaluator);
exports.AddSeconds = AddSeconds;

},{"../expressionType":192,"./timeTransformEvaluator":145,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],11:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.number.is-integer.js");
require("core-js/modules/es.number.constructor.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var dayjs_1 = __importDefault(require("dayjs"));
var utc_1 = __importDefault(require("dayjs/plugin/utc"));
dayjs_1.default.extend(utc_1.default);
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Add a number of time units to a timestamp.
 */
var AddToTime = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(AddToTime, _expressionEvaluator_);
  var _super = _createSuper(AddToTime);
  /**
   * Initializes a new instance of the [AddToTime](xref:adaptive-expressions.AddToTime) class.
   */
  function AddToTime() {
    (0, _classCallCheck2.default)(this, AddToTime);
    return _super.call(this, expressionType_1.ExpressionType.AddToTime, AddToTime.evaluator, returnType_1.ReturnType.String, AddToTime.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(AddToTime, null, [{
    key: "evaluator",
    value: function evaluator(expression, state, options) {
      var value;
      var locale = options.locale ? options.locale : Intl.DateTimeFormat().resolvedOptions().locale;
      var format = functionUtils_1.FunctionUtils.DefaultDateTimeFormat;
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expression, state, options),
        args = _functionUtils_1$Func.args,
        childrenError = _functionUtils_1$Func.error;
      var error = childrenError;
      if (!error) {
        var _functionUtils_1$Func2 = functionUtils_1.FunctionUtils.determineFormatAndLocale(args, 5, format, locale);
        format = _functionUtils_1$Func2.format;
        locale = _functionUtils_1$Func2.locale;
        if (typeof args[0] === 'string' && Number.isInteger(args[1]) && typeof args[2] === 'string') {
          var _AddToTime$evalAddToT = AddToTime.evalAddToTime(args[0], args[1], args[2], format, locale);
          value = _AddToTime$evalAddToT.value;
          error = _AddToTime$evalAddToT.error;
        } else {
          error = "".concat(expression, " should contain an ISO format timestamp, a time interval integer, a string unit of time and an optional output format string.");
        }
      }
      return {
        value: value,
        error: error
      };
    }
    /**
     * @private
     */
  }, {
    key: "evalAddToTime",
    value: function evalAddToTime(timeStamp, interval, timeUnit, format, locale) {
      var result;
      var error = functionUtils_internal_1.InternalFunctionUtils.verifyISOTimestamp(timeStamp);
      if (!error) {
        var _functionUtils_intern = functionUtils_internal_1.InternalFunctionUtils.timeUnitTransformer(interval, timeUnit),
          duration = _functionUtils_intern.duration,
          tsStr = _functionUtils_intern.tsStr;
        result = dayjs_1.default(timeStamp).locale(locale).utc().add(duration, tsStr).format(format);
      }
      return {
        value: result,
        error: error
      };
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateOrder(expression, [returnType_1.ReturnType.String, returnType_1.ReturnType.String], returnType_1.ReturnType.String, returnType_1.ReturnType.Number, returnType_1.ReturnType.String);
    }
  }]);
  return AddToTime;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.AddToTime = AddToTime;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.number.is-integer.js":595,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"dayjs":697,"dayjs/plugin/utc":700}],12:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Determines whether all elements of a sequence satisfy a condition.
 */
var All = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(All, _expressionEvaluator_);
  var _super = _createSuper(All);
  /**
   * Initializes a new instance of the [All](xref:adaptive-expressions.All) class.
   */
  function All() {
    (0, _classCallCheck2.default)(this, All);
    return _super.call(this, expressionType_1.ExpressionType.All, All.evaluator, returnType_1.ReturnType.Boolean, functionUtils_internal_1.InternalFunctionUtils.ValidateLambdaExpression);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(All, null, [{
    key: "evaluator",
    value: function evaluator(expression, state, options) {
      var result = true;
      var _expression$children$ = expression.children[0].tryEvaluate(state, options),
        instance = _expression$children$.value,
        childrenError = _expression$children$.error;
      var error = childrenError;
      if (!error) {
        var list = functionUtils_internal_1.InternalFunctionUtils.convertToList(instance);
        if (!list) {
          error = "".concat(expression.children[0], " is not a collection or structure object to run Any");
        } else {
          functionUtils_internal_1.InternalFunctionUtils.lambdaEvaluator(expression, state, options, list, function (currentItem, r, e) {
            if (e || !functionUtils_internal_1.InternalFunctionUtils.isLogicTrue(r)) {
              result = false;
              return true;
            }
            return false;
          });
        }
      }
      return {
        value: result,
        error: error
      };
    }
  }]);
  return All;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.All = All;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],13:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var options_1 = require("../options");
var returnType_1 = require("../returnType");
/**
 * Return true if all expressions are true or return false if at least one expression is false.
 */
var And = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(And, _expressionEvaluator_);
  var _super = _createSuper(And);
  /**
   * Initializes a new instance of the [And](xref:adaptive-expressions.And) class.
   */
  function And() {
    (0, _classCallCheck2.default)(this, And);
    return _super.call(this, expressionType_1.ExpressionType.And, And.evaluator, returnType_1.ReturnType.Boolean, functionUtils_1.FunctionUtils.validateAtLeastOne);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(And, null, [{
    key: "evaluator",
    value: function evaluator(expression, state, options) {
      var result = true;
      var error;
      var _iterator = _createForOfIteratorHelper(expression.children),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var child = _step.value;
          var newOptions = new options_1.Options(options);
          newOptions.nullSubstitution = undefined;
          var _child$tryEvaluate = child.tryEvaluate(state, newOptions);
          result = _child$tryEvaluate.value;
          error = _child$tryEvaluate.error;
          if (!error) {
            if (functionUtils_internal_1.InternalFunctionUtils.isLogicTrue(result)) {
              result = true;
            } else {
              result = false;
              break;
            }
          } else {
            result = false;
            error = undefined;
            break;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return {
        value: result,
        error: error
      };
    }
  }]);
  return And;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.And = And;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../options":204,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],14:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Determines whether any element of a sequence satisfies a condition.
 */
var Any = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Any, _expressionEvaluator_);
  var _super = _createSuper(Any);
  /**
   * Initializes a new instance of the [Any](xref:adaptive-expressions.Any) class.
   */
  function Any() {
    (0, _classCallCheck2.default)(this, Any);
    return _super.call(this, expressionType_1.ExpressionType.Any, Any.evaluator, returnType_1.ReturnType.Boolean, functionUtils_internal_1.InternalFunctionUtils.ValidateLambdaExpression);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Any, null, [{
    key: "evaluator",
    value: function evaluator(expression, state, options) {
      var result = false;
      var _expression$children$ = expression.children[0].tryEvaluate(state, options),
        instance = _expression$children$.value,
        childrenError = _expression$children$.error;
      var error = childrenError;
      if (!error) {
        var list = functionUtils_internal_1.InternalFunctionUtils.convertToList(instance);
        if (!list) {
          error = "".concat(expression.children[0], " is not a collection or structure object to run Any");
        } else {
          functionUtils_internal_1.InternalFunctionUtils.lambdaEvaluator(expression, state, options, list, function (currentItem, r, e) {
            if (!e && functionUtils_internal_1.InternalFunctionUtils.isLogicTrue(r)) {
              result = true;
              return true;
            }
            return false;
          });
        }
      }
      return {
        value: result,
        error: error
      };
    }
  }]);
  return Any;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Any = Any;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],15:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.object.to-string.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Return the average of a numeric array.
 */
var Average = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Average, _expressionEvaluator_);
  var _super = _createSuper(Average);
  /**
   * Initializes a new instance of the [Average](xref:adaptive-expressions.Average) class.
   */
  function Average() {
    (0, _classCallCheck2.default)(this, Average);
    return _super.call(this, expressionType_1.ExpressionType.Average, Average.evaluator(), returnType_1.ReturnType.Number, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Average, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        return args[0].reduce(function (x, y) {
          return x + y;
        }) / args[0].length;
      }, functionUtils_1.FunctionUtils.verifyNumericList);
    }
  }]);
  return Average;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Average = Average;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],16:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array-buffer.slice.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.typed-array.uint8-array.js");
require("core-js/modules/es.typed-array.copy-within.js");
require("core-js/modules/es.typed-array.every.js");
require("core-js/modules/es.typed-array.fill.js");
require("core-js/modules/es.typed-array.filter.js");
require("core-js/modules/es.typed-array.find.js");
require("core-js/modules/es.typed-array.find-index.js");
require("core-js/modules/es.typed-array.for-each.js");
require("core-js/modules/es.typed-array.includes.js");
require("core-js/modules/es.typed-array.index-of.js");
require("core-js/modules/es.typed-array.iterator.js");
require("core-js/modules/es.typed-array.join.js");
require("core-js/modules/es.typed-array.last-index-of.js");
require("core-js/modules/es.typed-array.map.js");
require("core-js/modules/es.typed-array.reduce.js");
require("core-js/modules/es.typed-array.reduce-right.js");
require("core-js/modules/es.typed-array.reverse.js");
require("core-js/modules/es.typed-array.set.js");
require("core-js/modules/es.typed-array.slice.js");
require("core-js/modules/es.typed-array.some.js");
require("core-js/modules/es.typed-array.sort.js");
require("core-js/modules/es.typed-array.subarray.js");
require("core-js/modules/es.typed-array.to-locale-string.js");
require("core-js/modules/es.typed-array.to-string.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
var btoa_lite_1 = __importDefault(require("btoa-lite"));
var functionUtils_internal_1 = require("../functionUtils.internal");
/**
 * Return the base64-encoded version of a string or byte array.
 */
var Base64 = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Base64, _expressionEvaluator_);
  var _super = _createSuper(Base64);
  /**
   * Initializes a new instance of the [Base64](xref:adaptive-expressions.Base64) class.
   */
  function Base64() {
    (0, _classCallCheck2.default)(this, Base64);
    return _super.call(this, expressionType_1.ExpressionType.Base64, Base64.evaluator(), returnType_1.ReturnType.String, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Base64, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        var result;
        var firstChild = args[0];
        if (typeof firstChild === 'string') {
          result = btoa_lite_1.default(firstChild);
        }
        if (firstChild instanceof Uint8Array) {
          var stringContent = functionUtils_internal_1.InternalFunctionUtils.getTextDecoder().decode(firstChild);
          result = btoa_lite_1.default(stringContent);
        }
        return result;
      });
    }
  }]);
  return Base64;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Base64 = Base64;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"btoa-lite":420,"core-js/modules/es.array-buffer.slice.js":568,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.typed-array.copy-within.js":641,"core-js/modules/es.typed-array.every.js":642,"core-js/modules/es.typed-array.fill.js":643,"core-js/modules/es.typed-array.filter.js":644,"core-js/modules/es.typed-array.find-index.js":645,"core-js/modules/es.typed-array.find.js":646,"core-js/modules/es.typed-array.for-each.js":649,"core-js/modules/es.typed-array.includes.js":650,"core-js/modules/es.typed-array.index-of.js":651,"core-js/modules/es.typed-array.iterator.js":655,"core-js/modules/es.typed-array.join.js":656,"core-js/modules/es.typed-array.last-index-of.js":657,"core-js/modules/es.typed-array.map.js":658,"core-js/modules/es.typed-array.reduce-right.js":659,"core-js/modules/es.typed-array.reduce.js":660,"core-js/modules/es.typed-array.reverse.js":661,"core-js/modules/es.typed-array.set.js":662,"core-js/modules/es.typed-array.slice.js":663,"core-js/modules/es.typed-array.some.js":664,"core-js/modules/es.typed-array.sort.js":665,"core-js/modules/es.typed-array.subarray.js":666,"core-js/modules/es.typed-array.to-locale-string.js":667,"core-js/modules/es.typed-array.to-string.js":668,"core-js/modules/es.typed-array.uint8-array.js":671}],17:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
var atob_lite_1 = __importDefault(require("atob-lite"));
/**
 * Return the binary array of a base64-encoded string.
 */
var Base64ToBinary = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Base64ToBinary, _expressionEvaluator_);
  var _super = _createSuper(Base64ToBinary);
  /**
   * Initializes a new instance of the [Base64ToBinary](xref:adaptive-expressions.Base64ToBinary) class.
   */
  function Base64ToBinary() {
    (0, _classCallCheck2.default)(this, Base64ToBinary);
    return _super.call(this, expressionType_1.ExpressionType.Base64ToBinary, Base64ToBinary.evaluator(), returnType_1.ReturnType.Object, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Base64ToBinary, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        var raw = atob_lite_1.default(args[0].toString());
        return functionUtils_internal_1.InternalFunctionUtils.getTextEncoder().encode(raw);
      }, functionUtils_1.FunctionUtils.verifyString);
    }
  }]);
  return Base64ToBinary;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Base64ToBinary = Base64ToBinary;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"atob-lite":417,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.to-string.js":620}],18:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
var atob_lite_1 = __importDefault(require("atob-lite"));
/**
 * Return the string version of a base64-encoded string, effectively decoding the base64 string.
 */
var Base64ToString = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Base64ToString, _expressionEvaluator_);
  var _super = _createSuper(Base64ToString);
  /**
   * Initializes a new instance of the [Base64ToString](xref:adaptive-expressions.Base64ToString) class.
   */
  function Base64ToString() {
    (0, _classCallCheck2.default)(this, Base64ToString);
    return _super.call(this, expressionType_1.ExpressionType.Base64ToString, Base64ToString.evaluator(), returnType_1.ReturnType.String, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Base64ToString, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        return atob_lite_1.default(args[0]);
      }, functionUtils_1.FunctionUtils.verifyString);
    }
  }]);
  return Base64ToString;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Base64ToString = Base64ToString;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"atob-lite":417,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],19:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Return the binary version of a string.
 */
var Binary = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Binary, _expressionEvaluator_);
  var _super = _createSuper(Binary);
  /**
   * Initializes a new instance of the [Binary](xref:adaptive-expressions.Binary) class.
   */
  function Binary() {
    (0, _classCallCheck2.default)(this, Binary);
    return _super.call(this, expressionType_1.ExpressionType.Binary, Binary.evaluator(), returnType_1.ReturnType.Object, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Binary, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        return functionUtils_internal_1.InternalFunctionUtils.getTextEncoder().encode(args[0]);
      }, functionUtils_1.FunctionUtils.verifyString);
    }
  }]);
  return Binary;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Binary = Binary;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],20:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.regexp.exec.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var comparisonEvaluator_1 = require("./comparisonEvaluator");
/**
 * Return the Boolean version of a value.
 */
var Bool = /*#__PURE__*/function (_comparisonEvaluator_) {
  (0, _inherits2.default)(Bool, _comparisonEvaluator_);
  var _super = _createSuper(Bool);
  /**
   * Initializes a new instance of the [Bool](xref:adaptive-expressions.Bool) class.
   */
  function Bool() {
    (0, _classCallCheck2.default)(this, Bool);
    return _super.call(this, expressionType_1.ExpressionType.Bool, Bool.func, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Bool, null, [{
    key: "func",
    value: function func(args) {
      if (functionUtils_1.FunctionUtils.isNumber(args[0])) {
        return args[0] !== 0;
      }
      if (/false/i.test(args[0])) {
        return false;
      }
      return functionUtils_internal_1.InternalFunctionUtils.isLogicTrue(args[0]);
    }
  }]);
  return Bool;
}(comparisonEvaluator_1.ComparisonEvaluator);
exports.Bool = Bool;

},{"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"./comparisonEvaluator":23,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618}],21:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionType_1 = require("../expressionType");
var numberTransformEvaluator_1 = require("./numberTransformEvaluator");
/**
 * Returns the smallest integral value that is greater than or equal to the specified number.
 */
var Ceiling = /*#__PURE__*/function (_numberTransformEvalu) {
  (0, _inherits2.default)(Ceiling, _numberTransformEvalu);
  var _super = _createSuper(Ceiling);
  /**
   * Initializes a new instance of the [Ceiling](xref:adaptive-expressions.Ceiling) class.
   */
  function Ceiling() {
    (0, _classCallCheck2.default)(this, Ceiling);
    return _super.call(this, expressionType_1.ExpressionType.Ceiling, Ceiling.func);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Ceiling, null, [{
    key: "func",
    value: function func(args) {
      return Math.ceil(args[0]);
    }
  }]);
  return Ceiling;
}(numberTransformEvaluator_1.NumberTransformEvaluator);
exports.Ceiling = Ceiling;

},{"../expressionType":192,"./numberTransformEvaluator":107,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],22:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Return the first non-null value from one or more parameters.
 * Empty strings, empty arrays, and empty objects are not null.
 */
var Coalesce = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Coalesce, _expressionEvaluator_);
  var _super = _createSuper(Coalesce);
  /**
   * Initializes a new instance of the [Coalesce](xref:adaptive-expressions.Coalesce) class.
   */
  function Coalesce() {
    (0, _classCallCheck2.default)(this, Coalesce);
    return _super.call(this, expressionType_1.ExpressionType.Coalesce, Coalesce.evaluator(), returnType_1.ReturnType.Object, functionUtils_1.FunctionUtils.validateAtLeastOne);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Coalesce, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        return Coalesce.evalCoalesce(args);
      });
    }
    /**
     * @private
     */
  }, {
    key: "evalCoalesce",
    value: function evalCoalesce(objectList) {
      var _iterator = _createForOfIteratorHelper(objectList),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var obj = _step.value;
          if (obj != null) {
            return obj;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return undefined;
    }
  }]);
  return Coalesce;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Coalesce = Coalesce;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],23:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var __1 = require("../");
var expressionEvaluator_1 = require("../expressionEvaluator");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Comparison operators.
 * A comparison operator returns false if the comparison is false, or there is an error.  This prevents errors from short-circuiting boolean expressions.
 */
var ComparisonEvaluator = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(ComparisonEvaluator, _expressionEvaluator_);
  var _super = _createSuper(ComparisonEvaluator);
  /**
   * Initializes a new instance of the [ComparisonEvaluator](xref:adaptive-expressions.ComparisonEvaluator) class.
   *
   * @param type Name of the built-in function.
   * @param func The comparison function, it takes a list of objects and returns a boolean.
   * @param validator [ValidateExpressionDelegate](xref:adaptive-expressions.ValidateExpressionDelegate) for input arguments.
   * @param verify Optional. [VerifyExpression](xref:adaptive-expressions.VerifyExpression) function to verify each child's result.
   */
  function ComparisonEvaluator(type, func, validator, verify) {
    (0, _classCallCheck2.default)(this, ComparisonEvaluator);
    return _super.call(this, type, ComparisonEvaluator.evaluator(func, verify), returnType_1.ReturnType.Boolean, validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(ComparisonEvaluator, null, [{
    key: "evaluator",
    value: function evaluator(func, verify) {
      return function (expression, state, options) {
        var result = false;
        var newOptions = new __1.Options(options);
        newOptions.nullSubstitution = undefined;
        var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expression, state, newOptions, verify),
          args = _functionUtils_1$Func.args,
          childrenError = _functionUtils_1$Func.error;
        var error = childrenError;
        if (!error) {
          try {
            result = func(args);
          } catch (e) {
            // NOTE: This should not happen in normal execution
            error = e.message;
          }
        } else {
          error = undefined;
        }
        return {
          value: result,
          error: error
        };
      };
    }
  }]);
  return ComparisonEvaluator;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.ComparisonEvaluator = ComparisonEvaluator;

},{"../":1,"../expressionEvaluator":180,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],24:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.concat.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
var functionUtils_internal_1 = require("../functionUtils.internal");
/**
 * Combine two or more strings, and return the combined string.
 */
var Concat = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Concat, _expressionEvaluator_);
  var _super = _createSuper(Concat);
  /**
   * Initializes a new instance of the [Concat](xref:adaptive-expressions.Concat) class.
   */
  function Concat() {
    (0, _classCallCheck2.default)(this, Concat);
    return _super.call(this, expressionType_1.ExpressionType.Concat, Concat.evaluator(), returnType_1.ReturnType.String | returnType_1.ReturnType.Array, functionUtils_1.FunctionUtils.validateAtLeastOne);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Concat, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.applySequence(function (args) {
        var firstItem = args[0];
        var secondItem = args[1];
        var isFirstList = Array.isArray(firstItem);
        var isSecondList = Array.isArray(secondItem);
        if (firstItem == null && secondItem == null) {
          return undefined;
        } else if (firstItem == null && isSecondList) {
          return secondItem;
        } else if (secondItem == null && isFirstList) {
          return firstItem;
        } else if (isFirstList && isSecondList) {
          return firstItem.concat(secondItem);
        } else {
          return functionUtils_internal_1.InternalFunctionUtils.commonStringify(firstItem) + functionUtils_internal_1.InternalFunctionUtils.commonStringify(secondItem);
        }
      });
    }
  }]);
  return Concat;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Concat = Concat;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],25:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.includes.js");
require("core-js/modules/es.string.includes.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Check whether a collection has a specific item. Return true if the item is found, or return false if not found.
 * This function is case-sensitive.
 */
var Contains = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Contains, _expressionEvaluator_);
  var _super = _createSuper(Contains);
  /**
   * Initializes a new instance of the [Contains](xref:adaptive-expressions.Contains) class.
   */
  function Contains() {
    (0, _classCallCheck2.default)(this, Contains);
    return _super.call(this, expressionType_1.ExpressionType.Contains, Contains.evaluator, returnType_1.ReturnType.Boolean, functionUtils_1.FunctionUtils.validateBinary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Contains, null, [{
    key: "evaluator",
    value: function evaluator(expression, state, options) {
      var found = false;
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expression, state, options),
        args = _functionUtils_1$Func.args,
        childrenError = _functionUtils_1$Func.error;
      var error = childrenError;
      if (!error) {
        if (typeof args[0] === 'string' && typeof args[1] === 'string') {
          found = args[0].includes(args[1]);
        } else if (Array.isArray(args[0])) {
          var _iterator = _createForOfIteratorHelper(args[0]),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var item = _step.value;
              if (functionUtils_1.FunctionUtils.commonEquals(item, args[1])) {
                found = true;
                break;
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        } else if (typeof args[1] === 'string') {
          var value;
          var _functionUtils_intern = functionUtils_internal_1.InternalFunctionUtils.accessProperty(args[0], args[1]);
          value = _functionUtils_intern.value;
          error = _functionUtils_intern.error;
          found = !error && value !== undefined;
        }
      }
      return {
        value: found,
        error: undefined
      };
    }
  }]);
  return Contains;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Contains = Contains;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.includes.js":576,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.includes.js":625,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],26:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var dayjs_1 = __importDefault(require("dayjs"));
var timezone_1 = __importDefault(require("dayjs/plugin/timezone"));
dayjs_1.default.extend(timezone_1.default);
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
var timeZoneConverter_1 = require("../timeZoneConverter");
/**
 * Convert a timestamp from Universal Time Coordinated (UTC) to a target time zone.
 */
var ConvertFromUTC = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(ConvertFromUTC, _expressionEvaluator_);
  var _super = _createSuper(ConvertFromUTC);
  /**
   * Initializes a new instance of the [ConvertFromUTC](xref:adaptive-expressions.ConvertFromUTC) class.
   */
  function ConvertFromUTC() {
    (0, _classCallCheck2.default)(this, ConvertFromUTC);
    return _super.call(this, expressionType_1.ExpressionType.ConvertFromUTC, ConvertFromUTC.evaluator, returnType_1.ReturnType.String, ConvertFromUTC.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(ConvertFromUTC, null, [{
    key: "evaluator",
    value: function evaluator(expression, state, options) {
      var value;
      var locale = options.locale ? options.locale : Intl.DateTimeFormat().resolvedOptions().locale;
      var format = ConvertFromUTC.NoneUtcDefaultDateTimeFormat;
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expression, state, options),
        args = _functionUtils_1$Func.args,
        childrenError = _functionUtils_1$Func.error;
      var error = childrenError;
      if (!error) {
        var _functionUtils_1$Func2 = functionUtils_1.FunctionUtils.determineFormatAndLocale(args, 4, format, locale);
        format = _functionUtils_1$Func2.format;
        locale = _functionUtils_1$Func2.locale;
        if (typeof args[0] === 'string' && typeof args[1] === 'string') {
          var _ConvertFromUTC$evalC = ConvertFromUTC.evalConvertFromUTC(args[0], args[1], format, locale);
          value = _ConvertFromUTC$evalC.value;
          error = _ConvertFromUTC$evalC.error;
        } else {
          error = "".concat(expression, " should contain an ISO format timestamp, an origin time zone string and an optional output format string.");
        }
      }
      return {
        value: value,
        error: error
      };
    }
    /**
     * @private
     */
  }, {
    key: "evalConvertFromUTC",
    value: function evalConvertFromUTC(timeStamp, destinationTimeZone, format, locale) {
      var result;
      var error;
      error = functionUtils_internal_1.InternalFunctionUtils.verifyISOTimestamp(timeStamp);
      var timeZone = timeZoneConverter_1.TimeZoneConverter.windowsToIana(destinationTimeZone);
      if (!timeZoneConverter_1.TimeZoneConverter.verifyTimeZoneStr(timeZone)) {
        error = "".concat(destinationTimeZone, " is not a valid timezone");
      }
      if (!error) {
        try {
          result = dayjs_1.default(timeStamp).locale(locale).tz(timeZone).format(format);
        } catch (_a) {
          error = "".concat(format, " is not a valid timestamp format");
        }
      }
      return {
        value: result,
        error: error
      };
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateOrder(expression, [returnType_1.ReturnType.String, returnType_1.ReturnType.String], returnType_1.ReturnType.String, returnType_1.ReturnType.String);
    }
  }]);
  return ConvertFromUTC;
}(expressionEvaluator_1.ExpressionEvaluator);
ConvertFromUTC.NoneUtcDefaultDateTimeFormat = 'YYYY-MM-DDTHH:mm:ss.SSS0000';
exports.ConvertFromUTC = ConvertFromUTC;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"../timeZoneConverter":214,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"dayjs":697,"dayjs/plugin/timezone":699}],27:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.array.concat.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var dayjs_1 = __importDefault(require("dayjs"));
var timezone_1 = __importDefault(require("dayjs/plugin/timezone"));
dayjs_1.default.extend(timezone_1.default);
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
var timeZoneConverter_1 = require("../timeZoneConverter");
/**
 * Convert a timestamp to Universal Time Coordinated (UTC) from the source time zone.
 */
var ConvertToUTC = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(ConvertToUTC, _expressionEvaluator_);
  var _super = _createSuper(ConvertToUTC);
  /**
   * Initializes a new instance of the [ConvertToUTC](xref:adaptive-expressions.ConvertToUTC) class.
   */
  function ConvertToUTC() {
    (0, _classCallCheck2.default)(this, ConvertToUTC);
    return _super.call(this, expressionType_1.ExpressionType.ConvertToUTC, ConvertToUTC.evaluator, returnType_1.ReturnType.String, ConvertToUTC.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(ConvertToUTC, null, [{
    key: "evaluator",
    value: function evaluator(expression, state, options) {
      var value;
      var locale = options.locale ? options.locale : Intl.DateTimeFormat().resolvedOptions().locale;
      var format = functionUtils_1.FunctionUtils.DefaultDateTimeFormat;
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expression, state, options),
        args = _functionUtils_1$Func.args,
        childrenError = _functionUtils_1$Func.error;
      var error = childrenError;
      if (!error) {
        var _functionUtils_1$Func2 = functionUtils_1.FunctionUtils.determineFormatAndLocale(args, 4, format, locale);
        format = _functionUtils_1$Func2.format;
        locale = _functionUtils_1$Func2.locale;
        if (typeof args[0] === 'string' && typeof args[1] === 'string') {
          var _ConvertToUTC$evalCon = ConvertToUTC.evalConvertToUTC(args[0], args[1], format, locale);
          value = _ConvertToUTC$evalCon.value;
          error = _ConvertToUTC$evalCon.error;
        } else {
          error = "".concat(expression, " should contain an ISO format timestamp, a destination time zone string and an optional output format string.");
        }
      }
      return {
        value: value,
        error: error
      };
    }
    /**
     * @private
     */
  }, {
    key: "verifyTimeStamp",
    value: function verifyTimeStamp(timeStamp) {
      var parsed = dayjs_1.default(timeStamp);
      if (parsed.toString() === 'Invalid Date') {
        return "".concat(timeStamp, " is a invalid datetime");
      }
      return undefined;
    }
    /**
     * @private
     */
  }, {
    key: "evalConvertToUTC",
    value: function evalConvertToUTC(timeStamp, sourceTimezone, format, locale) {
      var result;
      var error;
      var formattedSourceTime;
      var timeZone = timeZoneConverter_1.TimeZoneConverter.windowsToIana(sourceTimezone);
      if (!timeZoneConverter_1.TimeZoneConverter.verifyTimeZoneStr(timeZone)) {
        error = "".concat(sourceTimezone, " is not a valid timezone");
      }
      if (!error) {
        error = this.verifyTimeStamp(timeStamp);
        if (!error) {
          try {
            var sourceTime = dayjs_1.default.tz(timeStamp, timeZone);
            formattedSourceTime = sourceTime.format();
          } catch (_a) {
            error = "".concat(timeStamp, " with ").concat(timeZone, " is not a valid timestamp with specified timeZone:");
          }
          if (!error) {
            try {
              result = dayjs_1.default(formattedSourceTime).locale(locale).tz('Etc/UTC').format(format);
            } catch (_b) {
              error = "".concat(format, " is not a valid timestamp format");
            }
          }
        }
      }
      return {
        value: result,
        error: error
      };
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expr) {
      functionUtils_1.FunctionUtils.validateOrder(expr, [returnType_1.ReturnType.String, returnType_1.ReturnType.String], returnType_1.ReturnType.String, returnType_1.ReturnType.String);
    }
  }]);
  return ConvertToUTC;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.ConvertToUTC = ConvertToUTC;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"../timeZoneConverter":214,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.to-string.js":620,"dayjs":697,"dayjs/plugin/timezone":699}],28:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.map.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.object.keys.js");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Return the number of items in a collection.
 */
var Count = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Count, _expressionEvaluator_);
  var _super = _createSuper(Count);
  /**
   * Initializes a new instance of the [Count](xref:adaptive-expressions.Count) class.
   */
  function Count() {
    (0, _classCallCheck2.default)(this, Count);
    return _super.call(this, expressionType_1.ExpressionType.Count, Count.evaluator(), returnType_1.ReturnType.Number, Count.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Count, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        var count;
        if (typeof args[0] === 'string' || Array.isArray(args[0])) {
          count = args[0].length;
        } else if (args[0] instanceof Map) {
          count = args[0].size;
        } else if ((0, _typeof2.default)(args[0]) === 'object') {
          count = Object.keys(args[0]).length;
        }
        return count;
      }, functionUtils_1.FunctionUtils.verifyContainer);
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateOrder(expression, [], returnType_1.ReturnType.String | returnType_1.ReturnType.Array);
    }
  }]);
  return Count;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Count = Count;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.map.js":587,"core-js/modules/es.object.keys.js":609,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.string.iterator.js":626,"core-js/modules/web.dom-collections.iterator.js":677}],29:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.split.js");
require("core-js/modules/es.string.trim.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Return the number of words in a string.
 */
var CountWord = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(CountWord, _expressionEvaluator_);
  var _super = _createSuper(CountWord);
  /**
   * Initializes a new instance of the [CountWord](xref:adaptive-expressions.CountWord) class.
   */
  function CountWord() {
    (0, _classCallCheck2.default)(this, CountWord);
    return _super.call(this, expressionType_1.ExpressionType.CountWord, CountWord.evaluator(), returnType_1.ReturnType.Number, functionUtils_1.FunctionUtils.validateUnaryString);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(CountWord, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        return functionUtils_internal_1.InternalFunctionUtils.parseStringOrUndefined(args[0]).trim().split(/\s+/).length;
      }, functionUtils_1.FunctionUtils.verifyStringOrNull);
    }
  }]);
  return CountWord;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.CountWord = CountWord;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.string.split.js":631,"core-js/modules/es.string.trim.js":634}],30:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Return an array from multiple inputs.
 */
var CreateArray = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(CreateArray, _expressionEvaluator_);
  var _super = _createSuper(CreateArray);
  /**
   * Initializes a new instance of the [CreateArray](xref:adaptive-expressions.CreateArray) class.
   */
  function CreateArray() {
    (0, _classCallCheck2.default)(this, CreateArray);
    return _super.call(this, expressionType_1.ExpressionType.CreateArray, CreateArray.evaluator(), returnType_1.ReturnType.Array);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(CreateArray, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        return Array.from(args);
      });
    }
  }]);
  return CreateArray;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.CreateArray = CreateArray;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.array.from.js":575,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.string.iterator.js":626}],31:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
var btoa_lite_1 = __importDefault(require("btoa-lite"));
/**
 * Return a data uniform resource identifier (URI) of a string.
 */
var DataUri = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(DataUri, _expressionEvaluator_);
  var _super = _createSuper(DataUri);
  /**
   * Initializes a new instance of the [DataUri](xref:adaptive-expressions.DataUri) class.
   */
  function DataUri() {
    (0, _classCallCheck2.default)(this, DataUri);
    return _super.call(this, expressionType_1.ExpressionType.DataUri, DataUri.evaluator(), returnType_1.ReturnType.String, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(DataUri, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        return 'data:text/plain;charset=utf-8;base64,'.concat(btoa_lite_1.default(args[0]));
      }, functionUtils_1.FunctionUtils.verifyString);
    }
  }]);
  return DataUri;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.DataUri = DataUri;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"btoa-lite":420,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],32:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Return the binary version of a data uniform resource identifier (URI).
 */
var DataUriToBinary = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(DataUriToBinary, _expressionEvaluator_);
  var _super = _createSuper(DataUriToBinary);
  /**
   * Initializes a new instance of the [DataUriToBinary](xref:adaptive-expressions.DataUriToBinary) class.
   */
  function DataUriToBinary() {
    (0, _classCallCheck2.default)(this, DataUriToBinary);
    return _super.call(this, expressionType_1.ExpressionType.DataUriToBinary, DataUriToBinary.evaluator(), returnType_1.ReturnType.Object, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(DataUriToBinary, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        return functionUtils_internal_1.InternalFunctionUtils.getTextEncoder().encode(args[0]);
      }, functionUtils_1.FunctionUtils.verifyString);
    }
  }]);
  return DataUriToBinary;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.DataUriToBinary = DataUriToBinary;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],33:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.slice.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
var atob_lite_1 = __importDefault(require("atob-lite"));
/**
 * Return the string version of a data uniform resource identifier (URI).
 */
var DataUriToString = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(DataUriToString, _expressionEvaluator_);
  var _super = _createSuper(DataUriToString);
  /**
   * Initializes a new instance of the [DataUriToString](xref:adaptive-expressions.DataUriToString) class.
   */
  function DataUriToString() {
    (0, _classCallCheck2.default)(this, DataUriToString);
    return _super.call(this, expressionType_1.ExpressionType.DataUriToString, DataUriToString.evaluator(), returnType_1.ReturnType.String, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(DataUriToString, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        return atob_lite_1.default(args[0].slice(args[0].indexOf(',') + 1));
      }, functionUtils_1.FunctionUtils.verifyString);
    }
  }]);
  return DataUriToString;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.DataUriToString = DataUriToString;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"atob-lite":417,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],34:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var dayjs_1 = __importDefault(require("dayjs"));
var utc_1 = __importDefault(require("dayjs/plugin/utc"));
dayjs_1.default.extend(utc_1.default);
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Return the date of a specified timestamp in m/dd/yyyy format.
 */
var DateFunc = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(DateFunc, _expressionEvaluator_);
  var _super = _createSuper(DateFunc);
  /**
   * Initializes a new instance of the [DateFunc](xref:adaptive-expressions.DateFunc) class.
   */
  function DateFunc() {
    (0, _classCallCheck2.default)(this, DateFunc);
    return _super.call(this, expressionType_1.ExpressionType.Date, DateFunc.evaluator(), returnType_1.ReturnType.String, functionUtils_1.FunctionUtils.validateUnaryString);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(DateFunc, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.applyWithError(function (args) {
        var error = functionUtils_internal_1.InternalFunctionUtils.verifyISOTimestamp(args[0]);
        if (!error) {
          return {
            value: dayjs_1.default(args[0]).utc().format('M/DD/YYYY'),
            error: error
          };
        }
        return {
          value: undefined,
          error: error
        };
      }, functionUtils_1.FunctionUtils.verifyString);
    }
  }]);
  return DateFunc;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.DateFunc = DateFunc;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"dayjs":697,"dayjs/plugin/utc":700}],35:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var recognizers_text_data_types_timex_expression_1 = require("@microsoft/recognizers-text-data-types-timex-expression");
var dayjs_1 = __importDefault(require("dayjs"));
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Uses the date-time library to provide a date readback.
 */
var DateReadBack = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(DateReadBack, _expressionEvaluator_);
  var _super = _createSuper(DateReadBack);
  /**
   * Initializes a new instance of the [DateReadBack](xref:adaptive-expressions.DateReadBack) class.
   */
  function DateReadBack() {
    (0, _classCallCheck2.default)(this, DateReadBack);
    return _super.call(this, expressionType_1.ExpressionType.DateReadBack, DateReadBack.evaluator(), returnType_1.ReturnType.String, DateReadBack.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(DateReadBack, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.applyWithError(function (args) {
        var dateFormat = 'YYYY-MM-DD';
        var error = functionUtils_internal_1.InternalFunctionUtils.verifyISOTimestamp(args[0]);
        if (!error) {
          var timestamp1 = dayjs_1.default(args[0]).toDate();
          error = functionUtils_internal_1.InternalFunctionUtils.verifyISOTimestamp(args[1]);
          if (!error) {
            var timestamp2 = dayjs_1.default(args[1]).format(dateFormat);
            var timex = new recognizers_text_data_types_timex_expression_1.TimexProperty(timestamp2);
            return {
              value: timex.toNaturalLanguage(timestamp1),
              error: error
            };
          }
        }
        return {
          value: undefined,
          error: error
        };
      }, functionUtils_1.FunctionUtils.verifyString);
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateOrder(expression, undefined, returnType_1.ReturnType.String, returnType_1.ReturnType.String);
    }
  }]);
  return DateReadBack;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.DateReadBack = DateReadBack;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@microsoft/recognizers-text-data-types-timex-expression":222,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"dayjs":697}],36:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var dayjs_1 = __importDefault(require("dayjs"));
var returnType_1 = require("../returnType");
var functionUtils_internal_1 = require("../functionUtils.internal");
/**
 * Return a number of ticks that the two timestamps differ.
 */
var DateTimeDiff = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(DateTimeDiff, _expressionEvaluator_);
  var _super = _createSuper(DateTimeDiff);
  /**
   * Initializes a new instance of the [DateTimeDiff](xref:adaptive-expressions.DateTimeDiff) class.
   */
  function DateTimeDiff() {
    (0, _classCallCheck2.default)(this, DateTimeDiff);
    return _super.call(this, expressionType_1.ExpressionType.DateTimeDiff, DateTimeDiff.evaluator, returnType_1.ReturnType.Number, DateTimeDiff.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(DateTimeDiff, null, [{
    key: "evaluator",
    value: function evaluator(expr, state, options) {
      var value;
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expr, state, options),
        args = _functionUtils_1$Func.args,
        childrenError = _functionUtils_1$Func.error;
      var error = childrenError;
      if (!error) {
        error = functionUtils_internal_1.InternalFunctionUtils.verifyISOTimestamp(args[0]);
        if (!error) {
          error = functionUtils_internal_1.InternalFunctionUtils.verifyISOTimestamp(args[1]);
          if (!error) {
            value = dayjs_1.default(args[0]).diff(dayjs_1.default(args[1]), 'milliseconds') * 10000;
          }
        }
      }
      return {
        value: value,
        error: error
      };
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateArityAndAnyType(expression, 2, 2, returnType_1.ReturnType.String);
    }
  }]);
  return DateTimeDiff;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.DateTimeDiff = DateTimeDiff;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"dayjs":697}],37:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Return the day of the month from a timestamp.
 */
var DayOfMonth = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(DayOfMonth, _expressionEvaluator_);
  var _super = _createSuper(DayOfMonth);
  /**
   * Initializes a new instance of the [DayOfMonth](xref:adaptive-expressions.DayOfMonth) class.
   */
  function DayOfMonth() {
    (0, _classCallCheck2.default)(this, DayOfMonth);
    return _super.call(this, expressionType_1.ExpressionType.DayOfMonth, DayOfMonth.evaluator(), returnType_1.ReturnType.Number, functionUtils_1.FunctionUtils.validateUnaryString);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(DayOfMonth, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.applyWithError(function (args) {
        var error = functionUtils_internal_1.InternalFunctionUtils.verifyISOTimestamp(args[0]);
        if (!error) {
          return {
            value: new Date(args[0]).getUTCDate(),
            error: error
          };
        }
        return {
          value: undefined,
          error: error
        };
      }, functionUtils_1.FunctionUtils.verifyString);
    }
  }]);
  return DayOfMonth;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.DayOfMonth = DayOfMonth;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],38:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Return the day of the week from a timestamp.
 */
var DayOfWeek = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(DayOfWeek, _expressionEvaluator_);
  var _super = _createSuper(DayOfWeek);
  /**
   * Initializes a new instance of the [DayOfWeek](xref:adaptive-expressions.DayOfWeek) class.
   */
  function DayOfWeek() {
    (0, _classCallCheck2.default)(this, DayOfWeek);
    return _super.call(this, expressionType_1.ExpressionType.DayOfWeek, DayOfWeek.evaluator(), returnType_1.ReturnType.Number, functionUtils_1.FunctionUtils.validateUnaryString);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(DayOfWeek, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.applyWithError(function (args) {
        var error = functionUtils_internal_1.InternalFunctionUtils.verifyISOTimestamp(args[0]);
        if (!error) {
          return {
            value: new Date(args[0]).getUTCDay(),
            error: error
          };
        }
        return {
          value: undefined,
          error: error
        };
      }, functionUtils_1.FunctionUtils.verifyString);
    }
  }]);
  return DayOfWeek;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.DayOfWeek = DayOfWeek;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],39:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var dayjs_1 = __importDefault(require("dayjs"));
var dayOfYear_1 = __importDefault(require("dayjs/plugin/dayOfYear"));
dayjs_1.default.extend(dayOfYear_1.default);
var utc_1 = __importDefault(require("dayjs/plugin/utc"));
dayjs_1.default.extend(utc_1.default);
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Return the day of the year from a timestamp.
 */
var DayOfYear = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(DayOfYear, _expressionEvaluator_);
  var _super = _createSuper(DayOfYear);
  /**
   * Initializes a new instance of the [DayOfYear](xref:adaptive-expressions.DayOfYear) class.
   */
  function DayOfYear() {
    (0, _classCallCheck2.default)(this, DayOfYear);
    return _super.call(this, expressionType_1.ExpressionType.DayOfYear, DayOfYear.evaluator(), returnType_1.ReturnType.Number, functionUtils_1.FunctionUtils.validateUnaryString);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(DayOfYear, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.applyWithError(function (args) {
        var error = functionUtils_internal_1.InternalFunctionUtils.verifyISOTimestamp(args[0]);
        if (!error) {
          return {
            value: dayjs_1.default(args[0]).utc().dayOfYear(),
            error: error
          };
        }
        return {
          value: undefined,
          error: error
        };
      }, functionUtils_1.FunctionUtils.verifyString);
    }
  }]);
  return DayOfYear;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.DayOfYear = DayOfYear;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"dayjs":697,"dayjs/plugin/dayOfYear":698,"dayjs/plugin/utc":700}],40:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.number.constructor.js");
require("core-js/modules/es.number.is-integer.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var multivariateNumericEvaluator_1 = require("./multivariateNumericEvaluator");
/**
 * Return the integer result from dividing two numbers.
 */
var Divide = /*#__PURE__*/function (_multivariateNumericE) {
  (0, _inherits2.default)(Divide, _multivariateNumericE);
  var _super = _createSuper(Divide);
  /**
   * Initializes a new instance of the [Divide](xref:adaptive-expressions.Divide) class.
   */
  function Divide() {
    (0, _classCallCheck2.default)(this, Divide);
    return _super.call(this, expressionType_1.ExpressionType.Divide, Divide.func, Divide.verify);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Divide, null, [{
    key: "func",
    value: function func(args) {
      var result = Number(args[0]) / Number(args[1]);
      if (Number.isInteger(args[0]) && Number.isInteger(args[1])) {
        return Math.floor(result);
      }
      return result;
    }
    /**
     * @private
     */
  }, {
    key: "verify",
    value: function verify(val, expression, pos) {
      var error = functionUtils_1.FunctionUtils.verifyNumber(val, expression, pos);
      if (!error && pos > 0 && Number(val) === 0) {
        error = "Cannot divide by 0 from ".concat(expression);
      }
      return error;
    }
  }]);
  return Divide;
}(multivariateNumericEvaluator_1.MultivariateNumericEvaluator);
exports.Divide = Divide;

},{"../expressionType":192,"../functionUtils":196,"./multivariateNumericEvaluator":103,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.number.is-integer.js":595,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],41:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.number.is-integer.js");
require("core-js/modules/es.number.constructor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var options_1 = require("../options");
var returnType_1 = require("../returnType");
/**
 * The indexing operator ([ ]) selects a single element from a sequence.
 * Support number index for list or string index for object.
 */
var Element = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Element, _expressionEvaluator_);
  var _super = _createSuper(Element);
  /**
   * Initializes a new instance of the [Element](xref:adaptive-expressions.Element) class.
   */
  function Element() {
    (0, _classCallCheck2.default)(this, Element);
    return _super.call(this, expressionType_1.ExpressionType.Element, Element.evaluator, returnType_1.ReturnType.Object, functionUtils_1.FunctionUtils.validateBinary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Element, null, [{
    key: "evaluator",
    value: function evaluator(expression, state, options) {
      var value;
      var instance = expression.children[0];
      var index = expression.children[1];
      var _instance$tryEvaluate = instance.tryEvaluate(state, options),
        inst = _instance$tryEvaluate.value,
        evalError = _instance$tryEvaluate.error;
      var error = evalError;
      if (!error) {
        var idxValue;
        var newOptions = new options_1.Options(options);
        newOptions.nullSubstitution = undefined;
        var _index$tryEvaluate = index.tryEvaluate(state, newOptions);
        idxValue = _index$tryEvaluate.value;
        error = _index$tryEvaluate.error;
        if (!error) {
          if (Number.isInteger(idxValue)) {
            var _functionUtils_intern = functionUtils_internal_1.InternalFunctionUtils.accessIndex(inst, Number(idxValue));
            value = _functionUtils_intern.value;
            error = _functionUtils_intern.error;
          } else if (typeof idxValue === 'string') {
            var _functionUtils_intern2 = functionUtils_internal_1.InternalFunctionUtils.accessProperty(inst, idxValue.toString());
            value = _functionUtils_intern2.value;
            error = _functionUtils_intern2.error;
          } else {
            error = "Could not coerce ".concat(index, " to an int or string.");
          }
          return {
            value: value,
            error: error
          };
        }
      }
    }
  }]);
  return Element;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Element = Element;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../options":204,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.number.is-integer.js":595,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.to-string.js":620}],42:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.map.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.object.keys.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var comparisonEvaluator_1 = require("./comparisonEvaluator");
/**
 * Check whether an instance is empty. Return true if the input is empty. Empty means:
 * 1.Input is null or undefined.
 * 2.Input is a null or empty string.
 * 3.Input is zero size collection.
 * 4.Input is an object with no property.
 */
var Empty = /*#__PURE__*/function (_comparisonEvaluator_) {
  (0, _inherits2.default)(Empty, _comparisonEvaluator_);
  var _super = _createSuper(Empty);
  /**
   * Initializes a new instance of the [Empty](xref:adaptive-expressions.Empty) class.
   */
  function Empty() {
    (0, _classCallCheck2.default)(this, Empty);
    return _super.call(this, expressionType_1.ExpressionType.Empty, Empty.func, functionUtils_1.FunctionUtils.validateUnary, functionUtils_1.FunctionUtils.verifyContainerOrNull);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Empty, null, [{
    key: "func",
    value: function func(args) {
      return Empty.isEmpty(args[0]);
    }
    /**
     * @private
     */
  }, {
    key: "isEmpty",
    value: function isEmpty(instance) {
      var result;
      if (instance == null) {
        result = true;
      } else if (typeof instance === 'string') {
        result = instance === '';
      } else if (Array.isArray(instance)) {
        result = instance.length === 0;
      } else if (instance instanceof Map) {
        result = instance.size === 0;
      } else {
        result = Object.keys(instance).length === 0;
      }
      return result;
    }
  }]);
  return Empty;
}(comparisonEvaluator_1.ComparisonEvaluator);
exports.Empty = Empty;

},{"../expressionType":192,"../functionUtils":196,"./comparisonEvaluator":23,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.map.js":587,"core-js/modules/es.object.keys.js":609,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.string.iterator.js":626,"core-js/modules/web.dom-collections.iterator.js":677}],43:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.string.ends-with.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Check whether a string ends with a specific substring. Return true if the substring is found, or return false if not found.
 * This function is case-insensitive.
 */
var EndsWith = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(EndsWith, _expressionEvaluator_);
  var _super = _createSuper(EndsWith);
  /**
   * Initializes a new instance of the [EndsWith](xref:adaptive-expressions.EndsWith) class.
   */
  function EndsWith() {
    (0, _classCallCheck2.default)(this, EndsWith);
    return _super.call(this, expressionType_1.ExpressionType.EndsWith, EndsWith.evaluator(), returnType_1.ReturnType.Boolean, EndsWith.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(EndsWith, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        return functionUtils_internal_1.InternalFunctionUtils.parseStringOrUndefined(args[0]).endsWith(functionUtils_internal_1.InternalFunctionUtils.parseStringOrUndefined(args[1]));
      }, functionUtils_1.FunctionUtils.verifyStringOrNull);
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateArityAndAnyType(expression, 2, 2, returnType_1.ReturnType.String);
    }
  }]);
  return EndsWith;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.EndsWith = EndsWith;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.string.ends-with.js":623}],44:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.includes.js");
require("core-js/modules/es.string.includes.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Return the newline string according to the environment.
 */
var EOL = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(EOL, _expressionEvaluator_);
  var _super = _createSuper(EOL);
  /**
   * Initializes a new instance of the [EOL](xref:adaptive-expressions.EOL) class.
   */
  function EOL() {
    (0, _classCallCheck2.default)(this, EOL);
    return _super.call(this, expressionType_1.ExpressionType.EOL, EOL.evaluator(), returnType_1.ReturnType.String, EOL.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(EOL, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function () {
        return EOL.platformSpecificEOL();
      });
    }
    /**
     * @private
     */
  }, {
    key: "platformSpecificEOL",
    value: function platformSpecificEOL() {
      if (typeof window !== 'undefined') {
        return window.navigator.platform.includes('Win') ? '\r\n' : '\n';
      } else if (typeof self !== 'undefined') {
        return self.navigator.platform.includes('Win') ? '\r\n' : '\n';
      } else {
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        var os = require('os');
        return os.EOL;
      }
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateArityAndAnyType(expression, 0, 0);
    }
  }]);
  return EOL;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.EOL = EOL;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.array.includes.js":576,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.string.includes.js":625,"os":731}],45:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var comparisonEvaluator_1 = require("./comparisonEvaluator");
/**
 * Check whether both values, expressions, or objects are equivalent.
 * Return true if both are equivalent, or return false if they're not equivalent.
 */
var Equal = /*#__PURE__*/function (_comparisonEvaluator_) {
  (0, _inherits2.default)(Equal, _comparisonEvaluator_);
  var _super = _createSuper(Equal);
  /**
   * Initializes a new instance of the [Equal](xref:adaptive-expressions.Equal) class.
   */
  function Equal() {
    (0, _classCallCheck2.default)(this, Equal);
    return _super.call(this, expressionType_1.ExpressionType.Equal, function (args) {
      return functionUtils_1.FunctionUtils.commonEquals(args[0], args[1]);
    }, functionUtils_1.FunctionUtils.validateBinary);
  }
  return (0, _createClass2.default)(Equal);
}(comparisonEvaluator_1.ComparisonEvaluator);
exports.Equal = Equal;

},{"../expressionType":192,"../functionUtils":196,"./comparisonEvaluator":23,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],46:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var comparisonEvaluator_1 = require("./comparisonEvaluator");
/**
 * Evaluates an expression for truthiness.
 */
var Exists = /*#__PURE__*/function (_comparisonEvaluator_) {
  (0, _inherits2.default)(Exists, _comparisonEvaluator_);
  var _super = _createSuper(Exists);
  /**
   * Initializes a new instance of the [Exists](xref:adaptive-expressions.Exists) class.
   */
  function Exists() {
    (0, _classCallCheck2.default)(this, Exists);
    return _super.call(this, expressionType_1.ExpressionType.Exists, Exists.func, functionUtils_1.FunctionUtils.validateUnary, functionUtils_1.FunctionUtils.verifyNotNull);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Exists, null, [{
    key: "func",
    value: function func(args) {
      return args[0] != null;
    }
  }]);
  return Exists;
}(comparisonEvaluator_1.ComparisonEvaluator);
exports.Exists = Exists;

},{"../expressionType":192,"../functionUtils":196,"./comparisonEvaluator":23,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],47:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Return the first item from a string or array.
 */
var First = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(First, _expressionEvaluator_);
  var _super = _createSuper(First);
  /**
   * Initializes a new instance of the [First](xref:adaptive-expressions.First) class.
   */
  function First() {
    (0, _classCallCheck2.default)(this, First);
    return _super.call(this, expressionType_1.ExpressionType.First, First.evaluator(), returnType_1.ReturnType.Object, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(First, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        var first;
        if (typeof args[0] === 'string' && args[0].length > 0) {
          first = args[0][0];
        }
        if (Array.isArray(args[0]) && args[0].length > 0) {
          first = functionUtils_internal_1.InternalFunctionUtils.accessIndex(args[0], 0).value;
        }
        return first;
      });
    }
  }]);
  return First;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.First = First;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],48:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.object.keys.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.array.concat.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 *  Flatten an array into non-array values. You can optionally set the maximum depth to flatten to.
 */
var Flatten = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Flatten, _expressionEvaluator_);
  var _super = _createSuper(Flatten);
  /**
   * Initializes a new instance of the [Flatten](xref:adaptive-expressions.Flatten) class.
   */
  function Flatten() {
    (0, _classCallCheck2.default)(this, Flatten);
    return _super.call(this, expressionType_1.ExpressionType.Flatten, Flatten.evaluator(), returnType_1.ReturnType.Array, Flatten.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Flatten, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        var array = args[0];
        var depth = args.length > 1 ? args[1] : 100;
        return Flatten.evalFlatten(array, depth);
      });
    }
    /**
     * @private
     */
  }, {
    key: "evalFlatten",
    value: function evalFlatten(arr, dept) {
      if (!functionUtils_1.FunctionUtils.isNumber(dept) || dept < 1) {
        dept = 1;
      }
      var res = JSON.parse(JSON.stringify(arr));
      var reduceArr = function reduceArr(_arr) {
        return _arr.reduce(function (prevItem, curItem) {
          return prevItem.concat(curItem);
        }, []);
      };
      for (var i = 0; i < dept; i++) {
        var hasArrayItem = res.some(function (item) {
          return Array.isArray(item);
        });
        if (hasArrayItem) {
          res = reduceArr(res);
        } else {
          break;
        }
      }
      return res;
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateOrder(expression, [returnType_1.ReturnType.Number], returnType_1.ReturnType.Array);
    }
  }]);
  return Flatten;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Flatten = Flatten;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.object.keys.js":609,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],49:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
var big_integer_1 = __importDefault(require("big-integer"));
/**
 * Convert the string version of a floating-point number to a floating-point number.
 */
var Float = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Float, _expressionEvaluator_);
  var _super = _createSuper(Float);
  /**
   * Initializes a new instance of the [Float](xref:adaptive-expressions.Float) class.
   */
  function Float() {
    (0, _classCallCheck2.default)(this, Float);
    return _super.call(this, expressionType_1.ExpressionType.Float, Float.evaluator(), returnType_1.ReturnType.Number, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Float, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.applyWithError(function (args) {
        var firstChild = args[0];
        var error;
        var value;
        if (big_integer_1.default.isInstance(firstChild)) {
          return {
            value: firstChild.toJSNumber(),
            error: error
          };
        }
        if (typeof firstChild === 'string') {
          value = parseFloat(firstChild);
          if (!functionUtils_1.FunctionUtils.isNumber(value)) {
            error = "parameter ".concat(args[0], " is not a valid number string.");
          }
        } else if (functionUtils_1.FunctionUtils.isNumber(firstChild)) {
          value = firstChild;
        }
        return {
          value: value,
          error: error
        };
      });
    }
  }]);
  return Float;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Float = Float;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"big-integer":419,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],50:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionType_1 = require("../expressionType");
var numberTransformEvaluator_1 = require("./numberTransformEvaluator");
/**
 * Returns the largest integer less than or equal to the specified number.
 */
var Floor = /*#__PURE__*/function (_numberTransformEvalu) {
  (0, _inherits2.default)(Floor, _numberTransformEvalu);
  var _super = _createSuper(Floor);
  /**
   * Initializes a new instance of the [Floor](xref:adaptive-expressions.Floor) class.
   */
  function Floor() {
    (0, _classCallCheck2.default)(this, Floor);
    return _super.call(this, expressionType_1.ExpressionType.Floor, Floor.func);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Floor, null, [{
    key: "func",
    value: function func(args) {
      return Math.floor(args[0]);
    }
  }]);
  return Floor;
}(numberTransformEvaluator_1.NumberTransformEvaluator);
exports.Floor = Floor;

},{"../expressionType":192,"./numberTransformEvaluator":107,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],51:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Operate on each element and return the new collection.
 */
var Foreach = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Foreach, _expressionEvaluator_);
  var _super = _createSuper(Foreach);
  /**
   * Initializes a new instance of the [Foreach](xref:adaptive-expressions.Foreach) class.
   */
  function Foreach() {
    (0, _classCallCheck2.default)(this, Foreach);
    return _super.call(this, expressionType_1.ExpressionType.Foreach, functionUtils_internal_1.InternalFunctionUtils.foreach, returnType_1.ReturnType.Array, functionUtils_internal_1.InternalFunctionUtils.ValidateLambdaExpression);
  }
  return (0, _createClass2.default)(Foreach);
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Foreach = Foreach;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],52:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.string.ends-with.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var dayjs_1 = __importDefault(require("dayjs"));
var utc_1 = __importDefault(require("dayjs/plugin/utc"));
dayjs_1.default.extend(utc_1.default);
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Return a timestamp in the specified format.
 * Format reference: https://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings
 */
var FormatDateTime = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(FormatDateTime, _expressionEvaluator_);
  var _super = _createSuper(FormatDateTime);
  /**
   * Initializes a new instance of the [FormatDateTime](xref:adaptive-expressions.FormatDateTime) class.
   */
  function FormatDateTime() {
    (0, _classCallCheck2.default)(this, FormatDateTime);
    return _super.call(this, expressionType_1.ExpressionType.FormatDateTime, FormatDateTime.evaluator(), returnType_1.ReturnType.String, FormatDateTime.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(FormatDateTime, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.applyWithOptionsAndError(function (args, options) {
        var error;
        var arg = args[0];
        var locale = options.locale ? options.locale : Intl.DateTimeFormat().resolvedOptions().locale;
        var format = functionUtils_1.FunctionUtils.DefaultDateTimeFormat;
        if (typeof arg === 'string') {
          error = functionUtils_internal_1.InternalFunctionUtils.verifyTimestamp(arg.toString());
        } else {
          arg = arg.toISOString();
        }
        var value;
        if (!error) {
          var _functionUtils_1$Func = functionUtils_1.FunctionUtils.determineFormatAndLocale(args, 3, format, locale);
          format = _functionUtils_1$Func.format;
          locale = _functionUtils_1$Func.locale;
          var dateString;
          if (arg.endsWith('Z')) {
            dateString = new Date(arg).toISOString();
          } else {
            try {
              dateString = new Date("".concat(arg, "Z")).toISOString();
            } catch (_a) {
              dateString = new Date(arg).toISOString();
            }
          }
          value = dayjs_1.default(dateString).locale(locale).utc().format(format);
        }
        return {
          value: value,
          error: error
        };
      });
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateOrder(expression, [returnType_1.ReturnType.String, returnType_1.ReturnType.String], returnType_1.ReturnType.String);
    }
  }]);
  return FormatDateTime;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.FormatDateTime = FormatDateTime;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.ends-with.js":623,"dayjs":697,"dayjs/plugin/utc":700}],53:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var dayjs_1 = __importDefault(require("dayjs"));
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Return a timestamp in the specified format from UNIX time (also know as Epoch time, POSIX time, UNIX Epoch time).
 */
var FormatEpoch = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(FormatEpoch, _expressionEvaluator_);
  var _super = _createSuper(FormatEpoch);
  /**
   * Initializes a new instance of the [FormatEpoch](xref:adaptive-expressions.FormatEpoch) class.
   */
  function FormatEpoch() {
    (0, _classCallCheck2.default)(this, FormatEpoch);
    return _super.call(this, expressionType_1.ExpressionType.FormatEpoch, FormatEpoch.evaluator(), returnType_1.ReturnType.String, FormatEpoch.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(FormatEpoch, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.applyWithOptionsAndError(function (args, options) {
        var error;
        var arg = args[0];
        var locale = options.locale ? options.locale : Intl.DateTimeFormat().resolvedOptions().locale;
        var format = functionUtils_1.FunctionUtils.DefaultDateTimeFormat;
        if (!functionUtils_1.FunctionUtils.isNumber(arg)) {
          error = "formatEpoch first argument ".concat(arg, " must be a number");
        } else {
          // Convert to ms
          arg = arg * 1000;
        }
        var value;
        if (!error) {
          var _functionUtils_1$Func = functionUtils_1.FunctionUtils.determineFormatAndLocale(args, 3, format, locale);
          format = _functionUtils_1$Func.format;
          locale = _functionUtils_1$Func.locale;
          var dateString = new Date(arg).toISOString();
          value = dayjs_1.default(dateString).locale(locale).utc().format(format);
        }
        return {
          value: value,
          error: error
        };
      });
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateOrder(expression, [returnType_1.ReturnType.String, returnType_1.ReturnType.String], returnType_1.ReturnType.Number);
    }
  }]);
  return FormatEpoch;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.FormatEpoch = FormatEpoch;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"dayjs":697}],54:[function(require,module,exports){
"use strict";

/* eslint-disable security/detect-object-injection */
/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var d3_format_1 = require("d3-format");
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
var localeInfo_1 = require("../localeInfo");
/**
 * Format number into required decimal numbers.
 */
var FormatNumber = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(FormatNumber, _expressionEvaluator_);
  var _super = _createSuper(FormatNumber);
  /**
   * Initializes a new instance of the [FormatNumber](xref:adaptive-expressions.FormatNumber) class.
   */
  function FormatNumber() {
    (0, _classCallCheck2.default)(this, FormatNumber);
    return _super.call(this, expressionType_1.ExpressionType.FormatNumber, FormatNumber.evaluator(), returnType_1.ReturnType.String, FormatNumber.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(FormatNumber, null, [{
    key: "evaluator",
    value: function evaluator() {
      var _this = this;
      return functionUtils_1.FunctionUtils.applyWithOptionsAndError(function (args, options) {
        var value = null;
        var error;
        var number = args[0];
        var precision = args[1];
        var locale = options.locale ? options.locale : Intl.DateTimeFormat().resolvedOptions().locale;
        locale = functionUtils_1.FunctionUtils.determineLocale(args, 3, locale);
        if (!functionUtils_1.FunctionUtils.isNumber(number)) {
          error = "formatNumber first argument ".concat(number, " must be a number");
        } else if (!functionUtils_1.FunctionUtils.isNumber(precision)) {
          error = "formatNumber second argument ".concat(precision, " must be a number");
        } else if (locale && typeof locale !== 'string') {
          error = "formatNubmer third argument ".concat(locale, " is not a valid locale");
        } else {
          var fixedNotation = ",.".concat(precision, "f");
          var roundedNumber = _this.roundToPrecision(number, precision);
          var formatLocale = localeInfo_1.localeInfo[locale];
          if (formatLocale !== undefined) {
            value = d3_format_1.formatLocale(formatLocale).format(fixedNotation)(roundedNumber);
          } else {
            value = d3_format_1.format(fixedNotation)(roundedNumber);
          }
        }
        return {
          value: value,
          error: error
        };
      });
    }
  }, {
    key: "validator",
    value: function validator(expr) {
      functionUtils_1.FunctionUtils.validateOrder(expr, [returnType_1.ReturnType.String], returnType_1.ReturnType.Number, returnType_1.ReturnType.Number);
    }
  }]);
  return FormatNumber;
}(expressionEvaluator_1.ExpressionEvaluator);
FormatNumber.roundToPrecision = function (num, digits) {
  return Math.round(num * Math.pow(10, digits)) / Math.pow(10, digits);
};
exports.FormatNumber = FormatNumber;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../localeInfo":200,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"d3-format":692}],55:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var big_integer_1 = __importDefault(require("big-integer"));
var dayjs_1 = __importDefault(require("dayjs"));
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Return a timestamp in the specified format from ticks.
 */
var FormatTicks = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(FormatTicks, _expressionEvaluator_);
  var _super = _createSuper(FormatTicks);
  /**
   * Initializes a new instance of the [FormatTicks](xref:adaptive-expressions.FormatTicks) class.
   */
  function FormatTicks() {
    (0, _classCallCheck2.default)(this, FormatTicks);
    return _super.call(this, expressionType_1.ExpressionType.FormatTicks, FormatTicks.evaluator(), returnType_1.ReturnType.String, FormatTicks.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(FormatTicks, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.applyWithOptionsAndError(function (args, options) {
        var error;
        var arg = args[0];
        var locale = options.locale ? options.locale : Intl.DateTimeFormat().resolvedOptions().locale;
        var format = functionUtils_1.FunctionUtils.DefaultDateTimeFormat;
        if (functionUtils_1.FunctionUtils.isNumber(arg)) {
          arg = big_integer_1.default(arg);
        }
        if (typeof arg === 'string') {
          arg = big_integer_1.default(arg);
        }
        if (!big_integer_1.default.isInstance(arg)) {
          error = "formatTicks first argument ".concat(arg, " is not a number, numeric string or bigInt");
        } else {
          // Convert to ms
          arg = arg.subtract(functionUtils_internal_1.InternalFunctionUtils.UnixMilliSecondToTicksConstant).divide(functionUtils_internal_1.InternalFunctionUtils.MillisecondToTickConstant).toJSNumber();
        }
        var value;
        if (!error) {
          var _functionUtils_1$Func = functionUtils_1.FunctionUtils.determineFormatAndLocale(args, 3, format, locale);
          format = _functionUtils_1$Func.format;
          locale = _functionUtils_1$Func.locale;
          if (functionUtils_1.FunctionUtils.isNumber(arg)) {
            var dateString = new Date(arg).toISOString();
            value = dayjs_1.default(dateString).locale(locale).utc().format(format);
          }
        }
        return {
          value: value,
          error: error
        };
      });
    }
    /**
     * @param expression
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateOrder(expression, [returnType_1.ReturnType.String, returnType_1.ReturnType.String], returnType_1.ReturnType.Number);
    }
  }]);
  return FormatTicks;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.FormatTicks = FormatTicks;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"big-integer":419,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"dayjs":697}],56:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.number.is-integer.js");
require("core-js/modules/es.number.constructor.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var dayjs_1 = __importDefault(require("dayjs"));
var utc_1 = __importDefault(require("dayjs/plugin/utc"));
dayjs_1.default.extend(utc_1.default);
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Return the current timestamp plus the specified time units.
 */
var GetFutureTime = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(GetFutureTime, _expressionEvaluator_);
  var _super = _createSuper(GetFutureTime);
  /**
   * Initializes a new instance of the [GetFutureTime](xref:adaptive-expressions.GetFutureTime) class.
   */
  function GetFutureTime() {
    (0, _classCallCheck2.default)(this, GetFutureTime);
    return _super.call(this, expressionType_1.ExpressionType.GetFutureTime, GetFutureTime.evaluator, returnType_1.ReturnType.String, GetFutureTime.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(GetFutureTime, null, [{
    key: "evaluator",
    value: function evaluator(expression, state, options) {
      var value;
      var locale = options.locale ? options.locale : Intl.DateTimeFormat().resolvedOptions().locale;
      var format = functionUtils_1.FunctionUtils.DefaultDateTimeFormat;
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expression, state, options),
        args = _functionUtils_1$Func.args,
        childrenError = _functionUtils_1$Func.error;
      var error = childrenError;
      if (!error) {
        if (Number.isInteger(args[0]) && typeof args[1] === 'string') {
          var _functionUtils_1$Func2 = functionUtils_1.FunctionUtils.determineFormatAndLocale(args, 4, format, locale);
          format = _functionUtils_1$Func2.format;
          locale = _functionUtils_1$Func2.locale;
          var _functionUtils_intern = functionUtils_internal_1.InternalFunctionUtils.timeUnitTransformer(args[0], args[1]),
            duration = _functionUtils_intern.duration,
            tsStr = _functionUtils_intern.tsStr;
          if (tsStr === undefined) {
            error = "".concat(args[2], " is not a valid time unit.");
          } else {
            value = dayjs_1.default().locale(locale).utc().add(duration, tsStr).format(format);
          }
        } else {
          error = "".concat(expression, " should contain a time interval integer, a string unit of time and an optional output format string.");
        }
      }
      return {
        value: value,
        error: error
      };
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateOrder(expression, [returnType_1.ReturnType.String, returnType_1.ReturnType.String], returnType_1.ReturnType.Number, returnType_1.ReturnType.String);
    }
  }]);
  return GetFutureTime;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.GetFutureTime = GetFutureTime;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.number.is-integer.js":595,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"dayjs":697,"dayjs/plugin/utc":700}],57:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var returnType_1 = require("../returnType");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var timeZoneConverter_1 = require("../timeZoneConverter");
var dayjs_1 = __importDefault(require("dayjs"));
var utc_1 = __importDefault(require("dayjs/plugin/utc"));
dayjs_1.default.extend(utc_1.default);
var timezone_1 = __importDefault(require("dayjs/plugin/timezone"));
dayjs_1.default.extend(timezone_1.default);
var recognizers_text_data_types_timex_expression_1 = require("@microsoft/recognizers-text-data-types-timex-expression");
/**
 * Return the next viable date of a timex expression based on the current date and user's timezone.
 */
var GetNextViableDate = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(GetNextViableDate, _expressionEvaluator_);
  var _super = _createSuper(GetNextViableDate);
  /**
   * Initializes a new instance of the [GetNextViableDate](xref:adaptive-expressions.GetNextViableDate) class.
   */
  function GetNextViableDate() {
    (0, _classCallCheck2.default)(this, GetNextViableDate);
    return _super.call(this, expressionType_1.ExpressionType.GetNextViableDate, GetNextViableDate.evaluator, returnType_1.ReturnType.String, functionUtils_1.FunctionUtils.validateUnaryOrBinaryString);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(GetNextViableDate, null, [{
    key: "evaluator",
    value: function evaluator(expr, state, options) {
      var parsed;
      var currentTime = dayjs_1.default(new Date().toISOString());
      var validYear = 0;
      var validMonth = 0;
      var validDay = 0;
      var convertedDateTime;
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expr, state, options),
        args = _functionUtils_1$Func.args,
        childrenError = _functionUtils_1$Func.error;
      var error = childrenError;
      if (!error) {
        var _functionUtils_intern = functionUtils_internal_1.InternalFunctionUtils.parseTimexProperty(args[0]);
        parsed = _functionUtils_intern.timexProperty;
        error = _functionUtils_intern.error;
      }
      if (parsed && !error) {
        if (parsed.year || !parsed.month || !parsed.dayOfMonth) {
          error = "".concat(args[0], " must be a timex string which only contains month and day-of-month, for example: 'XXXX-10-31'.");
        }
      }
      if (!error) {
        if (args.length === 2 && typeof args[1] === 'string') {
          var timeZone = timeZoneConverter_1.TimeZoneConverter.windowsToIana(args[1]);
          if (!timeZoneConverter_1.TimeZoneConverter.verifyTimeZoneStr(timeZone)) {
            error = "".concat(args[1], " is not a valid timezone");
          }
          if (!error) {
            convertedDateTime = currentTime.utc().tz(timeZone);
          }
        } else {
          convertedDateTime = currentTime.utc();
        }
      }
      if (!error) {
        var year = convertedDateTime.year();
        var month = convertedDateTime.month() + 1;
        var dayOfMonth = convertedDateTime.date();
        if (parsed.month > month || parsed.month === month && parsed.dayOfMonth >= dayOfMonth) {
          validYear = year;
        } else {
          validYear = year + 1;
        }
        validMonth = parsed.month;
        validDay = parsed.dayOfMonth;
        if (validMonth === 2 && validDay === 29) {
          while (!GetNextViableDate.leapYear(validYear)) {
            validYear += 1;
          }
        }
      }
      var value = recognizers_text_data_types_timex_expression_1.TimexProperty.fromDate(new Date(validYear, validMonth - 1, validDay)).timex;
      return {
        value: value,
        error: error
      };
    }
    /**
     * @private
     */
  }, {
    key: "leapYear",
    value: function leapYear(year) {
      return year % 4 === 0 && year % 100 != 0 || year % 400 === 0;
    }
  }]);
  return GetNextViableDate;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.GetNextViableDate = GetNextViableDate;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"../timeZoneConverter":214,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@microsoft/recognizers-text-data-types-timex-expression":222,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"dayjs":697,"dayjs/plugin/timezone":699,"dayjs/plugin/utc":700}],58:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var returnType_1 = require("../returnType");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var timeZoneConverter_1 = require("../timeZoneConverter");
var dayjs_1 = __importDefault(require("dayjs"));
var utc_1 = __importDefault(require("dayjs/plugin/utc"));
dayjs_1.default.extend(utc_1.default);
var timezone_1 = __importDefault(require("dayjs/plugin/timezone"));
dayjs_1.default.extend(timezone_1.default);
var recognizers_text_data_types_timex_expression_1 = require("@microsoft/recognizers-text-data-types-timex-expression");
/**
 * Return the next viable time of a timex expression based on the current time and user's timezone.
 */
var GetNextViableTime = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(GetNextViableTime, _expressionEvaluator_);
  var _super = _createSuper(GetNextViableTime);
  /**
   * Initializes a new instance of the [GetNextViableTime](xref:adaptive-expressions.GetNextViableTime) class.
   */
  function GetNextViableTime() {
    (0, _classCallCheck2.default)(this, GetNextViableTime);
    return _super.call(this, expressionType_1.ExpressionType.GetNextViableTime, GetNextViableTime.evaluator, returnType_1.ReturnType.String, functionUtils_1.FunctionUtils.validateUnaryOrBinaryString);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(GetNextViableTime, null, [{
    key: "evaluator",
    value: function evaluator(expr, state, options) {
      var parsed;
      var currentTime = dayjs_1.default(new Date().toISOString());
      var validHour = 0;
      var validMinute = 0;
      var validSecond = 0;
      var convertedDateTime;
      var formatRegex = /TXX:[0-5][0-9]:[0-5][0-9]/g;
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expr, state, options),
        args = _functionUtils_1$Func.args,
        childrenError = _functionUtils_1$Func.error;
      var error = childrenError;
      if (!error) {
        if (!formatRegex.test(args[0])) {
          error = "".concat(args[0], "  must be a timex string which only contains minutes and seconds, for example: 'TXX:15:28'");
        }
      }
      if (!error) {
        if (args.length === 2 && typeof args[1] === 'string') {
          var timeZone = timeZoneConverter_1.TimeZoneConverter.windowsToIana(args[1]);
          if (!timeZoneConverter_1.TimeZoneConverter.verifyTimeZoneStr(timeZone)) {
            error = "".concat(args[1], " is not a valid timezone");
          }
          if (!error) {
            convertedDateTime = currentTime.utc().tz(timeZone);
          }
        } else {
          convertedDateTime = currentTime.utc();
        }
      }
      if (!error) {
        var _functionUtils_intern = functionUtils_internal_1.InternalFunctionUtils.parseTimexProperty(args[0].replace('XX', '00'));
        parsed = _functionUtils_intern.timexProperty;
        error = _functionUtils_intern.error;
      }
      if (!error) {
        var hour = convertedDateTime.hour();
        var minute = convertedDateTime.minute();
        var second = convertedDateTime.second();
        if (parsed.minute > minute || parsed.minute === minute && parsed.second >= second) {
          validHour = hour;
        } else {
          validHour = hour + 1;
        }
        if (validHour >= 24) {
          validHour -= 24;
        }
        validMinute = parsed.minute;
        validSecond = parsed.second;
      }
      var value = recognizers_text_data_types_timex_expression_1.TimexProperty.fromTime(new recognizers_text_data_types_timex_expression_1.Time(validHour, validMinute, validSecond)).timex;
      return {
        value: value,
        error: error
      };
    }
  }]);
  return GetNextViableTime;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.GetNextViableTime = GetNextViableTime;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"../timeZoneConverter":214,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@microsoft/recognizers-text-data-types-timex-expression":222,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.string.replace.js":629,"dayjs":697,"dayjs/plugin/timezone":699,"dayjs/plugin/utc":700}],59:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.number.is-integer.js");
require("core-js/modules/es.number.constructor.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var dayjs_1 = __importDefault(require("dayjs"));
var utc_1 = __importDefault(require("dayjs/plugin/utc"));
dayjs_1.default.extend(utc_1.default);
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Return the current timestamp minus the specified time units.
 */
var GetPastTime = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(GetPastTime, _expressionEvaluator_);
  var _super = _createSuper(GetPastTime);
  /**
   * Initializes a new instance of the [GetPastTime](xref:adaptive-expressions.GetPastTime) class.
   */
  function GetPastTime() {
    (0, _classCallCheck2.default)(this, GetPastTime);
    return _super.call(this, expressionType_1.ExpressionType.GetPastTime, GetPastTime.evaluator, returnType_1.ReturnType.String, GetPastTime.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(GetPastTime, null, [{
    key: "evaluator",
    value: function evaluator(expression, state, options) {
      var value;
      var locale = options.locale ? options.locale : Intl.DateTimeFormat().resolvedOptions().locale;
      var format = functionUtils_1.FunctionUtils.DefaultDateTimeFormat;
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expression, state, options),
        args = _functionUtils_1$Func.args,
        childrenError = _functionUtils_1$Func.error;
      var error = childrenError;
      if (!error) {
        if (Number.isInteger(args[0]) && typeof args[1] === 'string') {
          var _functionUtils_1$Func2 = functionUtils_1.FunctionUtils.determineFormatAndLocale(args, 4, format, locale);
          format = _functionUtils_1$Func2.format;
          locale = _functionUtils_1$Func2.locale;
          var _functionUtils_intern = functionUtils_internal_1.InternalFunctionUtils.timeUnitTransformer(args[0], args[1]),
            duration = _functionUtils_intern.duration,
            tsStr = _functionUtils_intern.tsStr;
          if (tsStr === undefined) {
            error = "".concat(args[2], " is not a valid time unit.");
          } else {
            value = dayjs_1.default().locale(locale).utc().subtract(duration, tsStr).format(format);
          }
        } else {
          error = "".concat(expression, " should contain a time interval integer, a string unit of time and an optional output format string.");
        }
      }
      return {
        value: value,
        error: error
      };
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateOrder(expression, [returnType_1.ReturnType.String, returnType_1.ReturnType.String], returnType_1.ReturnType.Number, returnType_1.ReturnType.String);
    }
  }]);
  return GetPastTime;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.GetPastTime = GetPastTime;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.number.is-integer.js":595,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"dayjs":697,"dayjs/plugin/utc":700}],60:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var returnType_1 = require("../returnType");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var timeZoneConverter_1 = require("../timeZoneConverter");
var dayjs_1 = __importDefault(require("dayjs"));
var timezone_1 = __importDefault(require("dayjs/plugin/timezone"));
dayjs_1.default.extend(timezone_1.default);
var utc_1 = __importDefault(require("dayjs/plugin/utc"));
dayjs_1.default.extend(utc_1.default);
var recognizers_text_data_types_timex_expression_1 = require("@microsoft/recognizers-text-data-types-timex-expression");
/**
 * Return the previous viable date of a timex expression based on the current date and user's timezone.
 */
var GetPreviousViableDate = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(GetPreviousViableDate, _expressionEvaluator_);
  var _super = _createSuper(GetPreviousViableDate);
  /**
   * Initializes a new instance of the [GetPreviousViableDate](xref:adaptive-expressions.GetPreviousViableDate) class.
   */
  function GetPreviousViableDate() {
    (0, _classCallCheck2.default)(this, GetPreviousViableDate);
    return _super.call(this, expressionType_1.ExpressionType.GetPreviousViableDate, GetPreviousViableDate.evaluator, returnType_1.ReturnType.String, functionUtils_1.FunctionUtils.validateUnaryOrBinaryString);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(GetPreviousViableDate, null, [{
    key: "evaluator",
    value: function evaluator(expr, state, options) {
      var parsed;
      var currentTime = dayjs_1.default(new Date().toISOString());
      var validYear = 0;
      var validMonth = 0;
      var validDay = 0;
      var convertedDateTime;
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expr, state, options),
        args = _functionUtils_1$Func.args,
        childrenError = _functionUtils_1$Func.error;
      var error = childrenError;
      if (!error) {
        var _functionUtils_intern = functionUtils_internal_1.InternalFunctionUtils.parseTimexProperty(args[0]);
        parsed = _functionUtils_intern.timexProperty;
        error = _functionUtils_intern.error;
      }
      if (parsed && !error) {
        if (parsed.year || !parsed.month || !parsed.dayOfMonth) {
          error = "".concat(args[0], " must be a timex string which only contains month and day-of-month, for example: 'XXXX-10-31'.");
        }
      }
      if (!error) {
        if (args.length === 2 && typeof args[1] === 'string') {
          var timeZone = timeZoneConverter_1.TimeZoneConverter.windowsToIana(args[1]);
          if (!timeZoneConverter_1.TimeZoneConverter.verifyTimeZoneStr(timeZone)) {
            error = "".concat(args[1], " is not a valid timezone");
          }
          if (!error) {
            convertedDateTime = currentTime.utc().tz(timeZone);
          }
        } else {
          convertedDateTime = currentTime.utc();
        }
      }
      if (!error) {
        var year = convertedDateTime.year();
        var month = convertedDateTime.month() + 1;
        var dayOfMonth = convertedDateTime.date();
        if (parsed.month < month || parsed.month === month && parsed.dayOfMonth < dayOfMonth) {
          validYear = year;
        } else {
          validYear = year - 1;
        }
        validMonth = parsed.month;
        validDay = parsed.dayOfMonth;
        if (validMonth === 2 && validDay === 29) {
          while (!GetPreviousViableDate.leapYear(validYear)) {
            validYear -= 1;
          }
        }
      }
      var value = recognizers_text_data_types_timex_expression_1.TimexProperty.fromDate(new Date(validYear, validMonth - 1, validDay)).timex;
      return {
        value: value,
        error: error
      };
    }
    /**
     * @private
     */
  }, {
    key: "leapYear",
    value: function leapYear(year) {
      return year % 4 === 0 && year % 100 != 0 || year % 400 === 0;
    }
  }]);
  return GetPreviousViableDate;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.GetPreviousViableDate = GetPreviousViableDate;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"../timeZoneConverter":214,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@microsoft/recognizers-text-data-types-timex-expression":222,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"dayjs":697,"dayjs/plugin/timezone":699,"dayjs/plugin/utc":700}],61:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var returnType_1 = require("../returnType");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var timeZoneConverter_1 = require("../timeZoneConverter");
var dayjs_1 = __importDefault(require("dayjs"));
var timezone_1 = __importDefault(require("dayjs/plugin/timezone"));
dayjs_1.default.extend(timezone_1.default);
var recognizers_text_data_types_timex_expression_1 = require("@microsoft/recognizers-text-data-types-timex-expression");
/**
 * Return the previous viable time of a timex expression based on the current time and user's timezone.
 */
var GetPreviousViableTime = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(GetPreviousViableTime, _expressionEvaluator_);
  var _super = _createSuper(GetPreviousViableTime);
  /**
   * Initializes a new instance of the [GetPreviousViableTime](xref:adaptive-expressions.GetPreviousViableTime) class.
   */
  function GetPreviousViableTime() {
    (0, _classCallCheck2.default)(this, GetPreviousViableTime);
    return _super.call(this, expressionType_1.ExpressionType.GetPreviousViableTime, GetPreviousViableTime.evaluator, returnType_1.ReturnType.String, functionUtils_1.FunctionUtils.validateUnaryOrBinaryString);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(GetPreviousViableTime, null, [{
    key: "evaluator",
    value: function evaluator(expr, state, options) {
      var parsed;
      var currentTime = dayjs_1.default(new Date().toISOString());
      var validHour = 0;
      var validMinute = 0;
      var validSecond = 0;
      var convertedDateTime;
      var formatRegex = /TXX:[0-5][0-9]:[0-5][0-9]/g;
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expr, state, options),
        args = _functionUtils_1$Func.args,
        childrenError = _functionUtils_1$Func.error;
      var error = childrenError;
      if (!error) {
        if (!formatRegex.test(args[0])) {
          error = "".concat(args[0], "  must be a timex string which only contains minutes and seconds, for example: 'TXX:15:28'");
        }
      }
      if (!error) {
        if (args.length === 2 && typeof args[1] === 'string') {
          var timeZone = timeZoneConverter_1.TimeZoneConverter.windowsToIana(args[1]);
          if (!timeZoneConverter_1.TimeZoneConverter.verifyTimeZoneStr(timeZone)) {
            error = "".concat(args[1], " is not a valid timezone");
          }
          if (!error) {
            convertedDateTime = currentTime.utc().tz(timeZone);
          }
        } else {
          convertedDateTime = currentTime.utc();
        }
      }
      if (!error) {
        var _functionUtils_intern = functionUtils_internal_1.InternalFunctionUtils.parseTimexProperty(args[0].replace('XX', '00'));
        parsed = _functionUtils_intern.timexProperty;
        error = _functionUtils_intern.error;
      }
      if (!error) {
        var hour = convertedDateTime.hour();
        var minute = convertedDateTime.minute();
        var second = convertedDateTime.second();
        if (parsed.minute < minute || parsed.minute === minute && parsed.second < second) {
          validHour = hour;
        } else {
          validHour = hour - 1;
        }
        if (validHour < 0) {
          validHour += 24;
        }
        validMinute = parsed.minute;
        validSecond = parsed.second;
      }
      var value = recognizers_text_data_types_timex_expression_1.TimexProperty.fromTime(new recognizers_text_data_types_timex_expression_1.Time(validHour, validMinute, validSecond)).timex;
      return {
        value: value,
        error: error
      };
    }
  }]);
  return GetPreviousViableTime;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.GetPreviousViableTime = GetPreviousViableTime;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"../timeZoneConverter":214,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@microsoft/recognizers-text-data-types-timex-expression":222,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.string.replace.js":629,"dayjs":697,"dayjs/plugin/timezone":699}],62:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var simpleObjectMemory_1 = require("../memory/simpleObjectMemory");
var returnType_1 = require("../returnType");
/**
 * Retrieve the value of the specified property from the JSON object.
 */
var GetProperty = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(GetProperty, _expressionEvaluator_);
  var _super = _createSuper(GetProperty);
  /**
   * Initializes a new instance of the [GetProperty](xref:adaptive-expressions.GetProperty) class.
   */
  function GetProperty() {
    (0, _classCallCheck2.default)(this, GetProperty);
    return _super.call(this, expressionType_1.ExpressionType.GetProperty, GetProperty.evaluator, returnType_1.ReturnType.Object, GetProperty.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(GetProperty, null, [{
    key: "evaluator",
    value: function evaluator(expression, state, options) {
      var value;
      var property;
      var children = expression.children;
      var _children$0$tryEvalua = children[0].tryEvaluate(state, options),
        firstItem = _children$0$tryEvalua.value,
        childrenError = _children$0$tryEvalua.error;
      var error = childrenError;
      if (!error) {
        if (children.length === 1) {
          // get root value from memory
          if (typeof firstItem === 'string') {
            value = functionUtils_internal_1.InternalFunctionUtils.wrapGetValue(state, firstItem, options);
          } else {
            error = "\"Single parameter ".concat(children[0], " is not a string.\"");
          }
        } else {
          // get the peoperty value from the instance
          var _children$1$tryEvalua = children[1].tryEvaluate(state, options);
          property = _children$1$tryEvalua.value;
          error = _children$1$tryEvalua.error;
          if (!error) {
            value = functionUtils_internal_1.InternalFunctionUtils.wrapGetValue(new simpleObjectMemory_1.SimpleObjectMemory(firstItem), property.toString(), options);
          }
        }
      }
      return {
        value: value,
        error: error
      };
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateOrder(expression, [returnType_1.ReturnType.String], returnType_1.ReturnType.Object);
    }
  }]);
  return GetProperty;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.GetProperty = GetProperty;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../memory/simpleObjectMemory":202,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.to-string.js":620}],63:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var dayjs_1 = __importDefault(require("dayjs"));
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
var convertFromUTC_1 = require("./convertFromUTC");
/**
 * Returns time of day for a given timestamp.
 */
var GetTimeOfDay = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(GetTimeOfDay, _expressionEvaluator_);
  var _super = _createSuper(GetTimeOfDay);
  /**
   * Initializes a new instance of the [GetTimeOfDay](xref:adaptive-expressions.GetTimeOfDay) class.
   */
  function GetTimeOfDay() {
    (0, _classCallCheck2.default)(this, GetTimeOfDay);
    return _super.call(this, expressionType_1.ExpressionType.GetTimeOfDay, GetTimeOfDay.evaluator(), returnType_1.ReturnType.String, functionUtils_1.FunctionUtils.validateUnaryString);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(GetTimeOfDay, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.applyWithError(function (args) {
        var value;
        var error = functionUtils_internal_1.InternalFunctionUtils.verifyISOTimestamp(args[0]);
        var thisTime;
        if (error) {
          error = functionUtils_internal_1.InternalFunctionUtils.verifyTimestamp(args[0]);
          if (error) {
            return {
              value: value,
              error: error
            };
          } else {
            if (dayjs_1.default(args[0]).format(convertFromUTC_1.ConvertFromUTC.NoneUtcDefaultDateTimeFormat) === args[0]) {
              thisTime = new Date(args[0]).getHours() * 100 + new Date(args[0]).getMinutes();
              error = undefined;
            } else {
              return {
                value: value,
                error: error
              };
            }
          }
        } else {
          // utc iso format
          thisTime = new Date(args[0]).getUTCHours() * 100 + new Date(args[0]).getUTCMinutes();
        }
        if (thisTime === 0) {
          value = 'midnight';
        } else if (thisTime > 0 && thisTime < 1200) {
          value = 'morning';
        } else if (thisTime === 1200) {
          value = 'noon';
        } else if (thisTime > 1200 && thisTime < 1800) {
          value = 'afternoon';
        } else if (thisTime >= 1800 && thisTime <= 2200) {
          value = 'evening';
        } else if (thisTime > 2200 && thisTime <= 2359) {
          value = 'night';
        }
        return {
          value: value,
          error: error
        };
      }, functionUtils_1.FunctionUtils.verifyString);
    }
  }]);
  return GetTimeOfDay;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.GetTimeOfDay = GetTimeOfDay;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"./convertFromUTC":26,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"dayjs":697}],64:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.concat.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var comparisonEvaluator_1 = require("./comparisonEvaluator");
/**
 * Check whether the first value is greater than the second value.
 * Return true if the first value is more, or return false if less.
 */
var GreaterThan = /*#__PURE__*/function (_comparisonEvaluator_) {
  (0, _inherits2.default)(GreaterThan, _comparisonEvaluator_);
  var _super = _createSuper(GreaterThan);
  /**
   * Initializes a new instance of the [GreaterThan](xref:adaptive-expressions.GreaterThan) class.
   */
  function GreaterThan() {
    (0, _classCallCheck2.default)(this, GreaterThan);
    return _super.call(this, expressionType_1.ExpressionType.GreaterThan, GreaterThan.func, functionUtils_1.FunctionUtils.validateBinary, functionUtils_1.FunctionUtils.verifyNotNull);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(GreaterThan, null, [{
    key: "func",
    value: function func(args) {
      if (functionUtils_1.FunctionUtils.isNumber(args[0]) && functionUtils_1.FunctionUtils.isNumber(args[1]) || typeof args[0] === 'string' && typeof args[1] === 'string' || args[0] instanceof Date && args[1] instanceof Date) {
        return args[0] > args[1];
      } else {
        throw new Error("".concat(args[0], " and ").concat(args[1], " must be comparable."));
      }
    }
  }]);
  return GreaterThan;
}(comparisonEvaluator_1.ComparisonEvaluator);
exports.GreaterThan = GreaterThan;

},{"../expressionType":192,"../functionUtils":196,"./comparisonEvaluator":23,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],65:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.concat.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var comparisonEvaluator_1 = require("./comparisonEvaluator");
/**
 * Check whether the first value is greater than or equal to the second value. Return true when the first value is greater or equal,
 * or return false if the first value is less.
 */
var GreaterThanOrEqual = /*#__PURE__*/function (_comparisonEvaluator_) {
  (0, _inherits2.default)(GreaterThanOrEqual, _comparisonEvaluator_);
  var _super = _createSuper(GreaterThanOrEqual);
  /**
   * Initializes a new instance of the [GreaterThanOrEqual](xref:adaptive-expressions.GreaterThanOrEqual) class.
   */
  function GreaterThanOrEqual() {
    (0, _classCallCheck2.default)(this, GreaterThanOrEqual);
    return _super.call(this, expressionType_1.ExpressionType.GreaterThanOrEqual, GreaterThanOrEqual.func, functionUtils_1.FunctionUtils.validateBinary, functionUtils_1.FunctionUtils.verifyNotNull);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(GreaterThanOrEqual, null, [{
    key: "func",
    value: function func(args) {
      if (functionUtils_1.FunctionUtils.isNumber(args[0]) && functionUtils_1.FunctionUtils.isNumber(args[1]) || typeof args[0] === 'string' && typeof args[1] === 'string' || args[0] instanceof Date && args[1] instanceof Date) {
        return args[0] >= args[1];
      } else {
        throw new Error("".concat(args[0], " and ").concat(args[1], " must be comparable."));
      }
    }
  }]);
  return GreaterThanOrEqual;
}(comparisonEvaluator_1.ComparisonEvaluator);
exports.GreaterThanOrEqual = GreaterThanOrEqual;

},{"../expressionType":192,"../functionUtils":196,"./comparisonEvaluator":23,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],66:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var options_1 = require("../options");
var returnType_1 = require("../returnType");
/**
 * Check whether an expression is true or false. Based on the result, return a specified value.
 */
var If = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(If, _expressionEvaluator_);
  var _super = _createSuper(If);
  /**
   * Initializes a new instance of the [If](xref:adaptive-expressions.If) class.
   */
  function If() {
    (0, _classCallCheck2.default)(this, If);
    return _super.call(this, expressionType_1.ExpressionType.If, If.evaluator, returnType_1.ReturnType.Object, If.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(If, null, [{
    key: "evaluator",
    value: function evaluator(expression, state, options) {
      var result;
      var error;
      var newOptions = new options_1.Options(options);
      newOptions.nullSubstitution = undefined;
      var _expression$children$ = expression.children[0].tryEvaluate(state, newOptions);
      result = _expression$children$.value;
      error = _expression$children$.error;
      if (!error && functionUtils_internal_1.InternalFunctionUtils.isLogicTrue(result)) {
        var _expression$children$2 = expression.children[1].tryEvaluate(state, options);
        result = _expression$children$2.value;
        error = _expression$children$2.error;
      } else {
        var _expression$children$3 = expression.children[2].tryEvaluate(state, options);
        result = _expression$children$3.value;
        error = _expression$children$3.error;
      }
      return {
        value: result,
        error: error
      };
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expr) {
      functionUtils_1.FunctionUtils.validateArityAndAnyType(expr, 3, 3);
    }
  }]);
  return If;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.If = If;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../options":204,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],67:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Mark a clause so that MostSpecificSelector will ignore it.
 * MostSpecificSelector considers A &amp; B to be more specific than A, but some clauses are unique and incomparable.
 *
 */
var Ignore = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Ignore, _expressionEvaluator_);
  var _super = _createSuper(Ignore);
  /**
   * Initializes a new instance of the [Ignore](xref:adaptive-expressions.Ignore) class.
   */
  function Ignore() {
    var _this;
    (0, _classCallCheck2.default)(this, Ignore);
    _this = _super.call(this, expressionType_1.ExpressionType.Ignore, Ignore.evaluator, returnType_1.ReturnType.Boolean, functionUtils_1.FunctionUtils.validateUnaryBoolean);
    _this.negation = (0, _assertThisInitialized2.default)(_this);
    return _this;
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Ignore, null, [{
    key: "evaluator",
    value: function evaluator(expression, state, options) {
      return expression.children[0].tryEvaluate(state, options);
    }
  }]);
  return Ignore;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Ignore = Ignore;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/assertThisInitialized":229,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],68:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
function __export(m) {
  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", {
  value: true
});
__export(require("./abs"));
__export(require("./accessor"));
__export(require("./add"));
__export(require("./addDays"));
__export(require("./addHours"));
__export(require("./addMinutes"));
__export(require("./addOrdinal"));
__export(require("./addProperty"));
__export(require("./addSeconds"));
__export(require("./addToTime"));
__export(require("./all"));
__export(require("./and"));
__export(require("./any"));
__export(require("./average"));
__export(require("./base64"));
__export(require("./base64ToBinary"));
__export(require("./base64ToString"));
__export(require("./binary"));
__export(require("./bool"));
__export(require("./ceiling"));
__export(require("./coalesce"));
__export(require("./comparisonEvaluator"));
__export(require("./concat"));
__export(require("./contains"));
__export(require("./convertFromUTC"));
__export(require("./convertToUTC"));
__export(require("./count"));
__export(require("./countWord"));
__export(require("./createArray"));
__export(require("./dataUri"));
__export(require("./dataUriToBinary"));
__export(require("./dataUriToString"));
__export(require("./dateFunc"));
__export(require("./dateReadBack"));
__export(require("./dateTimeDiff"));
__export(require("./dayOfMonth"));
__export(require("./dayOfWeek"));
__export(require("./dayOfYear"));
__export(require("./divide"));
__export(require("./element"));
__export(require("./empty"));
__export(require("./endsWith"));
__export(require("./eol"));
__export(require("./equal"));
__export(require("./exists"));
__export(require("./flatten"));
__export(require("./first"));
__export(require("./float"));
__export(require("./floor"));
__export(require("./foreach"));
__export(require("./formatDateTime"));
__export(require("./formatEpoch"));
__export(require("./formatNumber"));
__export(require("./formatTicks"));
__export(require("./getFutureTime"));
__export(require("./getNextViableDate"));
__export(require("./getNextViableTime"));
__export(require("./getPastTime"));
__export(require("./getPreviousViableDate"));
__export(require("./getPreviousViableTime"));
__export(require("./getPastTime"));
__export(require("./getProperty"));
__export(require("./getTimeOfDay"));
__export(require("./greaterThan"));
__export(require("./greaterThanOrEqual"));
__export(require("./if"));
__export(require("./ignore"));
__export(require("./indexOf"));
__export(require("./indicesAndValues"));
__export(require("./int"));
__export(require("./intersection"));
__export(require("./isArray"));
__export(require("./isBoolean"));
__export(require("./isDate"));
__export(require("./isDateRange"));
__export(require("./isDateTime"));
__export(require("./isDefinite"));
__export(require("./isDuration"));
__export(require("./isFloat"));
__export(require("./isInteger"));
__export(require("./isMatch"));
__export(require("./isObject"));
__export(require("./isPresent"));
__export(require("./isString"));
__export(require("./isTime"));
__export(require("./isTimeRange"));
__export(require("./join"));
__export(require("./jPath"));
__export(require("./json"));
__export(require("./jsonStringify"));
__export(require("./last"));
__export(require("./lastIndexOf"));
__export(require("./length"));
__export(require("./lessThan"));
__export(require("./lessThanOrEqual"));
__export(require("./max"));
__export(require("./merge"));
__export(require("./min"));
__export(require("./mod"));
__export(require("./month"));
__export(require("./multiply"));
__export(require("./multivariateNumericEvaluator"));
__export(require("./newGuid"));
__export(require("./not"));
__export(require("./notEqual"));
__export(require("./numberTransformEvaluator"));
__export(require("./numericEvaluator"));
__export(require("./optional"));
__export(require("./or"));
__export(require("./power"));
__export(require("./rand"));
__export(require("./range"));
__export(require("./removeProperty"));
__export(require("./replace"));
__export(require("./replaceIgnoreCase"));
__export(require("./reverse"));
__export(require("./round"));
__export(require("./select"));
__export(require("./sentenceCase"));
__export(require("./setPathToValue"));
__export(require("./setProperty"));
__export(require("./skip"));
__export(require("./sortBy"));
__export(require("./sortByDescending"));
__export(require("./split"));
__export(require("./sqrt"));
__export(require("./startOfDay"));
__export(require("./startOfHour"));
__export(require("./startOfMonth"));
__export(require("./startsWith"));
__export(require("./string"));
__export(require("./stringOrValue"));
__export(require("./stringTransformEvaluator"));
__export(require("./subArray"));
__export(require("./substring"));
__export(require("./subtract"));
__export(require("./subtractFromTime"));
__export(require("./sum"));
__export(require("./take"));
__export(require("./ticks"));
__export(require("./ticksToDays"));
__export(require("./ticksToHours"));
__export(require("./ticksToMinutes"));
__export(require("./timeTransformEvaluator"));
__export(require("./timexResolve"));
__export(require("./titleCase"));
__export(require("./toLower"));
__export(require("./toUpper"));
__export(require("./trim"));
__export(require("./union"));
__export(require("./unique"));
__export(require("./uriComponent"));
__export(require("./uriComponentToString"));
__export(require("./uriHost"));
__export(require("./uriPath"));
__export(require("./uriPathAndQuery"));
__export(require("./uriPort"));
__export(require("./uriQuery"));
__export(require("./uriScheme"));
__export(require("./utcNow"));
__export(require("./where"));
__export(require("./xml"));
__export(require("./xpath"));
__export(require("./year"));

},{"./abs":2,"./accessor":3,"./add":4,"./addDays":5,"./addHours":6,"./addMinutes":7,"./addOrdinal":8,"./addProperty":9,"./addSeconds":10,"./addToTime":11,"./all":12,"./and":13,"./any":14,"./average":15,"./base64":16,"./base64ToBinary":17,"./base64ToString":18,"./binary":19,"./bool":20,"./ceiling":21,"./coalesce":22,"./comparisonEvaluator":23,"./concat":24,"./contains":25,"./convertFromUTC":26,"./convertToUTC":27,"./count":28,"./countWord":29,"./createArray":30,"./dataUri":31,"./dataUriToBinary":32,"./dataUriToString":33,"./dateFunc":34,"./dateReadBack":35,"./dateTimeDiff":36,"./dayOfMonth":37,"./dayOfWeek":38,"./dayOfYear":39,"./divide":40,"./element":41,"./empty":42,"./endsWith":43,"./eol":44,"./equal":45,"./exists":46,"./first":47,"./flatten":48,"./float":49,"./floor":50,"./foreach":51,"./formatDateTime":52,"./formatEpoch":53,"./formatNumber":54,"./formatTicks":55,"./getFutureTime":56,"./getNextViableDate":57,"./getNextViableTime":58,"./getPastTime":59,"./getPreviousViableDate":60,"./getPreviousViableTime":61,"./getProperty":62,"./getTimeOfDay":63,"./greaterThan":64,"./greaterThanOrEqual":65,"./if":66,"./ignore":67,"./indexOf":69,"./indicesAndValues":70,"./int":71,"./intersection":72,"./isArray":73,"./isBoolean":74,"./isDate":75,"./isDateRange":76,"./isDateTime":77,"./isDefinite":78,"./isDuration":79,"./isFloat":80,"./isInteger":81,"./isMatch":82,"./isObject":83,"./isPresent":84,"./isString":85,"./isTime":86,"./isTimeRange":87,"./jPath":88,"./join":89,"./json":90,"./jsonStringify":91,"./last":92,"./lastIndexOf":93,"./length":94,"./lessThan":95,"./lessThanOrEqual":96,"./max":97,"./merge":98,"./min":99,"./mod":100,"./month":101,"./multiply":102,"./multivariateNumericEvaluator":103,"./newGuid":104,"./not":105,"./notEqual":106,"./numberTransformEvaluator":107,"./numericEvaluator":108,"./optional":109,"./or":110,"./power":111,"./rand":112,"./range":113,"./removeProperty":114,"./replace":115,"./replaceIgnoreCase":116,"./reverse":117,"./round":118,"./select":119,"./sentenceCase":120,"./setPathToValue":121,"./setProperty":122,"./skip":123,"./sortBy":124,"./sortByDescending":125,"./split":126,"./sqrt":127,"./startOfDay":128,"./startOfHour":129,"./startOfMonth":130,"./startsWith":131,"./string":132,"./stringOrValue":133,"./stringTransformEvaluator":134,"./subArray":135,"./substring":136,"./subtract":137,"./subtractFromTime":138,"./sum":139,"./take":140,"./ticks":141,"./ticksToDays":142,"./ticksToHours":143,"./ticksToMinutes":144,"./timeTransformEvaluator":145,"./timexResolve":146,"./titleCase":147,"./toLower":148,"./toUpper":149,"./trim":150,"./union":151,"./unique":152,"./uriComponent":153,"./uriComponentToString":154,"./uriHost":155,"./uriPath":156,"./uriPathAndQuery":157,"./uriPort":158,"./uriQuery":159,"./uriScheme":160,"./utcNow":161,"./where":162,"./xml":163,"./xpath":164,"./year":165}],69:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Returns the index of the first occurrence of a value in an array.
 * The zero-based index position of value if that value is found, or -1 if it is not.
 */
var IndexOf = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(IndexOf, _expressionEvaluator_);
  var _super = _createSuper(IndexOf);
  /**
   * Initializes a new instance of the [IndexOf](xref:adaptive-expressions.IndexOf) class.
   */
  function IndexOf() {
    (0, _classCallCheck2.default)(this, IndexOf);
    return _super.call(this, expressionType_1.ExpressionType.IndexOf, IndexOf.evaluator, returnType_1.ReturnType.Number, IndexOf.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(IndexOf, null, [{
    key: "evaluator",
    value: function evaluator(expression, state, options) {
      var value = -1;
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expression, state, options),
        args = _functionUtils_1$Func.args,
        childrenError = _functionUtils_1$Func.error;
      var error = childrenError;
      if (!error) {
        if (args[0] == null || typeof args[0] === 'string') {
          if (args[1] === undefined || typeof args[1] === 'string') {
            value = functionUtils_internal_1.InternalFunctionUtils.parseStringOrUndefined(args[0]).indexOf(functionUtils_internal_1.InternalFunctionUtils.parseStringOrUndefined(args[1]));
          } else {
            error = "Can only look for indexof string in ".concat(expression);
          }
        } else if (Array.isArray(args[0])) {
          value = args[0].indexOf(args[1]);
        } else {
          error = "".concat(expression, " works only on string or list.");
        }
      }
      return {
        value: value,
        error: error
      };
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateOrder(expression, [], returnType_1.ReturnType.String | returnType_1.ReturnType.Array, returnType_1.ReturnType.Object);
    }
  }]);
  return IndexOf;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.IndexOf = IndexOf;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],70:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.object.entries.js");
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Turn an array or object into an array of objects with index and value properties.
 * For arrays, the index is the position in the array.
 * For objects, it is the key for the value.
 */
var IndicesAndValues = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(IndicesAndValues, _expressionEvaluator_);
  var _super = _createSuper(IndicesAndValues);
  /**
   * Initializes a new instance of the [IndicesAndValues](xref:adaptive-expressions.IndicesAndValues) class.
   */
  function IndicesAndValues() {
    (0, _classCallCheck2.default)(this, IndicesAndValues);
    return _super.call(this, expressionType_1.ExpressionType.IndicesAndValues, IndicesAndValues.evaluator, returnType_1.ReturnType.Array, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(IndicesAndValues, null, [{
    key: "evaluator",
    value: function evaluator(expression, state, options) {
      // eslint-disable-next-line @typescript-eslint/ban-types
      var result = undefined;
      var error = undefined;
      var value = undefined;
      var _expression$children$ = expression.children[0].tryEvaluate(state, options);
      value = _expression$children$.value;
      error = _expression$children$.error;
      if (error === undefined) {
        if (Array.isArray(value)) {
          var tempList = [];
          for (var i = 0; i < value.length; i++) {
            tempList.push({
              index: i,
              value: value[i]
            });
          }
          result = tempList;
        } else if ((0, _typeof2.default)(value) === 'object') {
          var _tempList = [];
          for (var _i = 0, _Object$entries = Object.entries(value); _i < _Object$entries.length; _i++) {
            var _Object$entries$_i = (0, _slicedToArray2.default)(_Object$entries[_i], 2),
              index = _Object$entries$_i[0],
              val = _Object$entries$_i[1];
            _tempList.push({
              index: index,
              value: val
            });
          }
          result = _tempList;
        } else {
          error = "".concat(expression.children[0], " is not array or object.");
        }
      }
      return {
        value: result,
        error: error
      };
    }
  }]);
  return IndicesAndValues;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.IndicesAndValues = IndicesAndValues;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/slicedToArray":247,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.entries.js":602,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],71:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var big_integer_1 = __importDefault(require("big-integer"));
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Return the integer version of a string.
 */
var Int = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Int, _expressionEvaluator_);
  var _super = _createSuper(Int);
  /**
   * Initializes a new instance of the [Int](xref:adaptive-expressions.Int) class.
   */
  function Int() {
    (0, _classCallCheck2.default)(this, Int);
    return _super.call(this, expressionType_1.ExpressionType.Int, Int.evaluator(), returnType_1.ReturnType.Number, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Int, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.applyWithError(function (args) {
        var error;
        var value;
        var firstChild = args[0];
        if (big_integer_1.default.isInstance(firstChild)) {
          return {
            value: firstChild.toJSNumber(),
            error: error
          };
        }
        if (typeof firstChild === 'string') {
          value = parseInt(firstChild, 10);
          if (!functionUtils_1.FunctionUtils.isNumber(value)) {
            error = "parameter ".concat(args[0], " is not a valid number string.");
          }
        } else if (functionUtils_1.FunctionUtils.isNumber(firstChild)) {
          value = parseInt(firstChild.toString(), 10);
        }
        return {
          value: value,
          error: error
        };
      });
    }
  }]);
  return Int;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Int = Int;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"big-integer":419,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.to-string.js":620}],72:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.reflect.construct.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.set.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.array.filter.js");
require("core-js/modules/es.number.max-safe-integer.js");
require("core-js/modules/es.number.constructor.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Return a collection that has only the common items across the specified collections.
 * To appear in the result, an item must appear in all the collections passed to this function.
 * If one or more items have the same name,
 * the last item with that name appears in the result.
 */
var Intersection = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Intersection, _expressionEvaluator_);
  var _super = _createSuper(Intersection);
  /**
   * Initializes a new instance of the [Intersection](xref:adaptive-expressions.Intersection) class.
   */
  function Intersection() {
    (0, _classCallCheck2.default)(this, Intersection);
    return _super.call(this, expressionType_1.ExpressionType.Intersection, Intersection.evaluator(), returnType_1.ReturnType.Array, Intersection.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Intersection, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        var result = args[0];
        var _iterator = _createForOfIteratorHelper(args),
          _step;
        try {
          var _loop = function _loop() {
            var arg = _step.value;
            result = result.filter(function (e) {
              return arg.indexOf(e) > -1;
            });
          };
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            _loop();
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return Array.from(new Set(result));
      }, functionUtils_1.FunctionUtils.verifyList);
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateArityAndAnyType(expression, 1, Number.MAX_SAFE_INTEGER, returnType_1.ReturnType.Array);
    }
  }]);
  return Intersection;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Intersection = Intersection;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.array.filter.js":572,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.number.max-safe-integer.js":597,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.set.js":621,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],73:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Return true if a given input is an array.
 */
var IsArray = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(IsArray, _expressionEvaluator_);
  var _super = _createSuper(IsArray);
  /**
   * Initializes a new instance of the [IsArray](xref:adaptive-expressions.IsArray) class.
   */
  function IsArray() {
    (0, _classCallCheck2.default)(this, IsArray);
    return _super.call(this, expressionType_1.ExpressionType.IsArray, IsArray.evaluator(), returnType_1.ReturnType.Boolean, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(IsArray, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        return Array.isArray(args[0]);
      });
    }
  }]);
  return IsArray;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.IsArray = IsArray;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],74:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Return true if a given input is a Boolean.
 */
var IsBoolean = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(IsBoolean, _expressionEvaluator_);
  var _super = _createSuper(IsBoolean);
  /**
   * Initializes a new instance of the [IsBoolean](xref:adaptive-expressions.IsBoolean) class.
   */
  function IsBoolean() {
    (0, _classCallCheck2.default)(this, IsBoolean);
    return _super.call(this, expressionType_1.ExpressionType.IsBoolean, IsBoolean.evaluator(), returnType_1.ReturnType.Boolean, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(IsBoolean, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        return typeof args[0] === 'boolean';
      });
    }
  }]);
  return IsBoolean;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.IsBoolean = IsBoolean;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],75:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Return true if a given `TimexProperty` or timex string refers to a valid date.
 * Valid dates contain the month and dayOfMonth, or contain the dayOfWeek.
 */
var IsDate = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(IsDate, _expressionEvaluator_);
  var _super = _createSuper(IsDate);
  /**
   * Initializes a new instance of the [IsDate](xref:adaptive-expressions.IsDate) class.
   */
  function IsDate() {
    (0, _classCallCheck2.default)(this, IsDate);
    return _super.call(this, expressionType_1.ExpressionType.IsDate, IsDate.evaluator, returnType_1.ReturnType.Boolean, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(IsDate, null, [{
    key: "evaluator",
    value: function evaluator(expr, state, options) {
      var parsed;
      var value = false;
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expr, state, options),
        args = _functionUtils_1$Func.args,
        childrenError = _functionUtils_1$Func.error;
      var error = childrenError;
      if (!error) {
        var _functionUtils_intern = functionUtils_internal_1.InternalFunctionUtils.parseTimexProperty(args[0]);
        parsed = _functionUtils_intern.timexProperty;
        error = _functionUtils_intern.error;
      }
      if (parsed && !error) {
        value = parsed.month !== undefined && parsed.dayOfMonth !== undefined || parsed.dayOfWeek !== undefined;
      }
      return {
        value: value,
        error: error
      };
    }
  }]);
  return IsDate;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.IsDate = IsDate;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],76:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Return true if a given TimexProperty or Timex expression refers to a valid date range.
 */
var IsDateRange = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(IsDateRange, _expressionEvaluator_);
  var _super = _createSuper(IsDateRange);
  /**
   * Initializes a new instance of the [IsDateRange](xref:adaptive-expressions.IsDateRange) class.
   */
  function IsDateRange() {
    (0, _classCallCheck2.default)(this, IsDateRange);
    return _super.call(this, expressionType_1.ExpressionType.IsDateRange, IsDateRange.evaluator, returnType_1.ReturnType.Boolean, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(IsDateRange, null, [{
    key: "evaluator",
    value: function evaluator(expr, state, options) {
      var parsed;
      var value = false;
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expr, state, options),
        args = _functionUtils_1$Func.args,
        childrenError = _functionUtils_1$Func.error;
      var error = childrenError;
      if (!error) {
        var _functionUtils_intern = functionUtils_internal_1.InternalFunctionUtils.parseTimexProperty(args[0]);
        parsed = _functionUtils_intern.timexProperty;
        error = _functionUtils_intern.error;
      }
      if (parsed && !error) {
        value = parsed.year !== undefined && parsed.dayOfMonth === undefined || parsed.year !== undefined && parsed.month !== undefined && parsed.dayOfMonth === undefined || parsed.month !== undefined && parsed.dayOfMonth === undefined || parsed.season !== undefined || parsed.weekOfYear !== undefined || parsed.weekOfMonth !== undefined;
      }
      return {
        value: value,
        error: error
      };
    }
  }]);
  return IsDateRange;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.IsDateRange = IsDateRange;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],77:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Return true if a given input is a UTC ISO format (YYYY-MM-DDTHH:mm:ss.fffZ) timestamp string.
 */
var IsDateTime = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(IsDateTime, _expressionEvaluator_);
  var _super = _createSuper(IsDateTime);
  /**
   * Initializes a new instance of the [IsDateTime](xref:adaptive-expressions.IsDateTime) class.
   */
  function IsDateTime() {
    (0, _classCallCheck2.default)(this, IsDateTime);
    return _super.call(this, expressionType_1.ExpressionType.IsDateTime, IsDateTime.evaluator(), returnType_1.ReturnType.Boolean, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(IsDateTime, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        return typeof args[0] === 'string' && functionUtils_internal_1.InternalFunctionUtils.verifyISOTimestamp(args[0]) === undefined;
      });
    }
  }]);
  return IsDateTime;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.IsDateTime = IsDateTime;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],78:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Return true if a given TimexProperty or Timex expression refers to a valid date. Valid dates contain the year, month and dayOfMonth.
 */
var IsDefinite = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(IsDefinite, _expressionEvaluator_);
  var _super = _createSuper(IsDefinite);
  /**
   * Initializes a new instance of the [IsDefinite](xref:adaptive-expressions.IsDefinite) class.
   */
  function IsDefinite() {
    (0, _classCallCheck2.default)(this, IsDefinite);
    return _super.call(this, expressionType_1.ExpressionType.IsDefinite, IsDefinite.evaluator, returnType_1.ReturnType.Boolean, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(IsDefinite, null, [{
    key: "evaluator",
    value: function evaluator(expr, state, options) {
      var parsed;
      var value = false;
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expr, state, options),
        args = _functionUtils_1$Func.args,
        childrenError = _functionUtils_1$Func.error;
      var error = childrenError;
      if (!error) {
        var _functionUtils_intern = functionUtils_internal_1.InternalFunctionUtils.parseTimexProperty(args[0]);
        parsed = _functionUtils_intern.timexProperty;
        error = _functionUtils_intern.error;
      }
      if (!error) {
        value = parsed != undefined && parsed.year !== undefined && parsed.month !== undefined && parsed.dayOfMonth !== undefined;
      }
      return {
        value: value,
        error: error
      };
    }
  }]);
  return IsDefinite;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.IsDefinite = IsDefinite;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],79:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Return true if a given TimexProperty or Timex expression refers to a valid duration.
 */
var IsDuration = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(IsDuration, _expressionEvaluator_);
  var _super = _createSuper(IsDuration);
  /**
   * Initializes a new instance of the [IsDuration](xref:adaptive-expressions.IsDuration) class.
   */
  function IsDuration() {
    (0, _classCallCheck2.default)(this, IsDuration);
    return _super.call(this, expressionType_1.ExpressionType.IsDuration, IsDuration.evaluator, returnType_1.ReturnType.Boolean, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(IsDuration, null, [{
    key: "evaluator",
    value: function evaluator(expr, state, options) {
      var parsed;
      var value = false;
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expr, state, options),
        args = _functionUtils_1$Func.args,
        childrenError = _functionUtils_1$Func.error;
      var error = childrenError;
      if (!error) {
        var _functionUtils_intern = functionUtils_internal_1.InternalFunctionUtils.parseTimexProperty(args[0]);
        parsed = _functionUtils_intern.timexProperty;
        error = _functionUtils_intern.error;
      }
      if (parsed && !error) {
        value = parsed.years !== undefined || parsed.months !== undefined || parsed.weeks !== undefined || parsed.days !== undefined || parsed.hours !== undefined || parsed.minutes !== undefined || parsed.seconds !== undefined;
      }
      return {
        value: value,
        error: error
      };
    }
  }]);
  return IsDuration;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.IsDuration = IsDuration;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],80:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.number.is-integer.js");
require("core-js/modules/es.number.constructor.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Return true if a given input is a floating-point number.
 * Due to the alignment between C# and JavaScript, a number with an non-zero residue of its modulo 1 will be treated as a floating-point number.
 */
var IsFloat = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(IsFloat, _expressionEvaluator_);
  var _super = _createSuper(IsFloat);
  /**
   * Initializes a new instance of the [IsFloat](xref:adaptive-expressions.IsFloat) class.
   */
  function IsFloat() {
    (0, _classCallCheck2.default)(this, IsFloat);
    return _super.call(this, expressionType_1.ExpressionType.IsFloat, IsFloat.evaluator(), returnType_1.ReturnType.Boolean, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(IsFloat, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        return functionUtils_1.FunctionUtils.isNumber(args[0]) && !Number.isInteger(args[0]);
      });
    }
  }]);
  return IsFloat;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.IsFloat = IsFloat;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.number.is-integer.js":595,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],81:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.number.is-integer.js");
require("core-js/modules/es.number.constructor.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Return true if a given input is an integer number. Due to the alignment between C# and JavaScript, a number with a zero residue of its modulo 1 will be treated as an integer number.
 */
var IsInteger = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(IsInteger, _expressionEvaluator_);
  var _super = _createSuper(IsInteger);
  /**
   * Initializes a new instance of the [IsInteger](xref:adaptive-expressions.IsInteger) class.
   */
  function IsInteger() {
    (0, _classCallCheck2.default)(this, IsInteger);
    return _super.call(this, expressionType_1.ExpressionType.IsInteger, IsInteger.evaluator(), returnType_1.ReturnType.Boolean, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(IsInteger, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        return functionUtils_1.FunctionUtils.isNumber(args[0]) && Number.isInteger(args[0]);
      });
    }
  }]);
  return IsInteger;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.IsInteger = IsInteger;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.number.is-integer.js":595,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],82:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.regexp.exec.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var commonRegex_1 = require("../commonRegex");
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Return true if a given string matches a specified regular expression pattern.
 */
var IsMatch = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(IsMatch, _expressionEvaluator_);
  var _super = _createSuper(IsMatch);
  /**
   * Initializes a new instance of the [IsMatch](xref:adaptive-expressions.IsMatch) class.
   */
  function IsMatch() {
    (0, _classCallCheck2.default)(this, IsMatch);
    return _super.call(this, expressionType_1.ExpressionType.IsMatch, IsMatch.evaluator(), returnType_1.ReturnType.Boolean, IsMatch.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(IsMatch, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.applyWithError(function (args) {
        var regex = commonRegex_1.CommonRegex.CreateRegex(args[1].toString());
        var inputString = args[0] ? args[0].toString() : '';
        var value = regex.test(inputString);
        return {
          value: value,
          undefined: undefined
        };
      }, functionUtils_1.FunctionUtils.verifyStringOrNull);
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateArityAndAnyType(expression, 2, 2, returnType_1.ReturnType.String);
      var second = expression.children[1];
      if (second.returnType === returnType_1.ReturnType.String && second.type === expressionType_1.ExpressionType.Constant) {
        commonRegex_1.CommonRegex.CreateRegex(second.value.toString());
      }
    }
  }]);
  return IsMatch;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.IsMatch = IsMatch;

},{"../commonRegex":166,"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620}],83:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Return true if a given input is a complex object or return false if it is a primitive object.
 * Primitive objects include strings, numbers, and Booleans;
 * complex types, contain properties.
 */
var IsObject = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(IsObject, _expressionEvaluator_);
  var _super = _createSuper(IsObject);
  /**
   * Initializes a new instance of the [IsObject](xref:adaptive-expressions.IsObject) class.
   */
  function IsObject() {
    (0, _classCallCheck2.default)(this, IsObject);
    return _super.call(this, expressionType_1.ExpressionType.IsObject, IsObject.evaluator(), returnType_1.ReturnType.Boolean, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(IsObject, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        return (0, _typeof2.default)(args[0]) === 'object';
      });
    }
  }]);
  return IsObject;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.IsObject = IsObject;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],84:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Return true if a given TimexProperty or Timex expression refers to the present.
 */
var IsPresent = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(IsPresent, _expressionEvaluator_);
  var _super = _createSuper(IsPresent);
  /**
   * Initializes a new instance of the [IsPresent](xref:adaptive-expressions.IsPresent) class.
   */
  function IsPresent() {
    (0, _classCallCheck2.default)(this, IsPresent);
    return _super.call(this, expressionType_1.ExpressionType.IsPresent, IsPresent.evaluator, returnType_1.ReturnType.Boolean, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(IsPresent, null, [{
    key: "evaluator",
    value: function evaluator(expr, state, options) {
      var parsed;
      var value = false;
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expr, state, options),
        args = _functionUtils_1$Func.args,
        childrenError = _functionUtils_1$Func.error;
      var error = childrenError;
      if (!error) {
        var _functionUtils_intern = functionUtils_internal_1.InternalFunctionUtils.parseTimexProperty(args[0]);
        parsed = _functionUtils_intern.timexProperty;
        error = _functionUtils_intern.error;
      }
      if (parsed && !error) {
        value = parsed.now !== undefined;
      }
      return {
        value: value,
        error: error
      };
    }
  }]);
  return IsPresent;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.IsPresent = IsPresent;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],85:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Return true if a given input is a string.
 */
var IsString = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(IsString, _expressionEvaluator_);
  var _super = _createSuper(IsString);
  /**
   * Initializes a new instance of the [IsString](xref:adaptive-expressions.IsString) class.
   */
  function IsString() {
    (0, _classCallCheck2.default)(this, IsString);
    return _super.call(this, expressionType_1.ExpressionType.IsString, IsString.evaluator(), returnType_1.ReturnType.Boolean, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(IsString, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        return typeof args[0] === 'string';
      });
    }
  }]);
  return IsString;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.IsString = IsString;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],86:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Return true if a given TimexProperty or Timex expression refers to a valid time.
 * Valid time contains hours, minutes and seconds.
 */
var IsTime = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(IsTime, _expressionEvaluator_);
  var _super = _createSuper(IsTime);
  /**
   * Initializes a new instance of the [IsTime](xref:adaptive-expressions.IsTime) class.
   */
  function IsTime() {
    (0, _classCallCheck2.default)(this, IsTime);
    return _super.call(this, expressionType_1.ExpressionType.IsTime, IsTime.evaluator, returnType_1.ReturnType.Boolean, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(IsTime, null, [{
    key: "evaluator",
    value: function evaluator(expr, state, options) {
      var parsed;
      var value = false;
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expr, state, options),
        args = _functionUtils_1$Func.args,
        childrenError = _functionUtils_1$Func.error;
      var error = childrenError;
      if (!error) {
        var _functionUtils_intern = functionUtils_internal_1.InternalFunctionUtils.parseTimexProperty(args[0]);
        parsed = _functionUtils_intern.timexProperty;
        error = _functionUtils_intern.error;
      }
      if (parsed && !error) {
        value = parsed.hour !== undefined && parsed.minute !== undefined && parsed.second !== undefined;
      }
      return {
        value: value,
        error: error
      };
    }
  }]);
  return IsTime;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.IsTime = IsTime;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],87:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Return true if a given `TimexProperty` or Timex string refers to a valid time range Valid time ranges contain partOfDay.
 */
var IsTimeRange = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(IsTimeRange, _expressionEvaluator_);
  var _super = _createSuper(IsTimeRange);
  /**
   * Initializes a new instance of the [IsTimeRange](xref:adaptive-expressions.IsTimeRange) class.
   */
  function IsTimeRange() {
    (0, _classCallCheck2.default)(this, IsTimeRange);
    return _super.call(this, expressionType_1.ExpressionType.IsTimeRange, IsTimeRange.evaluator, returnType_1.ReturnType.Boolean, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(IsTimeRange, null, [{
    key: "evaluator",
    value: function evaluator(expr, state, options) {
      var parsed;
      var value = false;
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expr, state, options),
        args = _functionUtils_1$Func.args,
        childrenError = _functionUtils_1$Func.error;
      var error = childrenError;
      if (!error) {
        var _functionUtils_intern = functionUtils_internal_1.InternalFunctionUtils.parseTimexProperty(args[0]);
        parsed = _functionUtils_intern.timexProperty;
        error = _functionUtils_intern.error;
      }
      if (parsed && !error) {
        value = parsed.partOfDay !== undefined;
      }
      return {
        value: value,
        error: error
      };
    }
  }]);
  return IsTimeRange;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.IsTimeRange = IsTimeRange;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],88:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.object.keys.js");
require("core-js/modules/es.array.concat.js");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result["default"] = mod;
  return result;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var jsPath = __importStar(require("jspath"));
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Check JSON or a JSON string for nodes or values that match a path expression, and return the matching nodes.
 */
var JPath = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(JPath, _expressionEvaluator_);
  var _super = _createSuper(JPath);
  /**
   * Initializes a new instance of the [JPath](xref:adaptive-expressions.JPath) class.
   */
  function JPath() {
    (0, _classCallCheck2.default)(this, JPath);
    return _super.call(this, expressionType_1.ExpressionType.JPath, JPath.evaluator(), returnType_1.ReturnType.Object, JPath.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(JPath, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.applyWithError(function (args) {
        return JPath.evalJPath(args[0], args[1].toString());
      });
    }
    /**
     * @private
     */
    // eslint-disable-next-line @typescript-eslint/ban-types
  }, {
    key: "evalJPath",
    value: function evalJPath(jsonEntity, path) {
      var error;
      var evaled;
      // eslint-disable-next-line @typescript-eslint/ban-types
      var json;
      if (typeof jsonEntity === 'string') {
        try {
          json = JSON.parse(jsonEntity);
        } catch (_a) {
          error = "".concat(jsonEntity, " is not a valid json string");
        }
      } else if ((0, _typeof2.default)(jsonEntity) === 'object') {
        json = jsonEntity;
      } else {
        error = 'the first parameter should be either an object or a string';
      }
      if (!error) {
        try {
          evaled = jsPath.apply(path, json);
        } catch (e) {
          error = "".concat(path, " is not a valid path + ").concat(e);
        }
      }
      return {
        value: evaled,
        error: error
      };
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expr) {
      functionUtils_1.FunctionUtils.validateOrder(expr, undefined, returnType_1.ReturnType.Object, returnType_1.ReturnType.String);
    }
  }]);
  return JPath;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.JPath = JPath;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.object.keys.js":609,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.to-string.js":620,"jspath":727}],89:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.concat.js");
require("core-js/modules/es.array.join.js");
require("core-js/modules/es.array.slice.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Return a string that has all the items from an array, with each character separated by a delimiter.
 */
var Join = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Join, _expressionEvaluator_);
  var _super = _createSuper(Join);
  /**
   * Initializes a new instance of the Join class.
   */
  function Join() {
    (0, _classCallCheck2.default)(this, Join);
    return _super.call(this, expressionType_1.ExpressionType.Join, Join.evaluator, returnType_1.ReturnType.String, Join.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Join, null, [{
    key: "evaluator",
    value: function evaluator(expression, state, options) {
      var value;
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expression, state, options),
        args = _functionUtils_1$Func.args,
        childrenError = _functionUtils_1$Func.error;
      var error = childrenError;
      if (!error) {
        if (!Array.isArray(args[0])) {
          error = "".concat(expression.children[0], " evaluates to ").concat(args[0], " which is not a list.");
        } else {
          if (args.length === 2) {
            value = args[0].join(args[1]);
          } else {
            if (args[0].length < 3) {
              value = args[0].join(args[2]);
            } else {
              var firstPart = args[0].slice(0, args[0].length - 1).join(args[1]);
              value = firstPart.concat(args[2], args[0][args[0].length - 1]);
            }
          }
        }
      }
      return {
        value: value,
        error: error
      };
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateOrder(expression, [returnType_1.ReturnType.String], returnType_1.ReturnType.Array, returnType_1.ReturnType.String);
    }
  }]);
  return Join;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Join = Join;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.array.join.js":578,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],90:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.object.keys.js");
require("core-js/modules/es.string.trim.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Return the JavaScript Object Notation (JSON) type value or object of a string or XML.
 */
var Json = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Json, _expressionEvaluator_);
  var _super = _createSuper(Json);
  /**
   * Initializes a new instance of the [Json](xref:adaptive-expressions.Json) class.
   */
  function Json() {
    (0, _classCallCheck2.default)(this, Json);
    return _super.call(this, expressionType_1.ExpressionType.Json, Json.evaluator(), returnType_1.ReturnType.Object, Json.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Json, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        return JSON.parse(args[0].trim());
      });
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateOrder(expression, undefined, returnType_1.ReturnType.String);
    }
  }]);
  return Json;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Json = Json;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.keys.js":609,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.string.trim.js":634}],91:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Return the string version of a value.
 */
var JsonStringify = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(JsonStringify, _expressionEvaluator_);
  var _super = _createSuper(JsonStringify);
  /**
   * Initializes a new instance of the [JsonStringify](xref:adaptive-expressions.JsonStringify) class.
   */
  function JsonStringify() {
    (0, _classCallCheck2.default)(this, JsonStringify);
    return _super.call(this, expressionType_1.ExpressionType.JsonStringify, JsonStringify.evaluator(), returnType_1.ReturnType.String, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(JsonStringify, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        return JSON.stringify(args[0]);
      });
    }
  }]);
  return JsonStringify;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.JsonStringify = JsonStringify;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],92:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Return the last item from a collection.
 */
var Last = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Last, _expressionEvaluator_);
  var _super = _createSuper(Last);
  /**
   * Initializes a new instance of the [Last](xref:adaptive-expressions.Last) class.
   */
  function Last() {
    (0, _classCallCheck2.default)(this, Last);
    return _super.call(this, expressionType_1.ExpressionType.Last, Last.evaluator(), returnType_1.ReturnType.Object, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Last, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        var last;
        if (typeof args[0] === 'string' && args[0].length > 0) {
          last = args[0][args[0].length - 1];
        }
        if (Array.isArray(args[0]) && args[0].length > 0) {
          last = functionUtils_internal_1.InternalFunctionUtils.accessIndex(args[0], args[0].length - 1).value;
        }
        return last;
      });
    }
  }]);
  return Last;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Last = Last;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],93:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Returns the index of the last occurrence of a specified value in an array.
 * The zero-based index position of value if that value is found, or -1 if it is not.
 */
var LastIndexOf = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(LastIndexOf, _expressionEvaluator_);
  var _super = _createSuper(LastIndexOf);
  /**
   * Initializes a new instance of the [LastIndexOf](xref:adaptive-expressions.LastIndexOf) class.
   */
  function LastIndexOf() {
    (0, _classCallCheck2.default)(this, LastIndexOf);
    return _super.call(this, expressionType_1.ExpressionType.LastIndexOf, LastIndexOf.evaluator, returnType_1.ReturnType.Number, LastIndexOf.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(LastIndexOf, null, [{
    key: "evaluator",
    value: function evaluator(expression, state, options) {
      var value = -1;
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expression, state, options),
        args = _functionUtils_1$Func.args,
        childrenError = _functionUtils_1$Func.error;
      var error = childrenError;
      if (!error) {
        if (args[0] == null || typeof args[0] === 'string') {
          if (args[1] === undefined || typeof args[1] === 'string') {
            var str = functionUtils_internal_1.InternalFunctionUtils.parseStringOrUndefined(args[0]);
            var searchValue = functionUtils_internal_1.InternalFunctionUtils.parseStringOrUndefined(args[1]);
            value = str.lastIndexOf(searchValue, str.length - 1);
          } else {
            error = "Can only look for indexof string in ".concat(expression);
          }
        } else if (Array.isArray(args[0])) {
          value = args[0].lastIndexOf(args[1]);
        } else {
          error = "".concat(expression, " works only on string or list.");
        }
      }
      return {
        value: value,
        error: error
      };
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateOrder(expression, [], returnType_1.ReturnType.String | returnType_1.ReturnType.Array, returnType_1.ReturnType.Object);
    }
  }]);
  return LastIndexOf;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.LastIndexOf = LastIndexOf;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],94:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Return the length of a string.
 */
var Length = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Length, _expressionEvaluator_);
  var _super = _createSuper(Length);
  /**
   * Initializes a new instance of the [Length](xref:adaptive-expressions.Length) class.
   */
  function Length() {
    (0, _classCallCheck2.default)(this, Length);
    return _super.call(this, expressionType_1.ExpressionType.Length, Length.evaluator(), returnType_1.ReturnType.Number, functionUtils_1.FunctionUtils.validateUnaryString);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Length, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        return functionUtils_internal_1.InternalFunctionUtils.parseStringOrUndefined(args[0]).length;
      }, functionUtils_1.FunctionUtils.verifyStringOrNull);
    }
  }]);
  return Length;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Length = Length;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],95:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.concat.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var comparisonEvaluator_1 = require("./comparisonEvaluator");
/**
 * Check whether the first value is less than the second value.
 * Return true if the first value is less, or return false if the first value is more.
 */
var LessThan = /*#__PURE__*/function (_comparisonEvaluator_) {
  (0, _inherits2.default)(LessThan, _comparisonEvaluator_);
  var _super = _createSuper(LessThan);
  /**
   * Initializes a new instance of the [LessThan](xref:adaptive-expressions.LessThan) class.
   */
  function LessThan() {
    (0, _classCallCheck2.default)(this, LessThan);
    return _super.call(this, expressionType_1.ExpressionType.LessThan, LessThan.func, functionUtils_1.FunctionUtils.validateBinary, functionUtils_1.FunctionUtils.verifyNotNull);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(LessThan, null, [{
    key: "func",
    value: function func(args) {
      if (functionUtils_1.FunctionUtils.isNumber(args[0]) && functionUtils_1.FunctionUtils.isNumber(args[1]) || typeof args[0] === 'string' && typeof args[1] === 'string' || args[0] instanceof Date && args[1] instanceof Date) {
        return args[0] < args[1];
      } else {
        throw new Error("".concat(args[0], " and ").concat(args[1], " must be comparable."));
      }
    }
  }]);
  return LessThan;
}(comparisonEvaluator_1.ComparisonEvaluator);
exports.LessThan = LessThan;

},{"../expressionType":192,"../functionUtils":196,"./comparisonEvaluator":23,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],96:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.concat.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var comparisonEvaluator_1 = require("./comparisonEvaluator");
/**
 * Check whether the first value is less than or equal to the second value.
 * Return true if the first value is less than or equal, or return false if the first value is more.
 */
var LessThanOrEqual = /*#__PURE__*/function (_comparisonEvaluator_) {
  (0, _inherits2.default)(LessThanOrEqual, _comparisonEvaluator_);
  var _super = _createSuper(LessThanOrEqual);
  /**
   * Initializes a new instance of the [LessThanOrEqual](xref:adaptive-expressions.LessThanOrEqual) class.
   */
  function LessThanOrEqual() {
    (0, _classCallCheck2.default)(this, LessThanOrEqual);
    return _super.call(this, expressionType_1.ExpressionType.LessThanOrEqual, LessThanOrEqual.func, functionUtils_1.FunctionUtils.validateBinary, functionUtils_1.FunctionUtils.verifyNotNull);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(LessThanOrEqual, null, [{
    key: "func",
    value: function func(args) {
      if (functionUtils_1.FunctionUtils.isNumber(args[0]) && functionUtils_1.FunctionUtils.isNumber(args[1]) || typeof args[0] === 'string' && typeof args[1] === 'string' || args[0] instanceof Date && args[1] instanceof Date) {
        return args[0] <= args[1];
      } else {
        throw new Error("".concat(args[0], " and ").concat(args[1], " must be comparable."));
      }
    }
  }]);
  return LessThanOrEqual;
}(comparisonEvaluator_1.ComparisonEvaluator);
exports.LessThanOrEqual = LessThanOrEqual;

},{"../expressionType":192,"../functionUtils":196,"./comparisonEvaluator":23,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],97:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.number.constructor.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 *  Return the highest value from an array. The array is inclusive at both ends.
 */
var Max = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Max, _expressionEvaluator_);
  var _super = _createSuper(Max);
  /**
   * Initializes a new instance of the [Max](xref:adaptive-expressions.Max) class.
   */
  function Max() {
    (0, _classCallCheck2.default)(this, Max);
    return _super.call(this, expressionType_1.ExpressionType.Max, Max.evaluator(), returnType_1.ReturnType.Number, functionUtils_1.FunctionUtils.validateAtLeastOne);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Max, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        var result = Number.NEGATIVE_INFINITY;
        if (args.length === 1) {
          if (Array.isArray(args[0])) {
            var _iterator = _createForOfIteratorHelper(args[0]),
              _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var value = _step.value;
                result = Math.max(result, value);
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
          } else {
            result = Math.max(result, args[0]);
          }
        } else {
          var _iterator2 = _createForOfIteratorHelper(args),
            _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var arg = _step2.value;
              if (Array.isArray(arg)) {
                var _iterator3 = _createForOfIteratorHelper(arg),
                  _step3;
                try {
                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                    var _value = _step3.value;
                    result = Math.max(result, _value);
                  }
                } catch (err) {
                  _iterator3.e(err);
                } finally {
                  _iterator3.f();
                }
              } else {
                result = Math.max(result, arg);
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
        return result;
      }, functionUtils_1.FunctionUtils.verifyNumberOrNumericList);
    }
  }]);
  return Max;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Max = Max;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],98:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.object.assign.js");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Merge multiple object(json) into one object(json).
 * If the item is array, the elements of the array are merged as well.
 */
var Merge = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Merge, _expressionEvaluator_);
  var _super = _createSuper(Merge);
  /**
   * Initializes a new instance of the [Merge](xref:adaptive-expressions.Merge) class.
   */
  function Merge() {
    (0, _classCallCheck2.default)(this, Merge);
    return _super.call(this, expressionType_1.ExpressionType.Merge, Merge.evaluator(), returnType_1.ReturnType.Object, functionUtils_1.FunctionUtils.validateAtLeastOne);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Merge, null, [{
    key: "evaluator",
    value: function evaluator() {
      var _this = this;
      return functionUtils_1.FunctionUtils.applyWithError(function (args) {
        var result = {};
        var _iterator = _createForOfIteratorHelper(args),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var arg = _step.value;
            var objectResult = _this.parseToObjectList(arg);
            if (objectResult.error != null) {
              return {
                value: undefined,
                error: objectResult.error
              };
            }
            var _iterator2 = _createForOfIteratorHelper(objectResult.result),
              _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var item = _step2.value;
                Object.assign(result, item);
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return {
          value: result,
          error: undefined
        };
      });
    }
  }, {
    key: "parseToObjectList",
    value: function parseToObjectList(arg) {
      var result = [];
      var error;
      if (arg == null) {
        error = "The argument ".concat(arg, " must be a JSON object or array.");
      } else if (Array.isArray(arg)) {
        var _iterator3 = _createForOfIteratorHelper(arg),
          _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var item = _step3.value;
            if ((0, _typeof2.default)(item) === 'object' && !Array.isArray(item)) {
              result.push(item);
            } else {
              error = "The argument ".concat(item, " in array must be a JSON object.");
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      } else if ((0, _typeof2.default)(arg) === 'object') {
        result.push(arg);
      } else {
        error = "The argument ".concat(arg, " must be a JSON object or array.");
      }
      return {
        result: result,
        error: error
      };
    }
  }]);
  return Merge;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Merge = Merge;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.assign.js":601,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],99:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.number.constructor.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Return the lowest value from a set of numbers in an array.
 */
var Min = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Min, _expressionEvaluator_);
  var _super = _createSuper(Min);
  /**
   * Initializes a new instance of the [Min](xref:adaptive-expressions.Min) class.
   */
  function Min() {
    (0, _classCallCheck2.default)(this, Min);
    return _super.call(this, expressionType_1.ExpressionType.Min, Min.evaluator(), returnType_1.ReturnType.Number, functionUtils_1.FunctionUtils.validateAtLeastOne);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Min, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        var result = Number.POSITIVE_INFINITY;
        if (args.length === 1) {
          if (Array.isArray(args[0])) {
            var _iterator = _createForOfIteratorHelper(args[0]),
              _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var value = _step.value;
                result = Math.min(result, value);
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
          } else {
            result = Math.min(result, args[0]);
          }
        } else {
          var _iterator2 = _createForOfIteratorHelper(args),
            _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var arg = _step2.value;
              if (Array.isArray(arg)) {
                var _iterator3 = _createForOfIteratorHelper(arg),
                  _step3;
                try {
                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                    var _value = _step3.value;
                    result = Math.min(result, _value);
                  }
                } catch (err) {
                  _iterator3.e(err);
                } finally {
                  _iterator3.f();
                }
              } else {
                result = Math.min(result, arg);
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
        return result;
      }, functionUtils_1.FunctionUtils.verifyNumberOrNumericList);
    }
  }]);
  return Min;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Min = Min;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],100:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.number.constructor.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Return the remainder from dividing two numbers.
 */
var Mod = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Mod, _expressionEvaluator_);
  var _super = _createSuper(Mod);
  /**
   * Initializes a new instance of the [Mod](xref:adaptive-expressions.Mod) class.
   */
  function Mod() {
    (0, _classCallCheck2.default)(this, Mod);
    return _super.call(this, expressionType_1.ExpressionType.Mod, Mod.evaluator(), returnType_1.ReturnType.Number, functionUtils_1.FunctionUtils.validateBinaryNumber);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Mod, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.applyWithError(function (args) {
        var error;
        var value;
        if (Number(args[1]) === 0) {
          error = 'Cannot mod by 0.';
        } else {
          value = args[0] % args[1];
        }
        return {
          value: value,
          error: error
        };
      }, functionUtils_1.FunctionUtils.verifyInteger);
    }
  }]);
  return Mod;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Mod = Mod;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],101:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Return the month of the specified timestamp.
 */
var Month = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Month, _expressionEvaluator_);
  var _super = _createSuper(Month);
  /**
   * Initializes a new instance of the [Month](xref:adaptive-expressions.Month) class.
   */
  function Month() {
    (0, _classCallCheck2.default)(this, Month);
    return _super.call(this, expressionType_1.ExpressionType.Month, Month.evaluator(), returnType_1.ReturnType.Number, functionUtils_1.FunctionUtils.validateUnaryString);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Month, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.applyWithError(function (args) {
        var error = functionUtils_internal_1.InternalFunctionUtils.verifyISOTimestamp(args[0]);
        if (!error) {
          return {
            value: new Date(args[0]).getUTCMonth() + 1,
            error: error
          };
        }
        return {
          value: undefined,
          error: error
        };
      }, functionUtils_1.FunctionUtils.verifyString);
    }
  }]);
  return Month;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Month = Month;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],102:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.number.constructor.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionType_1 = require("../expressionType");
var multivariateNumericEvaluator_1 = require("./multivariateNumericEvaluator");
/**
 * Return the product from multiplying any number of numbers.
 */
var Multiply = /*#__PURE__*/function (_multivariateNumericE) {
  (0, _inherits2.default)(Multiply, _multivariateNumericE);
  var _super = _createSuper(Multiply);
  /**
   * Initializes a new instance of the [Multiply](xref:adaptive-expressions.Multiply) class.
   */
  function Multiply() {
    (0, _classCallCheck2.default)(this, Multiply);
    return _super.call(this, expressionType_1.ExpressionType.Multiply, Multiply.func);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Multiply, null, [{
    key: "func",
    value: function func(args) {
      return Number(args[0]) * Number(args[1]);
    }
  }]);
  return Multiply;
}(multivariateNumericEvaluator_1.MultivariateNumericEvaluator);
exports.Multiply = Multiply;

},{"../expressionType":192,"./multivariateNumericEvaluator":103,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],103:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Numeric operators that can have 2 or more args.
 */
var MultivariateNumericEvaluator = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(MultivariateNumericEvaluator, _expressionEvaluator_);
  var _super = _createSuper(MultivariateNumericEvaluator);
  /**
   * Initializes a new instance of the [MultivariateNumericEvaluator](xref:adaptive-expressions.MultivariateNumericEvaluator) class.
   *
   * @param type Name of the built-in function.
   * @param func The evaluation function, it takes a list of objects and returns a number.
   * @param verify Optional. [VerifyExpression](xref:adaptive-expressions.VerifyExpression) function to verify each child's result.
   */
  function MultivariateNumericEvaluator(type, func, verify) {
    (0, _classCallCheck2.default)(this, MultivariateNumericEvaluator);
    return _super.call(this, type, MultivariateNumericEvaluator.evaluator(func, verify), returnType_1.ReturnType.Number, functionUtils_1.FunctionUtils.validateTwoOrMoreThanTwoNumbers);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(MultivariateNumericEvaluator, null, [{
    key: "evaluator",
    value: function evaluator(func, verify) {
      return functionUtils_1.FunctionUtils.applySequence(func, verify || functionUtils_1.FunctionUtils.verifyNumber);
    }
  }]);
  return MultivariateNumericEvaluator;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.MultivariateNumericEvaluator = MultivariateNumericEvaluator;

},{"../expressionEvaluator":180,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],104:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var uuid_1 = require("uuid");
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Return a new Guid string.
 */
var NewGuid = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(NewGuid, _expressionEvaluator_);
  var _super = _createSuper(NewGuid);
  /**
   * Initializes a new instance of the [NewGuid](xref:adaptive-expressions.NewGuid) class.
   */
  function NewGuid() {
    (0, _classCallCheck2.default)(this, NewGuid);
    return _super.call(this, expressionType_1.ExpressionType.NewGuid, NewGuid.evaluator(), returnType_1.ReturnType.String, NewGuid.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(NewGuid, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function () {
        return NewGuid.evalNewGuid();
      });
    }
    /**
     * @private
     */
  }, {
    key: "evalNewGuid",
    value: function evalNewGuid() {
      return uuid_1.v4();
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateArityAndAnyType(expression, 0, 0);
    }
  }]);
  return NewGuid;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.NewGuid = NewGuid;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"uuid":737}],105:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var options_1 = require("../options");
var returnType_1 = require("../returnType");
/**
 * Check whether an expression is false.
 * Return true if the expression is false, or return false if true.
 */
var Not = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Not, _expressionEvaluator_);
  var _super = _createSuper(Not);
  /**
   * Initializes a new instance of the [Not](xref:adaptive-expressions.Not) class.
   */
  function Not() {
    (0, _classCallCheck2.default)(this, Not);
    return _super.call(this, expressionType_1.ExpressionType.Not, Not.evaluator, returnType_1.ReturnType.Boolean, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Not, null, [{
    key: "evaluator",
    value: function evaluator(expression, state, options) {
      var result = false;
      var error;
      var newOptions = new options_1.Options(options);
      newOptions.nullSubstitution = undefined;
      var _expression$children$ = expression.children[0].tryEvaluate(state, newOptions);
      result = _expression$children$.value;
      error = _expression$children$.error;
      if (!error) {
        result = !functionUtils_internal_1.InternalFunctionUtils.isLogicTrue(result);
      } else {
        error = undefined;
        result = true;
      }
      return {
        value: result,
        error: error
      };
    }
  }]);
  return Not;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Not = Not;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../options":204,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],106:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var comparisonEvaluator_1 = require("./comparisonEvaluator");
/**
 * Return true if the two items are not equal.
 */
var NotEqual = /*#__PURE__*/function (_comparisonEvaluator_) {
  (0, _inherits2.default)(NotEqual, _comparisonEvaluator_);
  var _super = _createSuper(NotEqual);
  /**
   * Initializes a new instance of the [NotEqual](xref:adaptive-expressions.NotEqual) class.
   */
  function NotEqual() {
    (0, _classCallCheck2.default)(this, NotEqual);
    return _super.call(this, expressionType_1.ExpressionType.NotEqual, function (args) {
      return !functionUtils_1.FunctionUtils.commonEquals(args[0], args[1]);
    }, functionUtils_1.FunctionUtils.validateBinary);
  }
  return (0, _createClass2.default)(NotEqual);
}(comparisonEvaluator_1.ComparisonEvaluator);
exports.NotEqual = NotEqual;

},{"../expressionType":192,"../functionUtils":196,"./comparisonEvaluator":23,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],107:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Evaluator that transforms a number to another number.
 */
var NumberTransformEvaluator = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(NumberTransformEvaluator, _expressionEvaluator_);
  var _super = _createSuper(NumberTransformEvaluator);
  /**
   * Initializes a new instance of the [NumberTransformEvaluator](xref:adaptive-expressions.NumberTransformEvaluator) class.
   *
   * @param type Name of the built-in function.
   * @param func The evaluation function, it takes a list of objects and returns a number.
   */
  function NumberTransformEvaluator(type, func) {
    (0, _classCallCheck2.default)(this, NumberTransformEvaluator);
    return _super.call(this, type, NumberTransformEvaluator.evaluator(func), returnType_1.ReturnType.Number, functionUtils_1.FunctionUtils.validateUnaryNumber);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(NumberTransformEvaluator, null, [{
    key: "evaluator",
    value: function evaluator(func) {
      return functionUtils_1.FunctionUtils.apply(func, functionUtils_1.FunctionUtils.verifyNumber);
    }
  }]);
  return NumberTransformEvaluator;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.NumberTransformEvaluator = NumberTransformEvaluator;

},{"../expressionEvaluator":180,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],108:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Numeric operators that can have 1 or more args.
 */
var NumericEvaluator = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(NumericEvaluator, _expressionEvaluator_);
  var _super = _createSuper(NumericEvaluator);
  /**
   * Initializes a new instance of the [NumericEvaluator](xref:adaptive-expressions.NumericEvaluator) class.
   *
   * @param type Name of the built-in function.
   * @param func The evaluation function, it takes a list of objects and returns a number.
   */
  function NumericEvaluator(type, func) {
    (0, _classCallCheck2.default)(this, NumericEvaluator);
    return _super.call(this, type, NumericEvaluator.evaluator(func), returnType_1.ReturnType.Number, functionUtils_1.FunctionUtils.validateNumber);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(NumericEvaluator, null, [{
    key: "evaluator",
    value: function evaluator(func) {
      return functionUtils_1.FunctionUtils.applySequence(func, functionUtils_1.FunctionUtils.verifyNumber);
    }
  }]);
  return NumericEvaluator;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.NumericEvaluator = NumericEvaluator;

},{"../expressionEvaluator":180,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],109:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * For the MostSpecificSelector, this is a short hand so that instead of having to do A &amp; B || A you can do A &amp; optional(B) to mean the same thing.
 */
var Optional = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Optional, _expressionEvaluator_);
  var _super = _createSuper(Optional);
  /**
   * Initializes a new instance of the [Optional](xref:adaptive-expressions.Optional) class.
   */
  function Optional() {
    var _this;
    (0, _classCallCheck2.default)(this, Optional);
    _this = _super.call(this, expressionType_1.ExpressionType.Optional, Optional.evaluator(), returnType_1.ReturnType.Boolean, functionUtils_1.FunctionUtils.validateUnaryBoolean);
    _this.negation = (0, _assertThisInitialized2.default)(_this);
    return _this;
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Optional, null, [{
    key: "evaluator",
    value: function evaluator() {
      return undefined;
    }
  }]);
  return Optional;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Optional = Optional;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/assertThisInitialized":229,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],110:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var options_1 = require("../options");
var returnType_1 = require("../returnType");
/**
 * Check whether at least one expression is true.
 * Return true if at least one expression is true, or return false if all are false.
 */
var Or = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Or, _expressionEvaluator_);
  var _super = _createSuper(Or);
  /**
   * Initializes a new instance of the [Or](xref:adaptive-expressions.Or) class.
   */
  function Or() {
    (0, _classCallCheck2.default)(this, Or);
    return _super.call(this, expressionType_1.ExpressionType.Or, Or.evaluator, returnType_1.ReturnType.Boolean, functionUtils_1.FunctionUtils.validateAtLeastOne);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Or, null, [{
    key: "evaluator",
    value: function evaluator(expression, state, options) {
      var result = false;
      var error;
      var _iterator = _createForOfIteratorHelper(expression.children),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var child = _step.value;
          var newOptions = new options_1.Options(options);
          newOptions.nullSubstitution = undefined;
          var _child$tryEvaluate = child.tryEvaluate(state, newOptions);
          result = _child$tryEvaluate.value;
          error = _child$tryEvaluate.error;
          if (!error) {
            if (functionUtils_internal_1.InternalFunctionUtils.isLogicTrue(result)) {
              result = true;
              break;
            }
          } else {
            error = undefined;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return {
        value: result,
        error: error
      };
    }
  }]);
  return Or;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Or = Or;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../options":204,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],111:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var multivariateNumericEvaluator_1 = require("./multivariateNumericEvaluator");
/**
 * Return exponentiation of one number to another.
 */
var Power = /*#__PURE__*/function (_multivariateNumericE) {
  (0, _inherits2.default)(Power, _multivariateNumericE);
  var _super = _createSuper(Power);
  /**
   * Initializes a new instance of the [Power](xref:adaptive-expressions.Power) class.
   */
  function Power() {
    (0, _classCallCheck2.default)(this, Power);
    return _super.call(this, expressionType_1.ExpressionType.Power, Power.func, functionUtils_1.FunctionUtils.verifyNumberOrNumericList);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Power, null, [{
    key: "func",
    value: function func(args) {
      return Math.pow(args[0], args[1]);
    }
  }]);
  return Power;
}(multivariateNumericEvaluator_1.MultivariateNumericEvaluator);
exports.Power = Power;

},{"../expressionType":192,"../functionUtils":196,"./multivariateNumericEvaluator":103,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],112:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.number.is-integer.js");
require("core-js/modules/es.number.constructor.js");
require("core-js/modules/es.array.concat.js");
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
var extensions_1 = require("../extensions");
/**
 * Return a random integer from a specified range, which is inclusive only at the starting end.
 */
var Rand = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Rand, _expressionEvaluator_);
  var _super = _createSuper(Rand);
  /**
   * Initializes a new instance of the [Rand](xref:adaptive-expressions.Rand) class.
   */
  function Rand() {
    (0, _classCallCheck2.default)(this, Rand);
    return _super.call(this, expressionType_1.ExpressionType.Rand, Rand.evaluator, returnType_1.ReturnType.Number, functionUtils_1.FunctionUtils.validateBinaryNumber);
  }
  (0, _createClass2.default)(Rand, null, [{
    key: "evaluator",
    value: function evaluator(expression, state, options) {
      var result;
      var minValue;
      var maxValue;
      var error;
      var _expression$children = (0, _slicedToArray2.default)(expression.children, 2),
        maybeMinValue = _expression$children[0],
        maybeMaxValue = _expression$children[1];
      // eslint-disable-next-line prefer-const
      var _maybeMinValue$tryEva = maybeMinValue.tryEvaluate(state, options);
      minValue = _maybeMinValue$tryEva.value;
      error = _maybeMinValue$tryEva.error;
      if (error) {
        return {
          value: undefined,
          error: error
        };
      }
      if (!Number.isInteger(minValue)) {
        return {
          value: undefined,
          error: "".concat(minValue, " is not an integer.")
        };
      }
      // eslint-disable-next-line prefer-const
      var _maybeMaxValue$tryEva = maybeMaxValue.tryEvaluate(state, options);
      maxValue = _maybeMaxValue$tryEva.value;
      error = _maybeMaxValue$tryEva.error;
      if (error) {
        return {
          value: undefined,
          error: error
        };
      }
      if (!Number.isInteger(maxValue)) {
        return {
          value: undefined,
          error: "".concat(maxValue, " is not an integer.")
        };
      }
      if (minValue > maxValue) {
        error = "Min value ".concat(minValue, " cannot be greater than max value ").concat(maxValue, ".");
      } else {
        result = extensions_1.Extensions.randomNext(state, minValue, maxValue);
      }
      return {
        value: result,
        error: error
      };
    }
  }]);
  return Rand;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Rand = Rand;

},{"../expressionEvaluator":180,"../expressionType":192,"../extensions":193,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/slicedToArray":247,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.number.is-integer.js":595,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],113:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.map.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.number.constructor.js");
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Return an integer array that starts from a specified integer with the given length.
 */
var Range = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Range, _expressionEvaluator_);
  var _super = _createSuper(Range);
  /**
   * Initializes a new instance of the [Range](xref:adaptive-expressions.Range) class.
   */
  function Range() {
    (0, _classCallCheck2.default)(this, Range);
    return _super.call(this, expressionType_1.ExpressionType.Range, Range.evaluator(), returnType_1.ReturnType.Array, functionUtils_1.FunctionUtils.validateBinaryNumber);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Range, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.applyWithError(function (args) {
        var error;
        if (args[1] <= 0) {
          error = 'Second paramter must be more than zero';
        }
        var result = (0, _toConsumableArray2.default)(Array(args[1]).keys()).map(function (u) {
          return u + Number(args[0]);
        });
        return {
          value: result,
          error: error
        };
      }, functionUtils_1.FunctionUtils.verifyInteger);
    }
  }]);
  return Range;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Range = Range;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/toConsumableArray":249,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.map.js":579,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/web.dom-collections.iterator.js":677}],114:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Remove a property from an object and return the updated object.
 */
var RemoveProperty = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(RemoveProperty, _expressionEvaluator_);
  var _super = _createSuper(RemoveProperty);
  /**
   * Initializes a new instance of the [RemoveProperty](xref:adaptive-expressions.RemoveProperty) class.
   */
  function RemoveProperty() {
    (0, _classCallCheck2.default)(this, RemoveProperty);
    return _super.call(this, expressionType_1.ExpressionType.RemoveProperty, RemoveProperty.evaluator(), returnType_1.ReturnType.Object, RemoveProperty.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(RemoveProperty, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        var temp = args[0];
        delete temp[String(args[1])];
        return temp;
      });
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateOrder(expression, undefined, returnType_1.ReturnType.Object, returnType_1.ReturnType.String);
    }
  }]);
  return RemoveProperty;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.RemoveProperty = RemoveProperty;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],115:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.join.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.split.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Replace a substring with the specified string, and return the result string.
 * This function is case-sensitive.
 */
var Replace = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Replace, _expressionEvaluator_);
  var _super = _createSuper(Replace);
  /**
   * Initializes a new instance of the [Replace](xref:adaptive-expressions.Replace) class.
   */
  function Replace() {
    (0, _classCallCheck2.default)(this, Replace);
    return _super.call(this, expressionType_1.ExpressionType.Replace, Replace.evaluator(), returnType_1.ReturnType.String, Replace.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Replace, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.applyWithError(function (args) {
        var error = undefined;
        var result = undefined;
        if (functionUtils_internal_1.InternalFunctionUtils.parseStringOrUndefined(args[1]).length === 0) {
          error = "".concat(args[1], " should be a string with length at least 1");
        }
        if (!error) {
          result = functionUtils_internal_1.InternalFunctionUtils.parseStringOrUndefined(args[0]).split(functionUtils_internal_1.InternalFunctionUtils.parseStringOrUndefined(args[1])).join(functionUtils_internal_1.InternalFunctionUtils.parseStringOrUndefined(args[2]));
        }
        return {
          value: result,
          error: error
        };
      }, functionUtils_1.FunctionUtils.verifyStringOrNull);
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateArityAndAnyType(expression, 3, 3, returnType_1.ReturnType.String);
    }
  }]);
  return Replace;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Replace = Replace;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.array.join.js":578,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.string.split.js":631}],116:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.regexp.constructor.js");
require("core-js/modules/es.regexp.to-string.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Replace a substring with the specified string, and return the result string.
 * This function is case-insensitive.
 */
var ReplaceIgnoreCase = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(ReplaceIgnoreCase, _expressionEvaluator_);
  var _super = _createSuper(ReplaceIgnoreCase);
  /**
   * Initializes a new instance of the [ReplaceIgnoreCase](xref:adaptive-expressions.ReplaceIgnoreCase) class.
   */
  function ReplaceIgnoreCase() {
    (0, _classCallCheck2.default)(this, ReplaceIgnoreCase);
    return _super.call(this, expressionType_1.ExpressionType.ReplaceIgnoreCase, ReplaceIgnoreCase.evaluator(), returnType_1.ReturnType.String, ReplaceIgnoreCase.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(ReplaceIgnoreCase, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.applyWithError(function (args) {
        var error = undefined;
        var result = undefined;
        if (functionUtils_internal_1.InternalFunctionUtils.parseStringOrUndefined(args[1]).length === 0) {
          error = "".concat(args[1], " should be a string with length at least 1");
        }
        if (!error) {
          result = functionUtils_internal_1.InternalFunctionUtils.parseStringOrUndefined(args[0]).replace(
          // eslint-disable-next-line security/detect-non-literal-regexp
          new RegExp(functionUtils_internal_1.InternalFunctionUtils.parseStringOrUndefined(args[1]), 'gi'), functionUtils_internal_1.InternalFunctionUtils.parseStringOrUndefined(args[2]));
        }
        return {
          value: result,
          error: error
        };
      }, functionUtils_1.FunctionUtils.verifyStringOrNull);
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateArityAndAnyType(expression, 3, 3, returnType_1.ReturnType.String);
    }
  }]);
  return ReplaceIgnoreCase;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.ReplaceIgnoreCase = ReplaceIgnoreCase;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.constructor.js":617,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.replace.js":629}],117:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.join.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Reverses the order of the elements in a String or Array.
 */
var Reverse = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Reverse, _expressionEvaluator_);
  var _super = _createSuper(Reverse);
  /**
   * Initializes a new instance of the `Reverse` class.
   */
  function Reverse() {
    (0, _classCallCheck2.default)(this, Reverse);
    return _super.call(this, expressionType_1.ExpressionType.Reverse, Reverse.evaluator(), returnType_1.ReturnType.String | returnType_1.ReturnType.Array, Reverse.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Reverse, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.applyWithError(function (args) {
        var value = undefined;
        var error = undefined;
        if (typeof args[0] === 'string') {
          value = args[0].split('').reverse().join('');
        } else if (Array.isArray(args[0])) {
          value = args[0].reverse();
        } else {
          error = "".concat(args[0], " is not a string or list.");
        }
        return {
          value: value,
          error: error
        };
      }, functionUtils_1.FunctionUtils.verifyContainer);
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateOrder(expression, [], returnType_1.ReturnType.String | returnType_1.ReturnType.Array);
    }
  }]);
  return Reverse;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Reverse = Reverse;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.array.join.js":578,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],118:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.number.is-integer.js");
require("core-js/modules/es.number.constructor.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Rounds a number value to the nearest integer.
 */
var Round = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Round, _expressionEvaluator_);
  var _super = _createSuper(Round);
  /**
   * Initializes a new instance of the [Round](xref:adaptive-expressions.Round) class.
   */
  function Round() {
    (0, _classCallCheck2.default)(this, Round);
    return _super.call(this, expressionType_1.ExpressionType.Round, Round.evaluator(), returnType_1.ReturnType.Number, functionUtils_1.FunctionUtils.validateUnaryOrBinaryNumber);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Round, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.applyWithError(function (args) {
        var result;
        var error;
        if (args.length === 2 && !Number.isInteger(args[1])) {
          error = "The second parameter ".concat(args[1], " must be an integer.");
        }
        if (!error) {
          var digits = args.length === 2 ? args[1] : 0;
          if (digits < 0 || digits > 15) {
            error = "The second parameter ".concat(args[1], " must be an integer between 0 and 15;");
          } else {
            result = Round.roundToPrecision(args[0], digits);
          }
        }
        return {
          value: result,
          error: error
        };
      }, functionUtils_1.FunctionUtils.verifyNumber);
    }
  }]);
  return Round;
}(expressionEvaluator_1.ExpressionEvaluator);
Round.roundToPrecision = function (num, digits) {
  return Math.round(num * Math.pow(10, digits)) / Math.pow(10, digits);
};
exports.Round = Round;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.number.is-integer.js":595,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],119:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Operate on each element and return the new collection of transformed elements.
 */
var Select = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Select, _expressionEvaluator_);
  var _super = _createSuper(Select);
  /**
   * Initializes a new instance of the [Select](xref:adaptive-expressions.Select) class.
   */
  function Select() {
    (0, _classCallCheck2.default)(this, Select);
    return _super.call(this, expressionType_1.ExpressionType.Select, functionUtils_internal_1.InternalFunctionUtils.foreach, returnType_1.ReturnType.Array, functionUtils_internal_1.InternalFunctionUtils.ValidateLambdaExpression);
  }
  return (0, _createClass2.default)(Select);
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Select = Select;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],120:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var stringTransformEvaluator_1 = require("./stringTransformEvaluator");
/**
 * Capitalizing only the first word and leave others lowercase.
 */
var SentenceCase = /*#__PURE__*/function (_stringTransformEvalu) {
  (0, _inherits2.default)(SentenceCase, _stringTransformEvalu);
  var _super = _createSuper(SentenceCase);
  /**
   * Initializes a new instance of the [SentenceCase](xref:adaptive-expressions.SentenceCase) class.
   */
  function SentenceCase() {
    (0, _classCallCheck2.default)(this, SentenceCase);
    return _super.call(this, expressionType_1.ExpressionType.SentenceCase, SentenceCase.evaluator, functionUtils_1.FunctionUtils.validateUnaryOrBinaryString);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(SentenceCase, null, [{
    key: "evaluator",
    value: function evaluator(args, options) {
      var locale = options.locale ? options.locale : Intl.DateTimeFormat().resolvedOptions().locale;
      locale = functionUtils_1.FunctionUtils.determineLocale(args, 2, locale);
      var firstArg = args[0];
      if (typeof firstArg === 'string' || firstArg === undefined) {
        var inputStr = functionUtils_internal_1.InternalFunctionUtils.parseStringOrUndefined(firstArg).toLocaleLowerCase(locale);
        if (inputStr === '') {
          return inputStr;
        } else {
          return inputStr.charAt(0).toUpperCase() + inputStr.substr(1).toLocaleLowerCase(locale);
        }
      }
    }
  }]);
  return SentenceCase;
}(stringTransformEvaluator_1.StringTransformEvaluator);
exports.SentenceCase = SentenceCase;

},{"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"./stringTransformEvaluator":134,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],121:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Set path in a JSON object to value.
 */
var SetPathToValue = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(SetPathToValue, _expressionEvaluator_);
  var _super = _createSuper(SetPathToValue);
  /**
   * Initializes a new instance of the [SetPathToValue](xref:adaptive-expressions.SetPathToValue) class.
   */
  function SetPathToValue() {
    (0, _classCallCheck2.default)(this, SetPathToValue);
    return _super.call(this, expressionType_1.ExpressionType.SetPathToValue, SetPathToValue.evaluator, returnType_1.ReturnType.Object, functionUtils_1.FunctionUtils.validateBinary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(SetPathToValue, null, [{
    key: "evaluator",
    value: function evaluator(expression, state, options) {
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.tryAccumulatePath(expression.children[0], state, options),
        path = _functionUtils_1$Func.path,
        left = _functionUtils_1$Func.left,
        error = _functionUtils_1$Func.error;
      if (error !== undefined) {
        return {
          value: undefined,
          error: error
        };
      }
      if (left) {
        // the expression can't be fully merged as a path
        return {
          value: undefined,
          error: "".concat(expression.children[0].toString(), " is not a valid path to set value")
        };
      }
      var _expression$children$ = expression.children[1].tryEvaluate(state, options),
        value = _expression$children$.value,
        err = _expression$children$.error;
      if (err) {
        return {
          value: undefined,
          error: err
        };
      }
      state.setValue(path, value);
      return {
        value: value,
        error: undefined
      };
    }
  }]);
  return SetPathToValue;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.SetPathToValue = SetPathToValue;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.to-string.js":620}],122:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Set the value of an object's property and return the updated object.
 */
var SetProperty = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(SetProperty, _expressionEvaluator_);
  var _super = _createSuper(SetProperty);
  /**
   * Initializes a new instance of the [SetProperty](xref:adaptive-expressions.SetProperty) class.
   */
  function SetProperty() {
    (0, _classCallCheck2.default)(this, SetProperty);
    return _super.call(this, expressionType_1.ExpressionType.SetProperty, SetProperty.evaluator(), returnType_1.ReturnType.Object, SetProperty.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(SetProperty, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        var temp = args[0];
        temp[String(args[1])] = args[2];
        return temp;
      });
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateOrder(expression, undefined, returnType_1.ReturnType.Object, returnType_1.ReturnType.String, returnType_1.ReturnType.Object);
    }
  }]);
  return SetProperty;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.SetProperty = SetProperty;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],123:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.number.is-integer.js");
require("core-js/modules/es.number.constructor.js");
require("core-js/modules/es.array.slice.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Remove items from the front of a collection, and return all the other items.
 */
var Skip = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Skip, _expressionEvaluator_);
  var _super = _createSuper(Skip);
  /**
   * Initializes a new instance of the [Skip](xref:adaptive-expressions.Skip) class.
   */
  function Skip() {
    (0, _classCallCheck2.default)(this, Skip);
    return _super.call(this, expressionType_1.ExpressionType.Skip, Skip.evaluator, returnType_1.ReturnType.Array, Skip.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Skip, null, [{
    key: "evaluator",
    value: function evaluator(expression, state, options) {
      var result;
      var _expression$children$ = expression.children[0].tryEvaluate(state, options),
        arr = _expression$children$.value,
        childrenError = _expression$children$.error;
      var error = childrenError;
      if (!error) {
        if (Array.isArray(arr)) {
          var start;
          var startExpr = expression.children[1];
          var _startExpr$tryEvaluat = startExpr.tryEvaluate(state, options);
          start = _startExpr$tryEvaluat.value;
          error = _startExpr$tryEvaluat.error;
          if (!error && !Number.isInteger(start)) {
            error = "".concat(startExpr, " is not an integer.");
          }
          if (!error) {
            start = Math.max(start, 0);
            result = arr.slice(start);
          }
        } else {
          error = "".concat(expression.children[0], " is not array.");
        }
      }
      return {
        value: result,
        error: error
      };
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateOrder(expression, [], returnType_1.ReturnType.Array, returnType_1.ReturnType.Number);
    }
  }]);
  return Skip;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Skip = Skip;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.number.is-integer.js":595,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],124:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Sort elements in the collection in ascending order and return the sorted collection.
 */
var SortBy = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(SortBy, _expressionEvaluator_);
  var _super = _createSuper(SortBy);
  /**
   * Initializes a new instance of the [SortBy](xref:adaptive-expressions.SortBy) class.
   */
  function SortBy() {
    (0, _classCallCheck2.default)(this, SortBy);
    return _super.call(this, expressionType_1.ExpressionType.SortBy, functionUtils_internal_1.InternalFunctionUtils.sortBy(false), returnType_1.ReturnType.Array, SortBy.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(SortBy, null, [{
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateOrder(expression, [returnType_1.ReturnType.String], returnType_1.ReturnType.Array);
    }
  }]);
  return SortBy;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.SortBy = SortBy;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],125:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Sort elements in the collection in descending order, and return the sorted collection.
 */
var SortByDescending = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(SortByDescending, _expressionEvaluator_);
  var _super = _createSuper(SortByDescending);
  /**
   * Initializes a new instance of the [SortByDescending](xref:adaptive-expressions.SortByDescending) class.
   */
  function SortByDescending() {
    (0, _classCallCheck2.default)(this, SortByDescending);
    return _super.call(this, expressionType_1.ExpressionType.SortByDescending, functionUtils_internal_1.InternalFunctionUtils.sortBy(true), returnType_1.ReturnType.Array, SortByDescending.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(SortByDescending, null, [{
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateOrder(expression, [returnType_1.ReturnType.String], returnType_1.ReturnType.Array);
    }
  }]);
  return SortByDescending;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.SortByDescending = SortByDescending;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],126:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.split.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Return an array that contains substrings, separated by commas, based on the specified delimiter character in the original string.
 */
var Split = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Split, _expressionEvaluator_);
  var _super = _createSuper(Split);
  /**
   * Initializes a new instance of the [Split](xref:adaptive-expressions.Split) class.
   */
  function Split() {
    (0, _classCallCheck2.default)(this, Split);
    return _super.call(this, expressionType_1.ExpressionType.Split, Split.evaluator(), returnType_1.ReturnType.Array, Split.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Split, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        return functionUtils_internal_1.InternalFunctionUtils.parseStringOrUndefined(args[0]).split(functionUtils_internal_1.InternalFunctionUtils.parseStringOrUndefined(args[1] || ''));
      }, functionUtils_1.FunctionUtils.verifyStringOrNull);
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateArityAndAnyType(expression, 1, 2, returnType_1.ReturnType.String);
    }
  }]);
  return Split;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Split = Split;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.string.split.js":631}],127:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.number.constructor.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Returns the square root of a specified number.
 */
var Sqrt = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Sqrt, _expressionEvaluator_);
  var _super = _createSuper(Sqrt);
  /**
   * Initializes a new instance of the [SortBy](xref:adaptive-expressions.Sqrt) class.
   */
  function Sqrt() {
    (0, _classCallCheck2.default)(this, Sqrt);
    return _super.call(this, expressionType_1.ExpressionType.Sqrt, Sqrt.evaluator(), returnType_1.ReturnType.Number, functionUtils_1.FunctionUtils.validateUnaryNumber);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Sqrt, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.applyWithError(function (args) {
        var error;
        var value;
        var originalNumber = Number(args[0]);
        if (originalNumber < 0) {
          error = 'Do not support square root extraction of negative numbers.';
        } else {
          value = Math.sqrt(originalNumber);
        }
        return {
          value: value,
          error: error
        };
      }, functionUtils_1.FunctionUtils.verifyNumber);
    }
  }]);
  return Sqrt;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Sqrt = Sqrt;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],128:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var dayjs_1 = __importDefault(require("dayjs"));
var utc_1 = __importDefault(require("dayjs/plugin/utc"));
dayjs_1.default.extend(utc_1.default);
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Return the start of the day for a timestamp.
 */
var StartOfDay = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(StartOfDay, _expressionEvaluator_);
  var _super = _createSuper(StartOfDay);
  /**
   * Initializes a new instance of the [StartOfDay](xref:adaptive-expressions.StartOfDay) class.
   */
  function StartOfDay() {
    (0, _classCallCheck2.default)(this, StartOfDay);
    return _super.call(this, expressionType_1.ExpressionType.StartOfDay, StartOfDay.evaluator, returnType_1.ReturnType.String, StartOfDay.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(StartOfDay, null, [{
    key: "evaluator",
    value: function evaluator(expression, state, options) {
      var value;
      var locale = options.locale ? options.locale : Intl.DateTimeFormat().resolvedOptions().locale;
      var format = functionUtils_1.FunctionUtils.DefaultDateTimeFormat;
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expression, state, options),
        args = _functionUtils_1$Func.args,
        childrenError = _functionUtils_1$Func.error;
      var error = childrenError;
      if (!error) {
        var _functionUtils_1$Func2 = functionUtils_1.FunctionUtils.determineFormatAndLocale(args, 3, format, locale);
        format = _functionUtils_1$Func2.format;
        locale = _functionUtils_1$Func2.locale;
        if (typeof args[0] === 'string') {
          var _StartOfDay$evalStart = StartOfDay.evalStartOfDay(args[0], format, locale);
          value = _StartOfDay$evalStart.value;
          error = _StartOfDay$evalStart.error;
        } else {
          error = "".concat(expression, " should contain an ISO format timestamp and an optional output format string.");
        }
      }
      return {
        value: value,
        error: error
      };
    }
    /**
     * @private
     */
  }, {
    key: "evalStartOfDay",
    value: function evalStartOfDay(timeStamp, format, locale) {
      var result;
      var error = functionUtils_internal_1.InternalFunctionUtils.verifyISOTimestamp(timeStamp);
      if (!error) {
        result = dayjs_1.default(timeStamp).locale(locale).utc().startOf('day').format(format);
      }
      return {
        value: result,
        error: error
      };
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateOrder(expression, [returnType_1.ReturnType.String, returnType_1.ReturnType.String], returnType_1.ReturnType.String);
    }
  }]);
  return StartOfDay;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.StartOfDay = StartOfDay;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"dayjs":697,"dayjs/plugin/utc":700}],129:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var dayjs_1 = __importDefault(require("dayjs"));
var utc_1 = __importDefault(require("dayjs/plugin/utc"));
dayjs_1.default.extend(utc_1.default);
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Return the start of the hour for a timestamp.
 */
var StartOfHour = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(StartOfHour, _expressionEvaluator_);
  var _super = _createSuper(StartOfHour);
  /**
   * Initializes a new instance of the [StartOfHour](xref:adaptive-expressions.StartOfHour) class.
   */
  function StartOfHour() {
    (0, _classCallCheck2.default)(this, StartOfHour);
    return _super.call(this, expressionType_1.ExpressionType.StartOfHour, StartOfHour.evaluator, returnType_1.ReturnType.String, StartOfHour.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(StartOfHour, null, [{
    key: "evaluator",
    value: function evaluator(expr, state, options) {
      var value;
      var locale = options.locale ? options.locale : Intl.DateTimeFormat().resolvedOptions().locale;
      var format = functionUtils_1.FunctionUtils.DefaultDateTimeFormat;
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expr, state, options),
        args = _functionUtils_1$Func.args,
        childrenError = _functionUtils_1$Func.error;
      var error = childrenError;
      if (!error) {
        var _functionUtils_1$Func2 = functionUtils_1.FunctionUtils.determineFormatAndLocale(args, 3, format, locale);
        format = _functionUtils_1$Func2.format;
        locale = _functionUtils_1$Func2.locale;
        if (typeof args[0] === 'string') {
          var _StartOfHour$evalStar = StartOfHour.evalStartOfHour(args[0], format, locale);
          value = _StartOfHour$evalStar.value;
          error = _StartOfHour$evalStar.error;
        } else {
          error = "".concat(expr, " should contain an ISO format timestamp and an optional output format string.");
        }
      }
      return {
        value: value,
        error: error
      };
    }
    /**
     * @private
     */
  }, {
    key: "evalStartOfHour",
    value: function evalStartOfHour(timeStamp, format, locale) {
      var result;
      var error = functionUtils_internal_1.InternalFunctionUtils.verifyISOTimestamp(timeStamp);
      if (!error) {
        result = dayjs_1.default(timeStamp).locale(locale).utc().startOf('hour').format(format);
      }
      return {
        value: result,
        error: error
      };
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expr) {
      functionUtils_1.FunctionUtils.validateOrder(expr, [returnType_1.ReturnType.String, returnType_1.ReturnType.String], returnType_1.ReturnType.String);
    }
  }]);
  return StartOfHour;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.StartOfHour = StartOfHour;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"dayjs":697,"dayjs/plugin/utc":700}],130:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var dayjs_1 = __importDefault(require("dayjs"));
var utc_1 = __importDefault(require("dayjs/plugin/utc"));
dayjs_1.default.extend(utc_1.default);
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Return the start of the month for a timestamp.
 */
var StartOfMonth = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(StartOfMonth, _expressionEvaluator_);
  var _super = _createSuper(StartOfMonth);
  /**
   * Initializes a new instance of the [StartOfMonth](xref:adaptive-expressions.StartOfMonth) class.
   */
  function StartOfMonth() {
    (0, _classCallCheck2.default)(this, StartOfMonth);
    return _super.call(this, expressionType_1.ExpressionType.StartOfMonth, StartOfMonth.evaluator, returnType_1.ReturnType.String, StartOfMonth.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(StartOfMonth, null, [{
    key: "evaluator",
    value: function evaluator(expr, state, options) {
      var value;
      var locale = options.locale ? options.locale : Intl.DateTimeFormat().resolvedOptions().locale;
      var format = functionUtils_1.FunctionUtils.DefaultDateTimeFormat;
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expr, state, options),
        args = _functionUtils_1$Func.args,
        childrenError = _functionUtils_1$Func.error;
      var error = childrenError;
      if (!error) {
        var _functionUtils_1$Func2 = functionUtils_1.FunctionUtils.determineFormatAndLocale(args, 3, format, locale);
        format = _functionUtils_1$Func2.format;
        locale = _functionUtils_1$Func2.locale;
        if (typeof args[0] === 'string') {
          var _StartOfMonth$evalSta = StartOfMonth.evalStartOfMonth(args[0], format, locale);
          value = _StartOfMonth$evalSta.value;
          error = _StartOfMonth$evalSta.error;
        } else {
          error = "".concat(expr, " should contain an ISO format timestamp and an optional output format string.");
        }
      }
      return {
        value: value,
        error: error
      };
    }
    /**
     * @private
     */
  }, {
    key: "evalStartOfMonth",
    value: function evalStartOfMonth(timeStamp, format, locale) {
      var result;
      var error = functionUtils_internal_1.InternalFunctionUtils.verifyISOTimestamp(timeStamp);
      if (!error) {
        result = dayjs_1.default(timeStamp).locale(locale).utc().startOf('month').format(format);
      }
      return {
        value: result,
        error: error
      };
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expr) {
      functionUtils_1.FunctionUtils.validateOrder(expr, [returnType_1.ReturnType.String, returnType_1.ReturnType.String], returnType_1.ReturnType.String);
    }
  }]);
  return StartOfMonth;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.StartOfMonth = StartOfMonth;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"dayjs":697,"dayjs/plugin/utc":700}],131:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.string.starts-with.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Check whether a string starts with a specific substring. Return true if the substring is found, or return false if not found.
 * This function is case-insensitive.
 */
var StartsWith = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(StartsWith, _expressionEvaluator_);
  var _super = _createSuper(StartsWith);
  /**
   * Initializes a new instance of the [StartsWith](xref:adaptive-expressions.StartsWith) class.
   */
  function StartsWith() {
    (0, _classCallCheck2.default)(this, StartsWith);
    return _super.call(this, expressionType_1.ExpressionType.StartsWith, StartsWith.evaluator(), returnType_1.ReturnType.Boolean, StartsWith.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(StartsWith, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        return functionUtils_internal_1.InternalFunctionUtils.parseStringOrUndefined(args[0]).startsWith(functionUtils_internal_1.InternalFunctionUtils.parseStringOrUndefined(args[1]));
      }, functionUtils_1.FunctionUtils.verifyStringOrNull);
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateArityAndAnyType(expression, 2, 2, returnType_1.ReturnType.String);
    }
  }]);
  return StartsWith;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.StartsWith = StartsWith;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.string.starts-with.js":632}],132:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.array.includes.js");
require("core-js/modules/es.string.includes.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array-buffer.slice.js");
require("core-js/modules/es.typed-array.uint8-array.js");
require("core-js/modules/es.typed-array.copy-within.js");
require("core-js/modules/es.typed-array.every.js");
require("core-js/modules/es.typed-array.fill.js");
require("core-js/modules/es.typed-array.filter.js");
require("core-js/modules/es.typed-array.find.js");
require("core-js/modules/es.typed-array.find-index.js");
require("core-js/modules/es.typed-array.for-each.js");
require("core-js/modules/es.typed-array.includes.js");
require("core-js/modules/es.typed-array.index-of.js");
require("core-js/modules/es.typed-array.iterator.js");
require("core-js/modules/es.typed-array.join.js");
require("core-js/modules/es.typed-array.last-index-of.js");
require("core-js/modules/es.typed-array.map.js");
require("core-js/modules/es.typed-array.reduce.js");
require("core-js/modules/es.typed-array.reduce-right.js");
require("core-js/modules/es.typed-array.reverse.js");
require("core-js/modules/es.typed-array.set.js");
require("core-js/modules/es.typed-array.slice.js");
require("core-js/modules/es.typed-array.some.js");
require("core-js/modules/es.typed-array.sort.js");
require("core-js/modules/es.typed-array.subarray.js");
require("core-js/modules/es.typed-array.to-locale-string.js");
require("core-js/modules/es.typed-array.to-string.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var d3_format_1 = require("d3-format");
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
var localeInfo_1 = require("../localeInfo");
var functionUtils_internal_1 = require("../functionUtils.internal");
/**
 * Return the string version of a value.
 */
var String = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(String, _expressionEvaluator_);
  var _super = _createSuper(String);
  /**
   * Initializes a new instance of the [String](xref:adaptive-expressions.String) class.
   */
  function String() {
    (0, _classCallCheck2.default)(this, String);
    return _super.call(this, expressionType_1.ExpressionType.String, String.evaluator(), returnType_1.ReturnType.String, String.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(String, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.applyWithOptionsAndError(function (args, options) {
        var result;
        var error;
        var locale = options.locale ? options.locale : Intl.DateTimeFormat().resolvedOptions().locale;
        if (!error) {
          locale = functionUtils_1.FunctionUtils.determineLocale(args, 2, locale);
        }
        if (!error) {
          if (typeof args[0] === 'string') {
            result = args[0];
          } else if (functionUtils_1.FunctionUtils.isNumber(args[0])) {
            var formatLocale = localeInfo_1.localeInfo[locale];
            var tempStrValue = args[0].toString();
            var precision = 0;
            if (tempStrValue.includes('.')) {
              precision = tempStrValue.split('.')[1].length;
            }
            var fixedNotation = ",.".concat(precision, "f");
            if (formatLocale !== undefined) {
              result = d3_format_1.formatLocale(formatLocale).format(fixedNotation)(args[0]);
            } else {
              result = d3_format_1.format(fixedNotation)(args[0]);
            }
          } else if (args[0] instanceof Date) {
            result = args[0].toLocaleDateString(locale);
          } else if (args[0] instanceof Uint8Array) {
            result = functionUtils_internal_1.InternalFunctionUtils.getTextDecoder().decode(args[0]);
          } else {
            result = functionUtils_internal_1.InternalFunctionUtils.commonStringify(args[0]);
          }
        }
        return {
          value: result,
          error: error
        };
      });
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expr) {
      functionUtils_1.FunctionUtils.validateOrder(expr, [returnType_1.ReturnType.String], returnType_1.ReturnType.Object);
    }
  }]);
  return String;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.String = String;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../localeInfo":200,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.array-buffer.slice.js":568,"core-js/modules/es.array.includes.js":576,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.includes.js":625,"core-js/modules/es.typed-array.copy-within.js":641,"core-js/modules/es.typed-array.every.js":642,"core-js/modules/es.typed-array.fill.js":643,"core-js/modules/es.typed-array.filter.js":644,"core-js/modules/es.typed-array.find-index.js":645,"core-js/modules/es.typed-array.find.js":646,"core-js/modules/es.typed-array.for-each.js":649,"core-js/modules/es.typed-array.includes.js":650,"core-js/modules/es.typed-array.index-of.js":651,"core-js/modules/es.typed-array.iterator.js":655,"core-js/modules/es.typed-array.join.js":656,"core-js/modules/es.typed-array.last-index-of.js":657,"core-js/modules/es.typed-array.map.js":658,"core-js/modules/es.typed-array.reduce-right.js":659,"core-js/modules/es.typed-array.reduce.js":660,"core-js/modules/es.typed-array.reverse.js":661,"core-js/modules/es.typed-array.set.js":662,"core-js/modules/es.typed-array.slice.js":663,"core-js/modules/es.typed-array.some.js":664,"core-js/modules/es.typed-array.sort.js":665,"core-js/modules/es.typed-array.subarray.js":666,"core-js/modules/es.typed-array.to-locale-string.js":667,"core-js/modules/es.typed-array.to-string.js":668,"core-js/modules/es.typed-array.uint8-array.js":671,"d3-format":692}],133:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var constant_1 = require("../constant");
var expression_1 = require("../expression");
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Wrap string interpolation to get real value.
 * For example: stringOrValue('${1}'), would get number 1
 * stringOrValue('${1} item'), would get string "1 item".
 */
var StringOrValue = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(StringOrValue, _expressionEvaluator_);
  var _super = _createSuper(StringOrValue);
  /**
   * Initializes a new instance of the [StringOrValue](xref:adaptive-expressions.StringOrValue) class.
   */
  function StringOrValue() {
    (0, _classCallCheck2.default)(this, StringOrValue);
    return _super.call(this, expressionType_1.ExpressionType.StringOrValue, StringOrValue.evaluator, returnType_1.ReturnType.Object, functionUtils_1.FunctionUtils.validateUnaryString);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(StringOrValue, null, [{
    key: "evaluator",
    value: function evaluator(expression, state, options) {
      var _expression$children$ = expression.children[0].tryEvaluate(state, options),
        stringInput = _expression$children$.value,
        childrenError = _expression$children$.error;
      var error = childrenError;
      if (typeof stringInput !== 'string') {
        error = 'Parameter should be a string.';
      }
      if (!error) {
        var expr = expression_1.Expression.parse('`' + stringInput + '`');
        if (expr.children.length === 2) {
          var firstChild = expr.children[0];
          var secondChild = expr.children[1];
          // If the Expression follows this format:
          // concat('', childExpression)
          // return the childExpression result directly.
          if (firstChild instanceof constant_1.Constant && firstChild.value.toString() === '' && !(secondChild instanceof constant_1.Constant)) {
            return secondChild.tryEvaluate(state, options);
          }
        }
        return expr.tryEvaluate(state, options);
      }
      return {
        value: undefined,
        error: error
      };
    }
  }]);
  return StringOrValue;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.StringOrValue = StringOrValue;

},{"../constant":167,"../expression":179,"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.to-string.js":620}],134:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Evaluator that transforms a string to another string.
 */
var StringTransformEvaluator = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(StringTransformEvaluator, _expressionEvaluator_);
  var _super = _createSuper(StringTransformEvaluator);
  /**
   * Initializes a new instance of the [StringTransformEvaluator](xref:adaptive-expressions.StringTransformEvaluator) class.
   *
   * @param type Name of the built-in function.
   * @param func The string transformation function, it takes a list of objects and returns an string.
   * @param validator The validation function.
   */
  function StringTransformEvaluator(type, func, validator) {
    (0, _classCallCheck2.default)(this, StringTransformEvaluator);
    return _super.call(this, type, functionUtils_1.FunctionUtils.applyWithOptions(func, functionUtils_1.FunctionUtils.verifyStringOrNull), returnType_1.ReturnType.String, validator ? validator : functionUtils_1.FunctionUtils.validateUnaryString);
  }
  return (0, _createClass2.default)(StringTransformEvaluator);
}(expressionEvaluator_1.ExpressionEvaluator);
exports.StringTransformEvaluator = StringTransformEvaluator;

},{"../expressionEvaluator":180,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],135:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.number.is-integer.js");
require("core-js/modules/es.number.constructor.js");
require("core-js/modules/es.array.concat.js");
require("core-js/modules/es.array.slice.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Returns a subarray from specified start and end positions. Index values start with the number 0.
 */
var SubArray = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(SubArray, _expressionEvaluator_);
  var _super = _createSuper(SubArray);
  /**
   * Initializes a new instance of the [SubArray](xref:adaptive-expressions.SubArray) class.
   */
  function SubArray() {
    (0, _classCallCheck2.default)(this, SubArray);
    return _super.call(this, expressionType_1.ExpressionType.SubArray, SubArray.evaluator, returnType_1.ReturnType.Array, SubArray.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(SubArray, null, [{
    key: "evaluator",
    value: function evaluator(expression, state, options) {
      var result;
      var _expression$children$ = expression.children[0].tryEvaluate(state, options),
        arr = _expression$children$.value,
        childrenError = _expression$children$.error;
      var error = childrenError;
      if (!error) {
        if (Array.isArray(arr)) {
          var start;
          var startExpr = expression.children[1];
          var _startExpr$tryEvaluat = startExpr.tryEvaluate(state, options);
          start = _startExpr$tryEvaluat.value;
          error = _startExpr$tryEvaluat.error;
          if (!error && !Number.isInteger(start)) {
            error = "".concat(startExpr, " is not an integer.");
          } else if (start < 0 || start > arr.length) {
            error = "".concat(startExpr, "=").concat(start, " which is out of range for ").concat(arr);
          }
          if (!error) {
            var end;
            if (expression.children.length === 2) {
              end = arr.length;
            } else {
              var endExpr = expression.children[2];
              var _endExpr$tryEvaluate = endExpr.tryEvaluate(state, options);
              end = _endExpr$tryEvaluate.value;
              error = _endExpr$tryEvaluate.error;
              if (!error && !Number.isInteger(end)) {
                error = "".concat(endExpr, " is not an integer");
              } else if (end < 0 || end > arr.length) {
                error = "".concat(endExpr, "=").concat(end, " which is out of range for ").concat(arr);
              }
            }
            if (!error) {
              result = arr.slice(start, end);
            }
          }
        } else {
          error = "".concat(expression.children[0], " is not array.");
        }
      }
      return {
        value: result,
        error: error
      };
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateOrder(expression, [returnType_1.ReturnType.Number], returnType_1.ReturnType.Array, returnType_1.ReturnType.Number);
    }
  }]);
  return SubArray;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.SubArray = SubArray;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.number.is-integer.js":595,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],136:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.number.is-integer.js");
require("core-js/modules/es.number.constructor.js");
require("core-js/modules/es.array.concat.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Return characters from a string, starting from the specified position or index. Index values start with the number 0.
 */
var Substring = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Substring, _expressionEvaluator_);
  var _super = _createSuper(Substring);
  /**
   * Initializes a new instance of the [Substring](xref:adaptive-expressions.Substring) class.
   */
  function Substring() {
    (0, _classCallCheck2.default)(this, Substring);
    return _super.call(this, expressionType_1.ExpressionType.Substring, Substring.evaluator, returnType_1.ReturnType.String, Substring.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Substring, null, [{
    key: "evaluator",
    value: function evaluator(expression, state, options) {
      var result;
      var _expression$children$ = expression.children[0].tryEvaluate(state, options),
        str = _expression$children$.value,
        childrenError = _expression$children$.error;
      var error = childrenError;
      if (!error) {
        if (typeof str === 'string') {
          var start;
          var startExpr = expression.children[1];
          var _startExpr$tryEvaluat = startExpr.tryEvaluate(state, options);
          start = _startExpr$tryEvaluat.value;
          error = _startExpr$tryEvaluat.error;
          if (!error && !Number.isInteger(start)) {
            error = "".concat(startExpr, " is not an integer.");
          } else if (start < 0 || start > str.length) {
            error = "".concat(startExpr, "=").concat(start, " which is out of range for ").concat(str);
          }
          if (!error) {
            var length;
            if (expression.children.length === 2) {
              // Without length, compute to end
              length = str.length - start;
            } else {
              var lengthExpr = expression.children[2];
              var _lengthExpr$tryEvalua = lengthExpr.tryEvaluate(state, options);
              length = _lengthExpr$tryEvalua.value;
              error = _lengthExpr$tryEvalua.error;
              if (!error && !Number.isInteger(length)) {
                error = "".concat(lengthExpr, " is not an integer");
              } else if (length < 0 || Number(start) + Number(length) > str.length) {
                error = "".concat(lengthExpr, "=").concat(length, " which is out of range for ").concat(str);
              }
            }
            if (!error) {
              result = str.substr(start, length);
            }
          }
        } else if (str === undefined) {
          result = '';
        } else {
          error = "".concat(expression.children[0], " is neither a string nor a null object.");
        }
      }
      return {
        value: result,
        error: error
      };
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateOrder(expression, [returnType_1.ReturnType.Number], returnType_1.ReturnType.String, returnType_1.ReturnType.Number);
    }
  }]);
  return Substring;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Substring = Substring;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.number.is-integer.js":595,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],137:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.number.constructor.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionType_1 = require("../expressionType");
var multivariateNumericEvaluator_1 = require("./multivariateNumericEvaluator");
/**
 * Return the result from subtracting the next number from the previous number.
 */
var Subtract = /*#__PURE__*/function (_multivariateNumericE) {
  (0, _inherits2.default)(Subtract, _multivariateNumericE);
  var _super = _createSuper(Subtract);
  /**
   * Initializes a new instance of the [Subtract](xref:adaptive-expressions.Subtract) class.
   */
  function Subtract() {
    (0, _classCallCheck2.default)(this, Subtract);
    return _super.call(this, expressionType_1.ExpressionType.Subtract, Subtract.func);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Subtract, null, [{
    key: "func",
    value: function func(args) {
      return Number(args[0]) - Number(args[1]);
    }
  }]);
  return Subtract;
}(multivariateNumericEvaluator_1.MultivariateNumericEvaluator);
exports.Subtract = Subtract;

},{"../expressionType":192,"./multivariateNumericEvaluator":103,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],138:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.number.is-integer.js");
require("core-js/modules/es.number.constructor.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var dayjs_1 = __importDefault(require("dayjs"));
var utc_1 = __importDefault(require("dayjs/plugin/utc"));
dayjs_1.default.extend(utc_1.default);
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Subtract a number of time units from a timestamp.
 */
var SubtractFromTime = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(SubtractFromTime, _expressionEvaluator_);
  var _super = _createSuper(SubtractFromTime);
  /**
   * Initializes a new instance of the [SubtractFromTime](xref:adaptive-expressions.SubtractFromTime) class.
   */
  function SubtractFromTime() {
    (0, _classCallCheck2.default)(this, SubtractFromTime);
    return _super.call(this, expressionType_1.ExpressionType.SubtractFromTime, SubtractFromTime.evaluator, returnType_1.ReturnType.String, SubtractFromTime.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(SubtractFromTime, null, [{
    key: "evaluator",
    value: function evaluator(expression, state, options) {
      var value;
      var locale = options.locale ? options.locale : Intl.DateTimeFormat().resolvedOptions().locale;
      var format = functionUtils_1.FunctionUtils.DefaultDateTimeFormat;
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expression, state, options),
        args = _functionUtils_1$Func.args,
        childrenError = _functionUtils_1$Func.error;
      var error = childrenError;
      if (!error) {
        if (typeof args[0] === 'string' && Number.isInteger(args[1]) && typeof args[2] === 'string') {
          var _functionUtils_1$Func2 = functionUtils_1.FunctionUtils.determineFormatAndLocale(args, 5, format, locale);
          format = _functionUtils_1$Func2.format;
          locale = _functionUtils_1$Func2.locale;
          var _functionUtils_intern = functionUtils_internal_1.InternalFunctionUtils.timeUnitTransformer(args[1], args[2]),
            duration = _functionUtils_intern.duration,
            tsStr = _functionUtils_intern.tsStr;
          if (tsStr === undefined) {
            error = "".concat(args[2], " is not a valid time unit.");
          } else {
            var dur = duration;
            error = functionUtils_internal_1.InternalFunctionUtils.verifyISOTimestamp(args[0]);
            if (!error) {
              value = dayjs_1.default(args[0]).locale(locale).utc().subtract(dur, tsStr).format(format);
            }
          }
        } else {
          error = "".concat(expression, " should contain an ISO format timestamp, a time interval integer, a string unit of time and an optional output format string.");
        }
      }
      return {
        value: value,
        error: error
      };
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateOrder(expression, [returnType_1.ReturnType.String, returnType_1.ReturnType.String], returnType_1.ReturnType.String, returnType_1.ReturnType.Number, returnType_1.ReturnType.String);
    }
  }]);
  return SubtractFromTime;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.SubtractFromTime = SubtractFromTime;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.number.is-integer.js":595,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"dayjs":697,"dayjs/plugin/utc":700}],139:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.object.to-string.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Return the result from adding numbers in an array.
 */
var Sum = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Sum, _expressionEvaluator_);
  var _super = _createSuper(Sum);
  /**
   * Initializes a new instance of the [Sum](xref:adaptive-expressions.Sum) class.
   */
  function Sum() {
    (0, _classCallCheck2.default)(this, Sum);
    return _super.call(this, expressionType_1.ExpressionType.Sum, Sum.evaluator(), returnType_1.ReturnType.Number, Sum.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Sum, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        return args[0].reduce(function (x, y) {
          return x + y;
        });
      }, functionUtils_1.FunctionUtils.verifyNumericList);
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateOrder(expression, [], returnType_1.ReturnType.Array);
    }
  }]);
  return Sum;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Sum = Sum;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],140:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.number.is-integer.js");
require("core-js/modules/es.number.constructor.js");
require("core-js/modules/es.array.slice.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Return items from the front of an array or take the specific prefix from a string.
 */
var Take = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Take, _expressionEvaluator_);
  var _super = _createSuper(Take);
  /**
   * Initializes a new instance of the [Take](xref:adaptive-expressions.Take) class.
   */
  function Take() {
    (0, _classCallCheck2.default)(this, Take);
    return _super.call(this, expressionType_1.ExpressionType.Take, Take.evaluator, returnType_1.ReturnType.Array | returnType_1.ReturnType.String, Take.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Take, null, [{
    key: "evaluator",
    value: function evaluator(expression, state, options) {
      var result;
      var _expression$children$ = expression.children[0].tryEvaluate(state, options),
        arr = _expression$children$.value,
        childrenError = _expression$children$.error;
      var error = childrenError;
      if (!error) {
        if (Array.isArray(arr) || typeof arr === 'string') {
          var start;
          var startExpr = expression.children[1];
          var _startExpr$tryEvaluat = startExpr.tryEvaluate(state, options);
          start = _startExpr$tryEvaluat.value;
          error = _startExpr$tryEvaluat.error;
          if (!error && !Number.isInteger(start)) {
            error = "".concat(startExpr, " is not an integer.");
          }
          if (!error) {
            start = Math.max(start, 0);
            result = arr.slice(0, start);
          }
        } else {
          error = "".concat(expression.children[0], " is not array or string.");
        }
      }
      return {
        value: result,
        error: error
      };
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateOrder(expression, [], returnType_1.ReturnType.Array | returnType_1.ReturnType.String, returnType_1.ReturnType.Number);
    }
  }]);
  return Take;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Take = Take;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.number.is-integer.js":595,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],141:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Return the ticks property value of a specified timestamp. A tick is 100-nanosecond interval.
 */
var Ticks = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Ticks, _expressionEvaluator_);
  var _super = _createSuper(Ticks);
  /**
   * Initializes a new instance of the [Ticks](xref:adaptive-expressions.Ticks) class.
   */
  function Ticks() {
    (0, _classCallCheck2.default)(this, Ticks);
    return _super.call(this, expressionType_1.ExpressionType.Ticks, Ticks.evaluator, returnType_1.ReturnType.Number, Ticks.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Ticks, null, [{
    key: "evaluator",
    value: function evaluator(expr, state, options) {
      var value;
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expr, state, options),
        args = _functionUtils_1$Func.args,
        childrenError = _functionUtils_1$Func.error;
      var error = childrenError;
      if (!error) {
        if (typeof args[0] === 'string') {
          var _functionUtils_intern = functionUtils_internal_1.InternalFunctionUtils.ticks(args[0]);
          value = _functionUtils_intern.value;
          error = _functionUtils_intern.error;
        } else {
          error = "".concat(expr, " should contain an ISO format timestamp.");
        }
      }
      return {
        value: value,
        error: error
      };
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateArityAndAnyType(expression, 1, 1, returnType_1.ReturnType.String);
    }
  }]);
  return Ticks;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Ticks = Ticks;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],142:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.number.is-integer.js");
require("core-js/modules/es.number.constructor.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
var big_integer_1 = __importDefault(require("big-integer"));
/**
 * Convert ticks to number of days.
 */
var TicksToDays = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(TicksToDays, _expressionEvaluator_);
  var _super = _createSuper(TicksToDays);
  /**
   * Initializes a new instance of the [TicksToDays](xref:adaptive-expressions.TicksToDays) class.
   */
  function TicksToDays() {
    (0, _classCallCheck2.default)(this, TicksToDays);
    return _super.call(this, expressionType_1.ExpressionType.TicksToDays, TicksToDays.evaluator, returnType_1.ReturnType.Number, functionUtils_1.FunctionUtils.validateUnaryNumber);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(TicksToDays, null, [{
    key: "evaluator",
    value: function evaluator(expr, state, options) {
      var value;
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expr, state, options),
        args = _functionUtils_1$Func.args,
        childrenError = _functionUtils_1$Func.error;
      var error = childrenError;
      if (!error) {
        var firstChild = args[0];
        if (Number.isInteger(firstChild)) {
          value = firstChild / TicksToDays.TicksPerDay;
        } else if (big_integer_1.default.isInstance(firstChild)) {
          value = firstChild.toJSNumber() / TicksToDays.TicksPerDay;
        } else {
          error = "".concat(expr, " should contain an integer of ticks");
        }
      }
      return {
        value: value,
        error: error
      };
    }
  }]);
  return TicksToDays;
}(expressionEvaluator_1.ExpressionEvaluator);
TicksToDays.TicksPerDay = 24 * 60 * 60 * 10000000;
exports.TicksToDays = TicksToDays;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"big-integer":419,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.number.is-integer.js":595,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],143:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.number.is-integer.js");
require("core-js/modules/es.number.constructor.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
var big_integer_1 = __importDefault(require("big-integer"));
/**
 * Convert ticks to number of hours.
 */
var TicksToHours = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(TicksToHours, _expressionEvaluator_);
  var _super = _createSuper(TicksToHours);
  /**
   * Initializes a new instance of the [TicksToHours](xref:adaptive-expressions.TicksToHours) class.
   */
  function TicksToHours() {
    (0, _classCallCheck2.default)(this, TicksToHours);
    return _super.call(this, expressionType_1.ExpressionType.TicksToHours, TicksToHours.evaluator, returnType_1.ReturnType.Number, functionUtils_1.FunctionUtils.validateUnaryNumber);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(TicksToHours, null, [{
    key: "evaluator",
    value: function evaluator(expr, state, options) {
      var value;
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expr, state, options),
        args = _functionUtils_1$Func.args,
        childrenError = _functionUtils_1$Func.error;
      var error = childrenError;
      if (!error) {
        var firstChild = args[0];
        if (Number.isInteger(firstChild)) {
          value = firstChild / TicksToHours.TicksPerHour;
        } else if (big_integer_1.default.isInstance(firstChild)) {
          value = firstChild.toJSNumber() / TicksToHours.TicksPerHour;
        } else {
          error = "".concat(expr, " should contain an integer of ticks");
        }
      }
      return {
        value: value,
        error: error
      };
    }
  }]);
  return TicksToHours;
}(expressionEvaluator_1.ExpressionEvaluator);
TicksToHours.TicksPerHour = 60 * 60 * 10000000;
exports.TicksToHours = TicksToHours;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"big-integer":419,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.number.is-integer.js":595,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],144:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.number.is-integer.js");
require("core-js/modules/es.number.constructor.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
var big_integer_1 = __importDefault(require("big-integer"));
/**
 * Convert ticks to number of minutes.
 */
var TicksToMinutes = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(TicksToMinutes, _expressionEvaluator_);
  var _super = _createSuper(TicksToMinutes);
  /**
   * Initializes a new instance of the [TicksToMinutes](xref:adaptive-expressions.TicksToMinutes) class.
   */
  function TicksToMinutes() {
    (0, _classCallCheck2.default)(this, TicksToMinutes);
    return _super.call(this, expressionType_1.ExpressionType.TicksToMinutes, TicksToMinutes.evaluator, returnType_1.ReturnType.Number, functionUtils_1.FunctionUtils.validateUnaryNumber);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(TicksToMinutes, null, [{
    key: "evaluator",
    value: function evaluator(expr, state, options) {
      var value;
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expr, state, options),
        args = _functionUtils_1$Func.args,
        childrenError = _functionUtils_1$Func.error;
      var error = childrenError;
      if (!error) {
        var firstChild = args[0];
        if (Number.isInteger(firstChild)) {
          value = firstChild / TicksToMinutes.TicksPerMinute;
        } else if (big_integer_1.default.isInstance(firstChild)) {
          value = firstChild.toJSNumber() / TicksToMinutes.TicksPerMinute;
        } else {
          error = "".concat(expr, " should contain an integer of ticks");
        }
      }
      return {
        value: value,
        error: error
      };
    }
  }]);
  return TicksToMinutes;
}(expressionEvaluator_1.ExpressionEvaluator);
TicksToMinutes.TicksPerMinute = 60 * 10000000;
exports.TicksToMinutes = TicksToMinutes;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"big-integer":419,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.number.is-integer.js":595,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],145:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var dayjs_1 = __importDefault(require("dayjs"));
var utc_1 = __importDefault(require("dayjs/plugin/utc"));
dayjs_1.default.extend(utc_1.default);
var expressionEvaluator_1 = require("../expressionEvaluator");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Evaluator that transforms a datetime to another datetime.
 */
var TimeTransformEvaluator = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(TimeTransformEvaluator, _expressionEvaluator_);
  var _super = _createSuper(TimeTransformEvaluator);
  /**
   * Initializes a new instance of the [TimeTransformEvaluator](xref:adaptive-expressions.TimeTransformEvaluator) class.
   *
   * @param type Name of the built-in function.
   * @param func The evaluation function, it takes a timestamp and the number of transformation, and returns a `Date`.
   */
  function TimeTransformEvaluator(type, func) {
    (0, _classCallCheck2.default)(this, TimeTransformEvaluator);
    return _super.call(this, type, TimeTransformEvaluator.evaluator(func), returnType_1.ReturnType.String, TimeTransformEvaluator.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(TimeTransformEvaluator, null, [{
    key: "evaluator",
    value: function evaluator(func) {
      return function (expression, state, options) {
        var result;
        var locale = options.locale ? options.locale : Intl.DateTimeFormat().resolvedOptions().locale;
        var format = functionUtils_1.FunctionUtils.DefaultDateTimeFormat;
        var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expression, state, options),
          args = _functionUtils_1$Func.args,
          childrenError = _functionUtils_1$Func.error;
        var error = childrenError;
        if (!error) {
          var _functionUtils_1$Func2 = functionUtils_1.FunctionUtils.determineFormatAndLocale(args, 4, format, locale);
          format = _functionUtils_1$Func2.format;
          locale = _functionUtils_1$Func2.locale;
          if (typeof args[0] === 'string' && functionUtils_1.FunctionUtils.isNumber(args[1])) {
            error = functionUtils_internal_1.InternalFunctionUtils.verifyISOTimestamp(args[0]);
            if (!error) {
              result = dayjs_1.default(func(new Date(args[0]), args[1])).locale(locale).utc().format(format);
            }
          } else {
            error = "".concat(expression, " should contain an ISO format timestamp and a time interval integer.");
          }
        }
        return {
          value: result,
          error: error
        };
      };
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateOrder(expression, [returnType_1.ReturnType.String, returnType_1.ReturnType.String], returnType_1.ReturnType.String, returnType_1.ReturnType.Number);
    }
  }]);
  return TimeTransformEvaluator;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.TimeTransformEvaluator = TimeTransformEvaluator;

},{"../expressionEvaluator":180,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"dayjs":697,"dayjs/plugin/utc":700}],146:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.concat.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var recognizers_text_data_types_timex_expression_1 = require("@microsoft/recognizers-text-data-types-timex-expression");
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 *  Return true if a given TimexProperty or Timex expression refers to a valid time.
 */
var TimexResolve = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(TimexResolve, _expressionEvaluator_);
  var _super = _createSuper(TimexResolve);
  /**
   * Initializes a new instance of the [TimexResolve](xref:adaptive-expressions.TimexResolve) class.
   */
  function TimexResolve() {
    (0, _classCallCheck2.default)(this, TimexResolve);
    return _super.call(this, expressionType_1.ExpressionType.TimexResolve, TimexResolve.evaluator, returnType_1.ReturnType.String, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(TimexResolve, null, [{
    key: "evaluator",
    value: function evaluator(expr, state, options) {
      var parsed;
      var value = false;
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expr, state, options),
        args = _functionUtils_1$Func.args,
        childrenError = _functionUtils_1$Func.error;
      var error = childrenError;
      if (!error) {
        var _functionUtils_intern = functionUtils_internal_1.InternalFunctionUtils.parseTimexProperty(args[0]);
        parsed = _functionUtils_intern.timexProperty;
        error = _functionUtils_intern.error;
      }
      if (!error && parsed.types.size === 0) {
        error = "The parsed TimexProperty of ".concat(args[0], " in ").concat(expr, " has no types. It can't be resolved to a string value.");
      }
      if (!error) {
        var formatedTimex = parsed.timex;
        try {
          var resolvedValues = recognizers_text_data_types_timex_expression_1.valueResolver.resolve([formatedTimex]);
          value = resolvedValues.values[0].value;
        } catch (err) {
          error = "".concat(args[0], " in ").concat(expr, " is not a valid argument. ").concat(err.Message);
        }
      }
      return {
        value: value,
        error: error
      };
    }
  }]);
  return TimexResolve;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.TimexResolve = TimexResolve;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@microsoft/recognizers-text-data-types-timex-expression":222,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/web.dom-collections.iterator.js":677}],147:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var functionUtils_1 = require("../functionUtils");
var expressionType_1 = require("../expressionType");
var functionUtils_internal_1 = require("../functionUtils.internal");
var stringTransformEvaluator_1 = require("./stringTransformEvaluator");
/**
 * Converts the specified string to title case.
 */
var TitleCase = /*#__PURE__*/function (_stringTransformEvalu) {
  (0, _inherits2.default)(TitleCase, _stringTransformEvalu);
  var _super = _createSuper(TitleCase);
  /**
   * Initializes a new instance of the [TitleCase](xref:adaptive-expressions.TitleCase) class.
   */
  function TitleCase() {
    (0, _classCallCheck2.default)(this, TitleCase);
    return _super.call(this, expressionType_1.ExpressionType.TitleCase, TitleCase.evaluator, functionUtils_1.FunctionUtils.validateUnaryOrBinaryString);
  }
  (0, _createClass2.default)(TitleCase, null, [{
    key: "evaluator",
    value: function evaluator(args, options) {
      var locale = options.locale ? options.locale : Intl.DateTimeFormat().resolvedOptions().locale;
      locale = functionUtils_1.FunctionUtils.determineLocale(args, 2, locale);
      var firstArg = args[0];
      if (typeof firstArg === 'string' || firstArg === undefined) {
        var inputStr = functionUtils_internal_1.InternalFunctionUtils.parseStringOrUndefined(firstArg).toLocaleLowerCase(locale);
        if (inputStr === '') {
          return inputStr;
        } else {
          return inputStr.replace(/\w\S*/g, function (txt) {
            return txt.charAt(0).toUpperCase() + txt.substr(1).toLocaleLowerCase(locale);
          });
        }
      }
    }
  }]);
  return TitleCase;
}(stringTransformEvaluator_1.StringTransformEvaluator);
exports.TitleCase = TitleCase;

},{"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"./stringTransformEvaluator":134,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.string.replace.js":629}],148:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var stringTransformEvaluator_1 = require("./stringTransformEvaluator");
/**
 * Return a string in lowercase format.
 * If a character in the string doesn't have a lowercase version, that character stays unchanged in the returned string.
 */
var ToLower = /*#__PURE__*/function (_stringTransformEvalu) {
  (0, _inherits2.default)(ToLower, _stringTransformEvalu);
  var _super = _createSuper(ToLower);
  /**
   * Initializes a new instance of the [ToLower](xref:adaptive-expressions.ToLower) class.
   */
  function ToLower() {
    (0, _classCallCheck2.default)(this, ToLower);
    return _super.call(this, expressionType_1.ExpressionType.ToLower, ToLower.evaluator, functionUtils_1.FunctionUtils.validateUnaryOrBinaryString);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(ToLower, null, [{
    key: "evaluator",
    value: function evaluator(args, options) {
      var locale = options.locale ? options.locale : Intl.DateTimeFormat().resolvedOptions().locale;
      locale = functionUtils_1.FunctionUtils.determineLocale(args, 2, locale);
      var firstArg = args[0];
      if (typeof firstArg === 'string' || firstArg === undefined) {
        return functionUtils_internal_1.InternalFunctionUtils.parseStringOrUndefined(firstArg).toLocaleLowerCase(locale);
      }
    }
  }]);
  return ToLower;
}(stringTransformEvaluator_1.StringTransformEvaluator);
exports.ToLower = ToLower;

},{"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"./stringTransformEvaluator":134,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],149:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var stringTransformEvaluator_1 = require("./stringTransformEvaluator");
/**
 * Return a string in uppercase format.
 * If a character in the string doesn't have an uppercase version, that character stays unchanged in the returned string.
 */
var ToUpper = /*#__PURE__*/function (_stringTransformEvalu) {
  (0, _inherits2.default)(ToUpper, _stringTransformEvalu);
  var _super = _createSuper(ToUpper);
  /**
   * Initializes a new instance of the [ToUpper](xref:adaptive-expressions.ToUpper) class.
   */
  function ToUpper() {
    (0, _classCallCheck2.default)(this, ToUpper);
    return _super.call(this, expressionType_1.ExpressionType.ToUpper, ToUpper.evaluator, functionUtils_1.FunctionUtils.validateUnaryOrBinaryString);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(ToUpper, null, [{
    key: "evaluator",
    value: function evaluator(args, options) {
      var locale = options.locale ? options.locale : Intl.DateTimeFormat().resolvedOptions().locale;
      locale = functionUtils_1.FunctionUtils.determineLocale(args, 2, locale);
      var firstArg = args[0];
      if (typeof firstArg === 'string' || firstArg === undefined) {
        return functionUtils_internal_1.InternalFunctionUtils.parseStringOrUndefined(firstArg).toLocaleUpperCase(locale);
      }
    }
  }]);
  return ToUpper;
}(stringTransformEvaluator_1.StringTransformEvaluator);
exports.ToUpper = ToUpper;

},{"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"./stringTransformEvaluator":134,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],150:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.string.trim.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionType_1 = require("../expressionType");
var functionUtils_internal_1 = require("../functionUtils.internal");
var stringTransformEvaluator_1 = require("./stringTransformEvaluator");
/**
 * Remove leading and trailing whitespace from a string, and return the updated string.
 */
var Trim = /*#__PURE__*/function (_stringTransformEvalu) {
  (0, _inherits2.default)(Trim, _stringTransformEvalu);
  var _super = _createSuper(Trim);
  /**
   * Initializes a new instance of the [Trim](xref:adaptive-expressions.Trim) class.
   */
  function Trim() {
    (0, _classCallCheck2.default)(this, Trim);
    return _super.call(this, expressionType_1.ExpressionType.Trim, Trim.evaluator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Trim, null, [{
    key: "evaluator",
    value: function evaluator(args) {
      var firstArg = args[0];
      if (typeof firstArg === 'string' || firstArg === undefined) {
        return String(functionUtils_internal_1.InternalFunctionUtils.parseStringOrUndefined(firstArg)).trim();
      }
    }
  }]);
  return Trim;
}(stringTransformEvaluator_1.StringTransformEvaluator);
exports.Trim = Trim;

},{"../expressionType":192,"../functionUtils.internal":195,"./stringTransformEvaluator":134,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.string.trim.js":634}],151:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.reflect.construct.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.set.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.array.concat.js");
require("core-js/modules/es.number.max-safe-integer.js");
require("core-js/modules/es.number.constructor.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Return a collection that has all the items from the specified collections.
 * To appear in the result, an item can appear in any collection passed to this function.
 * If one or more items have the same name, the last item with that name appears in the result.
 */
var Union = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Union, _expressionEvaluator_);
  var _super = _createSuper(Union);
  /**
   * Initializes a new instance of the [Union](xref:adaptive-expressions.Union) class.
   */
  function Union() {
    (0, _classCallCheck2.default)(this, Union);
    return _super.call(this, expressionType_1.ExpressionType.Union, Union.evaluator(), returnType_1.ReturnType.Array, Union.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Union, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        var result = [];
        var _iterator = _createForOfIteratorHelper(args),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var arg = _step.value;
            result = result.concat(arg);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return Array.from(new Set(result));
      }, functionUtils_1.FunctionUtils.verifyList);
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateArityAndAnyType(expression, 1, Number.MAX_SAFE_INTEGER, returnType_1.ReturnType.Array);
    }
  }]);
  return Union;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Union = Union;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.number.max-safe-integer.js":597,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.set.js":621,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],152:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.set.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Remove all duplicates from an array.
 */
var Unique = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Unique, _expressionEvaluator_);
  var _super = _createSuper(Unique);
  /**
   * Initializes a new instance of the [Unique](xref:adaptive-expressions.Unique) class.
   */
  function Unique() {
    (0, _classCallCheck2.default)(this, Unique);
    return _super.call(this, expressionType_1.ExpressionType.Unique, Unique.evaluator(), returnType_1.ReturnType.Array, Unique.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Unique, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        return (0, _toConsumableArray2.default)(new Set(args[0]));
      }, functionUtils_1.FunctionUtils.verifyList);
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateOrder(expression, [], returnType_1.ReturnType.Array);
    }
  }]);
  return Unique;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Unique = Unique;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/toConsumableArray":249,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.set.js":621,"core-js/modules/es.string.iterator.js":626,"core-js/modules/web.dom-collections.iterator.js":677}],153:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Return the binary version of a uniform resource identifier (URI) component.
 */
var UriComponent = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(UriComponent, _expressionEvaluator_);
  var _super = _createSuper(UriComponent);
  /**
   * Initializes a new instance of the [UriComponent](xref:adaptive-expressions.UriComponent) class.
   */
  function UriComponent() {
    (0, _classCallCheck2.default)(this, UriComponent);
    return _super.call(this, expressionType_1.ExpressionType.UriComponent, UriComponent.evaluator(), returnType_1.ReturnType.String, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(UriComponent, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        return encodeURIComponent(args[0]);
      }, functionUtils_1.FunctionUtils.verifyString);
    }
  }]);
  return UriComponent;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.UriComponent = UriComponent;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],154:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Return the string version of a uniform resource identifier (URI) encoded string, effectively decoding the URI-encoded string.
 */
var UriComponentToString = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(UriComponentToString, _expressionEvaluator_);
  var _super = _createSuper(UriComponentToString);
  /**
   * Initializes a new instance of the [UriComponentToString](xref:adaptive-expressions.UriComponentToString) class.
   */
  function UriComponentToString() {
    (0, _classCallCheck2.default)(this, UriComponentToString);
    return _super.call(this, expressionType_1.ExpressionType.UriComponentToString, UriComponentToString.evaluator(), returnType_1.ReturnType.String, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(UriComponentToString, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.apply(function (args) {
        return decodeURIComponent(args[0]);
      }, functionUtils_1.FunctionUtils.verifyString);
    }
  }]);
  return UriComponentToString;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.UriComponentToString = UriComponentToString;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],155:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Return the host value of a unified resource identifier (URI).
 */
var UriHost = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(UriHost, _expressionEvaluator_);
  var _super = _createSuper(UriHost);
  /**
   * Initializes a new instance of the [UriHost](xref:adaptive-expressions.UriHost) class.
   */
  function UriHost() {
    (0, _classCallCheck2.default)(this, UriHost);
    return _super.call(this, expressionType_1.ExpressionType.UriHost, UriHost.evaluator, returnType_1.ReturnType.String, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(UriHost, null, [{
    key: "evaluator",
    value: function evaluator(expr, state, options) {
      var value;
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expr, state, options),
        args = _functionUtils_1$Func.args,
        childrenError = _functionUtils_1$Func.error;
      var error = childrenError;
      if (!error) {
        if (typeof args[0] === 'string') {
          var _UriHost$evalUriHost = UriHost.evalUriHost(args[0]);
          value = _UriHost$evalUriHost.value;
          error = _UriHost$evalUriHost.error;
        } else {
          error = "".concat(expr, " should contain a URI string.");
        }
      }
      return {
        value: value,
        error: error
      };
    }
    /**
     * @private
     */
  }, {
    key: "evalUriHost",
    value: function evalUriHost(uri) {
      var result;
      var _functionUtils_intern = functionUtils_internal_1.InternalFunctionUtils.parseUri(uri),
        parsed = _functionUtils_intern.value,
        parseError = _functionUtils_intern.error;
      var error = parseError;
      if (!error) {
        try {
          result = parsed.hostname;
        } catch (_a) {
          error = 'invalid operation, input uri should be an absolute URI';
        }
      }
      return {
        value: result,
        error: error
      };
    }
  }]);
  return UriHost;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.UriHost = UriHost;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],156:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/web.url.js");
require("core-js/modules/web.url-search-params.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Return the path value of a unified resource identifier (URI).
 */
var UriPath = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(UriPath, _expressionEvaluator_);
  var _super = _createSuper(UriPath);
  /**
   * Initializes a new instance of the [UriPath](xref:adaptive-expressions.UriPath) class.
   */
  function UriPath() {
    (0, _classCallCheck2.default)(this, UriPath);
    return _super.call(this, expressionType_1.ExpressionType.UriPath, UriPath.evaluator, returnType_1.ReturnType.String, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(UriPath, null, [{
    key: "evaluator",
    value: function evaluator(expr, state, options) {
      var value;
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expr, state, options),
        args = _functionUtils_1$Func.args,
        childrenError = _functionUtils_1$Func.error;
      var error = childrenError;
      if (!error) {
        if (typeof args[0] === 'string') {
          var _UriPath$evalUriPath = UriPath.evalUriPath(args[0]);
          value = _UriPath$evalUriPath.value;
          error = _UriPath$evalUriPath.error;
        } else {
          error = "".concat(expr, " should contain a URI string.");
        }
      }
      return {
        value: value,
        error: error
      };
    }
    /**
     * @private
     */
  }, {
    key: "evalUriPath",
    value: function evalUriPath(uri) {
      var result;
      var error = functionUtils_internal_1.InternalFunctionUtils.parseUri(uri).error;
      if (!error) {
        try {
          var uriObj = new URL(uri);
          result = uriObj.pathname;
        } catch (_a) {
          error = 'invalid operation, input uri should be an absolute URI';
        }
      }
      return {
        value: result,
        error: error
      };
    }
  }]);
  return UriPath;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.UriPath = UriPath;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.string.iterator.js":626,"core-js/modules/web.dom-collections.iterator.js":677,"core-js/modules/web.url-search-params.js":678,"core-js/modules/web.url.js":679}],157:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.search.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Return the path and query value of a unified resource identifier (URI).
 */
var UriPathAndQuery = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(UriPathAndQuery, _expressionEvaluator_);
  var _super = _createSuper(UriPathAndQuery);
  /**
   * Initializes a new instance of the [UriPathAndQuery](xref:adaptive-expressions.UriPathAndQuery) class.
   */
  function UriPathAndQuery() {
    (0, _classCallCheck2.default)(this, UriPathAndQuery);
    return _super.call(this, expressionType_1.ExpressionType.UriPathAndQuery, UriPathAndQuery.evaluator, returnType_1.ReturnType.String, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(UriPathAndQuery, null, [{
    key: "evaluator",
    value: function evaluator(expr, state, options) {
      var value;
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expr, state, options),
        args = _functionUtils_1$Func.args,
        childrenError = _functionUtils_1$Func.error;
      var error = childrenError;
      if (!error) {
        if (typeof args[0] === 'string') {
          var _UriPathAndQuery$eval = UriPathAndQuery.evalUriPathAndQuery(args[0]);
          value = _UriPathAndQuery$eval.value;
          error = _UriPathAndQuery$eval.error;
        } else {
          error = "".concat(expr, " should contain a URI string.");
        }
      }
      return {
        value: value,
        error: error
      };
    }
    /**
     * @private
     */
  }, {
    key: "evalUriPathAndQuery",
    value: function evalUriPathAndQuery(uri) {
      var result;
      var _functionUtils_intern = functionUtils_internal_1.InternalFunctionUtils.parseUri(uri),
        parsed = _functionUtils_intern.value,
        parseError = _functionUtils_intern.error;
      var error = parseError;
      if (!error) {
        try {
          result = parsed.pathname + parsed.search;
        } catch (_a) {
          error = 'invalid operation, input uri should be an absolute URI';
        }
      }
      return {
        value: result,
        error: error
      };
    }
  }]);
  return UriPathAndQuery;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.UriPathAndQuery = UriPathAndQuery;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.string.search.js":630}],158:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Return the port value of a unified resource identifier (URI).
 */
var UriPort = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(UriPort, _expressionEvaluator_);
  var _super = _createSuper(UriPort);
  /**
   * Initializes a new instance of the [UriPort](xref:adaptive-expressions.UriPort) class.
   */
  function UriPort() {
    (0, _classCallCheck2.default)(this, UriPort);
    return _super.call(this, expressionType_1.ExpressionType.UriPort, UriPort.evaluator, returnType_1.ReturnType.Number, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(UriPort, null, [{
    key: "evaluator",
    value: function evaluator(expr, state, options) {
      var value;
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expr, state, options),
        args = _functionUtils_1$Func.args,
        childrenError = _functionUtils_1$Func.error;
      var error = childrenError;
      if (!error) {
        if (typeof args[0] === 'string') {
          var _UriPort$evalUriPort = UriPort.evalUriPort(args[0]);
          value = _UriPort$evalUriPort.value;
          error = _UriPort$evalUriPort.error;
        } else {
          error = "".concat(expr, " should contain a URI string.");
        }
      }
      return {
        value: value,
        error: error
      };
    }
    /**
     * @private
     */
  }, {
    key: "evalUriPort",
    value: function evalUriPort(uri) {
      var result;
      var _functionUtils_intern = functionUtils_internal_1.InternalFunctionUtils.parseUri(uri),
        parsed = _functionUtils_intern.value,
        parseError = _functionUtils_intern.error;
      var error = parseError;
      if (!error) {
        try {
          result = parseInt(parsed.port);
        } catch (_a) {
          error = 'invalid operation, input uri should be an absolute URI';
        }
      }
      return {
        value: result,
        error: error
      };
    }
  }]);
  return UriPort;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.UriPort = UriPort;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],159:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.search.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Return the query value of a unified resource identifier (URI).
 */
var UriQuery = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(UriQuery, _expressionEvaluator_);
  var _super = _createSuper(UriQuery);
  /**
   * Initializes a new instance of the [UriQuery](xref:adaptive-expressions.UriQuery) class.
   */
  function UriQuery() {
    (0, _classCallCheck2.default)(this, UriQuery);
    return _super.call(this, expressionType_1.ExpressionType.UriQuery, UriQuery.evaluator, returnType_1.ReturnType.String, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(UriQuery, null, [{
    key: "evaluator",
    value: function evaluator(expr, state, options) {
      var value;
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expr, state, options),
        args = _functionUtils_1$Func.args,
        childrenError = _functionUtils_1$Func.error;
      var error = childrenError;
      if (!error) {
        if (typeof args[0] === 'string') {
          var _UriQuery$evalUriQuer = UriQuery.evalUriQuery(args[0]);
          value = _UriQuery$evalUriQuer.value;
          error = _UriQuery$evalUriQuer.error;
        } else {
          error = "".concat(expr, " should contain a URI string.");
        }
      }
      return {
        value: value,
        error: error
      };
    }
    /**
     * @private
     */
  }, {
    key: "evalUriQuery",
    value: function evalUriQuery(uri) {
      var result;
      var _functionUtils_intern = functionUtils_internal_1.InternalFunctionUtils.parseUri(uri),
        parsed = _functionUtils_intern.value,
        parseError = _functionUtils_intern.error;
      var error = parseError;
      if (!error) {
        try {
          result = parsed.search;
        } catch (_a) {
          error = 'invalid operation, input uri should be an absolute URI';
        }
      }
      return {
        value: result,
        error: error
      };
    }
  }]);
  return UriQuery;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.UriQuery = UriQuery;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.string.search.js":630}],160:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Return the scheme value of a unified resource identifier (URI).
 */
var UriScheme = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(UriScheme, _expressionEvaluator_);
  var _super = _createSuper(UriScheme);
  /**
   * Initializes a new instance of the [UriScheme](xref:adaptive-expressions.UriScheme) class.
   */
  function UriScheme() {
    (0, _classCallCheck2.default)(this, UriScheme);
    return _super.call(this, expressionType_1.ExpressionType.UriScheme, UriScheme.evaluator, returnType_1.ReturnType.String, functionUtils_1.FunctionUtils.validateUnary);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(UriScheme, null, [{
    key: "evaluator",
    value: function evaluator(expr, state, options) {
      var value;
      var _functionUtils_1$Func = functionUtils_1.FunctionUtils.evaluateChildren(expr, state, options),
        args = _functionUtils_1$Func.args,
        childrenError = _functionUtils_1$Func.error;
      var error = childrenError;
      if (!error) {
        if (typeof args[0] === 'string') {
          var _UriScheme$evalUriSch = UriScheme.evalUriScheme(args[0]);
          value = _UriScheme$evalUriSch.value;
          error = _UriScheme$evalUriSch.error;
        } else {
          error = "".concat(expr, " should contain a URI string.");
        }
      }
      return {
        value: value,
        error: error
      };
    }
    /**
     * @private
     */
  }, {
    key: "evalUriScheme",
    value: function evalUriScheme(uri) {
      var result;
      var _functionUtils_intern = functionUtils_internal_1.InternalFunctionUtils.parseUri(uri),
        parsed = _functionUtils_intern.value,
        parseError = _functionUtils_intern.error;
      var error = parseError;
      if (!error) {
        try {
          result = parsed.protocol.replace(':', '');
        } catch (_a) {
          error = 'invalid operation, input uri should be an absolute URI';
        }
      }
      return {
        value: result,
        error: error
      };
    }
  }]);
  return UriScheme;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.UriScheme = UriScheme;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.string.replace.js":629}],161:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var dayjs_1 = __importDefault(require("dayjs"));
var utc_1 = __importDefault(require("dayjs/plugin/utc"));
dayjs_1.default.extend(utc_1.default);
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Return the current timestamp.
 */
var UtcNow = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(UtcNow, _expressionEvaluator_);
  var _super = _createSuper(UtcNow);
  /**
   * Initializes a new instance of the [UtcNow](xref:adaptive-expressions.UtcNow) class.
   */
  function UtcNow() {
    (0, _classCallCheck2.default)(this, UtcNow);
    return _super.call(this, expressionType_1.ExpressionType.UtcNow, UtcNow.evaluator(), returnType_1.ReturnType.String, UtcNow.validator);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(UtcNow, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.applyWithOptionsAndError(function (args, options) {
        var locale = options.locale ? options.locale : Intl.DateTimeFormat().resolvedOptions().locale;
        var format = functionUtils_1.FunctionUtils.DefaultDateTimeFormat;
        var _functionUtils_1$Func = functionUtils_1.FunctionUtils.determineFormatAndLocale(args, 2, format, locale);
        format = _functionUtils_1$Func.format;
        locale = _functionUtils_1$Func.locale;
        return {
          value: dayjs_1.default(new Date()).locale(locale).utc().format(format),
          error: undefined
        };
      });
    }
    /**
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateOrder(expression, [returnType_1.ReturnType.String, returnType_1.ReturnType.String]);
    }
  }]);
  return UtcNow;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.UtcNow = UtcNow;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"dayjs":697,"dayjs/plugin/utc":700}],162:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Filter on each element and return the new collection of filtered elements which match a specific condition.
 */
var Where = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Where, _expressionEvaluator_);
  var _super = _createSuper(Where);
  /**
   * Initializes a new instance of the [Where](xref:adaptive-expressions.Where) class.
   */
  function Where() {
    (0, _classCallCheck2.default)(this, Where);
    return _super.call(this, expressionType_1.ExpressionType.Where, Where.evaluator, returnType_1.ReturnType.Array, functionUtils_internal_1.InternalFunctionUtils.ValidateLambdaExpression);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Where, null, [{
    key: "evaluator",
    value: function evaluator(expression, state, options) {
      var result;
      var _expression$children$ = expression.children[0].tryEvaluate(state, options),
        instance = _expression$children$.value,
        childrenError = _expression$children$.error;
      var error = childrenError;
      if (!error) {
        var list = functionUtils_internal_1.InternalFunctionUtils.convertToList(instance);
        if (!list) {
          error = "".concat(expression.children[0], " is not a collection or structure object to run Where");
        } else {
          result = [];
          functionUtils_internal_1.InternalFunctionUtils.lambdaEvaluator(expression, state, options, list, function (currentItem, r, e) {
            if (functionUtils_internal_1.InternalFunctionUtils.isLogicTrue(r) && !e) {
              // add if only if it evaluates to true
              result.push(currentItem);
            }
            return false;
          });
          //reconstruct object if instance is object, otherwise, return array result
          if (!Array.isArray(instance)) {
            var objResult = {};
            var _iterator = _createForOfIteratorHelper(result),
              _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var item = _step.value;
                objResult[item.key] = item.value;
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
            result = objResult;
          }
        }
      }
      return {
        value: result,
        error: error
      };
    }
  }]);
  return Where;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Where = Where;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],163:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.object.keys.js");
require("core-js/modules/es.string.trim.js");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var fast_xml_parser_1 = require("fast-xml-parser");
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Return the newline string according to the environment.
 */
var XML = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(XML, _expressionEvaluator_);
  var _super = _createSuper(XML);
  /**
   * Initializes a new instance of the [EOL](xref:adaptive-expressions.EOL) class.
   */
  function XML() {
    (0, _classCallCheck2.default)(this, XML);
    return _super.call(this, expressionType_1.ExpressionType.XML, XML.evaluator(), returnType_1.ReturnType.String, functionUtils_1.FunctionUtils.validateUnary);
  }
  (0, _createClass2.default)(XML, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.applyWithError(function (args) {
        return XML.platformSpecificXML(args);
      });
    }
  }, {
    key: "platformSpecificXML",
    value: function platformSpecificXML(args) {
      var result;
      var error;
      var obj;
      try {
        if (typeof args[0] === 'string') {
          obj = JSON.parse(args[0]);
        } else if ((0, _typeof2.default)(args[0]) === 'object') {
          obj = args[0];
        }
        var parser = new fast_xml_parser_1.XMLBuilder({
          indentBy: '  ',
          format: true
        });
        result = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n".concat(parser.build(obj)).trim();
      } catch (_a) {
        error = "".concat(args[0], " is not a valid json");
      }
      return {
        value: result,
        error: error
      };
    }
  }]);
  return XML;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.XML = XML;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.keys.js":609,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.string.trim.js":634,"fast-xml-parser":701}],164:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.concat.js");
require("core-js/modules/es.array.map.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var returnType_1 = require("../returnType");
/**
 * Return the newline string according to the environment.
 */
var XPath = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(XPath, _expressionEvaluator_);
  var _super = _createSuper(XPath);
  /**
   * Initializes a new instance of the [EOL](xref:adaptive-expressions.EOL) class.
   */
  function XPath() {
    (0, _classCallCheck2.default)(this, XPath);
    return _super.call(this, expressionType_1.ExpressionType.XPath, XPath.evaluator(), returnType_1.ReturnType.Object, XPath.validator);
  }
  (0, _createClass2.default)(XPath, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.applyWithError(function (args) {
        return XPath.platformSpecificXPath(args);
      });
    }
  }, {
    key: "platformSpecificXPath",
    value: function platformSpecificXPath(args) {
      if (typeof window !== 'undefined' || typeof self !== 'undefined') {
        // this is for evaluating in browser environment, however it is not covered by any test currently
        var error;
        var result;
        var xmlDoc;
        try {
          var parser = new DOMParser();
          xmlDoc = parser.parseFromString(args[0], 'text/xml');
        } catch (_a) {
          error = error = "".concat(args[0], " is not valid xml input");
        }
        if (!error) {
          var nodes = xmlDoc.evaluate(args[1], xmlDoc, null, XPathResult.ANY_TYPE, null);
          var node = nodes.iterateNext();
          var evalResult = [];
          while (node) {
            evalResult.push(node.childNodes[0].nodeValue);
            node = nodes.iterateNext();
          }
          if (evalResult.length === 0) {
            error = "There is no matched nodes for the expression ".concat(args[1], " in the xml: ").concat(args[0]);
          } else if (evalResult.length === 1) {
            result = evalResult[0];
          } else {
            result = evalResult;
          }
          return {
            value: result,
            error: error
          };
        }
      } else {
        var _error;
        var _result;
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        var xpath = require('xpath');
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        var _require = require('@xmldom/xmldom'),
          _DOMParser = _require.DOMParser;
        var doc;
        try {
          doc = new _DOMParser().parseFromString(args[0], 'text/xml');
        } catch (_b) {
          _error = "".concat(args[0], " is not valid xml input");
        }
        if (!_error) {
          var _nodes = xpath.select(args[1], doc);
          if (Array.isArray(_nodes)) {
            if (_nodes.length === 0) {
              _error = "There is no matched nodes for the expression ".concat(args[1], " in the xml: ").concat(args[0]);
            } else {
              _result = _nodes.map(function (node) {
                return node.toString();
              });
            }
          } else {
            _result = _nodes;
          }
        }
        return {
          value: _result,
          error: _error
        };
      }
    }
    /**
     * @param expression
     * @private
     */
  }, {
    key: "validator",
    value: function validator(expression) {
      functionUtils_1.FunctionUtils.validateOrder(expression, undefined, returnType_1.ReturnType.Object, returnType_1.ReturnType.String);
    }
  }]);
  return XPath;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.XPath = XPath;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@xmldom/xmldom":260,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.array.map.js":579,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.to-string.js":620,"xpath":757}],165:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("../expressionEvaluator");
var expressionType_1 = require("../expressionType");
var functionUtils_1 = require("../functionUtils");
var functionUtils_internal_1 = require("../functionUtils.internal");
var returnType_1 = require("../returnType");
/**
 * Return the year of the specified timestamp.
 */
var Year = /*#__PURE__*/function (_expressionEvaluator_) {
  (0, _inherits2.default)(Year, _expressionEvaluator_);
  var _super = _createSuper(Year);
  /**
   * Initializes a new instance of the [Year](xref:adaptive-expressions.Year) class.
   */
  function Year() {
    (0, _classCallCheck2.default)(this, Year);
    return _super.call(this, expressionType_1.ExpressionType.Year, Year.evaluator(), returnType_1.ReturnType.Number, functionUtils_1.FunctionUtils.validateUnaryString);
  }
  /**
   * @private
   */
  (0, _createClass2.default)(Year, null, [{
    key: "evaluator",
    value: function evaluator() {
      return functionUtils_1.FunctionUtils.applyWithError(function (args) {
        var error = functionUtils_internal_1.InternalFunctionUtils.verifyISOTimestamp(args[0]);
        if (!error) {
          return {
            value: new Date(args[0]).getUTCFullYear(),
            error: error
          };
        }
        return {
          value: undefined,
          error: error
        };
      }, functionUtils_1.FunctionUtils.verifyString);
    }
  }]);
  return Year;
}(expressionEvaluator_1.ExpressionEvaluator);
exports.Year = Year;

},{"../expressionEvaluator":180,"../expressionType":192,"../functionUtils":196,"../functionUtils.internal":195,"../returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],166:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.array.includes.js");
require("core-js/modules/es.string.includes.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.regexp.constructor.js");
require("core-js/modules/es.regexp.to-string.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
/* eslint-disable security/detect-non-literal-regexp */
/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var antlr4ts_1 = require("antlr4ts");
var lru_cache_1 = __importDefault(require("lru-cache"));
var generated_1 = require("./generated");
var regexErrorListener_1 = require("./regexErrorListener");
// tslint:disable-next-line: completed-docs
/**
 * Convert PCRE regex string to RegExp
 * PCRE ref: http://www.pcre.org/.
 * PCRE antlr g4 file: CommonRegex.g4.
 */
var CommonRegex = /*#__PURE__*/function () {
  function CommonRegex() {
    (0, _classCallCheck2.default)(this, CommonRegex);
  }
  (0, _createClass2.default)(CommonRegex, null, [{
    key: "CreateRegex",
    value:
    /**
     * Create RegExp object from PCRE pattern string.
     *
     * @param pattern PCRE pattern string.
     * @returns RegExp object.
     */
    function CreateRegex(pattern) {
      var result;
      if (pattern && this.regexCache.has(pattern)) {
        result = this.regexCache.get(pattern);
      } else {
        if (!pattern || !this.isCommonRegex(pattern)) {
          throw new Error("'".concat(pattern, "' is not a valid regex."));
        }
        result = this.getRegExpFromString(pattern);
        this.regexCache.set(pattern, result);
      }
      return result;
    }
    /**
     * @private
     */
  }, {
    key: "getRegExpFromString",
    value: function getRegExpFromString(pattern) {
      var flags = ['(?i)', '(?m)', '(?s)'];
      var flag = '';
      flags.forEach(function (e) {
        if (pattern.includes(e)) {
          flag += e.substr(2, 1);
          pattern = pattern.replace(e, '');
        }
      });
      var regexp;
      if (flag) {
        regexp = new RegExp("".concat(pattern), flag);
      } else {
        regexp = new RegExp("".concat(pattern));
      }
      return regexp;
    }
    /**
     * @private
     */
  }, {
    key: "isCommonRegex",
    value: function isCommonRegex(pattern) {
      try {
        this.antlrParse(pattern);
      } catch (_a) {
        return false;
      }
      return true;
    }
    /**
     * @private
     */
  }, {
    key: "antlrParse",
    value: function antlrParse(pattern) {
      var inputStream = new antlr4ts_1.ANTLRInputStream(pattern);
      var lexer = new generated_1.CommonRegexLexer(inputStream);
      lexer.removeErrorListeners();
      var tokenStream = new antlr4ts_1.CommonTokenStream(lexer);
      var parser = new generated_1.CommonRegexParser(tokenStream);
      parser.removeErrorListeners();
      // tslint:disable-next-line: no-use-before-declare
      parser.addErrorListener(regexErrorListener_1.RegexErrorListener.Instance);
      parser.buildParseTree = true;
      return parser.parse();
    }
  }]);
  return CommonRegex;
}();
CommonRegex.regexCache = new lru_cache_1.default(15);
exports.CommonRegex = CommonRegex;

},{"./generated":199,"./regexErrorListener":212,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"antlr4ts":368,"core-js/modules/es.array.includes.js":576,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.constructor.js":617,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.includes.js":625,"core-js/modules/es.string.replace.js":629,"lru-cache":223}],167:[function(require,module,exports){
"use strict";

require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.regexp.constructor.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.array.join.js");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var expression_1 = require("./expression");
var returnType_1 = require("./returnType");
var expressionEvaluator_1 = require("./expressionEvaluator");
var expressionType_1 = require("./expressionType");
var functionUtils_1 = require("./functionUtils");
/**
 * Construct an expression constant.
 */
var Constant = /*#__PURE__*/function (_expression_1$Express) {
  (0, _inherits2.default)(Constant, _expression_1$Express);
  var _super = _createSuper(Constant);
  /**
   * Initializes a new instance of the [Constant](xref:adaptive-expressions.Constant) class.
   * Constructs an expression constant.
   *
   * @param value Constant value.
   */
  function Constant(value) {
    var _this;
    (0, _classCallCheck2.default)(this, Constant);
    _this = _super.call(this, expressionType_1.ExpressionType.Constant, new expressionEvaluator_1.ExpressionEvaluator(expressionType_1.ExpressionType.Constant, function (expression) {
      return {
        value: expression.value,
        error: undefined
      };
    }));
    // original regex: (?<!\\)'
    _this.singleQuotRegex = new RegExp(/'(?!\\)/g);
    _this.value = value;
    return _this;
  }
  /**
   * Constant value.
   *
   * @returns The value.
   */
  (0, _createClass2.default)(Constant, [{
    key: "value",
    get: function get() {
      return this._value;
    }
    /**
     * Sets constant value.
     */,
    set: function set(theValue) {
      this.evaluator.returnType = typeof theValue === 'string' ? returnType_1.ReturnType.String : typeof theValue === 'boolean' ? returnType_1.ReturnType.Boolean : functionUtils_1.FunctionUtils.isNumber(theValue) ? returnType_1.ReturnType.Number : Array.isArray(theValue) ? returnType_1.ReturnType.Array : returnType_1.ReturnType.Object;
      this._value = theValue;
    }
    /**
     * Determines if the current [Expression](xref:adaptive-expressions.Expression) instance is deep equal to another one.
     *
     * @param other The other [Expression](xref:adaptive-expressions.Expression) instance to compare.
     * @returns A boolean value indicating whether the two expressions are deep equal (`true`) or not (`false`).
     */
  }, {
    key: "deepEquals",
    value: function deepEquals(other) {
      var eq;
      if (!other || other.type !== this.type) {
        eq = false;
      } else {
        var otherVal = other.value;
        eq = this.value === otherVal;
      }
      return eq;
    }
    /**
     * Returns a string that represents the current constant object.
     *
     * @returns A string that represents the current constant object.
     */
  }, {
    key: "toString",
    value: function toString() {
      if (this.value === undefined) {
        return 'undefined';
      } else if (this.value === null) {
        return 'null';
      } else if (typeof this.value === 'string') {
        var result = this.value;
        result = result.replace(/\\/g, '\\\\');
        result = this.reverseString(this.reverseString(result).replace(this.singleQuotRegex, function () {
          return "'\\";
        }));
        return "'".concat(result, "'");
      } else if (functionUtils_1.FunctionUtils.isNumber(this.value)) {
        return this.value.toString();
      } else if ((0, _typeof2.default)(this.value) === 'object') {
        return JSON.stringify(this.value);
      }
      return this.value.toString();
    }
    /**
     * @private
     */
  }, {
    key: "reverseString",
    value: function reverseString(str) {
      if (!str) {
        return str;
      }
      return str.split('').reverse().join('');
    }
  }]);
  return Constant;
}(expression_1.Expression);
exports.Constant = Constant;

},{"./expression":179,"./expressionEvaluator":180,"./expressionType":192,"./functionUtils":196,"./returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.join.js":578,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.constructor.js":617,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.replace.js":629}],168:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionProperties_1 = require("../expressionProperties");
/**
 * `array` to json [ArrayExpression](xref:adaptive-expressions.ArrayExpression) converter.
 *
 * @template T The type of the items of the array.
 */
var ArrayExpressionConverter = /*#__PURE__*/function () {
  function ArrayExpressionConverter() {
    (0, _classCallCheck2.default)(this, ArrayExpressionConverter);
  }
  (0, _createClass2.default)(ArrayExpressionConverter, [{
    key: "convert",
    value:
    /**
     * Converts an array into an [ArrayExpression](xref:adaptive-expressions.ArrayExpression).
     *
     * @param value `array` to convert.
     * @returns The [ArrayExpression](xref:adaptive-expressions.ArrayExpression).
     */
    function convert(value) {
      return value instanceof expressionProperties_1.ArrayExpression ? value : new expressionProperties_1.ArrayExpression(value);
    }
  }]);
  return ArrayExpressionConverter;
}();
exports.ArrayExpressionConverter = ArrayExpressionConverter;

},{"../expressionProperties":186,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237}],169:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionProperties_1 = require("../expressionProperties");
/**
 * `any` value to json [BoolExpression](xref:adaptive-expressions.BoolExpression) converter.
 */
var BoolExpressionConverter = /*#__PURE__*/function () {
  function BoolExpressionConverter() {
    (0, _classCallCheck2.default)(this, BoolExpressionConverter);
  }
  (0, _createClass2.default)(BoolExpressionConverter, [{
    key: "convert",
    value:
    /**
     * Converts `any` value into a [BoolExpression](xref:adaptive-expressions.BoolExpression).
     *
     * @param value `any` value to convert.
     * @returns The [BoolExpression](xref:adaptive-expressions.BoolExpression).
     */
    function convert(value) {
      return value instanceof expressionProperties_1.BoolExpression ? value : new expressionProperties_1.BoolExpression(value);
    }
  }]);
  return BoolExpressionConverter;
}();
exports.BoolExpressionConverter = BoolExpressionConverter;

},{"../expressionProperties":186,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237}],170:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.object.keys.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionProperties_1 = require("../expressionProperties");
/**
 * `string` to json [EnumExpression](xref:adaptive-expressions.EnumExpression) converter.
 */
var EnumExpressionConverter = /*#__PURE__*/function () {
  /**
   * Initializes a new instance of the [EnumExpressionConverter](xref:adaptive-expressions.EnumExpressionConverter) class.
   *
   * @param enumValue The enum value of the `string` to convert.
   */
  function EnumExpressionConverter(enumValue) {
    (0, _classCallCheck2.default)(this, EnumExpressionConverter);
    this.enumValue = enumValue;
    this.lowercaseIndex = Object.keys(enumValue || {}).reduce(function (acc, key) {
      acc[key.toLowerCase()] = key;
      return acc;
    }, {});
  }
  /**
   * Converts a `string` into an [EnumExpression](xref:adaptive-expressions.EnumExpression).
   *
   * @param value `string` to convert.
   * @returns The [EnumExpression](xref:adaptive-expressions.EnumExpression).
   */
  (0, _createClass2.default)(EnumExpressionConverter, [{
    key: "convert",
    value: function convert(value) {
      if (value instanceof expressionProperties_1.EnumExpression) {
        return value;
      }
      if (typeof value === 'string') {
        var enumValue = this.enumValue[value];
        if (enumValue === undefined) {
          enumValue = this.enumValue[this.lowercaseIndex[value]];
        }
        if (enumValue !== undefined) {
          return new expressionProperties_1.EnumExpression(enumValue);
        }
        return new expressionProperties_1.EnumExpression("=".concat(value));
      }
      return new expressionProperties_1.EnumExpression(value);
    }
  }]);
  return EnumExpressionConverter;
}();
exports.EnumExpressionConverter = EnumExpressionConverter;

},{"../expressionProperties":186,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"core-js/modules/es.object.keys.js":609,"core-js/modules/es.object.to-string.js":612}],171:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expression_1 = require("../expression");
/**
 * `string` to json [Expression](xref:adaptive-expressions.Expression) converter.
 */
var ExpressionConverter = /*#__PURE__*/function () {
  function ExpressionConverter() {
    (0, _classCallCheck2.default)(this, ExpressionConverter);
  }
  (0, _createClass2.default)(ExpressionConverter, [{
    key: "convert",
    value:
    /**
     * Converts a `string` into an [Expression](xref:adaptive-expressions.Expression).
     *
     * @param value `string` to convert.
     * @returns The [Expression](xref:adaptive-expressions.Expression).
     */
    function convert(value) {
      return value instanceof expression_1.Expression ? value : expression_1.Expression.parse(value);
    }
  }]);
  return ExpressionConverter;
}();
exports.ExpressionConverter = ExpressionConverter;

},{"../expression":179,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237}],172:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
function __export(m) {
  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", {
  value: true
});
__export(require("./arrayExpressionConverter"));
__export(require("./boolExpressionConverter"));
__export(require("./enumExpressionConverter"));
__export(require("./expressionConverter"));
__export(require("./intExpressionConverter"));
__export(require("./numberExpressionConverter"));
__export(require("./objectExpressionConverter"));
__export(require("./stringExpressionConverter"));
__export(require("./valueExpressionConverter"));

},{"./arrayExpressionConverter":168,"./boolExpressionConverter":169,"./enumExpressionConverter":170,"./expressionConverter":171,"./intExpressionConverter":173,"./numberExpressionConverter":174,"./objectExpressionConverter":175,"./stringExpressionConverter":176,"./valueExpressionConverter":177}],173:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionProperties_1 = require("../expressionProperties");
/**
 * `string` or `number` to json [IntExpression](xref:adaptive-expressions.IntExpression) converter.
 */
var IntExpressionConverter = /*#__PURE__*/function () {
  function IntExpressionConverter() {
    (0, _classCallCheck2.default)(this, IntExpressionConverter);
  }
  (0, _createClass2.default)(IntExpressionConverter, [{
    key: "convert",
    value:
    /**
     * Converts a `string` or `number` into an [IntExpression](xref:adaptive-expressions.IntExpression).
     *
     * @param value `string` or `number` to convert.
     * @returns The [IntExpression](xref:adaptive-expressions.IntExpression).
     */
    function convert(value) {
      return value instanceof expressionProperties_1.IntExpression ? value : new expressionProperties_1.IntExpression(value);
    }
  }]);
  return IntExpressionConverter;
}();
exports.IntExpressionConverter = IntExpressionConverter;

},{"../expressionProperties":186,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237}],174:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionProperties_1 = require("../expressionProperties");
/**
 * `string` or `number` to json [NumberExpression](xref:adaptive-expressions.NumberExpression) converter.
 */
var NumberExpressionConverter = /*#__PURE__*/function () {
  function NumberExpressionConverter() {
    (0, _classCallCheck2.default)(this, NumberExpressionConverter);
  }
  (0, _createClass2.default)(NumberExpressionConverter, [{
    key: "convert",
    value:
    /**
     * Converts a `string` or `number` into a [NumberExpression](xref:adaptive-expressions.NumberExpression).
     *
     * @param value `string` or `number` to convert.
     * @returns The [NumberExpression](xref:adaptive-expressions.NumberExpression).
     */
    function convert(value) {
      return value instanceof expressionProperties_1.NumberExpression ? value : new expressionProperties_1.NumberExpression(value);
    }
  }]);
  return NumberExpressionConverter;
}();
exports.NumberExpressionConverter = NumberExpressionConverter;

},{"../expressionProperties":186,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237}],175:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionProperties_1 = require("../expressionProperties");
/**
 * `any` value to json [ObjectExpressionConverter](xref:adaptive-expressions.ObjectExpressionConverter) converter.
 *
 * @template T The type of the value.
 */
// eslint-disable-next-line @typescript-eslint/ban-types
var ObjectExpressionConverter = /*#__PURE__*/function () {
  function ObjectExpressionConverter() {
    (0, _classCallCheck2.default)(this, ObjectExpressionConverter);
  }
  (0, _createClass2.default)(ObjectExpressionConverter, [{
    key: "convert",
    value:
    /**
     * Converts value of type `T` into an [ObjectExpression](xref:adaptive-expressions.ObjectExpression).
     *
     * @param value Value of type `T` to convert.
     * @returns The [ObjectExpression](xref:adaptive-expressions.ObjectExpression).
     */
    function convert(value) {
      return value instanceof expressionProperties_1.ObjectExpression ? value : new expressionProperties_1.ObjectExpression(value);
    }
  }]);
  return ObjectExpressionConverter;
}();
exports.ObjectExpressionConverter = ObjectExpressionConverter;

},{"../expressionProperties":186,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237}],176:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionProperties_1 = require("../expressionProperties");
/**
 * `string` to json [StringExpression](xref:adaptive-expressions.StringExpression) converter.
 */
var StringExpressionConverter = /*#__PURE__*/function () {
  function StringExpressionConverter() {
    (0, _classCallCheck2.default)(this, StringExpressionConverter);
  }
  (0, _createClass2.default)(StringExpressionConverter, [{
    key: "convert",
    value:
    /**
     * Converts a string into an [StringExpression](xref:adaptive-expressions.StringExpression).
     *
     * @param value `string` to convert.
     * @returns The [StringExpression](xref:adaptive-expressions.StringExpression).
     */
    function convert(value) {
      return value instanceof expressionProperties_1.StringExpression ? value : new expressionProperties_1.StringExpression(value);
    }
  }]);
  return StringExpressionConverter;
}();
exports.StringExpressionConverter = StringExpressionConverter;

},{"../expressionProperties":186,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237}],177:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionProperties_1 = require("../expressionProperties");
/**
 * `any` value to json [ValueExpression](xref:adaptive-expressions.ValueExpression) converter.
 */
var ValueExpressionConverter = /*#__PURE__*/function () {
  function ValueExpressionConverter() {
    (0, _classCallCheck2.default)(this, ValueExpressionConverter);
  }
  (0, _createClass2.default)(ValueExpressionConverter, [{
    key: "convert",
    value:
    /**
     * Converts `any` value into a [ValueExpression](xref:adaptive-expressions.ValueExpression).
     *
     * @param value `any` value to convert.
     * @returns The [ValueExpression](xref:adaptive-expressions.ValueExpression).
     */
    function convert(value) {
      return value instanceof expressionProperties_1.ValueExpression ? value : new expressionProperties_1.ValueExpression(value);
    }
  }]);
  return ValueExpressionConverter;
}();
exports.ValueExpressionConverter = ValueExpressionConverter;

},{"../expressionProperties":186,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237}],178:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var State;
(function (State) {
  State[State["None"] = 0] = "None";
  State[State["LowerD1"] = 1] = "LowerD1";
  State[State["LowerD2"] = 2] = "LowerD2";
  State[State["LowerD3"] = 3] = "LowerD3";
  State[State["LowerD4"] = 4] = "LowerD4";
  State[State["LowerF1"] = 5] = "LowerF1";
  State[State["LowerF2"] = 6] = "LowerF2";
  State[State["LowerF3"] = 7] = "LowerF3";
  State[State["CapitalF1"] = 8] = "CapitalF1";
  State[State["CapitalF2"] = 9] = "CapitalF2";
  State[State["CapitalF3"] = 10] = "CapitalF3";
  State[State["LowerG"] = 11] = "LowerG";
  State[State["LowerH1"] = 12] = "LowerH1";
  State[State["LowerH2"] = 13] = "LowerH2";
  State[State["CapitalH1"] = 14] = "CapitalH1";
  State[State["CapitalH2"] = 15] = "CapitalH2";
  State[State["CapitalK"] = 16] = "CapitalK";
  State[State["LowerM1"] = 17] = "LowerM1";
  State[State["LowerM2"] = 18] = "LowerM2";
  State[State["CapitalM1"] = 19] = "CapitalM1";
  State[State["CapitalM2"] = 20] = "CapitalM2";
  State[State["CapitalM3"] = 21] = "CapitalM3";
  State[State["CapitalM4"] = 22] = "CapitalM4";
  State[State["LowerS1"] = 23] = "LowerS1";
  State[State["LowerS2"] = 24] = "LowerS2";
  State[State["LowerT1"] = 25] = "LowerT1";
  State[State["LowerT2"] = 26] = "LowerT2";
  State[State["LowerY1"] = 27] = "LowerY1";
  State[State["LowerY2"] = 28] = "LowerY2";
  State[State["LowerY3"] = 29] = "LowerY3";
  State[State["LowerY4"] = 30] = "LowerY4";
  State[State["LowerZ1"] = 31] = "LowerZ1";
  State[State["LowerZ2"] = 32] = "LowerZ2";
  State[State["LowerZ3"] = 33] = "LowerZ3";
  State[State["InSingleQuoteLiteral"] = 34] = "InSingleQuoteLiteral";
  State[State["InDoubleQuoteLiteral"] = 35] = "InDoubleQuoteLiteral";
  State[State["EscapeSequence"] = 36] = "EscapeSequence";
})(State || (State = {}));
/**
 * Convert a CSharp style datetime format string to a Day.js style datetime format string. Ref: https://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings
 *
 * @param fmtString A CSharp style datetime format string. Ref: https://day.js.org/docs/en/display/format
 * @returns A Momengt.js style datetime format string.
 */
function convertCSharpDateTimeToDayjs(fmtString) {
  var fmtResult = '';
  var fmtState = State.None;
  var lTokenBuffer = '';
  if (fmtString.length === 0) {
    return fmtResult;
  }
  if (fmtString.length === 1) {
    switch (fmtString) {
      case 'R':
      case 'r':
        throw Error('RFC 1123 not supported  in Day.js');
      case 'O':
      case 'o':
        fmtString = 'YYYY-MM-DDTHH:mm:ss.SSS0000Z';
        break;
      case 'U':
        throw new Error('Universal Fulll Format not supported in Day.js');
      case 'u':
        throw new Error('Universal Sortable Format not supported in Day.js');
    }
  }
  var changeState = function changeState(newState) {
    switch (fmtState) {
      case State.LowerD1:
        fmtResult += 'D';
        break;
      case State.LowerD2:
        fmtResult += 'DD';
        break;
      case State.LowerD3:
        fmtResult += 'ddd';
        break;
      case State.LowerD4:
        fmtResult += 'dddd';
        break;
      case State.LowerF1:
      case State.CapitalF1:
        throw Error('S not supported in Day.js');
      case State.LowerF2:
      case State.CapitalF2:
        throw Error('SS not supported in Day.js');
      case State.LowerF3:
      case State.CapitalF3:
        fmtResult += 'SSS';
        break;
      case State.LowerG:
        throw Error('Era not supported in Day.js');
      case State.LowerH1:
        fmtResult += 'h';
        break;
      case State.LowerH2:
        fmtResult += 'hh';
        break;
      case State.CapitalH1:
        fmtResult += 'H';
        break;
      case State.CapitalH2:
        fmtResult += 'HH';
        break;
      case State.LowerM1:
        fmtResult += 'm';
        break;
      case State.LowerM2:
        fmtResult += 'mm';
        break;
      case State.CapitalM1:
        fmtResult += 'M';
        break;
      case State.CapitalM2:
        fmtResult += 'MM';
        break;
      case State.CapitalM3:
        fmtResult += 'MMM';
        break;
      case State.CapitalM4:
        fmtResult += 'MMMM';
        break;
      case State.LowerS1:
        fmtResult += 's';
        break;
      case State.LowerS2:
        fmtResult += 'ss';
        break;
      case State.LowerT1:
      case State.LowerT2:
        fmtResult += 'A';
        break;
      case State.LowerY1:
      case State.LowerY2:
        fmtResult += 'YY';
        break;
      case State.LowerY3:
      case State.LowerY4:
        fmtResult += 'YYYY';
        break;
      case State.LowerZ1:
      case State.LowerZ2:
        fmtResult += 'ZZ';
        break;
      case State.LowerZ3:
        fmtResult += 'Z';
        break;
      case State.InSingleQuoteLiteral:
      case State.InDoubleQuoteLiteral:
      case State.EscapeSequence:
        var _iterator = _createForOfIteratorHelper(lTokenBuffer),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var lCharacter = _step.value;
            fmtResult += lCharacter;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        break;
    }
    lTokenBuffer = '';
    fmtState = newState;
  };
  var _iterator2 = _createForOfIteratorHelper(fmtString),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var character = _step2.value;
      if (fmtState === State.EscapeSequence) {
        lTokenBuffer += character;
        changeState(State.None);
      } else if (fmtState === State.InDoubleQuoteLiteral) {
        if (character === '`') {
          changeState(State.None);
        } else {
          lTokenBuffer += character;
        }
      } else if (fmtState === State.InSingleQuoteLiteral) {
        if (character === "'") {
          changeState(State.None);
        } else {
          lTokenBuffer += character;
        }
      } else {
        switch (character) {
          case 'd':
            switch (fmtState) {
              case State.LowerD1:
                fmtState = State.LowerD2;
                break;
              case State.LowerD2:
                fmtState = State.LowerD3;
                break;
              case State.LowerD3:
                fmtState = State.LowerD4;
                break;
              case State.LowerD4:
                break;
              default:
                changeState(State.LowerD1);
                break;
            }
            break;
          case 'f':
            switch (fmtState) {
              case State.LowerF1:
                fmtState = State.LowerF2;
                break;
              case State.LowerF2:
                fmtState = State.LowerF3;
                break;
              case State.LowerF3:
                break;
              default:
                changeState(State.LowerF1);
                break;
            }
            break;
          case 'F':
            switch (fmtState) {
              case State.CapitalF1:
                fmtState = State.CapitalF2;
                break;
              case State.CapitalF2:
                fmtState = State.CapitalF3;
                break;
              case State.CapitalF3:
                break;
              default:
                changeState(State.CapitalF1);
                break;
            }
            break;
          case 'g':
            switch (fmtState) {
              case State.LowerG:
                break;
              default:
                changeState(State.LowerG);
                break;
            }
            break;
          case 'h':
            switch (fmtState) {
              case State.LowerH1:
                fmtState = State.LowerH2;
                break;
              case State.LowerH2:
                break;
              default:
                changeState(State.LowerH1);
                break;
            }
            break;
          case 'H':
            switch (fmtState) {
              case State.CapitalH1:
                fmtState = State.CapitalH2;
                break;
              case State.CapitalH2:
                break;
              default:
                changeState(State.CapitalH1);
                break;
            }
            break;
          case 'K':
            changeState(State.None);
            fmtResult += 'Z';
            break;
          case 'm':
            switch (fmtState) {
              case State.LowerM1:
                fmtState = State.LowerM2;
                break;
              case State.LowerM2:
                break;
              default:
                changeState(State.LowerM1);
                break;
            }
            break;
          case 'M':
            switch (fmtState) {
              case State.CapitalM1:
                fmtState = State.CapitalM2;
                break;
              case State.CapitalM2:
                fmtState = State.CapitalM3;
                break;
              case State.CapitalM3:
                fmtState = State.CapitalM4;
                break;
              case State.CapitalM4:
                break;
              default:
                changeState(State.CapitalM1);
                break;
            }
            break;
          case 's':
            switch (fmtState) {
              case State.LowerS1:
                fmtState = State.LowerS2;
                break;
              case State.LowerS2:
                break;
              default:
                changeState(State.LowerS1);
                break;
            }
            break;
          case 't':
            switch (fmtState) {
              case State.LowerT1:
                fmtState = State.LowerT2;
                break;
              case State.LowerT2:
                break;
              default:
                changeState(State.LowerT1);
                break;
            }
            break;
          case 'y':
            switch (fmtState) {
              case State.LowerY1:
                fmtState = State.LowerY2;
                break;
              case State.LowerY2:
                fmtState = State.LowerY3;
                break;
              case State.LowerY3:
                fmtState = State.LowerY4;
                break;
              case State.LowerY4:
                break;
              default:
                changeState(State.LowerY1);
                break;
            }
            break;
          case 'z':
            switch (fmtState) {
              case State.LowerZ1:
                fmtState = State.LowerZ2;
                break;
              case State.LowerZ2:
                fmtState = State.LowerZ3;
                break;
              case State.LowerZ3:
                break;
              default:
                changeState(State.LowerZ1);
                break;
            }
            break;
          case ':':
            changeState(State.None);
            fmtResult += ':';
            break;
          case '/':
            changeState(State.None);
            fmtResult += '/';
            break;
          case '`':
            changeState(State.InDoubleQuoteLiteral);
            break;
          case "'":
            changeState(State.InSingleQuoteLiteral);
            break;
          case '%':
            changeState(State.None);
            break;
          case '\\':
            changeState(State.EscapeSequence);
            break;
          default:
            changeState(State.None);
            fmtResult += character;
            break;
        }
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  if (fmtState === State.EscapeSequence || fmtState === State.InDoubleQuoteLiteral || fmtState === State.InSingleQuoteLiteral) {
    throw Error('Invalid Format String');
  }
  changeState(State.None);
  return fmtResult;
}
exports.convertCSharpDateTimeToDayjs = convertCSharpDateTimeToDayjs;

},{"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],179:[function(require,module,exports){
"use strict";

require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.set.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.array.concat.js");
require("core-js/modules/es.array.filter.js");
require("core-js/modules/es.string.starts-with.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.constructor.js");
require("core-js/modules/es.string.replace.js");
var _construct2 = _interopRequireDefault(require("@babel/runtime/helpers/construct"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var constant_1 = require("./constant");
var expressionEvaluator_1 = require("./expressionEvaluator");
var expressionType_1 = require("./expressionType");
var extensions_1 = require("./extensions");
var functionTable_1 = require("./functionTable");
var memory_1 = require("./memory");
var options_1 = require("./options");
var parser_1 = require("./parser");
var returnType_1 = require("./returnType");
/**
 * An expression which can be analyzed or evaluated to produce a value.
 * This provides an open-ended wrapper that supports a number of built-in functions and can also be extended at runtime.
 * It also supports validation of the correctness of an expression and evaluation that should be exception free.
 */
var Expression = /*#__PURE__*/function () {
  /**
   * expression constructor.
   *
   * @param type Type of expression from ExpressionType
   * @param evaluator Information about how to validate and evaluate expression.
   * @param children Child expressions.
   */
  function Expression(type, evaluator) {
    var _this = this;
    (0, _classCallCheck2.default)(this, Expression);
    /**
     * Validate immediate expression.
     *
     * @returns The validated expression.
     */
    this.validate = function () {
      return _this.evaluator.validateExpression(_this);
    };
    for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      children[_key - 2] = arguments[_key];
    }
    if (evaluator) {
      this.evaluator = evaluator;
      this.children = children;
    } else if (type !== undefined) {
      if (!Expression.functions.get(type)) {
        throw Error("".concat(type, " does not have an evaluator, it's not a built-in function or a custom function."));
      }
      this.evaluator = Expression.functions.get(type);
      this.children = children;
    }
  }
  /**
   * Expected result of evaluating the expression.
   *
   * @returns The expected result of evaluating the expression.
   */
  (0, _createClass2.default)(Expression, [{
    key: "returnType",
    get: function get() {
      return this.evaluator.returnType;
    }
    /**
     * Type of expression.
     *
     * @returns The type of the expression.
     */
  }, {
    key: "type",
    get: function get() {
      return this.evaluator.type;
    }
    /**
     * Do a deep equality between expressions.
     *
     * @param other Other expression.
     * @returns True if expressions are the same.
     */
  }, {
    key: "deepEquals",
    value: function deepEquals(other) {
      var eq = false;
      if (other) {
        eq = this.type === other.type;
        if (eq) {
          eq = this.children.length === other.children.length;
          if (this.type === expressionType_1.ExpressionType.And || this.type === expressionType_1.ExpressionType.Or) {
            // And/Or do not depand on order
            for (var i = 0; eq && i < this.children.length; i++) {
              var primary = this.children[0];
              var found = false;
              for (var j = 0; j < this.children.length; j++) {
                if (primary.deepEquals(other.children[j])) {
                  found = true;
                  break;
                }
              }
              eq = found;
            }
          } else {
            for (var _i = 0; eq && _i < this.children.length; _i++) {
              eq = this.children[_i].deepEquals(other.children[_i]);
            }
          }
        }
      }
      return eq;
    }
    /**
     * Return the static reference paths to memory.
     * Return all static paths to memory.  If there is a computed element index, then the path is terminated there,
     * but you might get other paths from the computed part as well.
     *
     * @returns List of the static reference paths.
     */
  }, {
    key: "references",
    value: function references() {
      var _this$referenceWalk = this.referenceWalk(this),
        path = _this$referenceWalk.path,
        refs = _this$referenceWalk.refs;
      if (path !== undefined) {
        refs.add(path);
      }
      return Array.from(refs);
    }
    /**
     * Walking function for identifying static memory references in an expression.
     *
     * @param expression Expression to analyze.
     * @param extension If present, called to override lookup for things like template expansion.
     * @returns Accessor path of expression.
     */
  }, {
    key: "referenceWalk",
    value: function referenceWalk(expression, extension) {
      var path;
      var refs = new Set();
      if (extension === undefined || !extension(expression)) {
        var children = expression.children;
        if (expression.type === expressionType_1.ExpressionType.Accessor) {
          var prop = children[0].value;
          if (children.length === 1) {
            path = prop;
          }
          if (children.length === 2) {
            var _this$referenceWalk2 = this.referenceWalk(children[1], extension);
            path = _this$referenceWalk2.path;
            refs = _this$referenceWalk2.refs;
            if (path !== undefined) {
              path = path.concat('.', prop);
            }
            // if path is null we still keep it null, won't append prop
            // because for example, first(items).x should not return x as refs
          }
        } else if (expression.type === expressionType_1.ExpressionType.Element) {
          var _this$referenceWalk3 = this.referenceWalk(children[0], extension);
          path = _this$referenceWalk3.path;
          refs = _this$referenceWalk3.refs;
          if (path !== undefined) {
            if (children[1] instanceof constant_1.Constant) {
              var cnst = children[1];
              if (cnst.returnType === returnType_1.ReturnType.String) {
                path += ".".concat(cnst.value);
              } else {
                path += "[".concat(cnst.value, "]");
              }
            } else {
              refs.add(path);
            }
          }
          var result = this.referenceWalk(children[1], extension);
          var idxPath = result.path;
          var refs1 = result.refs;
          refs = new Set([].concat((0, _toConsumableArray2.default)(refs), (0, _toConsumableArray2.default)(refs1)));
          if (idxPath !== undefined) {
            refs.add(idxPath);
          }
        } else if (expression.type === expressionType_1.ExpressionType.Foreach || expression.type === expressionType_1.ExpressionType.Where || expression.type === expressionType_1.ExpressionType.Select) {
          var _result = this.referenceWalk(children[0], extension);
          var child0Path = _result.path;
          var refs0 = _result.refs;
          if (child0Path !== undefined) {
            refs0.add(child0Path);
          }
          _result = this.referenceWalk(children[2], extension);
          var child2Path = _result.path;
          var refs2 = _result.refs;
          if (child2Path !== undefined) {
            refs2.add(child2Path);
          }
          var iteratorName = children[1].children[0].value;
          var nonLocalRefs2 = Array.from(refs2).filter(function (x) {
            return !(x === iteratorName || x.startsWith(iteratorName + '.') || x.startsWith(iteratorName + '['));
          });
          refs = new Set([].concat((0, _toConsumableArray2.default)(refs), (0, _toConsumableArray2.default)(refs0), (0, _toConsumableArray2.default)(nonLocalRefs2)));
        } else {
          var _iterator = _createForOfIteratorHelper(expression.children),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var child = _step.value;
              var _result2 = this.referenceWalk(child, extension);
              var childPath = _result2.path;
              var _refs = _result2.refs;
              refs = new Set([].concat((0, _toConsumableArray2.default)(refs), (0, _toConsumableArray2.default)(_refs)));
              if (childPath !== undefined) {
                refs.add(childPath);
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      }
      return {
        path: path,
        refs: refs
      };
    }
    /**
     * Parse an expression string into an [Expression](xref:adaptive-expressions.Expression) object.
     *
     * @param expression Expression string.
     * @param lookup Optional. [EvaluatorLookup](xref:adaptive-expressions.EvaluatorLookup) function lookup when parsing the expression. Default is [Expression.lookup](xref:adaptive-expressions.Expression.lookup) which uses [Expression.functions](xref:adaptive-expressions.Expression.functions) table.
     * @returns The expression object.
     */
  }, {
    key: "validateTree",
    value:
    /**
     * Recursively validate the expression tree.
     */
    function validateTree() {
      this.validate();
      var _iterator2 = _createForOfIteratorHelper(this.children),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var child = _step2.value;
          child.validateTree();
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
    /**
     * Evaluate the expression.
     *
     * @param state Global state to evaluate accessor expressions against. Can be Dictionary, otherwise reflection is used to access property and then indexer.
     * @param options Options used in the evaluation.
     * @returns Computed value and an error string. If the string is non-null, then there was an evaluation error.
     */
  }, {
    key: "tryEvaluate",
    value: function tryEvaluate(state) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      if (!extensions_1.Extensions.isMemoryInterface(state)) {
        state = memory_1.SimpleObjectMemory.wrap(state);
      }
      options = options ? options : new options_1.Options();
      return this.evaluator.tryEvaluate(this, state, options);
    }
    /**
     * Returns a string that represents the current [Expression](xref:adaptive-expressions.Expression) object.
     *
     * @returns A string that represents the current [Expression](xref:adaptive-expressions.Expression) object.
     */
  }, {
    key: "toString",
    value: function toString() {
      var builder = '';
      var valid = false;
      // Special support for memory paths
      if (this.type === expressionType_1.ExpressionType.Accessor && this.children.length >= 1) {
        if (this.children[0] instanceof constant_1.Constant) {
          var prop = this.children[0].value;
          if (typeof prop === 'string') {
            if (this.children.length === 1) {
              valid = true;
              builder = builder.concat(prop);
            } else if (this.children.length === 2) {
              valid = true;
              builder = builder.concat(this.children[1].toString(), '.', prop);
            }
          }
        }
      } else if (this.type === expressionType_1.ExpressionType.Element && this.children.length === 2) {
        valid = true;
        builder = builder.concat(this.children[0].toString(), '[', this.children[1].toString(), ']');
      }
      if (!valid) {
        var infix = this.type.length > 0 && !new RegExp(/[a-z]/i).test(this.type[0]) && this.children.length >= 2;
        if (!infix) {
          builder = builder.concat(this.type);
        }
        builder = builder.concat('(');
        var first = true;
        var _iterator3 = _createForOfIteratorHelper(this.children),
          _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var child = _step3.value;
            if (first) {
              first = false;
            } else {
              if (infix) {
                builder = builder.concat(' ', this.type, ' ');
              } else {
                builder = builder.concat(', ');
              }
            }
            builder = builder.concat(child.toString());
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        builder = builder.concat(')');
      }
      return builder;
    }
  }], [{
    key: "parse",
    value: function parse(expression, lookup) {
      return new parser_1.ExpressionParser(lookup || Expression.lookup).parse(expression.replace(/^=/, ''));
    }
    /**
     * Lookup an [ExpressionEvaluator](xref:adaptive-expressions.ExpressionEvaluator) function by name.
     *
     * @param functionName Name of function to lookup.
     * @returns An [ExpressionEvaluator](xref:adaptive-expressions.ExpressionEvaluator) corresponding to the function name.
     */
  }, {
    key: "lookup",
    value: function lookup(functionName) {
      var exprEvaluator = Expression.functions.get(functionName);
      if (!exprEvaluator) {
        return undefined;
      }
      return exprEvaluator;
    }
    /**
     * Make an expression and validate it.
     *
     * @param type Type of expression from ExpressionType.
     * @param evaluator Information about how to validate and evaluate expression.
     * @param children Child expressions.
     * @returns The new expression.
     */
  }, {
    key: "makeExpression",
    value: function makeExpression(type, evaluator) {
      for (var _len2 = arguments.length, children = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        children[_key2 - 2] = arguments[_key2];
      }
      var expr = (0, _construct2.default)(Expression, [type, evaluator].concat(children));
      expr.validate();
      return expr;
    }
    /**
     * Construct an expression from a EvaluateExpressionDelegate
     *
     * @param func Function to create an expression from.
     * @returns The new expression.
     */
  }, {
    key: "lambaExpression",
    value: function lambaExpression(func) {
      return new Expression(expressionType_1.ExpressionType.Lambda, new expressionEvaluator_1.ExpressionEvaluator(expressionType_1.ExpressionType.Lambda, func));
    }
    /**
     * Construct an expression from a lamba expression over the state.
     * Exceptions will be caught and surfaced as an error string.
     *
     * @param func ambda expression to evaluate.
     * @returns New expression.
     */
  }, {
    key: "lambda",
    value: function lambda(func) {
      return new Expression(expressionType_1.ExpressionType.Lambda, new expressionEvaluator_1.ExpressionEvaluator(expressionType_1.ExpressionType.Lambda, function (_expression, state, _) {
        var value;
        var error;
        try {
          value = func(state);
        } catch (funcError) {
          error = funcError;
        }
        return {
          value: value,
          error: error
        };
      }));
    }
    /**
     * Construct and validate an Set a property expression to a value expression.
     *
     * @param property property expression.
     * @param value value expression.
     * @returns New expression.
     */
  }, {
    key: "setPathToValue",
    value: function setPathToValue(property, value) {
      if (value instanceof Expression) {
        return Expression.makeExpression(expressionType_1.ExpressionType.SetPathToValue, undefined, property, value);
      } else {
        return Expression.makeExpression(expressionType_1.ExpressionType.SetPathToValue, undefined, property, new constant_1.Constant(value));
      }
    }
    /**
     * Construct and validate an Equals expression.
     *
     * @param children Child clauses.
     * @returns New expression.
     */
  }, {
    key: "equalsExpression",
    value: function equalsExpression() {
      for (var _len3 = arguments.length, children = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        children[_key3] = arguments[_key3];
      }
      return Expression.makeExpression.apply(Expression, [expressionType_1.ExpressionType.Equal, undefined].concat(children));
    }
    /**
     * Construct and validate an And expression.
     *
     * @param children Child clauses.
     * @returns New expression.
     */
  }, {
    key: "andExpression",
    value: function andExpression() {
      for (var _len4 = arguments.length, children = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        children[_key4] = arguments[_key4];
      }
      if (children.length > 1) {
        return Expression.makeExpression.apply(Expression, [expressionType_1.ExpressionType.And, undefined].concat(children));
      } else {
        return children[0];
      }
    }
    /**
     * Construct and validate an Or expression.
     *
     * @param children Child clauses.
     * @returns New expression.
     */
  }, {
    key: "orExpression",
    value: function orExpression() {
      for (var _len5 = arguments.length, children = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        children[_key5] = arguments[_key5];
      }
      if (children.length > 1) {
        return Expression.makeExpression.apply(Expression, [expressionType_1.ExpressionType.Or, undefined].concat(children));
      } else {
        return children[0];
      }
    }
    /**
     * Construct and validate an Not expression.
     *
     * @param child Child clauses.
     * @returns New expression.
     */
  }, {
    key: "notExpression",
    value: function notExpression(child) {
      return Expression.makeExpression(expressionType_1.ExpressionType.Not, undefined, child);
    }
  }]);
  return Expression;
}();
/**
 * Dictionary of function => ExpressionEvaluator.
 * This is all available functions, you can add custom functions to it, but you cannot
 * replace builtin functions.  If you clear the dictionary, it will be reset to the built in functions.
 */
Expression.functions = new functionTable_1.FunctionTable();
exports.Expression = Expression;

},{"./constant":167,"./expressionEvaluator":180,"./expressionType":192,"./extensions":193,"./functionTable":194,"./memory":201,"./options":204,"./parser":209,"./returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/construct":231,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/toConsumableArray":249,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.array.filter.js":572,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.constructor.js":617,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.set.js":621,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.string.replace.js":629,"core-js/modules/es.string.starts-with.js":632,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],180:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
Object.defineProperty(exports, "__esModule", {
  value: true
});
var returnType_1 = require("./returnType");
/**
 * Information on how to evaluate an expression.
 */
var ExpressionEvaluator = /*#__PURE__*/function () {
  /**
   * Initializes a new instance of the <see cref="ExpressionEvaluator"/> class.
   *
   * @param type Expression type.
   * @param evaluator Delegate to evaluate an expression.
   * @param returnType Type expected from evaluation.
   * @param validator Static validation of expression.
   */
  function ExpressionEvaluator(type, evaluator) {
    var _this = this;
    var returnType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : returnType_1.ReturnType.Object;
    var validator = arguments.length > 3 ? arguments[3] : undefined;
    (0, _classCallCheck2.default)(this, ExpressionEvaluator);
    /**
     * Evaluate an expression.
     *
     * @param expression Expression to evaluate.
     * @param state Global state information.
     * @param options Options used in the evaluation.
     * @returns The value and error string that is non-null if there is an error.
     */
    this.tryEvaluate = function (expression, state, options) {
      return _this._evaluator(expression, state, options);
    };
    /**
     * Validate an expression.
     *
     * @param expression Expression to validate.
     * @returns The validated expression.
     */
    this.validateExpression = function (expression) {
      return _this._validator(expression);
    };
    this.type = type;
    this._evaluator = evaluator;
    this.returnType = returnType;
    this._validator = validator || function (_expr) {
      //noop
    };
  }
  /**
   * Gets the evaluator that is a negation of this one.
   *
   * @returns The evaluator that is a negation of this one.
   */
  (0, _createClass2.default)(ExpressionEvaluator, [{
    key: "negation",
    get: function get() {
      return this._negation;
    }
    /**
     * Sets the evaluator that is a negation of this one.
     */,
    set: function set(value) {
      value._negation = this;
      this._negation = value;
    }
  }]);
  return ExpressionEvaluator;
}();
exports.ExpressionEvaluator = ExpressionEvaluator;

},{"./returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237}],181:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.map.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/web.dom-collections.for-each.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result["default"] = mod;
  return result;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var BuiltinFunctions = __importStar(require("./builtinFunctions"));
var expressionType_1 = require("./expressionType");
/**
 *  <summary>
 *  Definition of default built-in functions for expressions.
 *  </summary>
 *  <remarks>
 *  These functions are largely from WDL https://docs.microsoft.com/en-us/azure/logic-apps/workflow-definition-language-functions-reference
 *  with a few extensions like infix operators for math, logic and comparisons.
 *  This class also has some methods that are useful to use when defining custom functions.
 *  You can always construct a <see cref="ExpressionEvaluator"/> directly which gives the maximum amount of control over validation and evaluation.
 *  Validators are static checkers that should throw an exception if something is not valid statically.
 *  Evaluators are called to evaluate an expression and should try not to throw.
 *  There are some evaluators in this file that take in a verifier that is called at runtime to verify arguments are proper.
 *  </remarks>
 */
var ExpressionFunctions = /*#__PURE__*/function () {
  function ExpressionFunctions() {
    (0, _classCallCheck2.default)(this, ExpressionFunctions);
  }
  (0, _createClass2.default)(ExpressionFunctions, null, [{
    key: "getStandardFunctions",
    value:
    /**
     * @private
     */
    function getStandardFunctions() {
      var functions = [new BuiltinFunctions.Abs(), new BuiltinFunctions.Accessor(), new BuiltinFunctions.Add(), new BuiltinFunctions.AddDays(), new BuiltinFunctions.AddHours(), new BuiltinFunctions.AddMinutes(), new BuiltinFunctions.AddOrdinal(), new BuiltinFunctions.AddProperty(), new BuiltinFunctions.AddSeconds(), new BuiltinFunctions.AddToTime(), new BuiltinFunctions.All(), new BuiltinFunctions.And(), new BuiltinFunctions.Any(), new BuiltinFunctions.Average(), new BuiltinFunctions.Base64(), new BuiltinFunctions.Base64ToBinary(), new BuiltinFunctions.Base64ToString(), new BuiltinFunctions.Binary(), new BuiltinFunctions.Bool(), new BuiltinFunctions.Ceiling(), new BuiltinFunctions.Coalesce(), new BuiltinFunctions.Concat(), new BuiltinFunctions.Contains(), new BuiltinFunctions.ConvertFromUTC(), new BuiltinFunctions.ConvertToUTC(), new BuiltinFunctions.Count(), new BuiltinFunctions.CountWord(), new BuiltinFunctions.CreateArray(), new BuiltinFunctions.DataUri(), new BuiltinFunctions.DataUriToBinary(), new BuiltinFunctions.DataUriToString(), new BuiltinFunctions.DateFunc(), new BuiltinFunctions.DateReadBack(), new BuiltinFunctions.DateTimeDiff(), new BuiltinFunctions.DayOfMonth(), new BuiltinFunctions.DayOfWeek(), new BuiltinFunctions.DayOfYear(), new BuiltinFunctions.Divide(), new BuiltinFunctions.Element(), new BuiltinFunctions.Empty(), new BuiltinFunctions.EndsWith(), new BuiltinFunctions.EOL(), new BuiltinFunctions.Equal(), new BuiltinFunctions.Exists(), new BuiltinFunctions.Flatten(), new BuiltinFunctions.First(), new BuiltinFunctions.Float(), new BuiltinFunctions.Floor(), new BuiltinFunctions.Foreach(), new BuiltinFunctions.FormatDateTime(), new BuiltinFunctions.FormatEpoch(), new BuiltinFunctions.FormatNumber(), new BuiltinFunctions.FormatTicks(), new BuiltinFunctions.GetFutureTime(), new BuiltinFunctions.GetNextViableDate(), new BuiltinFunctions.GetNextViableTime(), new BuiltinFunctions.GetPastTime(), new BuiltinFunctions.GetPreviousViableDate(), new BuiltinFunctions.GetPreviousViableTime(), new BuiltinFunctions.GetPastTime(), new BuiltinFunctions.GetProperty(), new BuiltinFunctions.GetTimeOfDay(), new BuiltinFunctions.GreaterThan(), new BuiltinFunctions.GreaterThanOrEqual(), new BuiltinFunctions.If(), new BuiltinFunctions.Ignore(), new BuiltinFunctions.IndexOf(), new BuiltinFunctions.IndicesAndValues(), new BuiltinFunctions.Int(), new BuiltinFunctions.Intersection(), new BuiltinFunctions.IsArray(), new BuiltinFunctions.IsBoolean(), new BuiltinFunctions.IsDate(), new BuiltinFunctions.IsDateRange(), new BuiltinFunctions.IsDateTime(), new BuiltinFunctions.IsDefinite(), new BuiltinFunctions.IsDuration(), new BuiltinFunctions.IsFloat(), new BuiltinFunctions.IsInteger(), new BuiltinFunctions.IsMatch(), new BuiltinFunctions.IsObject(), new BuiltinFunctions.IsPresent(), new BuiltinFunctions.IsString(), new BuiltinFunctions.IsTime(), new BuiltinFunctions.IsTimeRange(), new BuiltinFunctions.Join(), new BuiltinFunctions.JPath(), new BuiltinFunctions.Json(), new BuiltinFunctions.JsonStringify(), new BuiltinFunctions.Last(), new BuiltinFunctions.LastIndexOf(), new BuiltinFunctions.Length(), new BuiltinFunctions.LessThan(), new BuiltinFunctions.LessThanOrEqual(), new BuiltinFunctions.Max(), new BuiltinFunctions.Merge(), new BuiltinFunctions.Min(), new BuiltinFunctions.Mod(), new BuiltinFunctions.Month(), new BuiltinFunctions.Multiply(), new BuiltinFunctions.NewGuid(), new BuiltinFunctions.Not(), new BuiltinFunctions.NotEqual(), new BuiltinFunctions.Optional(), new BuiltinFunctions.Or(), new BuiltinFunctions.Power(), new BuiltinFunctions.Rand(), new BuiltinFunctions.Range(), new BuiltinFunctions.RemoveProperty(), new BuiltinFunctions.Replace(), new BuiltinFunctions.ReplaceIgnoreCase(), new BuiltinFunctions.Reverse(), new BuiltinFunctions.Round(), new BuiltinFunctions.Select(), new BuiltinFunctions.SentenceCase(), new BuiltinFunctions.SetPathToValue(), new BuiltinFunctions.SetProperty(), new BuiltinFunctions.Skip(), new BuiltinFunctions.SortBy(), new BuiltinFunctions.SortByDescending(), new BuiltinFunctions.Split(), new BuiltinFunctions.Sqrt(), new BuiltinFunctions.StartOfDay(), new BuiltinFunctions.StartOfHour(), new BuiltinFunctions.StartOfMonth(), new BuiltinFunctions.StartsWith(), new BuiltinFunctions.String(), new BuiltinFunctions.StringOrValue(), new BuiltinFunctions.SubArray(), new BuiltinFunctions.Substring(), new BuiltinFunctions.Subtract(), new BuiltinFunctions.SubtractFromTime(), new BuiltinFunctions.Sum(), new BuiltinFunctions.Take(), new BuiltinFunctions.Ticks(), new BuiltinFunctions.TicksToDays(), new BuiltinFunctions.TicksToHours(), new BuiltinFunctions.TicksToMinutes(), new BuiltinFunctions.TimexResolve(), new BuiltinFunctions.TitleCase(), new BuiltinFunctions.ToLower(), new BuiltinFunctions.ToUpper(), new BuiltinFunctions.Trim(), new BuiltinFunctions.Union(), new BuiltinFunctions.Unique(), new BuiltinFunctions.UriComponent(), new BuiltinFunctions.UriComponentToString(), new BuiltinFunctions.UriHost(), new BuiltinFunctions.UriPath(), new BuiltinFunctions.UriPathAndQuery(), new BuiltinFunctions.UriPort(), new BuiltinFunctions.UriQuery(), new BuiltinFunctions.UriScheme(), new BuiltinFunctions.UtcNow(), new BuiltinFunctions.Where(), new BuiltinFunctions.XML(), new BuiltinFunctions.XPath(), new BuiltinFunctions.Year()];
      var lookup = new Map();
      functions.forEach(function (func) {
        lookup.set(func.type, func);
      });
      // Attach negations
      lookup.get(expressionType_1.ExpressionType.LessThan).negation = lookup.get(expressionType_1.ExpressionType.GreaterThanOrEqual);
      lookup.get(expressionType_1.ExpressionType.LessThanOrEqual).negation = lookup.get(expressionType_1.ExpressionType.GreaterThan);
      lookup.get(expressionType_1.ExpressionType.Equal).negation = lookup.get(expressionType_1.ExpressionType.NotEqual);
      // Math aliases
      lookup.set('add', lookup.get(expressionType_1.ExpressionType.Add)); // more than 1 param
      lookup.set('mul', lookup.get(expressionType_1.ExpressionType.Multiply)); // more than 1 param
      lookup.set('div', lookup.get(expressionType_1.ExpressionType.Divide)); // more than 1 param
      lookup.set('sub', lookup.get(expressionType_1.ExpressionType.Subtract)); // more than 1 param
      lookup.set('exp', lookup.get(expressionType_1.ExpressionType.Power)); // more than 1 param
      lookup.set('mod', lookup.get(expressionType_1.ExpressionType.Mod));
      // Comparison aliases
      lookup.set('and', lookup.get(expressionType_1.ExpressionType.And));
      lookup.set('equals', lookup.get(expressionType_1.ExpressionType.Equal));
      lookup.set('greater', lookup.get(expressionType_1.ExpressionType.GreaterThan));
      lookup.set('greaterOrEquals', lookup.get(expressionType_1.ExpressionType.GreaterThanOrEqual));
      lookup.set('less', lookup.get(expressionType_1.ExpressionType.LessThan));
      lookup.set('lessOrEquals', lookup.get(expressionType_1.ExpressionType.LessThanOrEqual));
      lookup.set('not', lookup.get(expressionType_1.ExpressionType.Not));
      lookup.set('or', lookup.get(expressionType_1.ExpressionType.Or));
      lookup.set('&', lookup.get(expressionType_1.ExpressionType.Concat));
      lookup.set('??', lookup.get(expressionType_1.ExpressionType.Coalesce));
      return lookup;
    }
  }]);
  return ExpressionFunctions;
}();
/**
 * Read only Dictionary of built in functions.
 */
ExpressionFunctions.standardFunctions = ExpressionFunctions.getStandardFunctions();
exports.ExpressionFunctions = ExpressionFunctions;

},{"./builtinFunctions":68,"./expressionType":192,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.map.js":587,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.string.iterator.js":626,"core-js/modules/web.dom-collections.for-each.js":676,"core-js/modules/web.dom-collections.iterator.js":677}],182:[function(require,module,exports){
"use strict";

require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var expressionProperty_1 = require("./expressionProperty");
var expression_1 = require("../expression");
/**
 * Represents a property which is either a value of array of T or a string expression to bind to a
 * array of T.
 *
 * @remarks
 * String values are always interpreted as an expression, whether it has '=' prefix or not.
 * @param T Type of object in the array.
 */
var ArrayExpression = /*#__PURE__*/function (_expressionProperty_) {
  (0, _inherits2.default)(ArrayExpression, _expressionProperty_);
  var _super = _createSuper(ArrayExpression);
  /**
   * Initializes a new instance of the [ArrayExpression<T>](xref:adaptive-expressions.ArrayExpression) class.
   *
   * @param value Value of `T[]` or a `string` expression to bind to a `T[]`.
   */
  function ArrayExpression(value) {
    (0, _classCallCheck2.default)(this, ArrayExpression);
    return _super.call(this, value);
  }
  /**
   * Set an array value.
   *
   * @param value Value to set.
   */
  (0, _createClass2.default)(ArrayExpression, [{
    key: "setValue",
    value: function setValue(value) {
      if (value != null && !Array.isArray(value) && typeof value !== 'string' && !(value instanceof expression_1.Expression)) {
        throw new Error('ArrayExpression accepts string, array or Expression as the value.');
      }
      (0, _get2.default)((0, _getPrototypeOf2.default)(ArrayExpression.prototype), "setValue", this).call(this, value);
    }
  }]);
  return ArrayExpression;
}(expressionProperty_1.ExpressionProperty);
exports.ArrayExpression = ArrayExpression;

},{"../expression":179,"./expressionProperty":185,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/get":234,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],183:[function(require,module,exports){
"use strict";

require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var expressionProperty_1 = require("./expressionProperty");
var expression_1 = require("../expression");
/**
 * Represents a property which is either a boolean or a string expression which resolves to a boolean.
 *
 * @remarks
 * String values are always interpreted as an expression, whether it has '=' prefix or not.
 */
var BoolExpression = /*#__PURE__*/function (_expressionProperty_) {
  (0, _inherits2.default)(BoolExpression, _expressionProperty_);
  var _super = _createSuper(BoolExpression);
  /**
   * Initializes a new instance of the [BoolExpression](xref:adaptive-expressions.BoolExpression) class.
   *
   * @param value A `boolean` or a `string` expression which resolves to a `boolean`.
   */
  function BoolExpression(value) {
    (0, _classCallCheck2.default)(this, BoolExpression);
    return _super.call(this, value, false);
  }
  /**
   * Set a boolean value.
   *
   * @param value Value to set.
   */
  (0, _createClass2.default)(BoolExpression, [{
    key: "setValue",
    value: function setValue(value) {
      if (value != null && typeof value !== 'boolean' && typeof value !== 'string' && !(value instanceof expression_1.Expression)) {
        throw new Error('BoolExpression accepts string, boolean or Expression as the value.');
      }
      (0, _get2.default)((0, _getPrototypeOf2.default)(BoolExpression.prototype), "setValue", this).call(this, value);
    }
  }]);
  return BoolExpression;
}(expressionProperty_1.ExpressionProperty);
exports.BoolExpression = BoolExpression;

},{"../expression":179,"./expressionProperty":185,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/get":234,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],184:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.string.starts-with.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionProperty_1 = require("./expressionProperty");
/**
 * EnumExpression - represents a property which is either an enum of T or a string expression which resolves to an enum.
 *
 * @remarks
 * String values are always interpreted as an expression whether it has '=' prefix or not, as string values cannot be parsed to enum values.
 */
var EnumExpression = /*#__PURE__*/function (_expressionProperty_) {
  (0, _inherits2.default)(EnumExpression, _expressionProperty_);
  var _super = _createSuper(EnumExpression);
  /**
   * Initializes a new instance of the [EnumExpression<T>](xref:adaptive-expressions.EnumExpression) class.
   *
   * @param value An enum of `T` or a `string` expression which resolves to an `enum`.
   */
  function EnumExpression(value) {
    (0, _classCallCheck2.default)(this, EnumExpression);
    return _super.call(this, value);
  }
  /**
   * Set an enum value.
   *
   * @param value value to set.
   */
  (0, _createClass2.default)(EnumExpression, [{
    key: "setValue",
    value: function setValue(value) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(EnumExpression.prototype), "setValue", this).call(this, undefined);
      if (typeof value == 'string' && !value.startsWith('=')) {
        // Initialize value
        this.value = value;
        return;
      }
      (0, _get2.default)((0, _getPrototypeOf2.default)(EnumExpression.prototype), "setValue", this).call(this, value);
    }
  }]);
  return EnumExpression;
}(expressionProperty_1.ExpressionProperty);
exports.EnumExpression = EnumExpression;

},{"./expressionProperty":185,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/get":234,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.string.starts-with.js":632}],185:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var expression_1 = require("../expression");
/**
 * Base class which defines an Expression or value for a property.
 *
 * @param T Type of value of the expression property.
 */
var ExpressionProperty = /*#__PURE__*/function () {
  /**
   * Initializes a new instance of the [ExpressionProperty<T>](xref:adaptive-expressions.ExpressionProperty) class.
   *
   * @param value Optional. Raw value of the expression property.
   * @param defaultValue Optional. Default value for the property.
   */
  function ExpressionProperty(value, defaultValue) {
    (0, _classCallCheck2.default)(this, ExpressionProperty);
    this.defaultValue = defaultValue;
    this.setValue(value);
  }
  /**
   * Convert an expression property to string.
   *
   * @returns The converted string.
   */
  (0, _createClass2.default)(ExpressionProperty, [{
    key: "toString",
    value: function toString() {
      if (this.expressionText) {
        return "=".concat(this.expressionText.replace(/^=/, ''));
      }
      return this.value ? this.value.toString() : '';
    }
    /**
     * This will return the existing expression if the value is non-complex type.
     *
     * @returns The existing expression if the value is non-complex type.
     */
  }, {
    key: "toExpression",
    value: function toExpression() {
      if (this.expression) {
        return this.expression;
      }
      if (this.expressionText) {
        this.expression = expression_1.Expression.parse(this.expressionText.replace(/^=/, ''));
        return this.expression;
      }
      // Generate expression
      switch ((0, _typeof2.default)(this.value)) {
        case 'string':
        case 'number':
        case 'boolean':
          this.expression = expression_1.Expression.parse(this.value.toString());
          break;
        default:
          if (this.value === undefined) {
            this.expression = expression_1.Expression.parse('undefined');
          } else if (this.value === null) {
            this.expression = expression_1.Expression.parse('null');
          } else {
            this.expression = expression_1.Expression.parse("json(".concat(JSON.stringify(this.value), ")"));
          }
          break;
      }
      return this.expression;
    }
    /**
     * Get the value.
     *
     * @remarks
     * An error will be thrown if value is an invalid expression.
     * @param data Data to use for expression binding.
     * @returns The value.
     */
    // eslint-disable-next-line @typescript-eslint/ban-types
  }, {
    key: "getValue",
    value: function getValue(data) {
      var _this$tryGetValue = this.tryGetValue(data),
        value = _this$tryGetValue.value,
        error = _this$tryGetValue.error;
      if (error) {
        throw error;
      }
      return value;
    }
    /**
     * Try to Get the value.
     *
     * @param data Data to use for expression binding.
     * @returns the value or an error.
     */
    // eslint-disable-next-line @typescript-eslint/ban-types
  }, {
    key: "tryGetValue",
    value: function tryGetValue(data) {
      if (!this.expression && this.expressionText) {
        try {
          this.expression = expression_1.Expression.parse(this.expressionText.replace(/^=/, ''));
        } catch (error) {
          return {
            value: undefined,
            error: error.message
          };
        }
      }
      if (this.expression) {
        return this.expression.tryEvaluate(data);
      }
      return {
        value: this.value,
        error: undefined
      };
    }
    /**
     * Set the value.
     *
     * @param value Value to set.
     */
  }, {
    key: "setValue",
    value: function setValue(value) {
      this.value = this.defaultValue;
      this.expression = undefined;
      this.expressionText = undefined;
      if (typeof value == 'string') {
        this.expressionText = value.replace(/^=/, '');
      } else if (value instanceof expression_1.Expression) {
        this.expression = value;
        this.expressionText = value.toString();
      } else if (value !== undefined) {
        this.value = value;
      }
    }
  }]);
  return ExpressionProperty;
}();
exports.ExpressionProperty = ExpressionProperty;

},{"../expression":179,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.replace.js":629}],186:[function(require,module,exports){
"use strict";

function __export(m) {
  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
__export(require("./arrayExpression"));
__export(require("./boolExpression"));
__export(require("./enumExpression"));
__export(require("./expressionProperty"));
__export(require("./intExpression"));
__export(require("./numberExpression"));
__export(require("./objectExpression"));
__export(require("./stringExpression"));
__export(require("./valueExpression"));

},{"./arrayExpression":182,"./boolExpression":183,"./enumExpression":184,"./expressionProperty":185,"./intExpression":187,"./numberExpression":188,"./objectExpression":189,"./stringExpression":190,"./valueExpression":191}],187:[function(require,module,exports){
"use strict";

require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.math.trunc.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var expressionProperty_1 = require("./expressionProperty");
var expression_1 = require("../expression");
var functionUtils_1 = require("../functionUtils");
/**
 * Represents a property which is either a int or a string expression which resolves to a int.
 *
 * @remarks
 * String values are always interpreted as an expression, whether it has '=' prefix or not.
 */
var IntExpression = /*#__PURE__*/function (_expressionProperty_) {
  (0, _inherits2.default)(IntExpression, _expressionProperty_);
  var _super = _createSuper(IntExpression);
  /**
   * Initializes a new instance of the [IntExpression](xref:adaptive-expressions.IntExpression) class.
   *
   * @param value An int `number` or `string` expression which resolves to an int `number`.
   */
  function IntExpression(value) {
    (0, _classCallCheck2.default)(this, IntExpression);
    return _super.call(this, value, 0);
  }
  /**
   * Try to get the value.
   *
   * @param data Data to use for expression binding.
   * @returns Value of int number
   */
  // eslint-disable-next-line @typescript-eslint/ban-types
  (0, _createClass2.default)(IntExpression, [{
    key: "tryGetValue",
    value: function tryGetValue(data) {
      var result = (0, _get2.default)((0, _getPrototypeOf2.default)(IntExpression.prototype), "tryGetValue", this).call(this, data);
      if (functionUtils_1.FunctionUtils.isNumber(result.value)) {
        // Ensure returned value is an int.
        result.value = Math.trunc(result.value);
      }
      return result;
    }
    /**
     * Set an integer value.
     *
     * @param value Value to set.
     */
  }, {
    key: "setValue",
    value: function setValue(value) {
      if (value != null && !functionUtils_1.FunctionUtils.isNumber(value) && typeof value !== 'string' && !(value instanceof expression_1.Expression)) {
        throw new Error('IntExpression accepts string, number or Expression as the value.');
      }
      (0, _get2.default)((0, _getPrototypeOf2.default)(IntExpression.prototype), "setValue", this).call(this, value);
    }
  }]);
  return IntExpression;
}(expressionProperty_1.ExpressionProperty);
exports.IntExpression = IntExpression;

},{"../expression":179,"../functionUtils":196,"./expressionProperty":185,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/get":234,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.math.trunc.js":592,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],188:[function(require,module,exports){
"use strict";

require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var expressionProperty_1 = require("./expressionProperty");
var expression_1 = require("../expression");
var functionUtils_1 = require("../functionUtils");
/**
 * Represents a property which is either a float or a string expression which resolves to a float.
 *
 * @remarks
 * String values are always interpreted as an expression, whether it has '=' prefix or not.
 */
var NumberExpression = /*#__PURE__*/function (_expressionProperty_) {
  (0, _inherits2.default)(NumberExpression, _expressionProperty_);
  var _super = _createSuper(NumberExpression);
  /**
   * Initializes a new instance of the [NumberExpression](xref:adaptive-expressions.NumberExpression) class.
   *
   * @param value A float `number` or `string` expression which resolves to a float `number`.
   */
  function NumberExpression(value) {
    (0, _classCallCheck2.default)(this, NumberExpression);
    return _super.call(this, value, 0);
  }
  /**
   * Set a number value.
   *
   * @param value Value to set.
   */
  (0, _createClass2.default)(NumberExpression, [{
    key: "setValue",
    value: function setValue(value) {
      if (value != null && !functionUtils_1.FunctionUtils.isNumber(value) && typeof value !== 'string' && !(value instanceof expression_1.Expression)) {
        throw new Error('NumberExpression accepts string, number or Expression as the value.');
      }
      (0, _get2.default)((0, _getPrototypeOf2.default)(NumberExpression.prototype), "setValue", this).call(this, value);
    }
  }]);
  return NumberExpression;
}(expressionProperty_1.ExpressionProperty);
exports.NumberExpression = NumberExpression;

},{"../expression":179,"../functionUtils":196,"./expressionProperty":185,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/get":234,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],189:[function(require,module,exports){
"use strict";

require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var expressionProperty_1 = require("./expressionProperty");
/**
 * Represents a property which is either an object of type T or a string expression which resolves
 * to a object of type T.
 *
 * @remarks
 * String values are always interpreted as an expression, whether it has '=' prefix or not.
 * @param T The type of object.
 */
var ObjectExpression = /*#__PURE__*/function (_expressionProperty_) {
  (0, _inherits2.default)(ObjectExpression, _expressionProperty_);
  var _super = _createSuper(ObjectExpression);
  /**
   * Initializes a new instance of the [ObjectExpression<T>](xref:adaptive-expressions.ObjectExpression) class.
   *
   * @param value An object of type `T` or a `string` expression which resolves to a object of type `T`.
   */
  function ObjectExpression(value) {
    (0, _classCallCheck2.default)(this, ObjectExpression);
    return _super.call(this, value);
  }
  return (0, _createClass2.default)(ObjectExpression);
}(expressionProperty_1.ExpressionProperty);
exports.ObjectExpression = ObjectExpression;

},{"./expressionProperty":185,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],190:[function(require,module,exports){
"use strict";

require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.string.starts-with.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var expressionProperty_1 = require("./expressionProperty");
var expression_1 = require("../expression");
/**
 * Represents a property which is either a string value or a string expression.
 *
 * @remarks
 * If the value is
 * - a string with '=' prefix then the string is treated as an expression to resolve to a string.
 * - a string without '=' then value is treated as string with string interpolation.
 * - You can escape the '=' prefix by putting a backslash.
 * Examples:
 *     prop = "Hello @{user.name}" => "Hello Joe"
 *     prop = "=length(user.name)" => "3"
 *     prop = "=user.name" => "Joe"
 *     prop = "\=user" => "=user".
 */
var StringExpression = /*#__PURE__*/function (_expressionProperty_) {
  (0, _inherits2.default)(StringExpression, _expressionProperty_);
  var _super = _createSuper(StringExpression);
  /**
   * Initializes a new instance of the [StringExpression](xref:adaptive-expressions.StringExpression) class.
   *
   * @param value A `string` value or a `string` expression.
   */
  function StringExpression(value) {
    (0, _classCallCheck2.default)(this, StringExpression);
    return _super.call(this, value);
  }
  /**
   * Set a string value.
   *
   * @param value Value to set.
   */
  (0, _createClass2.default)(StringExpression, [{
    key: "setValue",
    value: function setValue(value) {
      // reset state to no value or expression
      (0, _get2.default)((0, _getPrototypeOf2.default)(StringExpression.prototype), "setValue", this).call(this, undefined);
      if (value instanceof expression_1.Expression) {
        (0, _get2.default)((0, _getPrototypeOf2.default)(StringExpression.prototype), "setValue", this).call(this, value);
        return;
      }
      if (typeof value === 'string') {
        if (value.startsWith('=')) {
          this.expressionText = value;
          return;
        } else if (value.startsWith('\\=')) {
          // Trim off the escape char for equals (\=foo) should simply be the string (=foo).
          value = value.substr(1);
        }
        // keep the string as quoted expression, which will be literal unless string interpolation is used.
        this.expressionText = "=`".concat(value.replace('`', '\\`'), "`");
        return;
      }
      if (value != null) {
        throw new Error('StringExpression accepts string or Expression as the value.');
      }
    }
  }]);
  return StringExpression;
}(expressionProperty_1.ExpressionProperty);
exports.StringExpression = StringExpression;

},{"../expression":179,"./expressionProperty":185,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/get":234,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.string.replace.js":629,"core-js/modules/es.string.starts-with.js":632}],191:[function(require,module,exports){
"use strict";

require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.string.starts-with.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var expressionProperty_1 = require("./expressionProperty");
/**
 * Represents a property which is an object of any kind or a string expression.
 *
 * @remarks
 * If the value is
 * - a string with '=' prefix then the string is treated as an expression to resolve to a string.
 * - a string without '=' then value is treated as string with string interpolation.
 * - You can escape the '=' prefix by putting a backslash.
 * Examples:
 *     prop = "Hello @{user.name}" => "Hello Joe"
 *     prop = "=length(user.name)" => "3"
 *     prop = "=user.name" => "Joe"
 *     prop = "\=user" => "=user".
 */
var ValueExpression = /*#__PURE__*/function (_expressionProperty_) {
  (0, _inherits2.default)(ValueExpression, _expressionProperty_);
  var _super = _createSuper(ValueExpression);
  /**
   * Initializes a new instance of the [ValueExpression](xref:adaptive-expressions.ValueExpression) class.
   *
   * @param value An object of `any` kind or a `string` expression.
   */
  function ValueExpression(value) {
    (0, _classCallCheck2.default)(this, ValueExpression);
    return _super.call(this, value);
  }
  /**
   * Set value as value expression.
   *
   * @param value Value to set.
   */
  (0, _createClass2.default)(ValueExpression, [{
    key: "setValue",
    value: function setValue(value) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(ValueExpression.prototype), "setValue", this).call(this, undefined);
      if (typeof value == 'string') {
        if (value.startsWith('=')) {
          this.expressionText = value;
          return;
        } else if (value.startsWith('\\=')) {
          // Trim off the escape char for equals (\=foo) should simply be the string (=foo).
          value = value.substr(1);
        }
        // keep the string as quoted expression, which will be literal unless string interpolation is used.
        this.expressionText = "=`".concat(value.replace('`', '\\`'), "`");
        return;
      }
      (0, _get2.default)((0, _getPrototypeOf2.default)(ValueExpression.prototype), "setValue", this).call(this, value);
    }
  }]);
  return ValueExpression;
}(expressionProperty_1.ExpressionProperty);
exports.ValueExpression = ValueExpression;

},{"./expressionProperty":185,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/get":234,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.string.replace.js":629,"core-js/modules/es.string.starts-with.js":632}],192:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Built-in expression types.
 */
var ExpressionType = /*#__PURE__*/(0, _createClass2.default)(function ExpressionType() {
  (0, _classCallCheck2.default)(this, ExpressionType);
}); // Math
ExpressionType.Add = '+';
ExpressionType.Subtract = '-';
ExpressionType.Multiply = '*';
ExpressionType.Divide = '/';
ExpressionType.Min = 'min';
ExpressionType.Max = 'max';
ExpressionType.Power = '^';
ExpressionType.Mod = '%';
ExpressionType.Average = 'average';
ExpressionType.Sum = 'sum';
ExpressionType.Count = 'count';
ExpressionType.Range = 'range';
ExpressionType.Floor = 'floor';
ExpressionType.Ceiling = 'ceiling';
ExpressionType.Round = 'round';
ExpressionType.Abs = 'abs';
ExpressionType.Sqrt = 'sqrt';
// Comparisons
ExpressionType.LessThan = '<';
ExpressionType.LessThanOrEqual = '<=';
ExpressionType.Equal = '==';
ExpressionType.NotEqual = '!=';
ExpressionType.GreaterThan = '>';
ExpressionType.GreaterThanOrEqual = '>=';
ExpressionType.Exists = 'exists';
ExpressionType.Contains = 'contains';
ExpressionType.Empty = 'empty';
// Logic
ExpressionType.And = '&&';
ExpressionType.Or = '||';
ExpressionType.Not = '!';
// String
ExpressionType.Concat = 'concat';
ExpressionType.Length = 'length';
ExpressionType.Replace = 'replace';
ExpressionType.ReplaceIgnoreCase = 'replaceIgnoreCase';
ExpressionType.Split = 'split';
ExpressionType.Substring = 'substring';
ExpressionType.ToLower = 'toLower';
ExpressionType.ToUpper = 'toUpper';
ExpressionType.Trim = 'trim';
ExpressionType.Join = 'join';
ExpressionType.EndsWith = 'endsWith';
ExpressionType.StartsWith = 'startsWith';
ExpressionType.CountWord = 'countWord';
ExpressionType.AddOrdinal = 'addOrdinal';
ExpressionType.NewGuid = 'newGuid';
ExpressionType.IndexOf = 'indexOf';
ExpressionType.LastIndexOf = 'lastIndexOf';
ExpressionType.EOL = 'EOL';
ExpressionType.SentenceCase = 'sentenceCase';
ExpressionType.TitleCase = 'titleCase';
// DateTime
ExpressionType.AddDays = 'addDays';
ExpressionType.AddHours = 'addHours';
ExpressionType.AddMinutes = 'addMinutes';
ExpressionType.AddSeconds = 'addSeconds';
ExpressionType.DayOfMonth = 'dayOfMonth';
ExpressionType.DayOfWeek = 'dayOfWeek';
ExpressionType.DayOfYear = 'dayOfYear';
ExpressionType.Month = 'month';
ExpressionType.Date = 'date';
ExpressionType.Year = 'year';
ExpressionType.UtcNow = 'utcNow';
ExpressionType.FormatDateTime = 'formatDateTime';
ExpressionType.FormatEpoch = 'formatEpoch';
ExpressionType.FormatTicks = 'formatTicks';
ExpressionType.SubtractFromTime = 'subtractFromTime';
ExpressionType.DateReadBack = 'dateReadBack';
ExpressionType.GetTimeOfDay = 'getTimeOfDay';
ExpressionType.GetFutureTime = 'getFutureTime';
ExpressionType.GetPastTime = 'getPastTime';
ExpressionType.ConvertFromUTC = 'convertFromUTC';
ExpressionType.ConvertToUTC = 'convertToUTC';
ExpressionType.AddToTime = 'addToTime';
ExpressionType.StartOfDay = 'startOfDay';
ExpressionType.StartOfHour = 'startOfHour';
ExpressionType.StartOfMonth = 'startOfMonth';
ExpressionType.Ticks = 'ticks';
ExpressionType.TicksToDays = 'ticksToDays';
ExpressionType.TicksToHours = 'ticksToHours';
ExpressionType.TicksToMinutes = 'ticksToMinutes';
ExpressionType.DateTimeDiff = 'dateTimeDiff';
// timex
ExpressionType.IsDefinite = 'isDefinite';
ExpressionType.IsTime = 'isTime';
ExpressionType.IsDuration = 'isDuration';
ExpressionType.IsDate = 'isDate';
ExpressionType.IsTimeRange = 'isTimeRange';
ExpressionType.IsDateRange = 'isDateRange';
ExpressionType.IsPresent = 'isPresent';
ExpressionType.GetNextViableDate = 'getNextViableDate';
ExpressionType.GetPreviousViableDate = 'getPreviousViableDate';
ExpressionType.GetNextViableTime = 'getNextViableTime';
ExpressionType.GetPreviousViableTime = 'getPreviousViableTime';
ExpressionType.TimexResolve = 'resolve';
// Conversions
ExpressionType.Float = 'float';
ExpressionType.Int = 'int';
ExpressionType.String = 'string';
ExpressionType.Bool = 'bool';
ExpressionType.Binary = 'binary';
ExpressionType.Base64 = 'base64';
ExpressionType.Base64ToBinary = 'base64ToBinary';
ExpressionType.Base64ToString = 'base64ToString';
ExpressionType.DataUri = 'dataUri';
ExpressionType.DataUriToBinary = 'dataUriToBinary';
ExpressionType.DataUriToString = 'dataUriToString';
ExpressionType.UriComponent = 'uriComponent';
ExpressionType.UriComponentToString = 'uriComponentToString';
ExpressionType.FormatNumber = 'formatNumber';
ExpressionType.JsonStringify = 'jsonStringify';
// Memory
ExpressionType.Accessor = 'Accessor';
ExpressionType.Element = 'Element';
ExpressionType.CreateArray = 'createArray';
// Collection
ExpressionType.First = 'first';
ExpressionType.Last = 'last';
ExpressionType.Foreach = 'foreach';
ExpressionType.Select = 'select';
ExpressionType.Where = 'where';
ExpressionType.Union = 'union';
ExpressionType.Intersection = 'intersection';
ExpressionType.Skip = 'skip';
ExpressionType.Take = 'take';
ExpressionType.FilterNotEqual = 'filterNotEqual';
ExpressionType.SubArray = 'subArray';
ExpressionType.SortBy = 'sortBy';
ExpressionType.SortByDescending = 'sortByDescending';
ExpressionType.IndicesAndValues = 'indicesAndValues';
ExpressionType.Flatten = 'flatten';
ExpressionType.Unique = 'unique';
ExpressionType.Reverse = 'reverse';
ExpressionType.Any = 'any';
ExpressionType.All = 'all';
// Misc
ExpressionType.Constant = 'Constant';
ExpressionType.Lambda = 'Lambda';
ExpressionType.If = 'if';
ExpressionType.Rand = 'rand';
// Object manipulation and construction functions
ExpressionType.Json = 'json';
ExpressionType.AddProperty = 'addProperty';
ExpressionType.RemoveProperty = 'removeProperty';
ExpressionType.SetProperty = 'setProperty';
ExpressionType.GetProperty = 'getProperty';
ExpressionType.Coalesce = 'coalesce';
ExpressionType.JPath = 'jPath';
ExpressionType.SetPathToValue = 'setPathToValue';
ExpressionType.Merge = 'merge';
ExpressionType.XML = 'xml';
ExpressionType.XPath = 'xPath';
// URI parsing functions
ExpressionType.UriHost = 'uriHost';
ExpressionType.UriPath = 'uriPath';
ExpressionType.UriPathAndQuery = 'uriPathAndQuery';
ExpressionType.UriPort = 'uriPort';
ExpressionType.UriQuery = 'uriQuery';
ExpressionType.UriScheme = 'uriScheme';
// Regar expression
ExpressionType.IsMatch = 'isMatch';
//Type Checking
ExpressionType.IsString = 'isString';
ExpressionType.IsInteger = 'isInteger';
ExpressionType.IsArray = 'isArray';
ExpressionType.IsObject = 'isObject';
ExpressionType.IsFloat = 'isFloat';
ExpressionType.IsDateTime = 'isDateTime';
ExpressionType.IsBoolean = 'isBoolean';
// StringOrValue
ExpressionType.StringOrValue = 'stringOrValue';
ExpressionType.Ignore = 'ignore';
ExpressionType.Optional = 'optional';
exports.ExpressionType = ExpressionType;

},{"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237}],193:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Some util and extension functions
 */
var Extensions = /*#__PURE__*/function () {
  function Extensions() {
    (0, _classCallCheck2.default)(this, Extensions);
  }
  (0, _createClass2.default)(Extensions, null, [{
    key: "isMemoryInterface",
    value:
    /**
     * Patch method
     * TODO: is there any better solution?
     * To judge if an object is implements MemoryInterface. Same with 'is MemoryInterface' in C#
     *
     * @param obj The object to evaluate.
     * @returns True if the object implements MemoryInterface; False if it isn't.
     */
    function isMemoryInterface(obj) {
      if (obj === undefined) {
        return false;
      }
      if ((0, _typeof2.default)(obj) !== 'object') {
        return false;
      }
      return 'getValue' in obj && 'setValue' in obj && 'version' in obj && typeof obj.getValue === 'function' && typeof obj.setValue === 'function' && typeof obj.version === 'function';
    }
    /**
     * Generator random seed and value from properties.
     * If value is not null, the mock random value result would be: min + (value % (max - min)).
     *
     * @param memory memory state.
     * @param min The inclusive lower bound of the random number returned.
     * @param max The exclusive upper bound of the random number returned. max must be greater than or equal to min.
     * @returns Random value.
     */
  }, {
    key: "randomNext",
    value: function randomNext(memory, min, max) {
      var randomValue = memory.getValue('Conversation.TestOptions.randomValue');
      if (randomValue !== undefined) {
        return min + randomValue % (max - min);
      }
      return Math.floor(min + Math.random() * (max - min));
    }
  }]);
  return Extensions;
}();
exports.Extensions = Extensions;

},{"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252}],194:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.map.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.array.concat.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.to-string-tag.js");
require("core-js/modules/es.json.to-string-tag.js");
require("core-js/modules/es.math.to-string-tag.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expressionEvaluator_1 = require("./expressionEvaluator");
var expressionFunctions_1 = require("./expressionFunctions");
var functionUtils_1 = require("./functionUtils");
/**
 * FunctionTable is a dictionary which merges BuiltinFunctions.Functions with a CustomDictionary.
 */
var FunctionTable = /*#__PURE__*/function () {
  function FunctionTable() {
    (0, _classCallCheck2.default)(this, FunctionTable);
    this.customFunctions = new Map();
  }
  /**
   * Gets a collection of string values that represent the keys of the [ExpressionFunctions.standardFunctions](xref:adaptive-expressions.ExpressionFunctions.standardFunctions).
   *
   * @returns A list of string values.
   */
  (0, _createClass2.default)(FunctionTable, [{
    key: "keys",
    value: function keys() {
      var keysOfAllFunctions = Array.from(expressionFunctions_1.ExpressionFunctions.standardFunctions.keys()).concat(Array.from(this.customFunctions.keys()));
      return keysOfAllFunctions[Symbol.iterator]();
    }
    /**
     * Gets a collection of [ExpressionEvaluator](xref:adaptive-expressions.ExpressionEvaluator) which is the value of the StandardFunctions.
     *
     * @returns A list of [ExpressionEvaluator](xref:adaptive-expressions.ExpressionEvaluator).
     */
  }, {
    key: "values",
    value: function values() {
      var valuesOfAllFunctions = Array.from(expressionFunctions_1.ExpressionFunctions.standardFunctions.values()).concat(Array.from(this.customFunctions.values()));
      return valuesOfAllFunctions[Symbol.iterator]();
    }
    /**
     * Gets the total number of [ExpressionFunctions.standardFunctions](xref:adaptive-expressions.ExpressionFunctions.standardFunctions) and user [customFunctions](xref:adaptive-expressions.FunctionTable.customFunctions).
     *
     * @returns An integer value.
     */
  }, {
    key: "size",
    get: function get() {
      return expressionFunctions_1.ExpressionFunctions.standardFunctions.size + this.customFunctions.size;
    }
    /**
     * Gets a value indicating whether the [FunctionTable](xref:adaptive-expressions.FunctionTable) is readonly.
     *
     * @returns A boolean value indicating whether the [FunctionTable](xref:adaptive-expressions.FunctionTable) is readonly.
     */
  }, {
    key: "isReadOnly",
    get: function get() {
      return false;
    }
    /**
     * Gets a value of [ExpressionEvaluator](xref:adaptive-expressions.ExpressionEvaluator) corresponding to the given key.
     *
     * @param key A string value of function name.
     * @returns An [ExpressionEvaluator](xref:adaptive-expressions.ExpressionEvaluator).
     */
  }, {
    key: "get",
    value: function get(key) {
      if (expressionFunctions_1.ExpressionFunctions.standardFunctions.get(key)) {
        return expressionFunctions_1.ExpressionFunctions.standardFunctions.get(key);
      }
      if (this.customFunctions.get(key)) {
        return this.customFunctions.get(key);
      }
      return undefined;
    }
    /**
     * Sets a value of [ExpressionEvaluator](xref:adaptive-expressions.ExpressionEvaluator) corresponding to the given key.
     *
     * @param key A string value of function name.
     * @param value The value to set for the [ExpressionEvaluator](xref:adaptive-expressions.ExpressionEvaluator).
     * @returns The value of the [ExpressionEvaluator](xref:adaptive-expressions.ExpressionEvaluator).
     */
  }, {
    key: "set",
    value: function set(key, value) {
      if (expressionFunctions_1.ExpressionFunctions.standardFunctions.get(key)) {
        throw Error("You can't overwrite a built in function.");
      }
      this.customFunctions.set(key, value);
      return this;
    }
    /**
     * Inserts a mapping of a string key to [ExpressionEvaluator](xref:adaptive-expressions.ExpressionEvaluator) into [FunctionTable](xref:adaptive-expressions.FunctionTable).
     *
     * @param param1 Key-Value pair for the [ExpressionEvaluator](xref:adaptive-expressions.ExpressionEvaluator) or the function name to be added.
     * @param param2 Value of the [ExpressionEvaluator](xref:adaptive-expressions.ExpressionEvaluator) to be added or value of the user customized function to be added.
     */
  }, {
    key: "add",
    value: function add(param1, param2) {
      if (arguments.length === 1) {
        if (param1 instanceof Object) {
          this.set(param1.key, param1.value);
        }
      } else {
        if (typeof param1 === 'string') {
          if (param2 instanceof expressionEvaluator_1.ExpressionEvaluator) {
            this.set(param1, param2);
          } else {
            this.set(param1, new expressionEvaluator_1.ExpressionEvaluator(param1, functionUtils_1.FunctionUtils.apply(param2)));
          }
        }
      }
    }
    /**
     * Clears the user [customFunctions](xref:adaptive-expressions.FunctionTable.customFunctions).
     */
  }, {
    key: "clear",
    value: function clear() {
      this.customFunctions.clear();
    }
    /**
     * Determines if the [FunctionTable](xref:adaptive-expressions.FunctionTable) has a given string key.
     *
     * @param key A string key.
     * @returns `True` if the key is contained, otherwise returns `False`.
     */
  }, {
    key: "has",
    value: function has(key) {
      return expressionFunctions_1.ExpressionFunctions.standardFunctions.has(key) || this.customFunctions.has(key);
    }
    /**
     * Deletes a specified key from user [customFunctions](xref:adaptive-expressions.FunctionTable.customFunctions).
     *
     * @param key A string key of function name.
     * @returns A boolean value indicating whether the key is successfully deleted.
     */
  }, {
    key: "delete",
    value: function _delete(key) {
      return this.customFunctions.delete(key);
    }
    /**
     * Operates on each element of the [ExpressionFunctions.standardFunctions](xref:adaptive-expressions.ExpressionFunctions.standardFunctions).
     * Not implemented.
     *
     * @param _callbackfn Callback function.
     * @param _thisArg Optional. This args.
     */
  }, {
    key: "forEach",
    value: function forEach(_callbackfn, _thisArg) {
      throw Error('forEach function not implemented');
    }
    /**
     * Returns an iterable of key, value pairs for every entry in the map.
     * Not implemented.
     */
  }, {
    key: "entries",
    value: function entries() {
      throw Error('entries function not implemented');
    }
    /**
     * Returns an iterable of key, value pairs.
     * Not implemented.
     */
  }, {
    key: Symbol.iterator,
    get: function get() {
      throw Error('Symbol.iterator function not implemented');
    }
    /**
     * Returns a string value.
     * Not implemented.
     */
  }, {
    key: Symbol.toStringTag,
    get: function get() {
      throw Error('Symbol.toStringTag function not implemented');
    }
  }]);
  return FunctionTable;
}();
exports.FunctionTable = FunctionTable;

},{"./expressionEvaluator":180,"./expressionFunctions":181,"./functionUtils":196,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.json.to-string-tag.js":586,"core-js/modules/es.map.js":587,"core-js/modules/es.math.to-string-tag.js":591,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/es.symbol.to-string-tag.js":640,"core-js/modules/web.dom-collections.iterator.js":677}],195:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.object.keys.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.array.sort.js");
require("core-js/modules/es.array.concat.js");
require("core-js/modules/es.number.is-nan.js");
require("core-js/modules/es.number.constructor.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.map.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.array.find.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/web.dom-collections.for-each.js");
require("core-js/modules/web.url.js");
require("core-js/modules/web.url-search-params.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.regexp.to-string.js");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var constant_1 = require("./constant");
var dayjs_1 = __importDefault(require("dayjs"));
var utc_1 = __importDefault(require("dayjs/plugin/utc"));
dayjs_1.default.extend(utc_1.default);
var expressionType_1 = require("./expressionType");
var memory_1 = require("./memory");
var recognizers_text_data_types_timex_expression_1 = require("@microsoft/recognizers-text-data-types-timex-expression");
var bigInt = require("big-integer");
var util = require("util");
/**
 * Utility functions only used internal
 */
var InternalFunctionUtils = /*#__PURE__*/function () {
  function InternalFunctionUtils() {
    (0, _classCallCheck2.default)(this, InternalFunctionUtils);
  }
  (0, _createClass2.default)(InternalFunctionUtils, null, [{
    key: "parseTimexProperty",
    value:
    /**
     * Parse timex funcition.
     *
     * @param timexExpr String or TimexProperty input.
     * @returns TimexProperty and error.
     */
    function parseTimexProperty(timexExpr) {
      var parsed;
      if (timexExpr instanceof recognizers_text_data_types_timex_expression_1.TimexProperty) {
        parsed = timexExpr;
      } else if (typeof timexExpr === 'string') {
        parsed = new recognizers_text_data_types_timex_expression_1.TimexProperty(timexExpr);
      } else {
        parsed = new recognizers_text_data_types_timex_expression_1.TimexProperty(timexExpr);
        if (parsed === undefined || Object.keys(parsed).length === 0) {
          return {
            timexProperty: parsed,
            error: "".concat(timexExpr, " requires a TimexProperty or a string as a argument")
          };
        }
      }
      return {
        timexProperty: parsed,
        error: undefined
      };
    }
    /**
     * Sort helper function.
     *
     * @param isDescending Descending flag.
     * @returns The sorted array.
     */
  }, {
    key: "sortBy",
    value: function sortBy(isDescending) {
      return function (expression, state, options) {
        var result;
        var _expression$children$ = expression.children[0].tryEvaluate(state, options),
          oriArr = _expression$children$.value,
          childrenError = _expression$children$.error;
        var error = childrenError;
        if (!error) {
          if (Array.isArray(oriArr)) {
            // Ensures we don't mutate the array in place.
            var arr = oriArr.slice(0);
            if (expression.children.length === 1) {
              if (isDescending) {
                result = arr.sort().reverse();
              } else {
                result = arr.sort();
              }
            } else {
              var propertyName;
              var _expression$children$2 = expression.children[1].tryEvaluate(state, options);
              propertyName = _expression$children$2.value;
              error = _expression$children$2.error;
              if (!error) {
                propertyName = propertyName || '';
              }
              if (isDescending) {
                result = arr.sort(InternalFunctionUtils.sortByKey(propertyName)).reverse();
              } else {
                result = arr.sort(InternalFunctionUtils.sortByKey(propertyName));
              }
            }
          } else {
            error = "".concat(expression.children[0], " is not an array");
          }
        }
        return {
          value: result,
          error: error
        };
      };
    }
    /**
     * Lookup a string or number index of an Object.
     *
     * @param instance Instance with property.
     * @param index Property to lookup.
     * @returns Value and error information if any.
     */
  }, {
    key: "accessIndex",
    value: function accessIndex(instance, index) {
      // NOTE: This returns undefined rather than an error if instance is not present
      if (instance == null) {
        return {
          value: undefined,
          error: undefined
        };
      }
      var value;
      var error;
      if (Array.isArray(instance)) {
        if (index >= 0 && index < instance.length) {
          value = instance[index];
        } else {
          error = "".concat(index, " is out of range for ").concat(instance);
        }
      } else {
        error = "".concat(instance, " is not a collection.");
      }
      return {
        value: value,
        error: error
      };
    }
    /**
     * Verify a timestamp string is valid timestamp format.
     *
     * @param value Timestamp string to check.
     * @returns Error or undefined if invalid.
     */
  }, {
    key: "verifyTimestamp",
    value: function verifyTimestamp(value) {
      var error;
      try {
        var parsedData = new Date(value);
        if (Number.isNaN(parsedData.getTime())) {
          error = "".concat(value, " is not a valid datetime string.");
        }
      } catch (_a) {
        error = "".concat(value, " is not a valid datetime string.");
      }
      return error;
    }
    /**
     * Verify a timestamp string is valid ISO timestamp format.
     *
     * @param value Timestamp string to check.
     * @returns Error or undefined if invalid.
     */
  }, {
    key: "verifyISOTimestamp",
    value: function verifyISOTimestamp(value) {
      var error;
      try {
        var parsedData = new Date(value);
        if (Number.isNaN(parsedData.getTime())) {
          error = "".concat(value, " is not a valid datetime string.");
        } else if (parsedData.toISOString() !== value) {
          error = "".concat(value, " is not a ISO format datetime string.");
        }
      } catch (_a) {
        error = "".concat(value, " is not a valid datetime string.");
      }
      return error;
    }
    /**
     * Convert a string input to ticks number.
     *
     * @param timeStamp String timestamp input.
     * @returns The string converted in ticks.
     */
  }, {
    key: "ticks",
    value: function ticks(timeStamp) {
      var result;
      var error = this.verifyISOTimestamp(timeStamp);
      if (!error) {
        var unixMilliSec = dayjs_1.default(timeStamp).utc().valueOf();
        result = this.UnixMilliSecondToTicksConstant.add(bigInt(unixMilliSec).times(this.MillisecondToTickConstant));
      }
      return {
        value: result,
        error: error
      };
    }
    /**
     * Lookup a property in Map or Object.
     *
     * @param instance Instance with property.
     * @param property Property to lookup.
     * @returns Value and error information if any.
     */
  }, {
    key: "accessProperty",
    value: function accessProperty(instance, property) {
      // NOTE: This returns undefined rather than an error if property is not present
      if (!instance) {
        return {
          value: undefined,
          error: undefined
        };
      }
      var value;
      var error;
      if (instance instanceof Map && instance !== undefined) {
        var instanceMap = instance;
        value = instanceMap.get(property);
        if (value === undefined) {
          var prop = Array.from(instanceMap.keys()).find(function (k) {
            return k.toLowerCase() === property.toLowerCase();
          });
          if (prop !== undefined) {
            value = instanceMap.get(prop);
          }
        }
      } else {
        var _prop = Object.keys(instance).find(function (k) {
          return k.toLowerCase() === property.toLowerCase();
        });
        if (_prop !== undefined) {
          value = instance[_prop];
        }
      }
      return {
        value: value,
        error: error
      };
    }
    /**
     * Get the value of a path from a memory.
     *
     * @param state Memory.
     * @param path Path string.
     * @param options Options.
     * @returns The value of a path from a memory.
     */
  }, {
    key: "wrapGetValue",
    value: function wrapGetValue(state, path, options) {
      var result = state.getValue(path);
      if (result !== undefined) {
        return result;
      }
      if (options.nullSubstitution !== undefined) {
        return options.nullSubstitution(path);
      }
      return undefined;
    }
    /**
     * Wrap string or undefined into string. Default to empty string.
     *
     * @param input Input string
     * @returns The wrapped string.
     */
  }, {
    key: "parseStringOrUndefined",
    value: function parseStringOrUndefined(input) {
      if (typeof input === 'string') {
        return input;
      } else {
        return '';
      }
    }
    /**
     * Test result to see if True in logical comparison functions.
     *
     * @param instance Computed value.
     * @returns True if boolean true or non-null.
     */
  }, {
    key: "isLogicTrue",
    value: function isLogicTrue(instance) {
      var result = true;
      if (typeof instance === 'boolean') {
        result = instance;
      } else if (instance == null) {
        result = false;
      }
      return result;
    }
    /**
     * Evaluator for foreach and select functions.
     *
     * @param expression Expression.
     * @param state Memory scope.
     * @param options Options.
     * @returns The evaluated list.
     */
  }, {
    key: "foreach",
    value: function foreach(expression, state, options) {
      var result;
      var _expression$children$3 = expression.children[0].tryEvaluate(state, options),
        instance = _expression$children$3.value,
        childrenError = _expression$children$3.error;
      var error = childrenError;
      if (!instance) {
        error = "'".concat(expression.children[0], "' evaluated to null.");
      }
      if (!error) {
        var list = InternalFunctionUtils.convertToList(instance);
        if (!list) {
          error = "".concat(expression.children[0], " is not a collection or structure object to run Foreach");
        } else {
          result = [];
          InternalFunctionUtils.lambdaEvaluator(expression, state, options, list, function (currentItem, r, e) {
            if (e) {
              error = e;
              return true;
            } else {
              result.push(r);
              return false;
            }
          });
        }
      }
      return {
        value: result,
        error: error
      };
    }
    /**
     * Lambda evaluator.
     *
     * @param expression expression.
     * @param state memory state.
     * @param options options.
     * @param list item list.
     * @param callback call back. return the should break flag.
     */
  }, {
    key: "lambdaEvaluator",
    value: function lambdaEvaluator(expression, state, options, list, callback) {
      var firstChild = expression.children[1].children[0];
      if (!(firstChild instanceof constant_1.Constant) || typeof firstChild.value !== 'string') {
        return;
      }
      var iteratorName = firstChild.value;
      var stackedMemory = memory_1.StackedMemory.wrap(state);
      var _iterator = _createForOfIteratorHelper(list),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var item = _step.value;
          var currentItem = item;
          var local = new Map([[iteratorName, item]]);
          // the local iterator is pushed as one memory layer in the memory stack
          stackedMemory.push(memory_1.SimpleObjectMemory.wrap(local));
          var _expression$children$4 = expression.children[2].tryEvaluate(stackedMemory, options),
            r = _expression$children$4.value,
            e = _expression$children$4.error;
          stackedMemory.pop();
          var shouldBreak = callback(currentItem, r, e);
          if (shouldBreak) {
            break;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * Convert an object into array.
     * If the instance is array, return itself.
     * If the instance is object, return {key, value} pair list.
     * Else return undefined.
     *
     * @param instance input instance.
     * @returns The generated list.
     */
  }, {
    key: "convertToList",
    value: function convertToList(instance) {
      var arr;
      if (Array.isArray(instance)) {
        arr = instance;
      } else if ((0, _typeof2.default)(instance) === 'object') {
        arr = [];
        Object.keys(instance).forEach(function (u) {
          return arr.push({
            key: u,
            value: instance[u]
          });
        });
      }
      return arr;
    }
    /**
     * Validator for foreach, select, and where functions.
     *
     * @param expression The expression to validate.
     */
  }, {
    key: "ValidateLambdaExpression",
    value: function ValidateLambdaExpression(expression) {
      if (expression.children.length !== 3) {
        throw new Error("Lambda expression expect 3 parameters, found ".concat(expression.children.length));
      }
      var second = expression.children[1];
      if (!(second.type === expressionType_1.ExpressionType.Accessor && second.children.length === 1)) {
        throw new Error("Second parameter is not an identifier : ".concat(second));
      }
    }
    /**
     * Parse string into URL object.
     *
     * @param uri Input string uri.
     * @returns The parsed URL object.
     */
  }, {
    key: "parseUri",
    value: function parseUri(uri) {
      var result;
      var error;
      try {
        result = new URL(uri);
      } catch (_a) {
        error = "Invalid URI: ".concat(uri);
      }
      return {
        value: result,
        error: error
      };
    }
    /**
     * Transform C# period and unit into js period and unit.
     *
     * @param duration C# duration.
     * @param cSharpStr C# unit.
     * @returns The transformed timeUnit.
     */
  }, {
    key: "timeUnitTransformer",
    value: function timeUnitTransformer(duration, cSharpStr) {
      switch (cSharpStr) {
        case 'Day':
          return {
            duration: duration,
            tsStr: 'day'
          };
        case 'Week':
          return {
            duration: duration * 7,
            tsStr: 'day'
          };
        case 'Second':
          return {
            duration: duration,
            tsStr: 'second'
          };
        case 'Minute':
          return {
            duration: duration,
            tsStr: 'minute'
          };
        case 'Hour':
          return {
            duration: duration,
            tsStr: 'hour'
          };
        case 'Month':
          return {
            duration: duration,
            tsStr: 'month'
          };
        case 'Year':
          return {
            duration: duration,
            tsStr: 'year'
          };
        default:
          return {
            duration: duration,
            tsStr: undefined
          };
      }
    }
    /**
     * TextEncoder helper function.
     *
     * @returns The text encoder.
     */
  }, {
    key: "getTextEncoder",
    value: function getTextEncoder() {
      if (typeof window !== 'undefined' || typeof self !== 'undefined') {
        return new TextEncoder();
      }
      return new util.TextEncoder();
    }
    /**
     * TextDecoder helper function.
     *
     * @param code The encoding format.
     * @returns The text decoder.
     */
  }, {
    key: "getTextDecoder",
    value: function getTextDecoder() {
      var code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'utf-8';
      if (typeof window !== 'undefined' || typeof self !== 'undefined') {
        return new TextDecoder(code);
      }
      return new util.TextDecoder(code);
    }
    /**
     * Common Stringify an object.
     *
     * @param input input object.
     * @returns the stringified object.
     */
  }, {
    key: "commonStringify",
    value: function commonStringify(input) {
      if (input == null) {
        return '';
      }
      if ((0, _typeof2.default)(input) === 'object') {
        return JSON.stringify(input).replace(/(^['"]*)/g, '').replace(/(['"]*$)/g, '');
      } else {
        return input.toString();
      }
    }
    /**
     * @private
     */
  }, {
    key: "sortByKey",
    value: function sortByKey(key) {
      return function (a, b) {
        return a[key] > b[key] ? 1 : b[key] > a[key] ? -1 : 0;
      };
    }
  }]);
  return InternalFunctionUtils;
}();
/**
 * Constant for converting unix timestamp to ticks.
 */
InternalFunctionUtils.UnixMilliSecondToTicksConstant = bigInt('621355968000000000');
/**
 * Constant to convert between ticks and ms.
 */
InternalFunctionUtils.MillisecondToTickConstant = bigInt('10000');
exports.InternalFunctionUtils = InternalFunctionUtils;

},{"./constant":167,"./expressionType":192,"./memory":201,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"@microsoft/recognizers-text-data-types-timex-expression":222,"big-integer":419,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.array.find.js":574,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.array.sort.js":581,"core-js/modules/es.function.name.js":584,"core-js/modules/es.map.js":587,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.number.is-nan.js":596,"core-js/modules/es.object.keys.js":609,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.string.replace.js":629,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.for-each.js":676,"core-js/modules/web.dom-collections.iterator.js":677,"core-js/modules/web.url-search-params.js":678,"core-js/modules/web.url.js":679,"dayjs":697,"dayjs/plugin/utc":700,"util":736}],196:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.array.concat.js");
require("core-js/modules/es.number.max-safe-integer.js");
require("core-js/modules/es.number.constructor.js");
require("core-js/modules/es.map.js");
require("core-js/modules/es.number.is-integer.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.number.is-nan.js");
require("core-js/modules/es.number.epsilon.js");
require("core-js/modules/es.array.filter.js");
require("core-js/modules/es.object.keys.js");
require("core-js/modules/es.array.join.js");
require("core-js/modules/es.object.entries.js");
require("core-js/modules/es.object.assign.js");
require("core-js/modules/es.array.map.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.concat.js");
require("core-js/modules/es.number.max-safe-integer.js");
require("core-js/modules/es.number.constructor.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.map.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.number.is-integer.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.number.is-nan.js");
require("core-js/modules/es.number.epsilon.js");
require("core-js/modules/es.array.filter.js");
require("core-js/modules/es.object.keys.js");
require("core-js/modules/es.array.join.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.object.entries.js");
require("core-js/modules/es.object.assign.js");
require("core-js/modules/es.array.map.js");
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
function _createForOfIteratorHelper(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
      t && (r = t);
      var _n = 0,
        F = function F() {};
      return {
        s: F,
        n: function n() {
          return _n >= r.length ? {
            done: !0
          } : {
            done: !1,
            value: r[_n++]
          };
        },
        e: function e(r) {
          throw r;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o,
    a = !0,
    u = !1;
  return {
    s: function s() {
      t = t.call(r);
    },
    n: function n() {
      var r = t.next();
      return a = r.done, r;
    },
    e: function e(r) {
      u = !0, o = r;
    },
    f: function f() {
      try {
        a || null == t.return || t.return();
      } finally {
        if (u) throw o;
      }
    }
  };
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var datetimeFormatConverter_1 = require("./datetimeFormatConverter");
var expressionType_1 = require("./expressionType");
var returnType_1 = require("./returnType");
// eslint-disable-next-line lodash/import-scope
var lodash_isequal_1 = __importDefault(require("lodash.isequal"));
/**
 * Utility functions in AdaptiveExpression.
 */
var FunctionUtils = /*#__PURE__*/function () {
  function FunctionUtils() {
    (0, _classCallCheck2.default)(this, FunctionUtils);
  }
  (0, _createClass2.default)(FunctionUtils, null, [{
    key: "validateArityAndAnyType",
    value:
    /**
     * Validate that expression has a certain number of children that are of any of the supported types.
     *
     * @param expression Expression to validate.
     * @param minArity Minimum number of children.
     * @param maxArity Maximum number of children.
     * @param returnType Allowed return types for children.
     * If a child has a return type of Object then validation will happen at runtime.
     */
    function validateArityAndAnyType(expression, minArity, maxArity) {
      var returnType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : returnType_1.ReturnType.Object;
      if (expression.children.length < minArity) {
        throw new Error("".concat(expression, " should have at least ").concat(minArity, " children."));
      }
      if (expression.children.length > maxArity) {
        throw new Error("".concat(expression, " can't have more than ").concat(maxArity, " children."));
      }
      if ((returnType & returnType_1.ReturnType.Object) === 0) {
        var _iterator = _createForOfIteratorHelper(expression.children),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var child = _step.value;
            if ((child.returnType & returnType_1.ReturnType.Object) === 0 && (returnType & child.returnType) === 0) {
              throw new Error(FunctionUtils.buildTypeValidatorError(returnType, child, expression));
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }
    /**
     * Validate the number and type of arguments to a function.
     *
     * @param expression Expression to validate.
     * @param optional Optional types in order.
     * @param types Expected types in order.
     */
  }, {
    key: "validateOrder",
    value: function validateOrder(expression, optional) {
      if (optional === undefined) {
        optional = [];
      }
      if (expression.children.length < (arguments.length <= 2 ? 0 : arguments.length - 2) || expression.children.length > (arguments.length <= 2 ? 0 : arguments.length - 2) + optional.length) {
        throw new Error(optional.length === 0 ? "".concat(expression, " should have ").concat(arguments.length <= 2 ? 0 : arguments.length - 2, " children.") : "".concat(expression, " should have between ").concat(arguments.length <= 2 ? 0 : arguments.length - 2, " and ").concat((arguments.length <= 2 ? 0 : arguments.length - 2) + optional.length, " children."));
      }
      for (var i = 0; i < (arguments.length <= 2 ? 0 : arguments.length - 2); i++) {
        var child = expression.children[i];
        var type = i + 2 < 2 || arguments.length <= i + 2 ? undefined : arguments[i + 2];
        if ((type & returnType_1.ReturnType.Object) === 0 && (child.returnType & returnType_1.ReturnType.Object) === 0 && (type & child.returnType) === 0) {
          throw new Error(FunctionUtils.buildTypeValidatorError(type, child, expression));
        }
      }
      for (var _i = 0; _i < optional.length; _i++) {
        var ic = _i + (arguments.length <= 2 ? 0 : arguments.length - 2);
        if (ic >= expression.children.length) {
          break;
        }
        var _child = expression.children[ic];
        var _type = optional[_i];
        if ((_type & returnType_1.ReturnType.Object) === 0 && (_child.returnType & returnType_1.ReturnType.Object) === 0 && (_type & _child.returnType) === 0) {
          throw new Error(FunctionUtils.buildTypeValidatorError(_type, _child, expression));
        }
      }
    }
    /**
     * Validate at least 1 argument of any type.
     *
     * @param expression Expression to validate.
     */
  }, {
    key: "validateAtLeastOne",
    value: function validateAtLeastOne(expression) {
      FunctionUtils.validateArityAndAnyType(expression, 1, Number.MAX_SAFE_INTEGER);
    }
    /**
     * Validate 1 or more numeric arguments.
     *
     * @param expression Expression to validate.
     */
  }, {
    key: "validateNumber",
    value: function validateNumber(expression) {
      FunctionUtils.validateArityAndAnyType(expression, 1, Number.MAX_SAFE_INTEGER, returnType_1.ReturnType.Number);
    }
    /**
     * Validate 1 or more string arguments.
     *
     * @param expression Expression to validate.
     */
  }, {
    key: "validateString",
    value: function validateString(expression) {
      FunctionUtils.validateArityAndAnyType(expression, 1, Number.MAX_SAFE_INTEGER, returnType_1.ReturnType.String);
    }
    /**
     * Validate there are two children.
     *
     * @param expression Expression to validate.
     */
  }, {
    key: "validateBinary",
    value: function validateBinary(expression) {
      FunctionUtils.validateArityAndAnyType(expression, 2, 2);
    }
    /**
     * Validate 2 numeric arguments.
     *
     * @param expression Expression to validate.
     */
  }, {
    key: "validateBinaryNumber",
    value: function validateBinaryNumber(expression) {
      FunctionUtils.validateArityAndAnyType(expression, 2, 2, returnType_1.ReturnType.Number);
    }
    /**
     * Validate 1 or 2 numeric arguments.
     *
     * @param expression Expression to validate.
     */
  }, {
    key: "validateUnaryOrBinaryNumber",
    value: function validateUnaryOrBinaryNumber(expression) {
      FunctionUtils.validateArityAndAnyType(expression, 1, 2, returnType_1.ReturnType.Number);
    }
    /**
     * Validate 2 or more than 2 numeric arguments.
     *
     * @param expression Expression to validate.
     */
  }, {
    key: "validateTwoOrMoreThanTwoNumbers",
    value: function validateTwoOrMoreThanTwoNumbers(expression) {
      FunctionUtils.validateArityAndAnyType(expression, 2, Number.MAX_VALUE, returnType_1.ReturnType.Number);
    }
    /**
     * Validate there are 2 numeric or string arguments.
     *
     * @param expression Expression to validate.
     */
  }, {
    key: "validateBinaryNumberOrString",
    value: function validateBinaryNumberOrString(expression) {
      FunctionUtils.validateArityAndAnyType(expression, 2, 2, returnType_1.ReturnType.Number | returnType_1.ReturnType.String);
    }
    /**
     * Validate there is a single argument.
     *
     * @param expression Expression to validate.
     */
  }, {
    key: "validateUnary",
    value: function validateUnary(expression) {
      FunctionUtils.validateArityAndAnyType(expression, 1, 1);
    }
    /**
     * Validate there is a single argument.
     *
     * @param expression Expression to validate.
     */
  }, {
    key: "validateUnaryNumber",
    value: function validateUnaryNumber(expression) {
      FunctionUtils.validateArityAndAnyType(expression, 1, 1, returnType_1.ReturnType.Number);
    }
    /**
     * Validate there is a single string argument.
     *
     * @param expression Expression to validate.
     */
  }, {
    key: "validateUnaryString",
    value: function validateUnaryString(expression) {
      FunctionUtils.validateArityAndAnyType(expression, 1, 1, returnType_1.ReturnType.String);
    }
    /**
     * Validate there is one or two string arguments.
     *
     * @param expression Expression to validate.
     */
  }, {
    key: "validateUnaryOrBinaryString",
    value: function validateUnaryOrBinaryString(expression) {
      FunctionUtils.validateArityAndAnyType(expression, 1, 2, returnType_1.ReturnType.String);
    }
    /**
     * Validate there is a single boolean argument.
     *
     * @param expression Expression to validate.
     */
  }, {
    key: "validateUnaryBoolean",
    value: function validateUnaryBoolean(expression) {
      FunctionUtils.validateOrder(expression, undefined, returnType_1.ReturnType.Boolean);
    }
    /**
     * Verify value is numeric.
     *
     * @param value Value to check.
     * @param expression Expression that led to value.
     * @param _ No function.
     * @returns Error or undefined if invalid.
     */
  }, {
    key: "verifyNumber",
    value: function verifyNumber(value, expression, _) {
      var error;
      if (!FunctionUtils.isNumber(value)) {
        error = "".concat(expression, " is not a number.");
      }
      return error;
    }
    /**
     * Verify value is numeric.
     *
     * @param value Value to check.
     * @param expression Expression that led to value.
     * @param _ No function.
     * @returns Error or undefined if invalid.
     */
  }, {
    key: "verifyNumberOrNumericList",
    value: function verifyNumberOrNumericList(value, expression, _) {
      var error;
      if (FunctionUtils.isNumber(value)) {
        return error;
      }
      if (!Array.isArray(value)) {
        error = "".concat(expression, " is neither a list nor a number.");
      } else {
        var _iterator2 = _createForOfIteratorHelper(value),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var elt = _step2.value;
            if (!FunctionUtils.isNumber(elt)) {
              error = "".concat(elt, " is not a number in ").concat(expression, ".");
              break;
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
      return error;
    }
    /**
     * Verify value is numeric list.
     *
     * @param value Value to check.
     * @param expression Expression that led to value.
     * @param _ No function.
     * @returns Error or undefined if invalid.
     */
  }, {
    key: "verifyNumericList",
    value: function verifyNumericList(value, expression, _) {
      var error;
      if (!Array.isArray(value)) {
        error = "".concat(expression, " is not a list.");
      } else {
        var _iterator3 = _createForOfIteratorHelper(value),
          _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var elt = _step3.value;
            if (!FunctionUtils.isNumber(elt)) {
              error = "".concat(elt, " is not a number in ").concat(expression, ".");
              break;
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }
      return error;
    }
    /**
     * Verify value contains elements.
     *
     * @param value Value to check.
     * @param expression Expression that led to value.
     * @param _ No function.
     * @returns Error or undefined if invalid.
     */
  }, {
    key: "verifyContainer",
    value: function verifyContainer(value, expression, _) {
      var error;
      if (!(typeof value === 'string') && !Array.isArray(value) && !(value instanceof Map) && !((0, _typeof2.default)(value) === 'object')) {
        error = "".concat(expression, " must be a string, list, map or object.");
      }
      return error;
    }
    /**
     * Verify value contains elements or null.
     *
     * @param value Value to check.
     * @param expression Expression that led to value.
     * @param _ No function.
     * @returns Error or undefined if invalid.
     */
  }, {
    key: "verifyContainerOrNull",
    value: function verifyContainerOrNull(value, expression, _) {
      var error;
      if (value != null && !(typeof value === 'string') && !Array.isArray(value) && !(value instanceof Map) && !((0, _typeof2.default)(value) === 'object')) {
        error = "".concat(expression, " must be a string, list, map or object.");
      }
      return error;
    }
    /**
     * Verify value is not null or undefined.
     *
     * @param value Value to check.
     * @param expression Expression that led to value.
     * @param _ No function.
     * @returns Error or undefined if valid.
     */
  }, {
    key: "verifyNotNull",
    value: function verifyNotNull(value, expression, _) {
      var error;
      if (value == null) {
        error = "".concat(expression, " is null.");
      }
      return error;
    }
    /**
     * Verify value is an integer.
     *
     * @param value Value to check.
     * @param expression Expression that led to value.
     * @param _ No function.
     * @returns Error or undefined if invalid.
     */
  }, {
    key: "verifyInteger",
    value: function verifyInteger(value, expression, _) {
      var error;
      if (!Number.isInteger(value)) {
        error = "".concat(expression, " is not a integer.");
      }
      return error;
    }
    /**
     * Verify value is an list.
     *
     * @param value Value to check.
     * @param expression Expression that led to value.
     * @returns Error or undefined if invalid.
     */
  }, {
    key: "verifyList",
    value: function verifyList(value, expression) {
      var error;
      if (!Array.isArray(value)) {
        error = "".concat(expression, " is not a list or array.");
      }
      return error;
    }
    /**
     * Verify value is a string.
     *
     * @param value Value to check.
     * @param expression Expression that led to value.
     * @param _ No function.
     * @returns Error or undefined if invalid.
     */
  }, {
    key: "verifyString",
    value: function verifyString(value, expression, _) {
      var error;
      if (typeof value !== 'string') {
        error = "".concat(expression, " is not a string.");
      }
      return error;
    }
    /**
     * Verify an object is neither a string nor null.
     *
     * @param value Value to check.
     * @param expression Expression that led to value.
     * @param _ No function.
     * @returns Error or undefined if invalid.
     */
  }, {
    key: "verifyStringOrNull",
    value: function verifyStringOrNull(value, expression, _) {
      var error;
      if (typeof value !== 'string' && value !== undefined) {
        error = "".concat(expression, " is neither a string nor a null object.");
      }
      return error;
    }
    /**
     * Verify value is a number or string or null.
     *
     * @param value Value to check.
     * @param expression Expression that led to value.
     * @param _ No function.
     * @returns Error or undefined if invalid.
     */
  }, {
    key: "verifyNumberOrStringOrNull",
    value: function verifyNumberOrStringOrNull(value, expression, _) {
      var error;
      if (typeof value !== 'string' && value !== undefined && !FunctionUtils.isNumber(value)) {
        error = "".concat(expression, " is neither a number nor string");
      }
      return error;
    }
    /**
     * Verify value is a number or string.
     *
     * @param value Value to check.
     * @param expression Expression that led to value.
     * @param _ No function.
     * @returns Error or undefined if invalid.
     */
  }, {
    key: "verifyNumberOrString",
    value: function verifyNumberOrString(value, expression, _) {
      var error;
      if (value === undefined || !FunctionUtils.isNumber(value) && typeof value !== 'string') {
        error = "".concat(expression, " is not string or number.");
      }
      return error;
    }
    /**
     * Verify value is boolean.
     *
     * @param value Value to check.
     * @param expression Expression that led to value.
     * @param _ No function.
     * @returns Error or undefined if invalid.
     */
  }, {
    key: "verifyBoolean",
    value: function verifyBoolean(value, expression, _) {
      var error;
      if (typeof value !== 'boolean') {
        error = "".concat(expression, " is not a boolean.");
      }
      return error;
    }
    /**
     * Evaluate expression children and return them.
     *
     * @param expression Expression with children.
     * @param state Global state.
     * @param options Options used in evaluation.
     * @param verify Optional function to verify each child's result.
     * @returns List of child values or error message.
     */
  }, {
    key: "evaluateChildren",
    value: function evaluateChildren(expression, state, options, verify) {
      var args = [];
      var value;
      var error;
      var pos = 0;
      var _iterator4 = _createForOfIteratorHelper(expression.children),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var child = _step4.value;
          var _child$tryEvaluate = child.tryEvaluate(state, options);
          value = _child$tryEvaluate.value;
          error = _child$tryEvaluate.error;
          if (error) {
            break;
          }
          if (verify !== undefined) {
            error = verify(value, child, pos);
          }
          if (error) {
            break;
          }
          args.push(value);
          ++pos;
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      return {
        args: args,
        error: error
      };
    }
    /**
     * Generate an expression delegate that applies function after verifying all children.
     *
     * @param func Function to apply.
     * @param verify Function to check each arg for validity.
     * @returns Delegate for evaluating an expression.
     */
  }, {
    key: "apply",
    value: function apply(func, verify) {
      return function (expression, state, options) {
        var value;
        var _FunctionUtils$evalua = FunctionUtils.evaluateChildren(expression, state, options, verify),
          args = _FunctionUtils$evalua.args,
          childrenError = _FunctionUtils$evalua.error;
        var error = childrenError;
        if (!error) {
          try {
            value = func(args);
          } catch (e) {
            error = e.message;
          }
        }
        return {
          value: value,
          error: error
        };
      };
    }
    /**
     * Generate an expression delegate that applies function after verifying all children.
     *
     * @param func Function to apply.
     * @param verify Function to check each arg for validity.
     * @returns Delegate for evaluating an expression.
     */
  }, {
    key: "applyWithError",
    value: function applyWithError(func, verify) {
      return function (expression, state, options) {
        var value;
        var _FunctionUtils$evalua2 = FunctionUtils.evaluateChildren(expression, state, options, verify),
          args = _FunctionUtils$evalua2.args,
          childrenError = _FunctionUtils$evalua2.error;
        var error = childrenError;
        if (!error) {
          try {
            var _func = func(args);
            value = _func.value;
            error = _func.error;
          } catch (e) {
            error = e.message;
          }
        }
        return {
          value: value,
          error: error
        };
      };
    }
    /**
     * Generate an expression delegate that applies function after verifying all children.
     *
     * @param func Function to apply.
     * @param verify Function to check each arg for validity.
     * @returns Delegate for evaluating an expression.
     */
  }, {
    key: "applyWithOptionsAndError",
    value: function applyWithOptionsAndError(func, verify) {
      return function (expression, state, options) {
        var value;
        var _FunctionUtils$evalua3 = FunctionUtils.evaluateChildren(expression, state, options, verify),
          args = _FunctionUtils$evalua3.args,
          childrenError = _FunctionUtils$evalua3.error;
        var error = childrenError;
        if (!error) {
          try {
            var _func2 = func(args, options);
            value = _func2.value;
            error = _func2.error;
          } catch (e) {
            error = e.message;
          }
        }
        return {
          value: value,
          error: error
        };
      };
    }
    /**
     * Generate an expression delegate that applies function after verifying all children.
     *
     * @param func Function to apply.
     * @param verify Function to check each arg for validity.
     * @returns Delegate for evaluating an expression.
     */
  }, {
    key: "applyWithOptions",
    value: function applyWithOptions(func, verify) {
      return function (expression, state, options) {
        var value;
        var _FunctionUtils$evalua4 = FunctionUtils.evaluateChildren(expression, state, options, verify),
          args = _FunctionUtils$evalua4.args,
          childrenError = _FunctionUtils$evalua4.error;
        var error = childrenError;
        if (!error) {
          try {
            value = func(args, options);
          } catch (e) {
            error = e.message;
          }
        }
        return {
          value: value,
          error: error
        };
      };
    }
    /**
     * Generate an expression delegate that applies function on the accumulated value after verifying all children.
     *
     * @param func Function to apply.
     * @param verify Function to check each arg for validity.
     * @returns Delegate for evaluating an expression.
     */
  }, {
    key: "applySequence",
    value: function applySequence(func, verify) {
      return FunctionUtils.apply(function (args) {
        var binaryArgs = [undefined, undefined];
        var soFar = args[0];
        for (var i = 1; i < args.length; i++) {
          binaryArgs[0] = soFar;
          binaryArgs[1] = args[i];
          soFar = func(binaryArgs);
        }
        return soFar;
      }, verify);
    }
    /**
     * Generate an expression delegate that applies function on the accumulated value after verifying all children.
     *
     * @param func Function to apply.
     * @param verify Function to check each arg for validity.
     * @returns Delegate for evaluating an expression.
     */
  }, {
    key: "applySequenceWithError",
    value: function applySequenceWithError(func, verify) {
      return FunctionUtils.applyWithError(function (args) {
        var binaryArgs = [undefined, undefined];
        var soFar = args[0];
        var value;
        var error;
        for (var i = 1; i < args.length; i++) {
          binaryArgs[0] = soFar;
          binaryArgs[1] = args[i];
          var _func3 = func(binaryArgs);
          value = _func3.value;
          error = _func3.error;
          if (error) {
            return {
              value: value,
              error: error
            };
          } else {
            soFar = value;
          }
        }
        return {
          value: soFar,
          error: undefined
        };
      }, verify);
    }
    /**
     *
     * @param args An array of arguments.
     * @param maxArgsLength The max length of a given function.
     * @param locale A locale string
     * @returns The last item from the args param, otherwise the locale string.
     */
  }, {
    key: "determineLocale",
    value: function determineLocale(args, maxArgsLength) {
      var locale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'en-us';
      if (args.length === maxArgsLength) {
        var lastArg = args[maxArgsLength - 1];
        if (typeof lastArg === 'string') {
          locale = lastArg;
        }
      }
      return locale;
    }
    /**
     *
     * @param args An array of arguments.
     * @param maxArgsLength The max length of a given function.
     * @param format A format string.
     * @param locale A locale string.
     * @returns The format and the locale from the args param, otherwise the locale and format strings.
     */
  }, {
    key: "determineFormatAndLocale",
    value: function determineFormatAndLocale(args, maxArgsLength, format) {
      var locale = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'en-us';
      if (maxArgsLength >= 2) {
        if (args.length === maxArgsLength) {
          var lastArg = args[maxArgsLength - 1];
          var secondLastArg = args[maxArgsLength - 2];
          if (typeof lastArg === 'string' && typeof secondLastArg === 'string') {
            format = secondLastArg !== '' ? FunctionUtils.timestampFormatter(secondLastArg) : FunctionUtils.DefaultDateTimeFormat;
            locale = lastArg.substr(0, 2); //dayjs only support two-letter locale representattion
          }
        } else if (args.length === maxArgsLength - 1) {
          var _lastArg = args[maxArgsLength - 2];
          if (typeof _lastArg === 'string') {
            format = FunctionUtils.timestampFormatter(_lastArg);
          }
        }
      }
      return {
        format: format,
        locale: locale
      };
    }
    /**
     * Timestamp formatter, convert C# datetime to day.js format.
     *
     * @param formatter C# datetime format
     * @returns The formated datetime.
     */
  }, {
    key: "timestampFormatter",
    value: function timestampFormatter(formatter) {
      if (!formatter) {
        return FunctionUtils.DefaultDateTimeFormat;
      }
      var result = formatter;
      try {
        result = datetimeFormatConverter_1.convertCSharpDateTimeToDayjs(formatter);
      } catch (_a) {
        // do nothing
      }
      return result;
    }
    /**
     * State object for resolving memory paths.
     *
     * @param expression Expression.
     * @param state Scope.
     * @param options Options used in evaluation.
     * @returns Return the accumulated path and the expression left unable to accumulate.
     */
  }, {
    key: "tryAccumulatePath",
    value: function tryAccumulatePath(expression, state, options) {
      var path = '';
      var left = expression;
      while (left !== undefined) {
        if (left.type === expressionType_1.ExpressionType.Accessor) {
          path = left.children[0].value + '.' + path;
          left = left.children.length === 2 ? left.children[1] : undefined;
        } else if (left.type === expressionType_1.ExpressionType.Element) {
          var _left$children$1$tryE = left.children[1].tryEvaluate(state, options),
            value = _left$children$1$tryE.value,
            error = _left$children$1$tryE.error;
          if (error !== undefined) {
            return {
              path: undefined,
              left: undefined,
              error: error
            };
          }
          if (FunctionUtils.isNumber(parseInt(value))) {
            path = "[".concat(value, "].").concat(path);
          } else if (typeof value === 'string') {
            path = "['".concat(value, "'].").concat(path);
          } else {
            return {
              path: undefined,
              left: undefined,
              error: "".concat(left.children[1].toString(), " doesn't return an int or string")
            };
          }
          left = left.children[0];
        } else {
          break;
        }
      }
      // make sure we generated a valid path
      path = path.replace(/(\.*$)/g, '').replace(/(\.\[)/g, '[');
      if (path === '') {
        path = undefined;
      }
      return {
        path: path,
        left: left,
        error: undefined
      };
    }
    /**
     * Is number helper function.
     *
     * @param instance Input.
     * @returns True if the input is a number.
     */
  }, {
    key: "isNumber",
    value: function isNumber(instance) {
      return instance != null && typeof instance === 'number' && !Number.isNaN(instance);
    }
    /**
     * Equal helper function.
     * Compare the first param and second param.
     *
     * @param obj1 The first value to compare.
     * @param obj2 The second value to compare.
     * @returns A boolean based on the comparison.
     */
  }, {
    key: "commonEquals",
    value: function commonEquals(obj1, obj2) {
      if (obj1 == null || obj2 == null) {
        return obj1 == null && obj2 == null;
      }
      // Array Comparison
      if (Array.isArray(obj1) && Array.isArray(obj2)) {
        if (obj1.length !== obj2.length) {
          return false;
        }
        return obj1.every(function (item, i) {
          return FunctionUtils.commonEquals(item, obj2[i]);
        });
      }
      // Object Comparison
      var propertyCountOfObj1 = FunctionUtils.getPropertyCount(obj1);
      var propertyCountOfObj2 = FunctionUtils.getPropertyCount(obj2);
      if (propertyCountOfObj1 >= 0 && propertyCountOfObj2 >= 0) {
        if (propertyCountOfObj1 !== propertyCountOfObj2) {
          return false;
        }
        var jsonObj1 = FunctionUtils.convertToObj(obj1);
        var jsonObj2 = FunctionUtils.convertToObj(obj2);
        return lodash_isequal_1.default(jsonObj1, jsonObj2);
      }
      // Number Comparison
      if (FunctionUtils.isNumber(obj1) && FunctionUtils.isNumber(obj2)) {
        if (Math.abs(obj1 - obj2) < Number.EPSILON) {
          return true;
        }
      }
      try {
        return obj1 === obj2;
      } catch (_a) {
        return false;
      }
    }
    /**
     * @private
     */
  }, {
    key: "buildTypeValidatorError",
    value: function buildTypeValidatorError(returnType, childExpr, expr) {
      var names = Object.keys(returnType_1.ReturnType).filter(function (x) {
        return !(parseInt(x) >= 0);
      });
      var types = [];
      var _iterator5 = _createForOfIteratorHelper(names),
        _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var name = _step5.value;
          var value = returnType_1.ReturnType[name];
          if ((returnType & value) !== 0) {
            types.push(name);
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
      if (types.length === 1) {
        return "".concat(childExpr, " is not a ").concat(types[0], " expression in ").concat(expr, ".");
      } else {
        var typesStr = types.join(', ');
        return "".concat(childExpr, " in ").concat(expr, " is not any of [").concat(typesStr, "].");
      }
    }
    /**
     * Helper function of get the number of properties of an object.
     *
     * @param obj An object.
     * @returns The number of properties.
     */
  }, {
    key: "getPropertyCount",
    value: function getPropertyCount(obj) {
      var count = -1;
      if (obj != null && !Array.isArray(obj)) {
        if (obj instanceof Map) {
          count = obj.size;
        } else if ((0, _typeof2.default)(obj) === 'object' && !(obj instanceof Date)) {
          count = Object.keys(obj).length;
        }
      }
      return count;
    }
    /**
     * @private
     */
  }, {
    key: "convertToObj",
    value: function convertToObj(instance) {
      if (FunctionUtils.getPropertyCount(instance) >= 0) {
        var entries = instance instanceof Map ? Array.from(instance.entries()) : Object.entries(instance);
        return entries.reduce(function (acc, _ref) {
          var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
            key = _ref2[0],
            value = _ref2[1];
          return Object.assign({}, acc, (0, _defineProperty2.default)({}, key, FunctionUtils.convertToObj(value)));
        }, {});
      } else if (Array.isArray(instance)) {
        // Convert Array
        return instance.map(function (item) {
          return FunctionUtils.convertToObj(item);
        });
      }
      return instance;
    }
  }]);
  return FunctionUtils;
}();
/**
 * The default date time format string.
 */
FunctionUtils.DefaultDateTimeFormat = 'YYYY-MM-DDTHH:mm:ss.SSS[Z]';
exports.FunctionUtils = FunctionUtils;

},{"./datetimeFormatConverter":178,"./expressionType":192,"./returnType":213,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/defineProperty":233,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/slicedToArray":247,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.array.filter.js":572,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.join.js":578,"core-js/modules/es.array.map.js":579,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.map.js":587,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.number.epsilon.js":594,"core-js/modules/es.number.is-integer.js":595,"core-js/modules/es.number.is-nan.js":596,"core-js/modules/es.number.max-safe-integer.js":597,"core-js/modules/es.object.assign.js":601,"core-js/modules/es.object.entries.js":602,"core-js/modules/es.object.keys.js":609,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.string.replace.js":629,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677,"lodash.isequal":729}],197:[function(require,module,exports){
"use strict";

// Generated from src/CommonRegex.g4 by ANTLR 4.7.3-SNAPSHOT
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result["default"] = mod;
  return result;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var ATNDeserializer_1 = require("antlr4ts/atn/ATNDeserializer");
var Lexer_1 = require("antlr4ts/Lexer");
var LexerATNSimulator_1 = require("antlr4ts/atn/LexerATNSimulator");
var VocabularyImpl_1 = require("antlr4ts/VocabularyImpl");
var Utils = __importStar(require("antlr4ts/misc/Utils"));
var CommonRegexLexer = /*#__PURE__*/function (_Lexer_1$Lexer) {
  (0, _inherits2.default)(CommonRegexLexer, _Lexer_1$Lexer);
  var _super = _createSuper(CommonRegexLexer);
  // tslint:enable:no-trailing-whitespace
  function CommonRegexLexer(input) {
    var _this;
    (0, _classCallCheck2.default)(this, CommonRegexLexer);
    _this = _super.call(this, input);
    _this._interp = new LexerATNSimulator_1.LexerATNSimulator(CommonRegexLexer._ATN, (0, _assertThisInitialized2.default)(_this));
    return _this;
  }
  // @Override
  // @NotNull
  (0, _createClass2.default)(CommonRegexLexer, [{
    key: "vocabulary",
    get: function get() {
      return CommonRegexLexer.VOCABULARY;
    }
    // @Override
  }, {
    key: "grammarFileName",
    get: function get() {
      return "CommonRegex.g4";
    }
    // @Override
  }, {
    key: "ruleNames",
    get: function get() {
      return CommonRegexLexer.ruleNames;
    }
    // @Override
  }, {
    key: "serializedATN",
    get: function get() {
      return CommonRegexLexer._serializedATN;
    }
    // @Override
  }, {
    key: "channelNames",
    get: function get() {
      return CommonRegexLexer.channelNames;
    }
    // @Override
  }, {
    key: "modeNames",
    get: function get() {
      return CommonRegexLexer.modeNames;
    }
  }], [{
    key: "_ATN",
    get: function get() {
      if (!CommonRegexLexer.__ATN) {
        CommonRegexLexer.__ATN = new ATNDeserializer_1.ATNDeserializer().deserialize(Utils.toCharArray(CommonRegexLexer._serializedATN));
      }
      return CommonRegexLexer.__ATN;
    }
  }]);
  return CommonRegexLexer;
}(Lexer_1.Lexer);
CommonRegexLexer.Quoted = 1;
CommonRegexLexer.BlockQuoted = 2;
CommonRegexLexer.BellChar = 3;
CommonRegexLexer.ControlChar = 4;
CommonRegexLexer.EscapeChar = 5;
CommonRegexLexer.FormFeed = 6;
CommonRegexLexer.NewLine = 7;
CommonRegexLexer.CarriageReturn = 8;
CommonRegexLexer.Tab = 9;
CommonRegexLexer.Backslash = 10;
CommonRegexLexer.HexChar = 11;
CommonRegexLexer.Dot = 12;
CommonRegexLexer.DecimalDigit = 13;
CommonRegexLexer.NotDecimalDigit = 14;
CommonRegexLexer.CharWithProperty = 15;
CommonRegexLexer.CharWithoutProperty = 16;
CommonRegexLexer.WhiteSpace = 17;
CommonRegexLexer.NotWhiteSpace = 18;
CommonRegexLexer.WordChar = 19;
CommonRegexLexer.NotWordChar = 20;
CommonRegexLexer.CharacterClassStart = 21;
CommonRegexLexer.CharacterClassEnd = 22;
CommonRegexLexer.Caret = 23;
CommonRegexLexer.Hyphen = 24;
CommonRegexLexer.QuestionMark = 25;
CommonRegexLexer.Plus = 26;
CommonRegexLexer.Star = 27;
CommonRegexLexer.OpenBrace = 28;
CommonRegexLexer.CloseBrace = 29;
CommonRegexLexer.Comma = 30;
CommonRegexLexer.EndOfSubject = 31;
CommonRegexLexer.Pipe = 32;
CommonRegexLexer.OpenParen = 33;
CommonRegexLexer.CloseParen = 34;
CommonRegexLexer.LessThan = 35;
CommonRegexLexer.GreaterThan = 36;
CommonRegexLexer.SingleQuote = 37;
CommonRegexLexer.Underscore = 38;
CommonRegexLexer.Colon = 39;
CommonRegexLexer.Hash = 40;
CommonRegexLexer.Equals = 41;
CommonRegexLexer.Exclamation = 42;
CommonRegexLexer.Ampersand = 43;
CommonRegexLexer.ALC = 44;
CommonRegexLexer.BLC = 45;
CommonRegexLexer.CLC = 46;
CommonRegexLexer.DLC = 47;
CommonRegexLexer.ELC = 48;
CommonRegexLexer.FLC = 49;
CommonRegexLexer.GLC = 50;
CommonRegexLexer.HLC = 51;
CommonRegexLexer.ILC = 52;
CommonRegexLexer.JLC = 53;
CommonRegexLexer.KLC = 54;
CommonRegexLexer.LLC = 55;
CommonRegexLexer.MLC = 56;
CommonRegexLexer.NLC = 57;
CommonRegexLexer.OLC = 58;
CommonRegexLexer.PLC = 59;
CommonRegexLexer.QLC = 60;
CommonRegexLexer.RLC = 61;
CommonRegexLexer.SLC = 62;
CommonRegexLexer.TLC = 63;
CommonRegexLexer.ULC = 64;
CommonRegexLexer.VLC = 65;
CommonRegexLexer.WLC = 66;
CommonRegexLexer.XLC = 67;
CommonRegexLexer.YLC = 68;
CommonRegexLexer.ZLC = 69;
CommonRegexLexer.AUC = 70;
CommonRegexLexer.BUC = 71;
CommonRegexLexer.CUC = 72;
CommonRegexLexer.DUC = 73;
CommonRegexLexer.EUC = 74;
CommonRegexLexer.FUC = 75;
CommonRegexLexer.GUC = 76;
CommonRegexLexer.HUC = 77;
CommonRegexLexer.IUC = 78;
CommonRegexLexer.JUC = 79;
CommonRegexLexer.KUC = 80;
CommonRegexLexer.LUC = 81;
CommonRegexLexer.MUC = 82;
CommonRegexLexer.NUC = 83;
CommonRegexLexer.OUC = 84;
CommonRegexLexer.PUC = 85;
CommonRegexLexer.QUC = 86;
CommonRegexLexer.RUC = 87;
CommonRegexLexer.SUC = 88;
CommonRegexLexer.TUC = 89;
CommonRegexLexer.UUC = 90;
CommonRegexLexer.VUC = 91;
CommonRegexLexer.WUC = 92;
CommonRegexLexer.XUC = 93;
CommonRegexLexer.YUC = 94;
CommonRegexLexer.ZUC = 95;
CommonRegexLexer.D1 = 96;
CommonRegexLexer.D2 = 97;
CommonRegexLexer.D3 = 98;
CommonRegexLexer.D4 = 99;
CommonRegexLexer.D5 = 100;
CommonRegexLexer.D6 = 101;
CommonRegexLexer.D7 = 102;
CommonRegexLexer.D8 = 103;
CommonRegexLexer.D9 = 104;
CommonRegexLexer.D0 = 105;
CommonRegexLexer.OtherChar = 106;
// tslint:disable:no-trailing-whitespace
CommonRegexLexer.channelNames = ["DEFAULT_TOKEN_CHANNEL", "HIDDEN"];
// tslint:disable:no-trailing-whitespace
CommonRegexLexer.modeNames = ["DEFAULT_MODE"];
CommonRegexLexer.ruleNames = ["Quoted", "BlockQuoted", "BellChar", "ControlChar", "EscapeChar", "FormFeed", "NewLine", "CarriageReturn", "Tab", "Backslash", "HexChar", "Dot", "DecimalDigit", "NotDecimalDigit", "CharWithProperty", "CharWithoutProperty", "WhiteSpace", "NotWhiteSpace", "WordChar", "NotWordChar", "CharacterClassStart", "CharacterClassEnd", "Caret", "Hyphen", "QuestionMark", "Plus", "Star", "OpenBrace", "CloseBrace", "Comma", "EndOfSubject", "Pipe", "OpenParen", "CloseParen", "LessThan", "GreaterThan", "SingleQuote", "Underscore", "Colon", "Hash", "Equals", "Exclamation", "Ampersand", "ALC", "BLC", "CLC", "DLC", "ELC", "FLC", "GLC", "HLC", "ILC", "JLC", "KLC", "LLC", "MLC", "NLC", "OLC", "PLC", "QLC", "RLC", "SLC", "TLC", "ULC", "VLC", "WLC", "XLC", "YLC", "ZLC", "AUC", "BUC", "CUC", "DUC", "EUC", "FUC", "GUC", "HUC", "IUC", "JUC", "KUC", "LUC", "MUC", "NUC", "OUC", "PUC", "QUC", "RUC", "SUC", "TUC", "UUC", "VUC", "WUC", "XUC", "YUC", "ZUC", "D1", "D2", "D3", "D4", "D5", "D6", "D7", "D8", "D9", "D0", "OtherChar", "UnderscoreAlphaNumerics", "AlphaNumerics", "AlphaNumeric", "NonAlphaNumeric", "HexDigit", "ASCII"];
CommonRegexLexer._LITERAL_NAMES = [undefined, undefined, undefined, "'\\'", "'\\'", "'\\'", "'\\'", "'\\'", "'\\'", "'\\'", "'\\'", undefined, "'.'", "'\\'", "'\\'", undefined, undefined, "'\\'", "'\\'", "'\\'", "'\\'", "'['", "']'", "'^'", "'-'", "'?'", "'+'", "'*'", "'{'", "'}'", "','", "'$'", "'|'", "'('", "')'", "'<'", "'>'", "'''", "'_'", "':'", "'#'", "'='", "'!'", "'&'", "'a'", "'b'", "'c'", "'d'", "'e'", "'f'", "'g'", "'h'", "'i'", "'j'", "'k'", "'l'", "'m'", "'n'", "'o'", "'p'", "'q'", "'r'", "'s'", "'t'", "'u'", "'v'", "'w'", "'x'", "'y'", "'z'", "'A'", "'B'", "'C'", "'D'", "'E'", "'F'", "'G'", "'H'", "'I'", "'J'", "'K'", "'L'", "'M'", "'N'", "'O'", "'P'", "'Q'", "'R'", "'S'", "'T'", "'U'", "'V'", "'W'", "'X'", "'Y'", "'Z'", "'1'", "'2'", "'3'", "'4'", "'5'", "'6'", "'7'", "'8'", "'9'", "'0'"];
CommonRegexLexer._SYMBOLIC_NAMES = [undefined, "Quoted", "BlockQuoted", "BellChar", "ControlChar", "EscapeChar", "FormFeed", "NewLine", "CarriageReturn", "Tab", "Backslash", "HexChar", "Dot", "DecimalDigit", "NotDecimalDigit", "CharWithProperty", "CharWithoutProperty", "WhiteSpace", "NotWhiteSpace", "WordChar", "NotWordChar", "CharacterClassStart", "CharacterClassEnd", "Caret", "Hyphen", "QuestionMark", "Plus", "Star", "OpenBrace", "CloseBrace", "Comma", "EndOfSubject", "Pipe", "OpenParen", "CloseParen", "LessThan", "GreaterThan", "SingleQuote", "Underscore", "Colon", "Hash", "Equals", "Exclamation", "Ampersand", "ALC", "BLC", "CLC", "DLC", "ELC", "FLC", "GLC", "HLC", "ILC", "JLC", "KLC", "LLC", "MLC", "NLC", "OLC", "PLC", "QLC", "RLC", "SLC", "TLC", "ULC", "VLC", "WLC", "XLC", "YLC", "ZLC", "AUC", "BUC", "CUC", "DUC", "EUC", "FUC", "GUC", "HUC", "IUC", "JUC", "KUC", "LUC", "MUC", "NUC", "OUC", "PUC", "QUC", "RUC", "SUC", "TUC", "UUC", "VUC", "WUC", "XUC", "YUC", "ZUC", "D1", "D2", "D3", "D4", "D5", "D6", "D7", "D8", "D9", "D0", "OtherChar"];
CommonRegexLexer.VOCABULARY = new VocabularyImpl_1.VocabularyImpl(CommonRegexLexer._LITERAL_NAMES, CommonRegexLexer._SYMBOLIC_NAMES, []);
CommonRegexLexer._serializedATN = "\x03\uC91D\uCABA\u058D\uAFBA\u4F53\u0607\uEA8B\uC241\x02l\u01FC\b\x01" + "\x04\x02\t\x02\x04\x03\t\x03\x04\x04\t\x04\x04\x05\t\x05\x04\x06\t\x06" + "\x04\x07\t\x07\x04\b\t\b\x04\t\t\t\x04\n\t\n\x04\v\t\v\x04\f\t\f\x04\r" + "\t\r\x04\x0E\t\x0E\x04\x0F\t\x0F\x04\x10\t\x10\x04\x11\t\x11\x04\x12\t" + "\x12\x04\x13\t\x13\x04\x14\t\x14\x04\x15\t\x15\x04\x16\t\x16\x04\x17\t" + "\x17\x04\x18\t\x18\x04\x19\t\x19\x04\x1A\t\x1A\x04\x1B\t\x1B\x04\x1C\t" + "\x1C\x04\x1D\t\x1D\x04\x1E\t\x1E\x04\x1F\t\x1F\x04 \t \x04!\t!\x04\"\t" + "\"\x04#\t#\x04$\t$\x04%\t%\x04&\t&\x04\'\t\'\x04(\t(\x04)\t)\x04*\t*\x04" + "+\t+\x04,\t,\x04-\t-\x04.\t.\x04/\t/\x040\t0\x041\t1\x042\t2\x043\t3\x04" + "4\t4\x045\t5\x046\t6\x047\t7\x048\t8\x049\t9\x04:\t:\x04;\t;\x04<\t<\x04" + "=\t=\x04>\t>\x04?\t?\x04@\t@\x04A\tA\x04B\tB\x04C\tC\x04D\tD\x04E\tE\x04" + "F\tF\x04G\tG\x04H\tH\x04I\tI\x04J\tJ\x04K\tK\x04L\tL\x04M\tM\x04N\tN\x04" + "O\tO\x04P\tP\x04Q\tQ\x04R\tR\x04S\tS\x04T\tT\x04U\tU\x04V\tV\x04W\tW\x04" + "X\tX\x04Y\tY\x04Z\tZ\x04[\t[\x04\\\t\\\x04]\t]\x04^\t^\x04_\t_\x04`\t" + "`\x04a\ta\x04b\tb\x04c\tc\x04d\td\x04e\te\x04f\tf\x04g\tg\x04h\th\x04" + "i\ti\x04j\tj\x04k\tk\x04l\tl\x04m\tm\x04n\tn\x04o\to\x04p\tp\x04q\tq\x03" + "\x02\x03\x02\x03\x02\x03\x03\x03\x03\x03\x03\x03\x03\x07\x03\xEB\n\x03" + "\f\x03\x0E\x03\xEE\v\x03\x03\x03\x03\x03\x03\x03\x03\x04\x03\x04\x03\x04" + "\x03\x05\x03\x05\x03\x05\x03\x06\x03\x06\x03\x06\x03\x07\x03\x07\x03\x07" + "\x03\b\x03\b\x03\b\x03\t\x03\t\x03\t\x03\n\x03\n\x03\n\x03\v\x03\v\x03" + "\f\x03\f\x03\f\x03\f\x03\f\x03\f\x03\f\x03\f\x03\f\x03\f\x06\f\u0114\n" + "\f\r\f\x0E\f\u0115\x03\f\x03\f\x05\f\u011A\n\f\x03\r\x03\r\x03\x0E\x03" + "\x0E\x03\x0E\x03\x0F\x03\x0F\x03\x0F\x03\x10\x03\x10\x03\x10\x03\x10\x03" + "\x10\x03\x10\x03\x10\x03\x11\x03\x11\x03\x11\x03\x11\x03\x11\x03\x11\x03" + "\x11\x03\x12\x03\x12\x03\x12\x03\x13\x03\x13\x03\x13\x03\x14\x03\x14\x03" + "\x14\x03\x15\x03\x15\x03\x15\x03\x16\x03\x16\x03\x17\x03\x17\x03\x18\x03" + "\x18\x03\x19\x03\x19\x03\x1A\x03\x1A\x03\x1B\x03\x1B\x03\x1C\x03\x1C\x03" + "\x1D\x03\x1D\x03\x1E\x03\x1E\x03\x1F\x03\x1F\x03 \x03 \x03!\x03!\x03\"" + "\x03\"\x03#\x03#\x03$\x03$\x03%\x03%\x03&\x03&\x03\'\x03\'\x03(\x03(\x03" + ")\x03)\x03*\x03*\x03+\x03+\x03,\x03,\x03-\x03-\x03.\x03.\x03/\x03/\x03" + "0\x030\x031\x031\x032\x032\x033\x033\x034\x034\x035\x035\x036\x036\x03" + "7\x037\x038\x038\x039\x039\x03:\x03:\x03;\x03;\x03<\x03<\x03=\x03=\x03" + ">\x03>\x03?\x03?\x03@\x03@\x03A\x03A\x03B\x03B\x03C\x03C\x03D\x03D\x03" + "E\x03E\x03F\x03F\x03G\x03G\x03H\x03H\x03I\x03I\x03J\x03J\x03K\x03K\x03" + "L\x03L\x03M\x03M\x03N\x03N\x03O\x03O\x03P\x03P\x03Q\x03Q\x03R\x03R\x03" + "S\x03S\x03T\x03T\x03U\x03U\x03V\x03V\x03W\x03W\x03X\x03X\x03Y\x03Y\x03" + "Z\x03Z\x03[\x03[\x03\\\x03\\\x03]\x03]\x03^\x03^\x03_\x03_\x03`\x03`\x03" + "a\x03a\x03b\x03b\x03c\x03c\x03d\x03d\x03e\x03e\x03f\x03f\x03g\x03g\x03" + "h\x03h\x03i\x03i\x03j\x03j\x03k\x03k\x03l\x03l\x06l\u01EC\nl\rl\x0El\u01ED" + "\x03m\x06m\u01F1\nm\rm\x0Em\u01F2\x03n\x03n\x03o\x03o\x03p\x03p\x03q\x03" + "q\x03\xEC\x02\x02r\x03\x02\x03\x05\x02\x04\x07\x02\x05\t\x02\x06\v\x02" + "\x07\r\x02\b\x0F\x02\t\x11\x02\n\x13\x02\v\x15\x02\f\x17\x02\r\x19\x02" + "\x0E\x1B\x02\x0F\x1D\x02\x10\x1F\x02\x11!\x02\x12#\x02\x13%\x02\x14\'" + "\x02\x15)\x02\x16+\x02\x17-\x02\x18/\x02\x191\x02\x1A3\x02\x1B5\x02\x1C" + "7\x02\x1D9\x02\x1E;\x02\x1F=\x02 ?\x02!A\x02\"C\x02#E\x02$G\x02%I\x02" + "&K\x02\'M\x02(O\x02)Q\x02*S\x02+U\x02,W\x02-Y\x02.[\x02/]\x020_\x021a" + "\x022c\x023e\x024g\x025i\x026k\x027m\x028o\x029q\x02:s\x02;u\x02<w\x02" + "=y\x02>{\x02?}\x02@\x7F\x02A\x81\x02B\x83\x02C\x85\x02D\x87\x02E\x89\x02" + "F\x8B\x02G\x8D\x02H\x8F\x02I\x91\x02J\x93\x02K\x95\x02L\x97\x02M\x99\x02" + "N\x9B\x02O\x9D\x02P\x9F\x02Q\xA1\x02R\xA3\x02S\xA5\x02T\xA7\x02U\xA9\x02" + "V\xAB\x02W\xAD\x02X\xAF\x02Y\xB1\x02Z\xB3\x02[\xB5\x02\\\xB7\x02]\xB9" + "\x02^\xBB\x02_\xBD\x02`\xBF\x02a\xC1\x02b\xC3\x02c\xC5\x02d\xC7\x02e\xC9" + "\x02f\xCB\x02g\xCD\x02h\xCF\x02i\xD1\x02j\xD3\x02k\xD5\x02l\xD7\x02\x02" + "\xD9\x02\x02\xDB\x02\x02\xDD\x02\x02\xDF\x02\x02\xE1\x02\x02\x03\x02\x05" + "\x05\x022;C\\c|\x05\x022;CHch\x03\x02\x02\x81\x02\u01FB\x02\x03\x03\x02" + "\x02\x02\x02\x05\x03\x02\x02\x02\x02\x07\x03\x02\x02\x02\x02\t\x03\x02" + "\x02\x02\x02\v\x03\x02\x02\x02\x02\r\x03\x02\x02\x02\x02\x0F\x03\x02\x02" + "\x02\x02\x11\x03\x02\x02\x02\x02\x13\x03\x02\x02\x02\x02\x15\x03\x02\x02" + "\x02\x02\x17\x03\x02\x02\x02\x02\x19\x03\x02\x02\x02\x02\x1B\x03\x02\x02" + "\x02\x02\x1D\x03\x02\x02\x02\x02\x1F\x03\x02\x02\x02\x02!\x03\x02\x02" + "\x02\x02#\x03\x02\x02\x02\x02%\x03\x02\x02\x02\x02\'\x03\x02\x02\x02\x02" + ")\x03\x02\x02\x02\x02+\x03\x02\x02\x02\x02-\x03\x02\x02\x02\x02/\x03\x02" + "\x02\x02\x021\x03\x02\x02\x02\x023\x03\x02\x02\x02\x025\x03\x02\x02\x02" + "\x027\x03\x02\x02\x02\x029\x03\x02\x02\x02\x02;\x03\x02\x02\x02\x02=\x03" + "\x02\x02\x02\x02?\x03\x02\x02\x02\x02A\x03\x02\x02\x02\x02C\x03\x02\x02" + "\x02\x02E\x03\x02\x02\x02\x02G\x03\x02\x02\x02\x02I\x03\x02\x02\x02\x02" + "K\x03\x02\x02\x02\x02M\x03\x02\x02\x02\x02O\x03\x02\x02\x02\x02Q\x03\x02" + "\x02\x02\x02S\x03\x02\x02\x02\x02U\x03\x02\x02\x02\x02W\x03\x02\x02\x02" + "\x02Y\x03\x02\x02\x02\x02[\x03\x02\x02\x02\x02]\x03\x02\x02\x02\x02_\x03" + "\x02\x02\x02\x02a\x03\x02\x02\x02\x02c\x03\x02\x02\x02\x02e\x03\x02\x02" + "\x02\x02g\x03\x02\x02\x02\x02i\x03\x02\x02\x02\x02k\x03\x02\x02\x02\x02" + "m\x03\x02\x02\x02\x02o\x03\x02\x02\x02\x02q\x03\x02\x02\x02\x02s\x03\x02" + "\x02\x02\x02u\x03\x02\x02\x02\x02w\x03\x02\x02\x02\x02y\x03\x02\x02\x02" + "\x02{\x03\x02\x02\x02\x02}\x03\x02\x02\x02\x02\x7F\x03\x02\x02\x02\x02" + "\x81\x03\x02\x02\x02\x02\x83\x03\x02\x02\x02\x02\x85\x03\x02\x02\x02\x02" + "\x87\x03\x02\x02\x02\x02\x89\x03\x02\x02\x02\x02\x8B\x03\x02\x02\x02\x02" + "\x8D\x03\x02\x02\x02\x02\x8F\x03\x02\x02\x02\x02\x91\x03\x02\x02\x02\x02" + "\x93\x03\x02\x02\x02\x02\x95\x03\x02\x02\x02\x02\x97\x03\x02\x02\x02\x02" + "\x99\x03\x02\x02\x02\x02\x9B\x03\x02\x02\x02\x02\x9D\x03\x02\x02\x02\x02" + "\x9F\x03\x02\x02\x02\x02\xA1\x03\x02\x02\x02\x02\xA3\x03\x02\x02\x02\x02" + "\xA5\x03\x02\x02\x02\x02\xA7\x03\x02\x02\x02\x02\xA9\x03\x02\x02\x02\x02" + "\xAB\x03\x02\x02\x02\x02\xAD\x03\x02\x02\x02\x02\xAF\x03\x02\x02\x02\x02" + "\xB1\x03\x02\x02\x02\x02\xB3\x03\x02\x02\x02\x02\xB5\x03\x02\x02\x02\x02" + "\xB7\x03\x02\x02\x02\x02\xB9\x03\x02\x02\x02\x02\xBB\x03\x02\x02\x02\x02" + "\xBD\x03\x02\x02\x02\x02\xBF\x03\x02\x02\x02\x02\xC1\x03\x02\x02\x02\x02" + "\xC3\x03\x02\x02\x02\x02\xC5\x03\x02\x02\x02\x02\xC7\x03\x02\x02\x02\x02" + "\xC9\x03\x02\x02\x02\x02\xCB\x03\x02\x02\x02\x02\xCD\x03\x02\x02\x02\x02" + "\xCF\x03\x02\x02\x02\x02\xD1\x03\x02\x02\x02\x02\xD3\x03\x02\x02\x02\x02" + "\xD5\x03\x02\x02\x02\x03\xE3\x03\x02\x02\x02\x05\xE6\x03\x02\x02\x02\x07" + "\xF2\x03\x02\x02\x02\t\xF5\x03\x02\x02\x02\v\xF8\x03\x02\x02\x02\r\xFB" + "\x03\x02\x02\x02\x0F\xFE\x03\x02\x02\x02\x11\u0101\x03\x02\x02\x02\x13" + "\u0104\x03\x02\x02\x02\x15\u0107\x03\x02\x02\x02\x17\u0109\x03\x02\x02" + "\x02\x19\u011B\x03\x02\x02\x02\x1B\u011D\x03\x02\x02\x02\x1D\u0120\x03" + "\x02\x02\x02\x1F\u0123\x03\x02\x02\x02!\u012A\x03\x02\x02\x02#\u0131\x03" + "\x02\x02\x02%\u0134\x03\x02\x02\x02'\u0137\x03\x02\x02\x02)\u013A\x03" + "\x02\x02\x02+\u013D\x03\x02\x02\x02-\u013F\x03\x02\x02\x02/\u0141\x03" + "\x02\x02\x021\u0143\x03\x02\x02\x023\u0145\x03\x02\x02\x025\u0147\x03" + "\x02\x02\x027\u0149\x03\x02\x02\x029\u014B\x03\x02\x02\x02;\u014D\x03" + "\x02\x02\x02=\u014F\x03\x02\x02\x02?\u0151\x03\x02\x02\x02A\u0153\x03" + "\x02\x02\x02C\u0155\x03\x02\x02\x02E\u0157\x03\x02\x02\x02G\u0159\x03" + "\x02\x02\x02I\u015B\x03\x02\x02\x02K\u015D\x03\x02\x02\x02M\u015F\x03" + "\x02\x02\x02O\u0161\x03\x02\x02\x02Q\u0163\x03\x02\x02\x02S\u0165\x03" + "\x02\x02\x02U\u0167\x03\x02\x02\x02W\u0169\x03\x02\x02\x02Y\u016B\x03" + "\x02\x02\x02[\u016D\x03\x02\x02\x02]\u016F\x03\x02\x02\x02_\u0171\x03" + "\x02\x02\x02a\u0173\x03\x02\x02\x02c\u0175\x03\x02\x02\x02e\u0177\x03" + "\x02\x02\x02g\u0179\x03\x02\x02\x02i\u017B\x03\x02\x02\x02k\u017D\x03" + "\x02\x02\x02m\u017F\x03\x02\x02\x02o\u0181\x03\x02\x02\x02q\u0183\x03" + "\x02\x02\x02s\u0185\x03\x02\x02\x02u\u0187\x03\x02\x02\x02w\u0189\x03" + "\x02\x02\x02y\u018B\x03\x02\x02\x02{\u018D\x03\x02\x02\x02}\u018F\x03" + "\x02\x02\x02\x7F\u0191\x03\x02\x02\x02\x81\u0193\x03\x02\x02\x02\x83\u0195" + "\x03\x02\x02\x02\x85\u0197\x03\x02\x02\x02\x87\u0199\x03\x02\x02\x02\x89" + "\u019B\x03\x02\x02\x02\x8B\u019D\x03\x02\x02\x02\x8D\u019F\x03\x02\x02" + "\x02\x8F\u01A1\x03\x02\x02\x02\x91\u01A3\x03\x02\x02\x02\x93\u01A5\x03" + "\x02\x02\x02\x95\u01A7\x03\x02\x02\x02\x97\u01A9\x03\x02\x02\x02\x99\u01AB" + "\x03\x02\x02\x02\x9B\u01AD\x03\x02\x02\x02\x9D\u01AF\x03\x02\x02\x02\x9F" + "\u01B1\x03\x02\x02\x02\xA1\u01B3\x03\x02\x02\x02\xA3\u01B5\x03\x02\x02" + "\x02\xA5\u01B7\x03\x02\x02\x02\xA7\u01B9\x03\x02\x02\x02\xA9\u01BB\x03" + "\x02\x02\x02\xAB\u01BD\x03\x02\x02\x02\xAD\u01BF\x03\x02\x02\x02\xAF\u01C1" + "\x03\x02\x02\x02\xB1\u01C3\x03\x02\x02\x02\xB3\u01C5\x03\x02\x02\x02\xB5" + "\u01C7\x03\x02\x02\x02\xB7\u01C9\x03\x02\x02\x02\xB9\u01CB\x03\x02\x02" + "\x02\xBB\u01CD\x03\x02\x02\x02\xBD\u01CF\x03\x02\x02\x02\xBF\u01D1\x03" + "\x02\x02\x02\xC1\u01D3\x03\x02\x02\x02\xC3\u01D5\x03\x02\x02\x02\xC5\u01D7" + "\x03\x02\x02\x02\xC7\u01D9\x03\x02\x02\x02\xC9\u01DB\x03\x02\x02\x02\xCB" + "\u01DD\x03\x02\x02\x02\xCD\u01DF\x03\x02\x02\x02\xCF\u01E1\x03\x02\x02" + "\x02\xD1\u01E3\x03\x02\x02\x02\xD3\u01E5\x03\x02\x02\x02\xD5\u01E7\x03" + "\x02\x02\x02\xD7\u01EB\x03\x02\x02\x02\xD9\u01F0\x03\x02\x02\x02\xDB\u01F4" + "\x03\x02\x02\x02\xDD\u01F6\x03\x02\x02\x02\xDF\u01F8\x03\x02\x02\x02\xE1" + "\u01FA\x03\x02\x02\x02\xE3\xE4\x07^\x02\x02\xE4\xE5\x05\xDDo\x02\xE5\x04" + "\x03\x02\x02\x02\xE6\xE7\x07^\x02\x02\xE7\xE8\x07S\x02\x02\xE8\xEC\x03" + "\x02\x02\x02\xE9\xEB\v\x02\x02\x02\xEA\xE9\x03\x02\x02\x02\xEB\xEE\x03" + "\x02\x02\x02\xEC\xED\x03\x02\x02\x02\xEC\xEA\x03\x02\x02\x02\xED\xEF\x03" + "\x02\x02\x02\xEE\xEC\x03\x02\x02\x02\xEF\xF0\x07^\x02\x02\xF0\xF1\x07" + "G\x02\x02\xF1\x06\x03\x02\x02\x02\xF2\xF3\x07^\x02\x02\xF3\xF4\x07c\x02" + "\x02\xF4\b\x03\x02\x02\x02\xF5\xF6\x07^\x02\x02\xF6\xF7\x07e\x02\x02\xF7" + "\n\x03\x02\x02\x02\xF8\xF9\x07^\x02\x02\xF9\xFA\x07g\x02\x02\xFA\f\x03" + "\x02\x02\x02\xFB\xFC\x07^\x02\x02\xFC\xFD\x07h\x02\x02\xFD\x0E\x03\x02" + "\x02\x02\xFE\xFF\x07^\x02\x02\xFF\u0100\x07p\x02\x02\u0100\x10\x03\x02" + "\x02\x02\u0101\u0102\x07^\x02\x02\u0102\u0103\x07t\x02\x02\u0103\x12\x03" + "\x02\x02\x02\u0104\u0105\x07^\x02\x02\u0105\u0106\x07v\x02\x02\u0106\x14" + "\x03\x02\x02\x02\u0107\u0108\x07^\x02\x02\u0108\x16\x03\x02\x02\x02\u0109" + "\u010A\x07^\x02\x02\u010A\u010B\x07z\x02\x02\u010B\u0119\x03\x02\x02\x02" + "\u010C\u010D\x05\xDFp\x02\u010D\u010E\x05\xDFp\x02\u010E\u011A\x03\x02" + "\x02\x02\u010F\u0110\x07}\x02\x02\u0110\u0111\x05\xDFp\x02\u0111\u0113" + "\x05\xDFp\x02\u0112\u0114\x05\xDFp\x02\u0113\u0112\x03\x02\x02\x02\u0114" + "\u0115\x03\x02\x02\x02\u0115\u0113\x03\x02\x02\x02\u0115\u0116\x03\x02" + "\x02\x02\u0116\u0117\x03\x02\x02\x02\u0117\u0118\x07\x7F\x02\x02\u0118" + "\u011A\x03\x02\x02\x02\u0119\u010C\x03\x02\x02\x02\u0119\u010F\x03\x02" + "\x02\x02\u011A\x18\x03\x02\x02\x02\u011B\u011C\x070\x02\x02\u011C\x1A" + "\x03\x02\x02\x02\u011D\u011E\x07^\x02\x02\u011E\u011F\x07f\x02\x02\u011F" + "\x1C\x03\x02\x02\x02\u0120\u0121\x07^\x02\x02\u0121\u0122\x07F\x02\x02" + "\u0122\x1E\x03\x02\x02\x02\u0123\u0124\x07^\x02\x02\u0124\u0125\x07r\x02" + "\x02\u0125\u0126\x07}\x02\x02\u0126\u0127\x03\x02\x02\x02\u0127\u0128" + "\x05\xD7l\x02\u0128\u0129\x07\x7F\x02\x02\u0129 \x03\x02\x02\x02\u012A" + "\u012B\x07^\x02\x02\u012B\u012C\x07R\x02\x02\u012C\u012D\x07}\x02\x02" + "\u012D\u012E\x03\x02\x02\x02\u012E\u012F\x05\xD7l\x02\u012F\u0130\x07" + "\x7F\x02\x02\u0130\"\x03\x02\x02\x02\u0131\u0132\x07^\x02\x02\u0132\u0133" + "\x07u\x02\x02\u0133$\x03\x02\x02\x02\u0134\u0135\x07^\x02\x02\u0135\u0136" + "\x07U\x02\x02\u0136&\x03\x02\x02\x02\u0137\u0138\x07^\x02\x02\u0138\u0139" + "\x07y\x02\x02\u0139(\x03\x02\x02\x02\u013A\u013B\x07^\x02\x02\u013B\u013C" + "\x07Y\x02\x02\u013C*\x03\x02\x02\x02\u013D\u013E\x07]\x02\x02\u013E,\x03" + "\x02\x02\x02\u013F\u0140\x07_\x02\x02\u0140.\x03\x02\x02\x02\u0141\u0142" + "\x07`\x02\x02\u01420\x03\x02\x02\x02\u0143\u0144\x07/\x02\x02\u01442\x03" + "\x02\x02\x02\u0145\u0146\x07A\x02\x02\u01464\x03\x02\x02\x02\u0147\u0148" + "\x07-\x02\x02\u01486\x03\x02\x02\x02\u0149\u014A\x07,\x02\x02\u014A8\x03" + "\x02\x02\x02\u014B\u014C\x07}\x02\x02\u014C:\x03\x02\x02\x02\u014D\u014E" + "\x07\x7F\x02\x02\u014E<\x03\x02\x02\x02\u014F\u0150\x07.\x02\x02\u0150" + ">\x03\x02\x02\x02\u0151\u0152\x07&\x02\x02\u0152@\x03\x02\x02\x02\u0153" + "\u0154\x07~\x02\x02\u0154B\x03\x02\x02\x02\u0155\u0156\x07*\x02\x02\u0156" + "D\x03\x02\x02\x02\u0157\u0158\x07+\x02\x02\u0158F\x03\x02\x02\x02\u0159" + "\u015A\x07>\x02\x02\u015AH\x03\x02\x02\x02\u015B\u015C\x07@\x02\x02\u015C" + "J\x03\x02\x02\x02\u015D\u015E\x07)\x02\x02\u015EL\x03\x02\x02\x02\u015F" + "\u0160\x07a\x02\x02\u0160N\x03\x02\x02\x02\u0161\u0162\x07<\x02\x02\u0162" + "P\x03\x02\x02\x02\u0163\u0164\x07%\x02\x02\u0164R\x03\x02\x02\x02\u0165" + "\u0166\x07?\x02\x02\u0166T\x03\x02\x02\x02\u0167\u0168\x07#\x02\x02\u0168" + "V\x03\x02\x02\x02\u0169\u016A\x07(\x02\x02\u016AX\x03\x02\x02\x02\u016B" + "\u016C\x07c\x02\x02\u016CZ\x03\x02\x02\x02\u016D\u016E\x07d\x02\x02\u016E" + "\\\x03\x02\x02\x02\u016F\u0170\x07e\x02\x02\u0170^\x03\x02\x02\x02\u0171" + "\u0172\x07f\x02\x02\u0172`\x03\x02\x02\x02\u0173\u0174\x07g\x02\x02\u0174" + "b\x03\x02\x02\x02\u0175\u0176\x07h\x02\x02\u0176d\x03\x02\x02\x02\u0177" + "\u0178\x07i\x02\x02\u0178f\x03\x02\x02\x02\u0179\u017A\x07j\x02\x02\u017A" + "h\x03\x02\x02\x02\u017B\u017C\x07k\x02\x02\u017Cj\x03\x02\x02\x02\u017D" + "\u017E\x07l\x02\x02\u017El\x03\x02\x02\x02\u017F\u0180\x07m\x02\x02\u0180" + "n\x03\x02\x02\x02\u0181\u0182\x07n\x02\x02\u0182p\x03\x02\x02\x02\u0183" + "\u0184\x07o\x02\x02\u0184r\x03\x02\x02\x02\u0185\u0186\x07p\x02\x02\u0186" + "t\x03\x02\x02\x02\u0187\u0188\x07q\x02\x02\u0188v\x03\x02\x02\x02\u0189" + "\u018A\x07r\x02\x02\u018Ax\x03\x02\x02\x02\u018B\u018C\x07s\x02\x02\u018C" + "z\x03\x02\x02\x02\u018D\u018E\x07t\x02\x02\u018E|\x03\x02\x02\x02\u018F" + "\u0190\x07u\x02\x02\u0190~\x03\x02\x02\x02\u0191\u0192\x07v\x02\x02\u0192" + "\x80\x03\x02\x02\x02\u0193\u0194\x07w\x02\x02\u0194\x82\x03\x02\x02\x02" + "\u0195\u0196\x07x\x02\x02\u0196\x84\x03\x02\x02\x02\u0197\u0198\x07y\x02" + "\x02\u0198\x86\x03\x02\x02\x02\u0199\u019A\x07z\x02\x02\u019A\x88\x03" + "\x02\x02\x02\u019B\u019C\x07{\x02\x02\u019C\x8A\x03\x02\x02\x02\u019D" + "\u019E\x07|\x02\x02\u019E\x8C\x03\x02\x02\x02\u019F\u01A0\x07C\x02\x02" + "\u01A0\x8E\x03\x02\x02\x02\u01A1\u01A2\x07D\x02\x02\u01A2\x90\x03\x02" + "\x02\x02\u01A3\u01A4\x07E\x02\x02\u01A4\x92\x03\x02\x02\x02\u01A5\u01A6" + "\x07F\x02\x02\u01A6\x94\x03\x02\x02\x02\u01A7\u01A8\x07G\x02\x02\u01A8" + "\x96\x03\x02\x02\x02\u01A9\u01AA\x07H\x02\x02\u01AA\x98\x03\x02\x02\x02" + "\u01AB\u01AC\x07I\x02\x02\u01AC\x9A\x03\x02\x02\x02\u01AD\u01AE\x07J\x02" + "\x02\u01AE\x9C\x03\x02\x02\x02\u01AF\u01B0\x07K\x02\x02\u01B0\x9E\x03" + "\x02\x02\x02\u01B1\u01B2\x07L\x02\x02\u01B2\xA0\x03\x02\x02\x02\u01B3" + "\u01B4\x07M\x02\x02\u01B4\xA2\x03\x02\x02\x02\u01B5\u01B6\x07N\x02\x02" + "\u01B6\xA4\x03\x02\x02\x02\u01B7\u01B8\x07O\x02\x02\u01B8\xA6\x03\x02" + "\x02\x02\u01B9\u01BA\x07P\x02\x02\u01BA\xA8\x03\x02\x02\x02\u01BB\u01BC" + "\x07Q\x02\x02\u01BC\xAA\x03\x02\x02\x02\u01BD\u01BE\x07R\x02\x02\u01BE" + "\xAC\x03\x02\x02\x02\u01BF\u01C0\x07S\x02\x02\u01C0\xAE\x03\x02\x02\x02" + "\u01C1\u01C2\x07T\x02\x02\u01C2\xB0\x03\x02\x02\x02\u01C3\u01C4\x07U\x02" + "\x02\u01C4\xB2\x03\x02\x02\x02\u01C5\u01C6\x07V\x02\x02\u01C6\xB4\x03" + "\x02\x02\x02\u01C7\u01C8\x07W\x02\x02\u01C8\xB6\x03\x02\x02\x02\u01C9" + "\u01CA\x07X\x02\x02\u01CA\xB8\x03\x02\x02\x02\u01CB\u01CC\x07Y\x02\x02" + "\u01CC\xBA\x03\x02\x02\x02\u01CD\u01CE\x07Z\x02\x02\u01CE\xBC\x03\x02" + "\x02\x02\u01CF\u01D0\x07[\x02\x02\u01D0\xBE\x03\x02\x02\x02\u01D1\u01D2" + "\x07\\\x02\x02\u01D2\xC0\x03\x02\x02\x02\u01D3\u01D4\x073\x02\x02\u01D4" + "\xC2\x03\x02\x02\x02\u01D5\u01D6\x074\x02\x02\u01D6\xC4\x03\x02\x02\x02" + "\u01D7\u01D8\x075\x02\x02\u01D8\xC6\x03\x02\x02\x02\u01D9\u01DA\x076\x02" + "\x02\u01DA\xC8\x03\x02\x02\x02\u01DB\u01DC\x077\x02\x02\u01DC\xCA\x03" + "\x02\x02\x02\u01DD\u01DE\x078\x02\x02\u01DE\xCC\x03\x02\x02\x02\u01DF" + "\u01E0\x079\x02\x02\u01E0\xCE\x03\x02\x02\x02\u01E1\u01E2\x07:\x02\x02" + "\u01E2\xD0\x03\x02\x02\x02\u01E3\u01E4\x07;\x02\x02\u01E4\xD2\x03\x02" + "\x02\x02\u01E5\u01E6\x072\x02\x02\u01E6\xD4\x03\x02\x02\x02\u01E7\u01E8" + "\x0B\x02\x02\x02\u01E8\xD6\x03\x02\x02\x02\u01E9\u01EC\x07a\x02\x02\u01EA" + "\u01EC\x05\xDBn\x02\u01EB\u01E9\x03\x02\x02\x02\u01EB\u01EA\x03\x02\x02" + "\x02\u01EC\u01ED\x03\x02\x02\x02\u01ED\u01EB\x03\x02\x02\x02\u01ED\u01EE" + "\x03\x02\x02\x02\u01EE\xD8\x03\x02\x02\x02\u01EF\u01F1\x05\xDBn\x02\u01F0" + "\u01EF\x03\x02\x02\x02\u01F1\u01F2\x03\x02\x02\x02\u01F2\u01F0\x03\x02" + "\x02\x02\u01F2\u01F3\x03\x02\x02\x02\u01F3\xDA\x03\x02\x02\x02\u01F4\u01F5" + "\t\x02\x02\x02\u01F5\xDC\x03\x02\x02\x02\u01F6\u01F7\n\x02\x02\x02\u01F7" + "\xDE\x03\x02\x02\x02\u01F8\u01F9\t\x03\x02\x02\u01F9\xE0\x03\x02\x02\x02" + "\u01FA\u01FB\t\x04\x02\x02\u01FB\xE2\x03\x02\x02\x02\t\x02\xEC\u0115\u0119" + "\u01EB\u01ED\u01F2\x02";
exports.CommonRegexLexer = CommonRegexLexer;

},{"@babel/runtime/helpers/assertThisInitialized":229,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"antlr4ts/Lexer":280,"antlr4ts/VocabularyImpl":298,"antlr4ts/atn/ATNDeserializer":303,"antlr4ts/atn/LexerATNSimulator":324,"antlr4ts/misc/Utils":385,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],198:[function(require,module,exports){
"use strict";

// Generated from src/CommonRegex.g4 by ANTLR 4.7.3-SNAPSHOT
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.match.js");
require("core-js/modules/es.function.name.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result["default"] = mod;
  return result;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var ATNDeserializer_1 = require("antlr4ts/atn/ATNDeserializer");
var NoViableAltException_1 = require("antlr4ts/NoViableAltException");
var Parser_1 = require("antlr4ts/Parser");
var ParserRuleContext_1 = require("antlr4ts/ParserRuleContext");
var ParserATNSimulator_1 = require("antlr4ts/atn/ParserATNSimulator");
var RecognitionException_1 = require("antlr4ts/RecognitionException");
var Token_1 = require("antlr4ts/Token");
var VocabularyImpl_1 = require("antlr4ts/VocabularyImpl");
var Utils = __importStar(require("antlr4ts/misc/Utils"));
var CommonRegexParser = /*#__PURE__*/function (_Parser_1$Parser) {
  (0, _inherits2.default)(CommonRegexParser, _Parser_1$Parser);
  var _super = _createSuper(CommonRegexParser);
  function CommonRegexParser(input) {
    var _this;
    (0, _classCallCheck2.default)(this, CommonRegexParser);
    _this = _super.call(this, input);
    _this._interp = new ParserATNSimulator_1.ParserATNSimulator(CommonRegexParser._ATN, (0, _assertThisInitialized2.default)(_this));
    return _this;
  }
  // @Override
  // @NotNull
  (0, _createClass2.default)(CommonRegexParser, [{
    key: "vocabulary",
    get: function get() {
      return CommonRegexParser.VOCABULARY;
    }
    // tslint:enable:no-trailing-whitespace
    // @Override
  }, {
    key: "grammarFileName",
    get: function get() {
      return "CommonRegex.g4";
    }
    // @Override
  }, {
    key: "ruleNames",
    get: function get() {
      return CommonRegexParser.ruleNames;
    }
    // @Override
  }, {
    key: "serializedATN",
    get: function get() {
      return CommonRegexParser._serializedATN;
    }
    // @RuleVersion(0)
  }, {
    key: "parse",
    value: function parse() {
      var _localctx = new ParseContext(this._ctx, this.state);
      this.enterRule(_localctx, 0, CommonRegexParser.RULE_parse);
      try {
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 54;
          this.alternation();
          this.state = 55;
          this.match(CommonRegexParser.EOF);
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
  }, {
    key: "alternation",
    value: function alternation() {
      var _localctx = new AlternationContext(this._ctx, this.state);
      this.enterRule(_localctx, 2, CommonRegexParser.RULE_alternation);
      var _la;
      try {
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 57;
          this.expr();
          this.state = 62;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          while (_la === CommonRegexParser.Pipe) {
            {
              {
                this.state = 58;
                this.match(CommonRegexParser.Pipe);
                this.state = 59;
                this.expr();
              }
            }
            this.state = 64;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
  }, {
    key: "expr",
    value: function expr() {
      var _localctx = new ExprContext(this._ctx, this.state);
      this.enterRule(_localctx, 4, CommonRegexParser.RULE_expr);
      var _la;
      try {
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 68;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          while ((_la & ~0x1F) === 0 && (1 << _la & (1 << CommonRegexParser.Quoted | 1 << CommonRegexParser.BlockQuoted | 1 << CommonRegexParser.BellChar | 1 << CommonRegexParser.ControlChar | 1 << CommonRegexParser.EscapeChar | 1 << CommonRegexParser.FormFeed | 1 << CommonRegexParser.NewLine | 1 << CommonRegexParser.CarriageReturn | 1 << CommonRegexParser.Tab | 1 << CommonRegexParser.Backslash | 1 << CommonRegexParser.HexChar | 1 << CommonRegexParser.Dot | 1 << CommonRegexParser.DecimalDigit | 1 << CommonRegexParser.NotDecimalDigit | 1 << CommonRegexParser.CharWithProperty | 1 << CommonRegexParser.CharWithoutProperty | 1 << CommonRegexParser.WhiteSpace | 1 << CommonRegexParser.NotWhiteSpace | 1 << CommonRegexParser.WordChar | 1 << CommonRegexParser.NotWordChar | 1 << CommonRegexParser.CharacterClassStart | 1 << CommonRegexParser.CharacterClassEnd | 1 << CommonRegexParser.Caret | 1 << CommonRegexParser.Hyphen | 1 << CommonRegexParser.OpenBrace | 1 << CommonRegexParser.CloseBrace | 1 << CommonRegexParser.Comma | 1 << CommonRegexParser.EndOfSubject)) !== 0 || (_la - 33 & ~0x1F) === 0 && (1 << _la - 33 & (1 << CommonRegexParser.OpenParen - 33 | 1 << CommonRegexParser.LessThan - 33 | 1 << CommonRegexParser.GreaterThan - 33 | 1 << CommonRegexParser.SingleQuote - 33 | 1 << CommonRegexParser.Underscore - 33 | 1 << CommonRegexParser.Colon - 33 | 1 << CommonRegexParser.Hash - 33 | 1 << CommonRegexParser.Equals - 33 | 1 << CommonRegexParser.Exclamation - 33 | 1 << CommonRegexParser.Ampersand - 33 | 1 << CommonRegexParser.ALC - 33 | 1 << CommonRegexParser.BLC - 33 | 1 << CommonRegexParser.CLC - 33 | 1 << CommonRegexParser.DLC - 33 | 1 << CommonRegexParser.ELC - 33 | 1 << CommonRegexParser.FLC - 33 | 1 << CommonRegexParser.GLC - 33 | 1 << CommonRegexParser.HLC - 33 | 1 << CommonRegexParser.ILC - 33 | 1 << CommonRegexParser.JLC - 33 | 1 << CommonRegexParser.KLC - 33 | 1 << CommonRegexParser.LLC - 33 | 1 << CommonRegexParser.MLC - 33 | 1 << CommonRegexParser.NLC - 33 | 1 << CommonRegexParser.OLC - 33 | 1 << CommonRegexParser.PLC - 33 | 1 << CommonRegexParser.QLC - 33 | 1 << CommonRegexParser.RLC - 33 | 1 << CommonRegexParser.SLC - 33 | 1 << CommonRegexParser.TLC - 33 | 1 << CommonRegexParser.ULC - 33)) !== 0 || (_la - 65 & ~0x1F) === 0 && (1 << _la - 65 & (1 << CommonRegexParser.VLC - 65 | 1 << CommonRegexParser.WLC - 65 | 1 << CommonRegexParser.XLC - 65 | 1 << CommonRegexParser.YLC - 65 | 1 << CommonRegexParser.ZLC - 65 | 1 << CommonRegexParser.AUC - 65 | 1 << CommonRegexParser.BUC - 65 | 1 << CommonRegexParser.CUC - 65 | 1 << CommonRegexParser.DUC - 65 | 1 << CommonRegexParser.EUC - 65 | 1 << CommonRegexParser.FUC - 65 | 1 << CommonRegexParser.GUC - 65 | 1 << CommonRegexParser.HUC - 65 | 1 << CommonRegexParser.IUC - 65 | 1 << CommonRegexParser.JUC - 65 | 1 << CommonRegexParser.KUC - 65 | 1 << CommonRegexParser.LUC - 65 | 1 << CommonRegexParser.MUC - 65 | 1 << CommonRegexParser.NUC - 65 | 1 << CommonRegexParser.OUC - 65 | 1 << CommonRegexParser.PUC - 65 | 1 << CommonRegexParser.QUC - 65 | 1 << CommonRegexParser.RUC - 65 | 1 << CommonRegexParser.SUC - 65 | 1 << CommonRegexParser.TUC - 65 | 1 << CommonRegexParser.UUC - 65 | 1 << CommonRegexParser.VUC - 65 | 1 << CommonRegexParser.WUC - 65 | 1 << CommonRegexParser.XUC - 65 | 1 << CommonRegexParser.YUC - 65 | 1 << CommonRegexParser.ZUC - 65 | 1 << CommonRegexParser.D1 - 65)) !== 0 || (_la - 97 & ~0x1F) === 0 && (1 << _la - 97 & (1 << CommonRegexParser.D2 - 97 | 1 << CommonRegexParser.D3 - 97 | 1 << CommonRegexParser.D4 - 97 | 1 << CommonRegexParser.D5 - 97 | 1 << CommonRegexParser.D6 - 97 | 1 << CommonRegexParser.D7 - 97 | 1 << CommonRegexParser.D8 - 97 | 1 << CommonRegexParser.D9 - 97 | 1 << CommonRegexParser.D0 - 97 | 1 << CommonRegexParser.OtherChar - 97)) !== 0) {
            {
              {
                this.state = 65;
                this.element();
              }
            }
            this.state = 70;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
  }, {
    key: "element",
    value: function element() {
      var _localctx = new ElementContext(this._ctx, this.state);
      this.enterRule(_localctx, 6, CommonRegexParser.RULE_element);
      try {
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 71;
          this.atom();
          this.state = 73;
          this._errHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this._input, 2, this._ctx)) {
            case 1:
              {
                this.state = 72;
                this.quantifier();
              }
              break;
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
  }, {
    key: "quantifier",
    value: function quantifier() {
      var _localctx = new QuantifierContext(this._ctx, this.state);
      this.enterRule(_localctx, 8, CommonRegexParser.RULE_quantifier);
      try {
        this.state = 99;
        this._errHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this._input, 3, this._ctx)) {
          case 1:
            this.enterOuterAlt(_localctx, 1);
            {
              this.state = 75;
              this.match(CommonRegexParser.QuestionMark);
              this.state = 76;
              this.quantifier_type();
            }
            break;
          case 2:
            this.enterOuterAlt(_localctx, 2);
            {
              this.state = 77;
              this.match(CommonRegexParser.Plus);
              this.state = 78;
              this.quantifier_type();
            }
            break;
          case 3:
            this.enterOuterAlt(_localctx, 3);
            {
              this.state = 79;
              this.match(CommonRegexParser.Star);
              this.state = 80;
              this.quantifier_type();
            }
            break;
          case 4:
            this.enterOuterAlt(_localctx, 4);
            {
              this.state = 81;
              this.match(CommonRegexParser.OpenBrace);
              this.state = 82;
              this.number();
              this.state = 83;
              this.match(CommonRegexParser.CloseBrace);
              this.state = 84;
              this.quantifier_type();
            }
            break;
          case 5:
            this.enterOuterAlt(_localctx, 5);
            {
              this.state = 86;
              this.match(CommonRegexParser.OpenBrace);
              this.state = 87;
              this.number();
              this.state = 88;
              this.match(CommonRegexParser.Comma);
              this.state = 89;
              this.match(CommonRegexParser.CloseBrace);
              this.state = 90;
              this.quantifier_type();
            }
            break;
          case 6:
            this.enterOuterAlt(_localctx, 6);
            {
              this.state = 92;
              this.match(CommonRegexParser.OpenBrace);
              this.state = 93;
              this.number();
              this.state = 94;
              this.match(CommonRegexParser.Comma);
              this.state = 95;
              this.number();
              this.state = 96;
              this.match(CommonRegexParser.CloseBrace);
              this.state = 97;
              this.quantifier_type();
            }
            break;
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
  }, {
    key: "quantifier_type",
    value: function quantifier_type() {
      var _localctx = new Quantifier_typeContext(this._ctx, this.state);
      this.enterRule(_localctx, 10, CommonRegexParser.RULE_quantifier_type);
      try {
        this.state = 104;
        this._errHandler.sync(this);
        switch (this._input.LA(1)) {
          case CommonRegexParser.Plus:
            this.enterOuterAlt(_localctx, 1);
            {
              this.state = 101;
              this.match(CommonRegexParser.Plus);
            }
            break;
          case CommonRegexParser.QuestionMark:
            this.enterOuterAlt(_localctx, 2);
            {
              this.state = 102;
              this.match(CommonRegexParser.QuestionMark);
            }
            break;
          case CommonRegexParser.EOF:
          case CommonRegexParser.Quoted:
          case CommonRegexParser.BlockQuoted:
          case CommonRegexParser.BellChar:
          case CommonRegexParser.ControlChar:
          case CommonRegexParser.EscapeChar:
          case CommonRegexParser.FormFeed:
          case CommonRegexParser.NewLine:
          case CommonRegexParser.CarriageReturn:
          case CommonRegexParser.Tab:
          case CommonRegexParser.Backslash:
          case CommonRegexParser.HexChar:
          case CommonRegexParser.Dot:
          case CommonRegexParser.DecimalDigit:
          case CommonRegexParser.NotDecimalDigit:
          case CommonRegexParser.CharWithProperty:
          case CommonRegexParser.CharWithoutProperty:
          case CommonRegexParser.WhiteSpace:
          case CommonRegexParser.NotWhiteSpace:
          case CommonRegexParser.WordChar:
          case CommonRegexParser.NotWordChar:
          case CommonRegexParser.CharacterClassStart:
          case CommonRegexParser.CharacterClassEnd:
          case CommonRegexParser.Caret:
          case CommonRegexParser.Hyphen:
          case CommonRegexParser.OpenBrace:
          case CommonRegexParser.CloseBrace:
          case CommonRegexParser.Comma:
          case CommonRegexParser.EndOfSubject:
          case CommonRegexParser.Pipe:
          case CommonRegexParser.OpenParen:
          case CommonRegexParser.CloseParen:
          case CommonRegexParser.LessThan:
          case CommonRegexParser.GreaterThan:
          case CommonRegexParser.SingleQuote:
          case CommonRegexParser.Underscore:
          case CommonRegexParser.Colon:
          case CommonRegexParser.Hash:
          case CommonRegexParser.Equals:
          case CommonRegexParser.Exclamation:
          case CommonRegexParser.Ampersand:
          case CommonRegexParser.ALC:
          case CommonRegexParser.BLC:
          case CommonRegexParser.CLC:
          case CommonRegexParser.DLC:
          case CommonRegexParser.ELC:
          case CommonRegexParser.FLC:
          case CommonRegexParser.GLC:
          case CommonRegexParser.HLC:
          case CommonRegexParser.ILC:
          case CommonRegexParser.JLC:
          case CommonRegexParser.KLC:
          case CommonRegexParser.LLC:
          case CommonRegexParser.MLC:
          case CommonRegexParser.NLC:
          case CommonRegexParser.OLC:
          case CommonRegexParser.PLC:
          case CommonRegexParser.QLC:
          case CommonRegexParser.RLC:
          case CommonRegexParser.SLC:
          case CommonRegexParser.TLC:
          case CommonRegexParser.ULC:
          case CommonRegexParser.VLC:
          case CommonRegexParser.WLC:
          case CommonRegexParser.XLC:
          case CommonRegexParser.YLC:
          case CommonRegexParser.ZLC:
          case CommonRegexParser.AUC:
          case CommonRegexParser.BUC:
          case CommonRegexParser.CUC:
          case CommonRegexParser.DUC:
          case CommonRegexParser.EUC:
          case CommonRegexParser.FUC:
          case CommonRegexParser.GUC:
          case CommonRegexParser.HUC:
          case CommonRegexParser.IUC:
          case CommonRegexParser.JUC:
          case CommonRegexParser.KUC:
          case CommonRegexParser.LUC:
          case CommonRegexParser.MUC:
          case CommonRegexParser.NUC:
          case CommonRegexParser.OUC:
          case CommonRegexParser.PUC:
          case CommonRegexParser.QUC:
          case CommonRegexParser.RUC:
          case CommonRegexParser.SUC:
          case CommonRegexParser.TUC:
          case CommonRegexParser.UUC:
          case CommonRegexParser.VUC:
          case CommonRegexParser.WUC:
          case CommonRegexParser.XUC:
          case CommonRegexParser.YUC:
          case CommonRegexParser.ZUC:
          case CommonRegexParser.D1:
          case CommonRegexParser.D2:
          case CommonRegexParser.D3:
          case CommonRegexParser.D4:
          case CommonRegexParser.D5:
          case CommonRegexParser.D6:
          case CommonRegexParser.D7:
          case CommonRegexParser.D8:
          case CommonRegexParser.D9:
          case CommonRegexParser.D0:
          case CommonRegexParser.OtherChar:
            this.enterOuterAlt(_localctx, 3);
            // tslint:disable-next-line:no-empty
            {}
            break;
          default:
            throw new NoViableAltException_1.NoViableAltException(this);
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
  }, {
    key: "character_class",
    value: function character_class() {
      var _localctx = new Character_classContext(this._ctx, this.state);
      this.enterRule(_localctx, 12, CommonRegexParser.RULE_character_class);
      var _la;
      try {
        this.state = 123;
        this._errHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this._input, 7, this._ctx)) {
          case 1:
            this.enterOuterAlt(_localctx, 1);
            {
              this.state = 106;
              this.match(CommonRegexParser.CharacterClassStart);
              this.state = 107;
              this.match(CommonRegexParser.Caret);
              this.state = 109;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              do {
                {
                  {
                    this.state = 108;
                    this.cc_atom();
                  }
                }
                this.state = 111;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
              } while ((_la & ~0x1F) === 0 && (1 << _la & (1 << CommonRegexParser.Quoted | 1 << CommonRegexParser.BlockQuoted | 1 << CommonRegexParser.BellChar | 1 << CommonRegexParser.ControlChar | 1 << CommonRegexParser.EscapeChar | 1 << CommonRegexParser.FormFeed | 1 << CommonRegexParser.NewLine | 1 << CommonRegexParser.CarriageReturn | 1 << CommonRegexParser.Tab | 1 << CommonRegexParser.Backslash | 1 << CommonRegexParser.HexChar | 1 << CommonRegexParser.Dot | 1 << CommonRegexParser.DecimalDigit | 1 << CommonRegexParser.NotDecimalDigit | 1 << CommonRegexParser.CharWithProperty | 1 << CommonRegexParser.CharWithoutProperty | 1 << CommonRegexParser.WhiteSpace | 1 << CommonRegexParser.NotWhiteSpace | 1 << CommonRegexParser.WordChar | 1 << CommonRegexParser.NotWordChar | 1 << CommonRegexParser.CharacterClassStart | 1 << CommonRegexParser.Caret | 1 << CommonRegexParser.Hyphen | 1 << CommonRegexParser.QuestionMark | 1 << CommonRegexParser.Plus | 1 << CommonRegexParser.Star | 1 << CommonRegexParser.OpenBrace | 1 << CommonRegexParser.CloseBrace | 1 << CommonRegexParser.Comma | 1 << CommonRegexParser.EndOfSubject)) !== 0 || (_la - 32 & ~0x1F) === 0 && (1 << _la - 32 & (1 << CommonRegexParser.Pipe - 32 | 1 << CommonRegexParser.OpenParen - 32 | 1 << CommonRegexParser.CloseParen - 32 | 1 << CommonRegexParser.LessThan - 32 | 1 << CommonRegexParser.GreaterThan - 32 | 1 << CommonRegexParser.SingleQuote - 32 | 1 << CommonRegexParser.Underscore - 32 | 1 << CommonRegexParser.Colon - 32 | 1 << CommonRegexParser.Hash - 32 | 1 << CommonRegexParser.Equals - 32 | 1 << CommonRegexParser.Exclamation - 32 | 1 << CommonRegexParser.Ampersand - 32 | 1 << CommonRegexParser.ALC - 32 | 1 << CommonRegexParser.BLC - 32 | 1 << CommonRegexParser.CLC - 32 | 1 << CommonRegexParser.DLC - 32 | 1 << CommonRegexParser.ELC - 32 | 1 << CommonRegexParser.FLC - 32 | 1 << CommonRegexParser.GLC - 32 | 1 << CommonRegexParser.HLC - 32 | 1 << CommonRegexParser.ILC - 32 | 1 << CommonRegexParser.JLC - 32 | 1 << CommonRegexParser.KLC - 32 | 1 << CommonRegexParser.LLC - 32 | 1 << CommonRegexParser.MLC - 32 | 1 << CommonRegexParser.NLC - 32 | 1 << CommonRegexParser.OLC - 32 | 1 << CommonRegexParser.PLC - 32 | 1 << CommonRegexParser.QLC - 32 | 1 << CommonRegexParser.RLC - 32 | 1 << CommonRegexParser.SLC - 32 | 1 << CommonRegexParser.TLC - 32)) !== 0 || (_la - 64 & ~0x1F) === 0 && (1 << _la - 64 & (1 << CommonRegexParser.ULC - 64 | 1 << CommonRegexParser.VLC - 64 | 1 << CommonRegexParser.WLC - 64 | 1 << CommonRegexParser.XLC - 64 | 1 << CommonRegexParser.YLC - 64 | 1 << CommonRegexParser.ZLC - 64 | 1 << CommonRegexParser.AUC - 64 | 1 << CommonRegexParser.BUC - 64 | 1 << CommonRegexParser.CUC - 64 | 1 << CommonRegexParser.DUC - 64 | 1 << CommonRegexParser.EUC - 64 | 1 << CommonRegexParser.FUC - 64 | 1 << CommonRegexParser.GUC - 64 | 1 << CommonRegexParser.HUC - 64 | 1 << CommonRegexParser.IUC - 64 | 1 << CommonRegexParser.JUC - 64 | 1 << CommonRegexParser.KUC - 64 | 1 << CommonRegexParser.LUC - 64 | 1 << CommonRegexParser.MUC - 64 | 1 << CommonRegexParser.NUC - 64 | 1 << CommonRegexParser.OUC - 64 | 1 << CommonRegexParser.PUC - 64 | 1 << CommonRegexParser.QUC - 64 | 1 << CommonRegexParser.RUC - 64 | 1 << CommonRegexParser.SUC - 64 | 1 << CommonRegexParser.TUC - 64 | 1 << CommonRegexParser.UUC - 64 | 1 << CommonRegexParser.VUC - 64 | 1 << CommonRegexParser.WUC - 64 | 1 << CommonRegexParser.XUC - 64 | 1 << CommonRegexParser.YUC - 64 | 1 << CommonRegexParser.ZUC - 64)) !== 0 || (_la - 96 & ~0x1F) === 0 && (1 << _la - 96 & (1 << CommonRegexParser.D1 - 96 | 1 << CommonRegexParser.D2 - 96 | 1 << CommonRegexParser.D3 - 96 | 1 << CommonRegexParser.D4 - 96 | 1 << CommonRegexParser.D5 - 96 | 1 << CommonRegexParser.D6 - 96 | 1 << CommonRegexParser.D7 - 96 | 1 << CommonRegexParser.D8 - 96 | 1 << CommonRegexParser.D9 - 96 | 1 << CommonRegexParser.D0 - 96 | 1 << CommonRegexParser.OtherChar - 96)) !== 0);
              this.state = 113;
              this.match(CommonRegexParser.CharacterClassEnd);
            }
            break;
          case 2:
            this.enterOuterAlt(_localctx, 2);
            {
              this.state = 115;
              this.match(CommonRegexParser.CharacterClassStart);
              this.state = 117;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              do {
                {
                  {
                    this.state = 116;
                    this.cc_atom();
                  }
                }
                this.state = 119;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
              } while ((_la & ~0x1F) === 0 && (1 << _la & (1 << CommonRegexParser.Quoted | 1 << CommonRegexParser.BlockQuoted | 1 << CommonRegexParser.BellChar | 1 << CommonRegexParser.ControlChar | 1 << CommonRegexParser.EscapeChar | 1 << CommonRegexParser.FormFeed | 1 << CommonRegexParser.NewLine | 1 << CommonRegexParser.CarriageReturn | 1 << CommonRegexParser.Tab | 1 << CommonRegexParser.Backslash | 1 << CommonRegexParser.HexChar | 1 << CommonRegexParser.Dot | 1 << CommonRegexParser.DecimalDigit | 1 << CommonRegexParser.NotDecimalDigit | 1 << CommonRegexParser.CharWithProperty | 1 << CommonRegexParser.CharWithoutProperty | 1 << CommonRegexParser.WhiteSpace | 1 << CommonRegexParser.NotWhiteSpace | 1 << CommonRegexParser.WordChar | 1 << CommonRegexParser.NotWordChar | 1 << CommonRegexParser.CharacterClassStart | 1 << CommonRegexParser.Caret | 1 << CommonRegexParser.Hyphen | 1 << CommonRegexParser.QuestionMark | 1 << CommonRegexParser.Plus | 1 << CommonRegexParser.Star | 1 << CommonRegexParser.OpenBrace | 1 << CommonRegexParser.CloseBrace | 1 << CommonRegexParser.Comma | 1 << CommonRegexParser.EndOfSubject)) !== 0 || (_la - 32 & ~0x1F) === 0 && (1 << _la - 32 & (1 << CommonRegexParser.Pipe - 32 | 1 << CommonRegexParser.OpenParen - 32 | 1 << CommonRegexParser.CloseParen - 32 | 1 << CommonRegexParser.LessThan - 32 | 1 << CommonRegexParser.GreaterThan - 32 | 1 << CommonRegexParser.SingleQuote - 32 | 1 << CommonRegexParser.Underscore - 32 | 1 << CommonRegexParser.Colon - 32 | 1 << CommonRegexParser.Hash - 32 | 1 << CommonRegexParser.Equals - 32 | 1 << CommonRegexParser.Exclamation - 32 | 1 << CommonRegexParser.Ampersand - 32 | 1 << CommonRegexParser.ALC - 32 | 1 << CommonRegexParser.BLC - 32 | 1 << CommonRegexParser.CLC - 32 | 1 << CommonRegexParser.DLC - 32 | 1 << CommonRegexParser.ELC - 32 | 1 << CommonRegexParser.FLC - 32 | 1 << CommonRegexParser.GLC - 32 | 1 << CommonRegexParser.HLC - 32 | 1 << CommonRegexParser.ILC - 32 | 1 << CommonRegexParser.JLC - 32 | 1 << CommonRegexParser.KLC - 32 | 1 << CommonRegexParser.LLC - 32 | 1 << CommonRegexParser.MLC - 32 | 1 << CommonRegexParser.NLC - 32 | 1 << CommonRegexParser.OLC - 32 | 1 << CommonRegexParser.PLC - 32 | 1 << CommonRegexParser.QLC - 32 | 1 << CommonRegexParser.RLC - 32 | 1 << CommonRegexParser.SLC - 32 | 1 << CommonRegexParser.TLC - 32)) !== 0 || (_la - 64 & ~0x1F) === 0 && (1 << _la - 64 & (1 << CommonRegexParser.ULC - 64 | 1 << CommonRegexParser.VLC - 64 | 1 << CommonRegexParser.WLC - 64 | 1 << CommonRegexParser.XLC - 64 | 1 << CommonRegexParser.YLC - 64 | 1 << CommonRegexParser.ZLC - 64 | 1 << CommonRegexParser.AUC - 64 | 1 << CommonRegexParser.BUC - 64 | 1 << CommonRegexParser.CUC - 64 | 1 << CommonRegexParser.DUC - 64 | 1 << CommonRegexParser.EUC - 64 | 1 << CommonRegexParser.FUC - 64 | 1 << CommonRegexParser.GUC - 64 | 1 << CommonRegexParser.HUC - 64 | 1 << CommonRegexParser.IUC - 64 | 1 << CommonRegexParser.JUC - 64 | 1 << CommonRegexParser.KUC - 64 | 1 << CommonRegexParser.LUC - 64 | 1 << CommonRegexParser.MUC - 64 | 1 << CommonRegexParser.NUC - 64 | 1 << CommonRegexParser.OUC - 64 | 1 << CommonRegexParser.PUC - 64 | 1 << CommonRegexParser.QUC - 64 | 1 << CommonRegexParser.RUC - 64 | 1 << CommonRegexParser.SUC - 64 | 1 << CommonRegexParser.TUC - 64 | 1 << CommonRegexParser.UUC - 64 | 1 << CommonRegexParser.VUC - 64 | 1 << CommonRegexParser.WUC - 64 | 1 << CommonRegexParser.XUC - 64 | 1 << CommonRegexParser.YUC - 64 | 1 << CommonRegexParser.ZUC - 64)) !== 0 || (_la - 96 & ~0x1F) === 0 && (1 << _la - 96 & (1 << CommonRegexParser.D1 - 96 | 1 << CommonRegexParser.D2 - 96 | 1 << CommonRegexParser.D3 - 96 | 1 << CommonRegexParser.D4 - 96 | 1 << CommonRegexParser.D5 - 96 | 1 << CommonRegexParser.D6 - 96 | 1 << CommonRegexParser.D7 - 96 | 1 << CommonRegexParser.D8 - 96 | 1 << CommonRegexParser.D9 - 96 | 1 << CommonRegexParser.D0 - 96 | 1 << CommonRegexParser.OtherChar - 96)) !== 0);
              this.state = 121;
              this.match(CommonRegexParser.CharacterClassEnd);
            }
            break;
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
  }, {
    key: "capture",
    value: function capture() {
      var _localctx = new CaptureContext(this._ctx, this.state);
      this.enterRule(_localctx, 14, CommonRegexParser.RULE_capture);
      try {
        this.state = 137;
        this._errHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this._input, 8, this._ctx)) {
          case 1:
            this.enterOuterAlt(_localctx, 1);
            {
              this.state = 125;
              this.match(CommonRegexParser.OpenParen);
              this.state = 126;
              this.match(CommonRegexParser.QuestionMark);
              this.state = 127;
              this.match(CommonRegexParser.LessThan);
              this.state = 128;
              this.name();
              this.state = 129;
              this.match(CommonRegexParser.GreaterThan);
              this.state = 130;
              this.alternation();
              this.state = 131;
              this.match(CommonRegexParser.CloseParen);
            }
            break;
          case 2:
            this.enterOuterAlt(_localctx, 2);
            {
              this.state = 133;
              this.match(CommonRegexParser.OpenParen);
              this.state = 134;
              this.alternation();
              this.state = 135;
              this.match(CommonRegexParser.CloseParen);
            }
            break;
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
  }, {
    key: "non_capture",
    value: function non_capture() {
      var _localctx = new Non_captureContext(this._ctx, this.state);
      this.enterRule(_localctx, 16, CommonRegexParser.RULE_non_capture);
      try {
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 139;
          this.match(CommonRegexParser.OpenParen);
          this.state = 140;
          this.match(CommonRegexParser.QuestionMark);
          this.state = 141;
          this.match(CommonRegexParser.Colon);
          this.state = 142;
          this.alternation();
          this.state = 143;
          this.match(CommonRegexParser.CloseParen);
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
  }, {
    key: "option",
    value: function option() {
      var _localctx = new OptionContext(this._ctx, this.state);
      this.enterRule(_localctx, 18, CommonRegexParser.RULE_option);
      var _la;
      try {
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 145;
          this.match(CommonRegexParser.OpenParen);
          this.state = 146;
          this.match(CommonRegexParser.QuestionMark);
          this.state = 148;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          do {
            {
              {
                this.state = 147;
                this.option_flag();
              }
            }
            this.state = 150;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
          } while ((_la - 52 & ~0x1F) === 0 && (1 << _la - 52 & (1 << CommonRegexParser.ILC - 52 | 1 << CommonRegexParser.MLC - 52 | 1 << CommonRegexParser.SLC - 52)) !== 0);
          this.state = 152;
          this.match(CommonRegexParser.CloseParen);
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
  }, {
    key: "option_flag",
    value: function option_flag() {
      var _localctx = new Option_flagContext(this._ctx, this.state);
      this.enterRule(_localctx, 20, CommonRegexParser.RULE_option_flag);
      var _la;
      try {
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 154;
          _la = this._input.LA(1);
          if (!((_la - 52 & ~0x1F) === 0 && (1 << _la - 52 & (1 << CommonRegexParser.ILC - 52 | 1 << CommonRegexParser.MLC - 52 | 1 << CommonRegexParser.SLC - 52)) !== 0)) {
            this._errHandler.recoverInline(this);
          } else {
            if (this._input.LA(1) === Token_1.Token.EOF) {
              this.matchedEOF = true;
            }
            this._errHandler.reportMatch(this);
            this.consume();
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
  }, {
    key: "atom",
    value: function atom() {
      var _localctx = new AtomContext(this._ctx, this.state);
      this.enterRule(_localctx, 22, CommonRegexParser.RULE_atom);
      try {
        this.state = 165;
        this._errHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this._input, 10, this._ctx)) {
          case 1:
            this.enterOuterAlt(_localctx, 1);
            {
              this.state = 156;
              this.shared_atom();
            }
            break;
          case 2:
            this.enterOuterAlt(_localctx, 2);
            {
              this.state = 157;
              this.literal();
            }
            break;
          case 3:
            this.enterOuterAlt(_localctx, 3);
            {
              this.state = 158;
              this.character_class();
            }
            break;
          case 4:
            this.enterOuterAlt(_localctx, 4);
            {
              this.state = 159;
              this.capture();
            }
            break;
          case 5:
            this.enterOuterAlt(_localctx, 5);
            {
              this.state = 160;
              this.non_capture();
            }
            break;
          case 6:
            this.enterOuterAlt(_localctx, 6);
            {
              this.state = 161;
              this.option();
            }
            break;
          case 7:
            this.enterOuterAlt(_localctx, 7);
            {
              this.state = 162;
              this.match(CommonRegexParser.Dot);
            }
            break;
          case 8:
            this.enterOuterAlt(_localctx, 8);
            {
              this.state = 163;
              this.match(CommonRegexParser.Caret);
            }
            break;
          case 9:
            this.enterOuterAlt(_localctx, 9);
            {
              this.state = 164;
              this.match(CommonRegexParser.EndOfSubject);
            }
            break;
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
  }, {
    key: "cc_atom",
    value: function cc_atom() {
      var _localctx = new Cc_atomContext(this._ctx, this.state);
      this.enterRule(_localctx, 24, CommonRegexParser.RULE_cc_atom);
      try {
        this.state = 173;
        this._errHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this._input, 11, this._ctx)) {
          case 1:
            this.enterOuterAlt(_localctx, 1);
            {
              this.state = 167;
              this.cc_literal();
              this.state = 168;
              this.match(CommonRegexParser.Hyphen);
              this.state = 169;
              this.cc_literal();
            }
            break;
          case 2:
            this.enterOuterAlt(_localctx, 2);
            {
              this.state = 171;
              this.shared_atom();
            }
            break;
          case 3:
            this.enterOuterAlt(_localctx, 3);
            {
              this.state = 172;
              this.cc_literal();
            }
            break;
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
  }, {
    key: "shared_atom",
    value: function shared_atom() {
      var _localctx = new Shared_atomContext(this._ctx, this.state);
      this.enterRule(_localctx, 26, CommonRegexParser.RULE_shared_atom);
      var _la;
      try {
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 175;
          _la = this._input.LA(1);
          if (!((_la & ~0x1F) === 0 && (1 << _la & (1 << CommonRegexParser.ControlChar | 1 << CommonRegexParser.DecimalDigit | 1 << CommonRegexParser.NotDecimalDigit | 1 << CommonRegexParser.CharWithProperty | 1 << CommonRegexParser.CharWithoutProperty | 1 << CommonRegexParser.WhiteSpace | 1 << CommonRegexParser.NotWhiteSpace | 1 << CommonRegexParser.WordChar | 1 << CommonRegexParser.NotWordChar)) !== 0)) {
            this._errHandler.recoverInline(this);
          } else {
            if (this._input.LA(1) === Token_1.Token.EOF) {
              this.matchedEOF = true;
            }
            this._errHandler.reportMatch(this);
            this.consume();
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
  }, {
    key: "literal",
    value: function literal() {
      var _localctx = new LiteralContext(this._ctx, this.state);
      this.enterRule(_localctx, 28, CommonRegexParser.RULE_literal);
      try {
        this.state = 179;
        this._errHandler.sync(this);
        switch (this._input.LA(1)) {
          case CommonRegexParser.Quoted:
          case CommonRegexParser.BlockQuoted:
          case CommonRegexParser.BellChar:
          case CommonRegexParser.EscapeChar:
          case CommonRegexParser.FormFeed:
          case CommonRegexParser.NewLine:
          case CommonRegexParser.CarriageReturn:
          case CommonRegexParser.Tab:
          case CommonRegexParser.Backslash:
          case CommonRegexParser.HexChar:
          case CommonRegexParser.Hyphen:
          case CommonRegexParser.OpenBrace:
          case CommonRegexParser.CloseBrace:
          case CommonRegexParser.Comma:
          case CommonRegexParser.LessThan:
          case CommonRegexParser.GreaterThan:
          case CommonRegexParser.SingleQuote:
          case CommonRegexParser.Underscore:
          case CommonRegexParser.Colon:
          case CommonRegexParser.Hash:
          case CommonRegexParser.Equals:
          case CommonRegexParser.Exclamation:
          case CommonRegexParser.Ampersand:
          case CommonRegexParser.ALC:
          case CommonRegexParser.BLC:
          case CommonRegexParser.CLC:
          case CommonRegexParser.DLC:
          case CommonRegexParser.ELC:
          case CommonRegexParser.FLC:
          case CommonRegexParser.GLC:
          case CommonRegexParser.HLC:
          case CommonRegexParser.ILC:
          case CommonRegexParser.JLC:
          case CommonRegexParser.KLC:
          case CommonRegexParser.LLC:
          case CommonRegexParser.MLC:
          case CommonRegexParser.NLC:
          case CommonRegexParser.OLC:
          case CommonRegexParser.PLC:
          case CommonRegexParser.QLC:
          case CommonRegexParser.RLC:
          case CommonRegexParser.SLC:
          case CommonRegexParser.TLC:
          case CommonRegexParser.ULC:
          case CommonRegexParser.VLC:
          case CommonRegexParser.WLC:
          case CommonRegexParser.XLC:
          case CommonRegexParser.YLC:
          case CommonRegexParser.ZLC:
          case CommonRegexParser.AUC:
          case CommonRegexParser.BUC:
          case CommonRegexParser.CUC:
          case CommonRegexParser.DUC:
          case CommonRegexParser.EUC:
          case CommonRegexParser.FUC:
          case CommonRegexParser.GUC:
          case CommonRegexParser.HUC:
          case CommonRegexParser.IUC:
          case CommonRegexParser.JUC:
          case CommonRegexParser.KUC:
          case CommonRegexParser.LUC:
          case CommonRegexParser.MUC:
          case CommonRegexParser.NUC:
          case CommonRegexParser.OUC:
          case CommonRegexParser.PUC:
          case CommonRegexParser.QUC:
          case CommonRegexParser.RUC:
          case CommonRegexParser.SUC:
          case CommonRegexParser.TUC:
          case CommonRegexParser.UUC:
          case CommonRegexParser.VUC:
          case CommonRegexParser.WUC:
          case CommonRegexParser.XUC:
          case CommonRegexParser.YUC:
          case CommonRegexParser.ZUC:
          case CommonRegexParser.D1:
          case CommonRegexParser.D2:
          case CommonRegexParser.D3:
          case CommonRegexParser.D4:
          case CommonRegexParser.D5:
          case CommonRegexParser.D6:
          case CommonRegexParser.D7:
          case CommonRegexParser.D8:
          case CommonRegexParser.D9:
          case CommonRegexParser.D0:
          case CommonRegexParser.OtherChar:
            this.enterOuterAlt(_localctx, 1);
            {
              this.state = 177;
              this.shared_literal();
            }
            break;
          case CommonRegexParser.CharacterClassEnd:
            this.enterOuterAlt(_localctx, 2);
            {
              this.state = 178;
              this.match(CommonRegexParser.CharacterClassEnd);
            }
            break;
          default:
            throw new NoViableAltException_1.NoViableAltException(this);
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
  }, {
    key: "cc_literal",
    value: function cc_literal() {
      var _localctx = new Cc_literalContext(this._ctx, this.state);
      this.enterRule(_localctx, 30, CommonRegexParser.RULE_cc_literal);
      try {
        this.state = 192;
        this._errHandler.sync(this);
        switch (this._input.LA(1)) {
          case CommonRegexParser.Quoted:
          case CommonRegexParser.BlockQuoted:
          case CommonRegexParser.BellChar:
          case CommonRegexParser.EscapeChar:
          case CommonRegexParser.FormFeed:
          case CommonRegexParser.NewLine:
          case CommonRegexParser.CarriageReturn:
          case CommonRegexParser.Tab:
          case CommonRegexParser.Backslash:
          case CommonRegexParser.HexChar:
          case CommonRegexParser.Hyphen:
          case CommonRegexParser.OpenBrace:
          case CommonRegexParser.CloseBrace:
          case CommonRegexParser.Comma:
          case CommonRegexParser.LessThan:
          case CommonRegexParser.GreaterThan:
          case CommonRegexParser.SingleQuote:
          case CommonRegexParser.Underscore:
          case CommonRegexParser.Colon:
          case CommonRegexParser.Hash:
          case CommonRegexParser.Equals:
          case CommonRegexParser.Exclamation:
          case CommonRegexParser.Ampersand:
          case CommonRegexParser.ALC:
          case CommonRegexParser.BLC:
          case CommonRegexParser.CLC:
          case CommonRegexParser.DLC:
          case CommonRegexParser.ELC:
          case CommonRegexParser.FLC:
          case CommonRegexParser.GLC:
          case CommonRegexParser.HLC:
          case CommonRegexParser.ILC:
          case CommonRegexParser.JLC:
          case CommonRegexParser.KLC:
          case CommonRegexParser.LLC:
          case CommonRegexParser.MLC:
          case CommonRegexParser.NLC:
          case CommonRegexParser.OLC:
          case CommonRegexParser.PLC:
          case CommonRegexParser.QLC:
          case CommonRegexParser.RLC:
          case CommonRegexParser.SLC:
          case CommonRegexParser.TLC:
          case CommonRegexParser.ULC:
          case CommonRegexParser.VLC:
          case CommonRegexParser.WLC:
          case CommonRegexParser.XLC:
          case CommonRegexParser.YLC:
          case CommonRegexParser.ZLC:
          case CommonRegexParser.AUC:
          case CommonRegexParser.BUC:
          case CommonRegexParser.CUC:
          case CommonRegexParser.DUC:
          case CommonRegexParser.EUC:
          case CommonRegexParser.FUC:
          case CommonRegexParser.GUC:
          case CommonRegexParser.HUC:
          case CommonRegexParser.IUC:
          case CommonRegexParser.JUC:
          case CommonRegexParser.KUC:
          case CommonRegexParser.LUC:
          case CommonRegexParser.MUC:
          case CommonRegexParser.NUC:
          case CommonRegexParser.OUC:
          case CommonRegexParser.PUC:
          case CommonRegexParser.QUC:
          case CommonRegexParser.RUC:
          case CommonRegexParser.SUC:
          case CommonRegexParser.TUC:
          case CommonRegexParser.UUC:
          case CommonRegexParser.VUC:
          case CommonRegexParser.WUC:
          case CommonRegexParser.XUC:
          case CommonRegexParser.YUC:
          case CommonRegexParser.ZUC:
          case CommonRegexParser.D1:
          case CommonRegexParser.D2:
          case CommonRegexParser.D3:
          case CommonRegexParser.D4:
          case CommonRegexParser.D5:
          case CommonRegexParser.D6:
          case CommonRegexParser.D7:
          case CommonRegexParser.D8:
          case CommonRegexParser.D9:
          case CommonRegexParser.D0:
          case CommonRegexParser.OtherChar:
            this.enterOuterAlt(_localctx, 1);
            {
              this.state = 181;
              this.shared_literal();
            }
            break;
          case CommonRegexParser.Dot:
            this.enterOuterAlt(_localctx, 2);
            {
              this.state = 182;
              this.match(CommonRegexParser.Dot);
            }
            break;
          case CommonRegexParser.CharacterClassStart:
            this.enterOuterAlt(_localctx, 3);
            {
              this.state = 183;
              this.match(CommonRegexParser.CharacterClassStart);
            }
            break;
          case CommonRegexParser.Caret:
            this.enterOuterAlt(_localctx, 4);
            {
              this.state = 184;
              this.match(CommonRegexParser.Caret);
            }
            break;
          case CommonRegexParser.QuestionMark:
            this.enterOuterAlt(_localctx, 5);
            {
              this.state = 185;
              this.match(CommonRegexParser.QuestionMark);
            }
            break;
          case CommonRegexParser.Plus:
            this.enterOuterAlt(_localctx, 6);
            {
              this.state = 186;
              this.match(CommonRegexParser.Plus);
            }
            break;
          case CommonRegexParser.Star:
            this.enterOuterAlt(_localctx, 7);
            {
              this.state = 187;
              this.match(CommonRegexParser.Star);
            }
            break;
          case CommonRegexParser.EndOfSubject:
            this.enterOuterAlt(_localctx, 8);
            {
              this.state = 188;
              this.match(CommonRegexParser.EndOfSubject);
            }
            break;
          case CommonRegexParser.Pipe:
            this.enterOuterAlt(_localctx, 9);
            {
              this.state = 189;
              this.match(CommonRegexParser.Pipe);
            }
            break;
          case CommonRegexParser.OpenParen:
            this.enterOuterAlt(_localctx, 10);
            {
              this.state = 190;
              this.match(CommonRegexParser.OpenParen);
            }
            break;
          case CommonRegexParser.CloseParen:
            this.enterOuterAlt(_localctx, 11);
            {
              this.state = 191;
              this.match(CommonRegexParser.CloseParen);
            }
            break;
          default:
            throw new NoViableAltException_1.NoViableAltException(this);
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
  }, {
    key: "shared_literal",
    value: function shared_literal() {
      var _localctx = new Shared_literalContext(this._ctx, this.state);
      this.enterRule(_localctx, 32, CommonRegexParser.RULE_shared_literal);
      try {
        this.state = 220;
        this._errHandler.sync(this);
        switch (this._input.LA(1)) {
          case CommonRegexParser.Backslash:
            this.enterOuterAlt(_localctx, 1);
            {
              this.state = 194;
              this.octal_char();
            }
            break;
          case CommonRegexParser.ALC:
          case CommonRegexParser.BLC:
          case CommonRegexParser.CLC:
          case CommonRegexParser.DLC:
          case CommonRegexParser.ELC:
          case CommonRegexParser.FLC:
          case CommonRegexParser.GLC:
          case CommonRegexParser.HLC:
          case CommonRegexParser.ILC:
          case CommonRegexParser.JLC:
          case CommonRegexParser.KLC:
          case CommonRegexParser.LLC:
          case CommonRegexParser.MLC:
          case CommonRegexParser.NLC:
          case CommonRegexParser.OLC:
          case CommonRegexParser.PLC:
          case CommonRegexParser.QLC:
          case CommonRegexParser.RLC:
          case CommonRegexParser.SLC:
          case CommonRegexParser.TLC:
          case CommonRegexParser.ULC:
          case CommonRegexParser.VLC:
          case CommonRegexParser.WLC:
          case CommonRegexParser.XLC:
          case CommonRegexParser.YLC:
          case CommonRegexParser.ZLC:
          case CommonRegexParser.AUC:
          case CommonRegexParser.BUC:
          case CommonRegexParser.CUC:
          case CommonRegexParser.DUC:
          case CommonRegexParser.EUC:
          case CommonRegexParser.FUC:
          case CommonRegexParser.GUC:
          case CommonRegexParser.HUC:
          case CommonRegexParser.IUC:
          case CommonRegexParser.JUC:
          case CommonRegexParser.KUC:
          case CommonRegexParser.LUC:
          case CommonRegexParser.MUC:
          case CommonRegexParser.NUC:
          case CommonRegexParser.OUC:
          case CommonRegexParser.PUC:
          case CommonRegexParser.QUC:
          case CommonRegexParser.RUC:
          case CommonRegexParser.SUC:
          case CommonRegexParser.TUC:
          case CommonRegexParser.UUC:
          case CommonRegexParser.VUC:
          case CommonRegexParser.WUC:
          case CommonRegexParser.XUC:
          case CommonRegexParser.YUC:
          case CommonRegexParser.ZUC:
            this.enterOuterAlt(_localctx, 2);
            {
              this.state = 195;
              this.letter();
            }
            break;
          case CommonRegexParser.D1:
          case CommonRegexParser.D2:
          case CommonRegexParser.D3:
          case CommonRegexParser.D4:
          case CommonRegexParser.D5:
          case CommonRegexParser.D6:
          case CommonRegexParser.D7:
          case CommonRegexParser.D8:
          case CommonRegexParser.D9:
          case CommonRegexParser.D0:
            this.enterOuterAlt(_localctx, 3);
            {
              this.state = 196;
              this.digit();
            }
            break;
          case CommonRegexParser.BellChar:
            this.enterOuterAlt(_localctx, 4);
            {
              this.state = 197;
              this.match(CommonRegexParser.BellChar);
            }
            break;
          case CommonRegexParser.EscapeChar:
            this.enterOuterAlt(_localctx, 5);
            {
              this.state = 198;
              this.match(CommonRegexParser.EscapeChar);
            }
            break;
          case CommonRegexParser.FormFeed:
            this.enterOuterAlt(_localctx, 6);
            {
              this.state = 199;
              this.match(CommonRegexParser.FormFeed);
            }
            break;
          case CommonRegexParser.NewLine:
            this.enterOuterAlt(_localctx, 7);
            {
              this.state = 200;
              this.match(CommonRegexParser.NewLine);
            }
            break;
          case CommonRegexParser.CarriageReturn:
            this.enterOuterAlt(_localctx, 8);
            {
              this.state = 201;
              this.match(CommonRegexParser.CarriageReturn);
            }
            break;
          case CommonRegexParser.Tab:
            this.enterOuterAlt(_localctx, 9);
            {
              this.state = 202;
              this.match(CommonRegexParser.Tab);
            }
            break;
          case CommonRegexParser.HexChar:
            this.enterOuterAlt(_localctx, 10);
            {
              this.state = 203;
              this.match(CommonRegexParser.HexChar);
            }
            break;
          case CommonRegexParser.Quoted:
            this.enterOuterAlt(_localctx, 11);
            {
              this.state = 204;
              this.match(CommonRegexParser.Quoted);
            }
            break;
          case CommonRegexParser.BlockQuoted:
            this.enterOuterAlt(_localctx, 12);
            {
              this.state = 205;
              this.match(CommonRegexParser.BlockQuoted);
            }
            break;
          case CommonRegexParser.OpenBrace:
            this.enterOuterAlt(_localctx, 13);
            {
              this.state = 206;
              this.match(CommonRegexParser.OpenBrace);
            }
            break;
          case CommonRegexParser.CloseBrace:
            this.enterOuterAlt(_localctx, 14);
            {
              this.state = 207;
              this.match(CommonRegexParser.CloseBrace);
            }
            break;
          case CommonRegexParser.Comma:
            this.enterOuterAlt(_localctx, 15);
            {
              this.state = 208;
              this.match(CommonRegexParser.Comma);
            }
            break;
          case CommonRegexParser.Hyphen:
            this.enterOuterAlt(_localctx, 16);
            {
              this.state = 209;
              this.match(CommonRegexParser.Hyphen);
            }
            break;
          case CommonRegexParser.LessThan:
            this.enterOuterAlt(_localctx, 17);
            {
              this.state = 210;
              this.match(CommonRegexParser.LessThan);
            }
            break;
          case CommonRegexParser.GreaterThan:
            this.enterOuterAlt(_localctx, 18);
            {
              this.state = 211;
              this.match(CommonRegexParser.GreaterThan);
            }
            break;
          case CommonRegexParser.SingleQuote:
            this.enterOuterAlt(_localctx, 19);
            {
              this.state = 212;
              this.match(CommonRegexParser.SingleQuote);
            }
            break;
          case CommonRegexParser.Underscore:
            this.enterOuterAlt(_localctx, 20);
            {
              this.state = 213;
              this.match(CommonRegexParser.Underscore);
            }
            break;
          case CommonRegexParser.Colon:
            this.enterOuterAlt(_localctx, 21);
            {
              this.state = 214;
              this.match(CommonRegexParser.Colon);
            }
            break;
          case CommonRegexParser.Hash:
            this.enterOuterAlt(_localctx, 22);
            {
              this.state = 215;
              this.match(CommonRegexParser.Hash);
            }
            break;
          case CommonRegexParser.Equals:
            this.enterOuterAlt(_localctx, 23);
            {
              this.state = 216;
              this.match(CommonRegexParser.Equals);
            }
            break;
          case CommonRegexParser.Exclamation:
            this.enterOuterAlt(_localctx, 24);
            {
              this.state = 217;
              this.match(CommonRegexParser.Exclamation);
            }
            break;
          case CommonRegexParser.Ampersand:
            this.enterOuterAlt(_localctx, 25);
            {
              this.state = 218;
              this.match(CommonRegexParser.Ampersand);
            }
            break;
          case CommonRegexParser.OtherChar:
            this.enterOuterAlt(_localctx, 26);
            {
              this.state = 219;
              this.match(CommonRegexParser.OtherChar);
            }
            break;
          default:
            throw new NoViableAltException_1.NoViableAltException(this);
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
  }, {
    key: "number",
    value: function number() {
      var _localctx = new NumberContext(this._ctx, this.state);
      this.enterRule(_localctx, 34, CommonRegexParser.RULE_number);
      try {
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 222;
          this.digits();
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
  }, {
    key: "octal_char",
    value: function octal_char() {
      var _localctx = new Octal_charContext(this._ctx, this.state);
      this.enterRule(_localctx, 36, CommonRegexParser.RULE_octal_char);
      var _la;
      try {
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 233;
          this._errHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this._input, 15, this._ctx)) {
            case 1:
              {
                this.state = 224;
                this.match(CommonRegexParser.Backslash);
                this.state = 225;
                _la = this._input.LA(1);
                if (!((_la - 96 & ~0x1F) === 0 && (1 << _la - 96 & (1 << CommonRegexParser.D1 - 96 | 1 << CommonRegexParser.D2 - 96 | 1 << CommonRegexParser.D3 - 96 | 1 << CommonRegexParser.D0 - 96)) !== 0)) {
                  this._errHandler.recoverInline(this);
                } else {
                  if (this._input.LA(1) === Token_1.Token.EOF) {
                    this.matchedEOF = true;
                  }
                  this._errHandler.reportMatch(this);
                  this.consume();
                }
                this.state = 226;
                this.octal_digit();
                this.state = 227;
                this.octal_digit();
              }
              break;
            case 2:
              {
                this.state = 229;
                this.match(CommonRegexParser.Backslash);
                this.state = 230;
                this.octal_digit();
                this.state = 231;
                this.octal_digit();
              }
              break;
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
  }, {
    key: "octal_digit",
    value: function octal_digit() {
      var _localctx = new Octal_digitContext(this._ctx, this.state);
      this.enterRule(_localctx, 38, CommonRegexParser.RULE_octal_digit);
      var _la;
      try {
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 235;
          _la = this._input.LA(1);
          if (!((_la - 96 & ~0x1F) === 0 && (1 << _la - 96 & (1 << CommonRegexParser.D1 - 96 | 1 << CommonRegexParser.D2 - 96 | 1 << CommonRegexParser.D3 - 96 | 1 << CommonRegexParser.D4 - 96 | 1 << CommonRegexParser.D5 - 96 | 1 << CommonRegexParser.D6 - 96 | 1 << CommonRegexParser.D7 - 96 | 1 << CommonRegexParser.D0 - 96)) !== 0)) {
            this._errHandler.recoverInline(this);
          } else {
            if (this._input.LA(1) === Token_1.Token.EOF) {
              this.matchedEOF = true;
            }
            this._errHandler.reportMatch(this);
            this.consume();
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
  }, {
    key: "digits",
    value: function digits() {
      var _localctx = new DigitsContext(this._ctx, this.state);
      this.enterRule(_localctx, 40, CommonRegexParser.RULE_digits);
      var _la;
      try {
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 238;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          do {
            {
              {
                this.state = 237;
                this.digit();
              }
            }
            this.state = 240;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
          } while ((_la - 96 & ~0x1F) === 0 && (1 << _la - 96 & (1 << CommonRegexParser.D1 - 96 | 1 << CommonRegexParser.D2 - 96 | 1 << CommonRegexParser.D3 - 96 | 1 << CommonRegexParser.D4 - 96 | 1 << CommonRegexParser.D5 - 96 | 1 << CommonRegexParser.D6 - 96 | 1 << CommonRegexParser.D7 - 96 | 1 << CommonRegexParser.D8 - 96 | 1 << CommonRegexParser.D9 - 96 | 1 << CommonRegexParser.D0 - 96)) !== 0);
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
  }, {
    key: "digit",
    value: function digit() {
      var _localctx = new DigitContext(this._ctx, this.state);
      this.enterRule(_localctx, 42, CommonRegexParser.RULE_digit);
      var _la;
      try {
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 242;
          _la = this._input.LA(1);
          if (!((_la - 96 & ~0x1F) === 0 && (1 << _la - 96 & (1 << CommonRegexParser.D1 - 96 | 1 << CommonRegexParser.D2 - 96 | 1 << CommonRegexParser.D3 - 96 | 1 << CommonRegexParser.D4 - 96 | 1 << CommonRegexParser.D5 - 96 | 1 << CommonRegexParser.D6 - 96 | 1 << CommonRegexParser.D7 - 96 | 1 << CommonRegexParser.D8 - 96 | 1 << CommonRegexParser.D9 - 96 | 1 << CommonRegexParser.D0 - 96)) !== 0)) {
            this._errHandler.recoverInline(this);
          } else {
            if (this._input.LA(1) === Token_1.Token.EOF) {
              this.matchedEOF = true;
            }
            this._errHandler.reportMatch(this);
            this.consume();
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
  }, {
    key: "name",
    value: function name() {
      var _localctx = new NameContext(this._ctx, this.state);
      this.enterRule(_localctx, 44, CommonRegexParser.RULE_name);
      try {
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 244;
          this.alpha_nums();
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
  }, {
    key: "alpha_nums",
    value: function alpha_nums() {
      var _localctx = new Alpha_numsContext(this._ctx, this.state);
      this.enterRule(_localctx, 46, CommonRegexParser.RULE_alpha_nums);
      var _la;
      try {
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 248;
          this._errHandler.sync(this);
          switch (this._input.LA(1)) {
            case CommonRegexParser.ALC:
            case CommonRegexParser.BLC:
            case CommonRegexParser.CLC:
            case CommonRegexParser.DLC:
            case CommonRegexParser.ELC:
            case CommonRegexParser.FLC:
            case CommonRegexParser.GLC:
            case CommonRegexParser.HLC:
            case CommonRegexParser.ILC:
            case CommonRegexParser.JLC:
            case CommonRegexParser.KLC:
            case CommonRegexParser.LLC:
            case CommonRegexParser.MLC:
            case CommonRegexParser.NLC:
            case CommonRegexParser.OLC:
            case CommonRegexParser.PLC:
            case CommonRegexParser.QLC:
            case CommonRegexParser.RLC:
            case CommonRegexParser.SLC:
            case CommonRegexParser.TLC:
            case CommonRegexParser.ULC:
            case CommonRegexParser.VLC:
            case CommonRegexParser.WLC:
            case CommonRegexParser.XLC:
            case CommonRegexParser.YLC:
            case CommonRegexParser.ZLC:
            case CommonRegexParser.AUC:
            case CommonRegexParser.BUC:
            case CommonRegexParser.CUC:
            case CommonRegexParser.DUC:
            case CommonRegexParser.EUC:
            case CommonRegexParser.FUC:
            case CommonRegexParser.GUC:
            case CommonRegexParser.HUC:
            case CommonRegexParser.IUC:
            case CommonRegexParser.JUC:
            case CommonRegexParser.KUC:
            case CommonRegexParser.LUC:
            case CommonRegexParser.MUC:
            case CommonRegexParser.NUC:
            case CommonRegexParser.OUC:
            case CommonRegexParser.PUC:
            case CommonRegexParser.QUC:
            case CommonRegexParser.RUC:
            case CommonRegexParser.SUC:
            case CommonRegexParser.TUC:
            case CommonRegexParser.UUC:
            case CommonRegexParser.VUC:
            case CommonRegexParser.WUC:
            case CommonRegexParser.XUC:
            case CommonRegexParser.YUC:
            case CommonRegexParser.ZUC:
              {
                this.state = 246;
                this.letter();
              }
              break;
            case CommonRegexParser.Underscore:
              {
                this.state = 247;
                this.match(CommonRegexParser.Underscore);
              }
              break;
            default:
              throw new NoViableAltException_1.NoViableAltException(this);
          }
          this.state = 255;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          while ((_la - 38 & ~0x1F) === 0 && (1 << _la - 38 & (1 << CommonRegexParser.Underscore - 38 | 1 << CommonRegexParser.ALC - 38 | 1 << CommonRegexParser.BLC - 38 | 1 << CommonRegexParser.CLC - 38 | 1 << CommonRegexParser.DLC - 38 | 1 << CommonRegexParser.ELC - 38 | 1 << CommonRegexParser.FLC - 38 | 1 << CommonRegexParser.GLC - 38 | 1 << CommonRegexParser.HLC - 38 | 1 << CommonRegexParser.ILC - 38 | 1 << CommonRegexParser.JLC - 38 | 1 << CommonRegexParser.KLC - 38 | 1 << CommonRegexParser.LLC - 38 | 1 << CommonRegexParser.MLC - 38 | 1 << CommonRegexParser.NLC - 38 | 1 << CommonRegexParser.OLC - 38 | 1 << CommonRegexParser.PLC - 38 | 1 << CommonRegexParser.QLC - 38 | 1 << CommonRegexParser.RLC - 38 | 1 << CommonRegexParser.SLC - 38 | 1 << CommonRegexParser.TLC - 38 | 1 << CommonRegexParser.ULC - 38 | 1 << CommonRegexParser.VLC - 38 | 1 << CommonRegexParser.WLC - 38 | 1 << CommonRegexParser.XLC - 38 | 1 << CommonRegexParser.YLC - 38 | 1 << CommonRegexParser.ZLC - 38)) !== 0 || (_la - 70 & ~0x1F) === 0 && (1 << _la - 70 & (1 << CommonRegexParser.AUC - 70 | 1 << CommonRegexParser.BUC - 70 | 1 << CommonRegexParser.CUC - 70 | 1 << CommonRegexParser.DUC - 70 | 1 << CommonRegexParser.EUC - 70 | 1 << CommonRegexParser.FUC - 70 | 1 << CommonRegexParser.GUC - 70 | 1 << CommonRegexParser.HUC - 70 | 1 << CommonRegexParser.IUC - 70 | 1 << CommonRegexParser.JUC - 70 | 1 << CommonRegexParser.KUC - 70 | 1 << CommonRegexParser.LUC - 70 | 1 << CommonRegexParser.MUC - 70 | 1 << CommonRegexParser.NUC - 70 | 1 << CommonRegexParser.OUC - 70 | 1 << CommonRegexParser.PUC - 70 | 1 << CommonRegexParser.QUC - 70 | 1 << CommonRegexParser.RUC - 70 | 1 << CommonRegexParser.SUC - 70 | 1 << CommonRegexParser.TUC - 70 | 1 << CommonRegexParser.UUC - 70 | 1 << CommonRegexParser.VUC - 70 | 1 << CommonRegexParser.WUC - 70 | 1 << CommonRegexParser.XUC - 70 | 1 << CommonRegexParser.YUC - 70 | 1 << CommonRegexParser.ZUC - 70 | 1 << CommonRegexParser.D1 - 70 | 1 << CommonRegexParser.D2 - 70 | 1 << CommonRegexParser.D3 - 70 | 1 << CommonRegexParser.D4 - 70 | 1 << CommonRegexParser.D5 - 70 | 1 << CommonRegexParser.D6 - 70)) !== 0 || (_la - 102 & ~0x1F) === 0 && (1 << _la - 102 & (1 << CommonRegexParser.D7 - 102 | 1 << CommonRegexParser.D8 - 102 | 1 << CommonRegexParser.D9 - 102 | 1 << CommonRegexParser.D0 - 102)) !== 0) {
            {
              this.state = 253;
              this._errHandler.sync(this);
              switch (this._input.LA(1)) {
                case CommonRegexParser.ALC:
                case CommonRegexParser.BLC:
                case CommonRegexParser.CLC:
                case CommonRegexParser.DLC:
                case CommonRegexParser.ELC:
                case CommonRegexParser.FLC:
                case CommonRegexParser.GLC:
                case CommonRegexParser.HLC:
                case CommonRegexParser.ILC:
                case CommonRegexParser.JLC:
                case CommonRegexParser.KLC:
                case CommonRegexParser.LLC:
                case CommonRegexParser.MLC:
                case CommonRegexParser.NLC:
                case CommonRegexParser.OLC:
                case CommonRegexParser.PLC:
                case CommonRegexParser.QLC:
                case CommonRegexParser.RLC:
                case CommonRegexParser.SLC:
                case CommonRegexParser.TLC:
                case CommonRegexParser.ULC:
                case CommonRegexParser.VLC:
                case CommonRegexParser.WLC:
                case CommonRegexParser.XLC:
                case CommonRegexParser.YLC:
                case CommonRegexParser.ZLC:
                case CommonRegexParser.AUC:
                case CommonRegexParser.BUC:
                case CommonRegexParser.CUC:
                case CommonRegexParser.DUC:
                case CommonRegexParser.EUC:
                case CommonRegexParser.FUC:
                case CommonRegexParser.GUC:
                case CommonRegexParser.HUC:
                case CommonRegexParser.IUC:
                case CommonRegexParser.JUC:
                case CommonRegexParser.KUC:
                case CommonRegexParser.LUC:
                case CommonRegexParser.MUC:
                case CommonRegexParser.NUC:
                case CommonRegexParser.OUC:
                case CommonRegexParser.PUC:
                case CommonRegexParser.QUC:
                case CommonRegexParser.RUC:
                case CommonRegexParser.SUC:
                case CommonRegexParser.TUC:
                case CommonRegexParser.UUC:
                case CommonRegexParser.VUC:
                case CommonRegexParser.WUC:
                case CommonRegexParser.XUC:
                case CommonRegexParser.YUC:
                case CommonRegexParser.ZUC:
                  {
                    this.state = 250;
                    this.letter();
                  }
                  break;
                case CommonRegexParser.Underscore:
                  {
                    this.state = 251;
                    this.match(CommonRegexParser.Underscore);
                  }
                  break;
                case CommonRegexParser.D1:
                case CommonRegexParser.D2:
                case CommonRegexParser.D3:
                case CommonRegexParser.D4:
                case CommonRegexParser.D5:
                case CommonRegexParser.D6:
                case CommonRegexParser.D7:
                case CommonRegexParser.D8:
                case CommonRegexParser.D9:
                case CommonRegexParser.D0:
                  {
                    this.state = 252;
                    this.digit();
                  }
                  break;
                default:
                  throw new NoViableAltException_1.NoViableAltException(this);
              }
            }
            this.state = 257;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
  }, {
    key: "non_close_parens",
    value: function non_close_parens() {
      var _localctx = new Non_close_parensContext(this._ctx, this.state);
      this.enterRule(_localctx, 48, CommonRegexParser.RULE_non_close_parens);
      var _la;
      try {
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 259;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          do {
            {
              {
                this.state = 258;
                this.non_close_paren();
              }
            }
            this.state = 261;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
          } while ((_la & ~0x1F) === 0 && (1 << _la & (1 << CommonRegexParser.Quoted | 1 << CommonRegexParser.BlockQuoted | 1 << CommonRegexParser.BellChar | 1 << CommonRegexParser.ControlChar | 1 << CommonRegexParser.EscapeChar | 1 << CommonRegexParser.FormFeed | 1 << CommonRegexParser.NewLine | 1 << CommonRegexParser.CarriageReturn | 1 << CommonRegexParser.Tab | 1 << CommonRegexParser.Backslash | 1 << CommonRegexParser.HexChar | 1 << CommonRegexParser.Dot | 1 << CommonRegexParser.DecimalDigit | 1 << CommonRegexParser.NotDecimalDigit | 1 << CommonRegexParser.CharWithProperty | 1 << CommonRegexParser.CharWithoutProperty | 1 << CommonRegexParser.WhiteSpace | 1 << CommonRegexParser.NotWhiteSpace | 1 << CommonRegexParser.WordChar | 1 << CommonRegexParser.NotWordChar | 1 << CommonRegexParser.CharacterClassStart | 1 << CommonRegexParser.CharacterClassEnd | 1 << CommonRegexParser.Caret | 1 << CommonRegexParser.Hyphen | 1 << CommonRegexParser.QuestionMark | 1 << CommonRegexParser.Plus | 1 << CommonRegexParser.Star | 1 << CommonRegexParser.OpenBrace | 1 << CommonRegexParser.CloseBrace | 1 << CommonRegexParser.Comma | 1 << CommonRegexParser.EndOfSubject)) !== 0 || (_la - 32 & ~0x1F) === 0 && (1 << _la - 32 & (1 << CommonRegexParser.Pipe - 32 | 1 << CommonRegexParser.OpenParen - 32 | 1 << CommonRegexParser.LessThan - 32 | 1 << CommonRegexParser.GreaterThan - 32 | 1 << CommonRegexParser.SingleQuote - 32 | 1 << CommonRegexParser.Underscore - 32 | 1 << CommonRegexParser.Colon - 32 | 1 << CommonRegexParser.Hash - 32 | 1 << CommonRegexParser.Equals - 32 | 1 << CommonRegexParser.Exclamation - 32 | 1 << CommonRegexParser.Ampersand - 32 | 1 << CommonRegexParser.ALC - 32 | 1 << CommonRegexParser.BLC - 32 | 1 << CommonRegexParser.CLC - 32 | 1 << CommonRegexParser.DLC - 32 | 1 << CommonRegexParser.ELC - 32 | 1 << CommonRegexParser.FLC - 32 | 1 << CommonRegexParser.GLC - 32 | 1 << CommonRegexParser.HLC - 32 | 1 << CommonRegexParser.ILC - 32 | 1 << CommonRegexParser.JLC - 32 | 1 << CommonRegexParser.KLC - 32 | 1 << CommonRegexParser.LLC - 32 | 1 << CommonRegexParser.MLC - 32 | 1 << CommonRegexParser.NLC - 32 | 1 << CommonRegexParser.OLC - 32 | 1 << CommonRegexParser.PLC - 32 | 1 << CommonRegexParser.QLC - 32 | 1 << CommonRegexParser.RLC - 32 | 1 << CommonRegexParser.SLC - 32 | 1 << CommonRegexParser.TLC - 32)) !== 0 || (_la - 64 & ~0x1F) === 0 && (1 << _la - 64 & (1 << CommonRegexParser.ULC - 64 | 1 << CommonRegexParser.VLC - 64 | 1 << CommonRegexParser.WLC - 64 | 1 << CommonRegexParser.XLC - 64 | 1 << CommonRegexParser.YLC - 64 | 1 << CommonRegexParser.ZLC - 64 | 1 << CommonRegexParser.AUC - 64 | 1 << CommonRegexParser.BUC - 64 | 1 << CommonRegexParser.CUC - 64 | 1 << CommonRegexParser.DUC - 64 | 1 << CommonRegexParser.EUC - 64 | 1 << CommonRegexParser.FUC - 64 | 1 << CommonRegexParser.GUC - 64 | 1 << CommonRegexParser.HUC - 64 | 1 << CommonRegexParser.IUC - 64 | 1 << CommonRegexParser.JUC - 64 | 1 << CommonRegexParser.KUC - 64 | 1 << CommonRegexParser.LUC - 64 | 1 << CommonRegexParser.MUC - 64 | 1 << CommonRegexParser.NUC - 64 | 1 << CommonRegexParser.OUC - 64 | 1 << CommonRegexParser.PUC - 64 | 1 << CommonRegexParser.QUC - 64 | 1 << CommonRegexParser.RUC - 64 | 1 << CommonRegexParser.SUC - 64 | 1 << CommonRegexParser.TUC - 64 | 1 << CommonRegexParser.UUC - 64 | 1 << CommonRegexParser.VUC - 64 | 1 << CommonRegexParser.WUC - 64 | 1 << CommonRegexParser.XUC - 64 | 1 << CommonRegexParser.YUC - 64 | 1 << CommonRegexParser.ZUC - 64)) !== 0 || (_la - 96 & ~0x1F) === 0 && (1 << _la - 96 & (1 << CommonRegexParser.D1 - 96 | 1 << CommonRegexParser.D2 - 96 | 1 << CommonRegexParser.D3 - 96 | 1 << CommonRegexParser.D4 - 96 | 1 << CommonRegexParser.D5 - 96 | 1 << CommonRegexParser.D6 - 96 | 1 << CommonRegexParser.D7 - 96 | 1 << CommonRegexParser.D8 - 96 | 1 << CommonRegexParser.D9 - 96 | 1 << CommonRegexParser.D0 - 96 | 1 << CommonRegexParser.OtherChar - 96)) !== 0);
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
  }, {
    key: "non_close_paren",
    value: function non_close_paren() {
      var _localctx = new Non_close_parenContext(this._ctx, this.state);
      this.enterRule(_localctx, 50, CommonRegexParser.RULE_non_close_paren);
      var _la;
      try {
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 263;
          _la = this._input.LA(1);
          if (_la <= 0 || _la === CommonRegexParser.CloseParen) {
            this._errHandler.recoverInline(this);
          } else {
            if (this._input.LA(1) === Token_1.Token.EOF) {
              this.matchedEOF = true;
            }
            this._errHandler.reportMatch(this);
            this.consume();
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
  }, {
    key: "letter",
    value: function letter() {
      var _localctx = new LetterContext(this._ctx, this.state);
      this.enterRule(_localctx, 52, CommonRegexParser.RULE_letter);
      var _la;
      try {
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 265;
          _la = this._input.LA(1);
          if (!((_la - 44 & ~0x1F) === 0 && (1 << _la - 44 & (1 << CommonRegexParser.ALC - 44 | 1 << CommonRegexParser.BLC - 44 | 1 << CommonRegexParser.CLC - 44 | 1 << CommonRegexParser.DLC - 44 | 1 << CommonRegexParser.ELC - 44 | 1 << CommonRegexParser.FLC - 44 | 1 << CommonRegexParser.GLC - 44 | 1 << CommonRegexParser.HLC - 44 | 1 << CommonRegexParser.ILC - 44 | 1 << CommonRegexParser.JLC - 44 | 1 << CommonRegexParser.KLC - 44 | 1 << CommonRegexParser.LLC - 44 | 1 << CommonRegexParser.MLC - 44 | 1 << CommonRegexParser.NLC - 44 | 1 << CommonRegexParser.OLC - 44 | 1 << CommonRegexParser.PLC - 44 | 1 << CommonRegexParser.QLC - 44 | 1 << CommonRegexParser.RLC - 44 | 1 << CommonRegexParser.SLC - 44 | 1 << CommonRegexParser.TLC - 44 | 1 << CommonRegexParser.ULC - 44 | 1 << CommonRegexParser.VLC - 44 | 1 << CommonRegexParser.WLC - 44 | 1 << CommonRegexParser.XLC - 44 | 1 << CommonRegexParser.YLC - 44 | 1 << CommonRegexParser.ZLC - 44 | 1 << CommonRegexParser.AUC - 44 | 1 << CommonRegexParser.BUC - 44 | 1 << CommonRegexParser.CUC - 44 | 1 << CommonRegexParser.DUC - 44 | 1 << CommonRegexParser.EUC - 44 | 1 << CommonRegexParser.FUC - 44)) !== 0 || (_la - 76 & ~0x1F) === 0 && (1 << _la - 76 & (1 << CommonRegexParser.GUC - 76 | 1 << CommonRegexParser.HUC - 76 | 1 << CommonRegexParser.IUC - 76 | 1 << CommonRegexParser.JUC - 76 | 1 << CommonRegexParser.KUC - 76 | 1 << CommonRegexParser.LUC - 76 | 1 << CommonRegexParser.MUC - 76 | 1 << CommonRegexParser.NUC - 76 | 1 << CommonRegexParser.OUC - 76 | 1 << CommonRegexParser.PUC - 76 | 1 << CommonRegexParser.QUC - 76 | 1 << CommonRegexParser.RUC - 76 | 1 << CommonRegexParser.SUC - 76 | 1 << CommonRegexParser.TUC - 76 | 1 << CommonRegexParser.UUC - 76 | 1 << CommonRegexParser.VUC - 76 | 1 << CommonRegexParser.WUC - 76 | 1 << CommonRegexParser.XUC - 76 | 1 << CommonRegexParser.YUC - 76 | 1 << CommonRegexParser.ZUC - 76)) !== 0)) {
            this._errHandler.recoverInline(this);
          } else {
            if (this._input.LA(1) === Token_1.Token.EOF) {
              this.matchedEOF = true;
            }
            this._errHandler.reportMatch(this);
            this.consume();
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
  }], [{
    key: "_ATN",
    get: function get() {
      if (!CommonRegexParser.__ATN) {
        CommonRegexParser.__ATN = new ATNDeserializer_1.ATNDeserializer().deserialize(Utils.toCharArray(CommonRegexParser._serializedATN));
      }
      return CommonRegexParser.__ATN;
    }
  }]);
  return CommonRegexParser;
}(Parser_1.Parser);
CommonRegexParser.Quoted = 1;
CommonRegexParser.BlockQuoted = 2;
CommonRegexParser.BellChar = 3;
CommonRegexParser.ControlChar = 4;
CommonRegexParser.EscapeChar = 5;
CommonRegexParser.FormFeed = 6;
CommonRegexParser.NewLine = 7;
CommonRegexParser.CarriageReturn = 8;
CommonRegexParser.Tab = 9;
CommonRegexParser.Backslash = 10;
CommonRegexParser.HexChar = 11;
CommonRegexParser.Dot = 12;
CommonRegexParser.DecimalDigit = 13;
CommonRegexParser.NotDecimalDigit = 14;
CommonRegexParser.CharWithProperty = 15;
CommonRegexParser.CharWithoutProperty = 16;
CommonRegexParser.WhiteSpace = 17;
CommonRegexParser.NotWhiteSpace = 18;
CommonRegexParser.WordChar = 19;
CommonRegexParser.NotWordChar = 20;
CommonRegexParser.CharacterClassStart = 21;
CommonRegexParser.CharacterClassEnd = 22;
CommonRegexParser.Caret = 23;
CommonRegexParser.Hyphen = 24;
CommonRegexParser.QuestionMark = 25;
CommonRegexParser.Plus = 26;
CommonRegexParser.Star = 27;
CommonRegexParser.OpenBrace = 28;
CommonRegexParser.CloseBrace = 29;
CommonRegexParser.Comma = 30;
CommonRegexParser.EndOfSubject = 31;
CommonRegexParser.Pipe = 32;
CommonRegexParser.OpenParen = 33;
CommonRegexParser.CloseParen = 34;
CommonRegexParser.LessThan = 35;
CommonRegexParser.GreaterThan = 36;
CommonRegexParser.SingleQuote = 37;
CommonRegexParser.Underscore = 38;
CommonRegexParser.Colon = 39;
CommonRegexParser.Hash = 40;
CommonRegexParser.Equals = 41;
CommonRegexParser.Exclamation = 42;
CommonRegexParser.Ampersand = 43;
CommonRegexParser.ALC = 44;
CommonRegexParser.BLC = 45;
CommonRegexParser.CLC = 46;
CommonRegexParser.DLC = 47;
CommonRegexParser.ELC = 48;
CommonRegexParser.FLC = 49;
CommonRegexParser.GLC = 50;
CommonRegexParser.HLC = 51;
CommonRegexParser.ILC = 52;
CommonRegexParser.JLC = 53;
CommonRegexParser.KLC = 54;
CommonRegexParser.LLC = 55;
CommonRegexParser.MLC = 56;
CommonRegexParser.NLC = 57;
CommonRegexParser.OLC = 58;
CommonRegexParser.PLC = 59;
CommonRegexParser.QLC = 60;
CommonRegexParser.RLC = 61;
CommonRegexParser.SLC = 62;
CommonRegexParser.TLC = 63;
CommonRegexParser.ULC = 64;
CommonRegexParser.VLC = 65;
CommonRegexParser.WLC = 66;
CommonRegexParser.XLC = 67;
CommonRegexParser.YLC = 68;
CommonRegexParser.ZLC = 69;
CommonRegexParser.AUC = 70;
CommonRegexParser.BUC = 71;
CommonRegexParser.CUC = 72;
CommonRegexParser.DUC = 73;
CommonRegexParser.EUC = 74;
CommonRegexParser.FUC = 75;
CommonRegexParser.GUC = 76;
CommonRegexParser.HUC = 77;
CommonRegexParser.IUC = 78;
CommonRegexParser.JUC = 79;
CommonRegexParser.KUC = 80;
CommonRegexParser.LUC = 81;
CommonRegexParser.MUC = 82;
CommonRegexParser.NUC = 83;
CommonRegexParser.OUC = 84;
CommonRegexParser.PUC = 85;
CommonRegexParser.QUC = 86;
CommonRegexParser.RUC = 87;
CommonRegexParser.SUC = 88;
CommonRegexParser.TUC = 89;
CommonRegexParser.UUC = 90;
CommonRegexParser.VUC = 91;
CommonRegexParser.WUC = 92;
CommonRegexParser.XUC = 93;
CommonRegexParser.YUC = 94;
CommonRegexParser.ZUC = 95;
CommonRegexParser.D1 = 96;
CommonRegexParser.D2 = 97;
CommonRegexParser.D3 = 98;
CommonRegexParser.D4 = 99;
CommonRegexParser.D5 = 100;
CommonRegexParser.D6 = 101;
CommonRegexParser.D7 = 102;
CommonRegexParser.D8 = 103;
CommonRegexParser.D9 = 104;
CommonRegexParser.D0 = 105;
CommonRegexParser.OtherChar = 106;
CommonRegexParser.RULE_parse = 0;
CommonRegexParser.RULE_alternation = 1;
CommonRegexParser.RULE_expr = 2;
CommonRegexParser.RULE_element = 3;
CommonRegexParser.RULE_quantifier = 4;
CommonRegexParser.RULE_quantifier_type = 5;
CommonRegexParser.RULE_character_class = 6;
CommonRegexParser.RULE_capture = 7;
CommonRegexParser.RULE_non_capture = 8;
CommonRegexParser.RULE_option = 9;
CommonRegexParser.RULE_option_flag = 10;
CommonRegexParser.RULE_atom = 11;
CommonRegexParser.RULE_cc_atom = 12;
CommonRegexParser.RULE_shared_atom = 13;
CommonRegexParser.RULE_literal = 14;
CommonRegexParser.RULE_cc_literal = 15;
CommonRegexParser.RULE_shared_literal = 16;
CommonRegexParser.RULE_number = 17;
CommonRegexParser.RULE_octal_char = 18;
CommonRegexParser.RULE_octal_digit = 19;
CommonRegexParser.RULE_digits = 20;
CommonRegexParser.RULE_digit = 21;
CommonRegexParser.RULE_name = 22;
CommonRegexParser.RULE_alpha_nums = 23;
CommonRegexParser.RULE_non_close_parens = 24;
CommonRegexParser.RULE_non_close_paren = 25;
CommonRegexParser.RULE_letter = 26;
// tslint:disable:no-trailing-whitespace
CommonRegexParser.ruleNames = ["parse", "alternation", "expr", "element", "quantifier", "quantifier_type", "character_class", "capture", "non_capture", "option", "option_flag", "atom", "cc_atom", "shared_atom", "literal", "cc_literal", "shared_literal", "number", "octal_char", "octal_digit", "digits", "digit", "name", "alpha_nums", "non_close_parens", "non_close_paren", "letter"];
CommonRegexParser._LITERAL_NAMES = [undefined, undefined, undefined, "'\\'", "'\\'", "'\\'", "'\\'", "'\\'", "'\\'", "'\\'", "'\\'", undefined, "'.'", "'\\'", "'\\'", undefined, undefined, "'\\'", "'\\'", "'\\'", "'\\'", "'['", "']'", "'^'", "'-'", "'?'", "'+'", "'*'", "'{'", "'}'", "','", "'$'", "'|'", "'('", "')'", "'<'", "'>'", "'''", "'_'", "':'", "'#'", "'='", "'!'", "'&'", "'a'", "'b'", "'c'", "'d'", "'e'", "'f'", "'g'", "'h'", "'i'", "'j'", "'k'", "'l'", "'m'", "'n'", "'o'", "'p'", "'q'", "'r'", "'s'", "'t'", "'u'", "'v'", "'w'", "'x'", "'y'", "'z'", "'A'", "'B'", "'C'", "'D'", "'E'", "'F'", "'G'", "'H'", "'I'", "'J'", "'K'", "'L'", "'M'", "'N'", "'O'", "'P'", "'Q'", "'R'", "'S'", "'T'", "'U'", "'V'", "'W'", "'X'", "'Y'", "'Z'", "'1'", "'2'", "'3'", "'4'", "'5'", "'6'", "'7'", "'8'", "'9'", "'0'"];
CommonRegexParser._SYMBOLIC_NAMES = [undefined, "Quoted", "BlockQuoted", "BellChar", "ControlChar", "EscapeChar", "FormFeed", "NewLine", "CarriageReturn", "Tab", "Backslash", "HexChar", "Dot", "DecimalDigit", "NotDecimalDigit", "CharWithProperty", "CharWithoutProperty", "WhiteSpace", "NotWhiteSpace", "WordChar", "NotWordChar", "CharacterClassStart", "CharacterClassEnd", "Caret", "Hyphen", "QuestionMark", "Plus", "Star", "OpenBrace", "CloseBrace", "Comma", "EndOfSubject", "Pipe", "OpenParen", "CloseParen", "LessThan", "GreaterThan", "SingleQuote", "Underscore", "Colon", "Hash", "Equals", "Exclamation", "Ampersand", "ALC", "BLC", "CLC", "DLC", "ELC", "FLC", "GLC", "HLC", "ILC", "JLC", "KLC", "LLC", "MLC", "NLC", "OLC", "PLC", "QLC", "RLC", "SLC", "TLC", "ULC", "VLC", "WLC", "XLC", "YLC", "ZLC", "AUC", "BUC", "CUC", "DUC", "EUC", "FUC", "GUC", "HUC", "IUC", "JUC", "KUC", "LUC", "MUC", "NUC", "OUC", "PUC", "QUC", "RUC", "SUC", "TUC", "UUC", "VUC", "WUC", "XUC", "YUC", "ZUC", "D1", "D2", "D3", "D4", "D5", "D6", "D7", "D8", "D9", "D0", "OtherChar"];
CommonRegexParser.VOCABULARY = new VocabularyImpl_1.VocabularyImpl(CommonRegexParser._LITERAL_NAMES, CommonRegexParser._SYMBOLIC_NAMES, []);
CommonRegexParser._serializedATN = "\x03\uC91D\uCABA\u058D\uAFBA\u4F53\u0607\uEA8B\uC241\x03l\u010E\x04\x02" + "\t\x02\x04\x03\t\x03\x04\x04\t\x04\x04\x05\t\x05\x04\x06\t\x06\x04\x07" + "\t\x07\x04\b\t\b\x04\t\t\t\x04\n\t\n\x04\v\t\v\x04\f\t\f\x04\r\t\r\x04" + "\x0E\t\x0E\x04\x0F\t\x0F\x04\x10\t\x10\x04\x11\t\x11\x04\x12\t\x12\x04" + "\x13\t\x13\x04\x14\t\x14\x04\x15\t\x15\x04\x16\t\x16\x04\x17\t\x17\x04" + "\x18\t\x18\x04\x19\t\x19\x04\x1A\t\x1A\x04\x1B\t\x1B\x04\x1C\t\x1C\x03" + "\x02\x03\x02\x03\x02\x03\x03\x03\x03\x03\x03\x07\x03?\n\x03\f\x03\x0E" + "\x03B\v\x03\x03\x04\x07\x04E\n\x04\f\x04\x0E\x04H\v\x04\x03\x05\x03\x05" + "\x05\x05L\n\x05\x03\x06\x03\x06\x03\x06\x03\x06\x03\x06\x03\x06\x03\x06" + "\x03\x06\x03\x06\x03\x06\x03\x06\x03\x06\x03\x06\x03\x06\x03\x06\x03\x06" + "\x03\x06\x03\x06\x03\x06\x03\x06\x03\x06\x03\x06\x03\x06\x03\x06\x05\x06" + "f\n\x06\x03\x07\x03\x07\x03\x07\x05\x07k\n\x07\x03\b\x03\b\x03\b\x06\b" + "p\n\b\r\b\x0E\bq\x03\b\x03\b\x03\b\x03\b\x06\bx\n\b\r\b\x0E\by\x03\b\x03" + "\b\x05\b~\n\b\x03\t\x03\t\x03\t\x03\t\x03\t\x03\t\x03\t\x03\t\x03\t\x03" + "\t\x03\t\x03\t\x05\t\x8C\n\t\x03\n\x03\n\x03\n\x03\n\x03\n\x03\n\x03\v" + "\x03\v\x03\v\x06\v\x97\n\v\r\v\x0E\v\x98\x03\v\x03\v\x03\f\x03\f\x03\r" + "\x03\r\x03\r\x03\r\x03\r\x03\r\x03\r\x03\r\x03\r\x05\r\xA8\n\r\x03\x0E" + "\x03\x0E\x03\x0E\x03\x0E\x03\x0E\x03\x0E\x05\x0E\xB0\n\x0E\x03\x0F\x03" + "\x0F\x03\x10\x03\x10\x05\x10\xB6\n\x10\x03\x11\x03\x11\x03\x11\x03\x11" + "\x03\x11\x03\x11\x03\x11\x03\x11\x03\x11\x03\x11\x03\x11\x05\x11\xC3\n" + "\x11\x03\x12\x03\x12\x03\x12\x03\x12\x03\x12\x03\x12\x03\x12\x03\x12\x03" + "\x12\x03\x12\x03\x12\x03\x12\x03\x12\x03\x12\x03\x12\x03\x12\x03\x12\x03" + "\x12\x03\x12\x03\x12\x03\x12\x03\x12\x03\x12\x03\x12\x03\x12\x03\x12\x05" + "\x12\xDF\n\x12\x03\x13\x03\x13\x03\x14\x03\x14\x03\x14\x03\x14\x03\x14" + "\x03\x14\x03\x14\x03\x14\x03\x14\x05\x14\xEC\n\x14\x03\x15\x03\x15\x03" + "\x16\x06\x16\xF1\n\x16\r\x16\x0E\x16\xF2\x03\x17\x03\x17\x03\x18\x03\x18" + "\x03\x19\x03\x19\x05\x19\xFB\n\x19\x03\x19\x03\x19\x03\x19\x07\x19\u0100" + "\n\x19\f\x19\x0E\x19\u0103\x0B\x19\x03\x1A\x06\x1A\u0106\n\x1A\r\x1A\x0E" + "\x1A\u0107\x03\x1B\x03\x1B\x03\x1C\x03\x1C\x03\x1C\x02\x02\x02\x1D\x02" + "\x02\x04\x02\x06\x02\b\x02\n\x02\f\x02\x0E\x02\x10\x02\x12\x02\x14\x02" + "\x16\x02\x18\x02\x1A\x02\x1C\x02\x1E\x02 \x02\"\x02$\x02&\x02(\x02*\x02" + ",\x02.\x020\x022\x024\x026\x02\x02\t\x05\x0266::@@\x04\x02\x06\x06\x0F" + "\x16\x04\x02bdkk\x04\x02bhkk\x03\x02bk\x03\x02$$\x03\x02.a\x02\u0136\x02" + "8\x03\x02\x02\x02\x04;\x03\x02\x02\x02\x06F\x03\x02\x02\x02\bI\x03\x02" + "\x02\x02\ne\x03\x02\x02\x02\fj\x03\x02\x02\x02\x0E}\x03\x02\x02\x02\x10" + "\x8B\x03\x02\x02\x02\x12\x8D\x03\x02\x02\x02\x14\x93\x03\x02\x02\x02\x16" + "\x9C\x03\x02\x02\x02\x18\xA7\x03\x02\x02\x02\x1A\xAF\x03\x02\x02\x02\x1C" + "\xB1\x03\x02\x02\x02\x1E\xB5\x03\x02\x02\x02 \xC2\x03\x02\x02\x02\"\xDE" + "\x03\x02\x02\x02$\xE0\x03\x02\x02\x02&\xEB\x03\x02\x02\x02(\xED\x03\x02" + "\x02\x02*\xF0\x03\x02\x02\x02,\xF4\x03\x02\x02\x02.\xF6\x03\x02\x02\x02" + "0\xFA\x03\x02\x02\x022\u0105\x03\x02\x02\x024\u0109\x03\x02\x02\x026\u010B" + "\x03\x02\x02\x0289\x05\x04\x03\x029:\x07\x02\x02\x03:\x03\x03\x02\x02" + "\x02;@\x05\x06\x04\x02<=\x07\"\x02\x02=?\x05\x06\x04\x02><\x03\x02\x02" + "\x02?B\x03\x02\x02\x02@>\x03\x02\x02\x02@A\x03\x02\x02\x02A\x05\x03\x02" + "\x02\x02B@\x03\x02\x02\x02CE\x05\b\x05\x02DC\x03\x02\x02\x02EH\x03\x02" + "\x02\x02FD\x03\x02\x02\x02FG\x03\x02\x02\x02G\x07\x03\x02\x02\x02HF\x03" + "\x02\x02\x02IK\x05\x18\r\x02JL\x05\n\x06\x02KJ\x03\x02\x02\x02KL\x03\x02" + "\x02\x02L\t\x03\x02\x02\x02MN\x07\x1B\x02\x02Nf\x05\f\x07\x02OP\x07\x1C" + "\x02\x02Pf\x05\f\x07\x02QR\x07\x1D\x02\x02Rf\x05\f\x07\x02ST\x07\x1E\x02" + "\x02TU\x05$\x13\x02UV\x07\x1F\x02\x02VW\x05\f\x07\x02Wf\x03\x02\x02\x02" + "XY\x07\x1E\x02\x02YZ\x05$\x13\x02Z[\x07 \x02\x02[\\\x07\x1F\x02\x02\\" + "]\x05\f\x07\x02]f\x03\x02\x02\x02^_\x07\x1E\x02\x02_`\x05$\x13\x02`a\x07" + " \x02\x02ab\x05$\x13\x02bc\x07\x1F\x02\x02cd\x05\f\x07\x02df\x03\x02\x02" + "\x02eM\x03\x02\x02\x02eO\x03\x02\x02\x02eQ\x03\x02\x02\x02eS\x03\x02\x02" + "\x02eX\x03\x02\x02\x02e^\x03\x02\x02\x02f\v\x03\x02\x02\x02gk\x07\x1C" + "\x02\x02hk\x07\x1B\x02\x02ik\x03\x02\x02\x02jg\x03\x02\x02\x02jh\x03\x02" + "\x02\x02ji\x03\x02\x02\x02k\r\x03\x02\x02\x02lm\x07\x17\x02\x02mo\x07" + "\x19\x02\x02np\x05\x1A\x0E\x02on\x03\x02\x02\x02pq\x03\x02\x02\x02qo\x03" + "\x02\x02\x02qr\x03\x02\x02\x02rs\x03\x02\x02\x02st\x07\x18\x02\x02t~\x03" + "\x02\x02\x02uw\x07\x17\x02\x02vx\x05\x1A\x0E\x02wv\x03\x02\x02\x02xy\x03" + "\x02\x02\x02yw\x03\x02\x02\x02yz\x03\x02\x02\x02z{\x03\x02\x02\x02{|\x07" + "\x18\x02\x02|~\x03\x02\x02\x02}l\x03\x02\x02\x02}u\x03\x02\x02\x02~\x0F" + "\x03\x02\x02\x02\x7F\x80\x07#\x02\x02\x80\x81\x07\x1B\x02\x02\x81\x82" + "\x07%\x02\x02\x82\x83\x05.\x18\x02\x83\x84\x07&\x02\x02\x84\x85\x05\x04" + "\x03\x02\x85\x86\x07$\x02\x02\x86\x8C\x03\x02\x02\x02\x87\x88\x07#\x02" + "\x02\x88\x89\x05\x04\x03\x02\x89\x8A\x07$\x02\x02\x8A\x8C\x03\x02\x02" + "\x02\x8B\x7F\x03\x02\x02\x02\x8B\x87\x03\x02\x02\x02\x8C\x11\x03\x02\x02" + "\x02\x8D\x8E\x07#\x02\x02\x8E\x8F\x07\x1B\x02\x02\x8F\x90\x07)\x02\x02" + "\x90\x91\x05\x04\x03\x02\x91\x92\x07$\x02\x02\x92\x13\x03\x02\x02\x02" + "\x93\x94\x07#\x02\x02\x94\x96\x07\x1B\x02\x02\x95\x97\x05\x16\f\x02\x96" + "\x95\x03\x02\x02\x02\x97\x98\x03\x02\x02\x02\x98\x96\x03\x02\x02\x02\x98" + "\x99\x03\x02\x02\x02\x99\x9A\x03\x02\x02\x02\x9A\x9B\x07$\x02\x02\x9B" + "\x15\x03\x02\x02\x02\x9C\x9D\t\x02\x02\x02\x9D\x17\x03\x02\x02\x02\x9E" + "\xA8\x05\x1C\x0F\x02\x9F\xA8\x05\x1E\x10\x02\xA0\xA8\x05\x0E\b\x02\xA1" + "\xA8\x05\x10\t\x02\xA2\xA8\x05\x12\n\x02\xA3\xA8\x05\x14\v\x02\xA4\xA8" + "\x07\x0E\x02\x02\xA5\xA8\x07\x19\x02\x02\xA6\xA8\x07!\x02\x02\xA7\x9E" + "\x03\x02\x02\x02\xA7\x9F\x03\x02\x02\x02\xA7\xA0\x03\x02\x02\x02\xA7\xA1" + "\x03\x02\x02\x02\xA7\xA2\x03\x02\x02\x02\xA7\xA3\x03\x02\x02\x02\xA7\xA4" + "\x03\x02\x02\x02\xA7\xA5\x03\x02\x02\x02\xA7\xA6\x03\x02\x02\x02\xA8\x19" + "\x03\x02\x02\x02\xA9\xAA\x05 \x11\x02\xAA\xAB\x07\x1A\x02\x02\xAB\xAC" + "\x05 \x11\x02\xAC\xB0\x03\x02\x02\x02\xAD\xB0\x05\x1C\x0F\x02\xAE\xB0" + "\x05 \x11\x02\xAF\xA9\x03\x02\x02\x02\xAF\xAD\x03\x02\x02\x02\xAF\xAE" + "\x03\x02\x02\x02\xB0\x1B\x03\x02\x02\x02\xB1\xB2\t\x03\x02\x02\xB2\x1D" + "\x03\x02\x02\x02\xB3\xB6\x05\"\x12\x02\xB4\xB6\x07\x18\x02\x02\xB5\xB3" + "\x03\x02\x02\x02\xB5\xB4\x03\x02\x02\x02\xB6\x1F\x03\x02\x02\x02\xB7\xC3" + "\x05\"\x12\x02\xB8\xC3\x07\x0E\x02\x02\xB9\xC3\x07\x17\x02\x02\xBA\xC3" + "\x07\x19\x02\x02\xBB\xC3\x07\x1B\x02\x02\xBC\xC3\x07\x1C\x02\x02\xBD\xC3" + "\x07\x1D\x02\x02\xBE\xC3\x07!\x02\x02\xBF\xC3\x07\"\x02\x02\xC0\xC3\x07" + "#\x02\x02\xC1\xC3\x07$\x02\x02\xC2\xB7\x03\x02\x02\x02\xC2\xB8\x03\x02" + "\x02\x02\xC2\xB9\x03\x02\x02\x02\xC2\xBA\x03\x02\x02\x02\xC2\xBB\x03\x02" + "\x02\x02\xC2\xBC\x03\x02\x02\x02\xC2\xBD\x03\x02\x02\x02\xC2\xBE\x03\x02" + "\x02\x02\xC2\xBF\x03\x02\x02\x02\xC2\xC0\x03\x02\x02\x02\xC2\xC1\x03\x02" + "\x02\x02\xC3!\x03\x02\x02\x02\xC4\xDF\x05&\x14\x02\xC5\xDF\x056\x1C\x02" + "\xC6\xDF\x05,\x17\x02\xC7\xDF\x07\x05\x02\x02\xC8\xDF\x07\x07\x02\x02" + "\xC9\xDF\x07\b\x02\x02\xCA\xDF\x07\t\x02\x02\xCB\xDF\x07\n\x02\x02\xCC" + "\xDF\x07\v\x02\x02\xCD\xDF\x07\r\x02\x02\xCE\xDF\x07\x03\x02\x02\xCF\xDF" + "\x07\x04\x02\x02\xD0\xDF\x07\x1E\x02\x02\xD1\xDF\x07\x1F\x02\x02\xD2\xDF" + "\x07 \x02\x02\xD3\xDF\x07\x1A\x02\x02\xD4\xDF\x07%\x02\x02\xD5\xDF\x07" + "&\x02\x02\xD6\xDF\x07\'\x02\x02\xD7\xDF\x07(\x02\x02\xD8\xDF\x07)\x02" + "\x02\xD9\xDF\x07*\x02\x02\xDA\xDF\x07+\x02\x02\xDB\xDF\x07,\x02\x02\xDC" + "\xDF\x07-\x02\x02\xDD\xDF\x07l\x02\x02\xDE\xC4\x03\x02\x02\x02\xDE\xC5" + "\x03\x02\x02\x02\xDE\xC6\x03\x02\x02\x02\xDE\xC7\x03\x02\x02\x02\xDE\xC8" + "\x03\x02\x02\x02\xDE\xC9\x03\x02\x02\x02\xDE\xCA\x03\x02\x02\x02\xDE\xCB" + "\x03\x02\x02\x02\xDE\xCC\x03\x02\x02\x02\xDE\xCD\x03\x02\x02\x02\xDE\xCE" + "\x03\x02\x02\x02\xDE\xCF\x03\x02\x02\x02\xDE\xD0\x03\x02\x02\x02\xDE\xD1" + "\x03\x02\x02\x02\xDE\xD2\x03\x02\x02\x02\xDE\xD3\x03\x02\x02\x02\xDE\xD4" + "\x03\x02\x02\x02\xDE\xD5\x03\x02\x02\x02\xDE\xD6\x03\x02\x02\x02\xDE\xD7" + "\x03\x02\x02\x02\xDE\xD8\x03\x02\x02\x02\xDE\xD9\x03\x02\x02\x02\xDE\xDA" + "\x03\x02\x02\x02\xDE\xDB\x03\x02\x02\x02\xDE\xDC\x03\x02\x02\x02\xDE\xDD" + "\x03\x02\x02\x02\xDF#\x03\x02\x02\x02\xE0\xE1\x05*\x16\x02\xE1%\x03\x02" + "\x02\x02\xE2\xE3\x07\f\x02\x02\xE3\xE4\t\x04\x02\x02\xE4\xE5\x05(\x15" + "\x02\xE5\xE6\x05(\x15\x02\xE6\xEC\x03\x02\x02\x02\xE7\xE8\x07\f\x02\x02" + "\xE8\xE9\x05(\x15\x02\xE9\xEA\x05(\x15\x02\xEA\xEC\x03\x02\x02\x02\xEB" + "\xE2\x03\x02\x02\x02\xEB\xE7\x03\x02\x02\x02\xEC\'\x03\x02\x02\x02\xED" + "\xEE\t\x05\x02\x02\xEE)\x03\x02\x02\x02\xEF\xF1\x05,\x17\x02\xF0\xEF\x03" + "\x02\x02\x02\xF1\xF2\x03\x02\x02\x02\xF2\xF0\x03\x02\x02\x02\xF2\xF3\x03" + "\x02\x02\x02\xF3+\x03\x02\x02\x02\xF4\xF5\t\x06\x02\x02\xF5-\x03\x02\x02" + "\x02\xF6\xF7\x050\x19\x02\xF7/\x03\x02\x02\x02\xF8\xFB\x056\x1C\x02\xF9" + "\xFB\x07(\x02\x02\xFA\xF8\x03\x02\x02\x02\xFA\xF9\x03\x02\x02\x02\xFB" + "\u0101\x03\x02\x02\x02\xFC\u0100\x056\x1C\x02\xFD\u0100\x07(\x02\x02\xFE" + "\u0100\x05,\x17\x02\xFF\xFC\x03\x02\x02\x02\xFF\xFD\x03\x02\x02\x02\xFF" + "\xFE\x03\x02\x02\x02\u0100\u0103\x03\x02\x02\x02\u0101\xFF\x03\x02\x02" + "\x02\u0101\u0102\x03\x02\x02\x02\u01021\x03\x02\x02\x02\u0103\u0101\x03" + "\x02\x02\x02\u0104\u0106\x054\x1B\x02\u0105\u0104\x03\x02\x02\x02\u0106" + "\u0107\x03\x02\x02\x02\u0107\u0105\x03\x02\x02\x02\u0107\u0108\x03\x02" + "\x02\x02\u01083\x03\x02\x02\x02\u0109\u010A\n\x07\x02\x02\u010A5\x03\x02" + "\x02\x02\u010B\u010C\t\b\x02\x02\u010C7\x03\x02\x02\x02\x17@FKejqy}\x8B" + "\x98\xA7\xAF\xB5\xC2\xDE\xEB\xF2\xFA\xFF\u0101\u0107";
exports.CommonRegexParser = CommonRegexParser;
var ParseContext = /*#__PURE__*/function (_ParserRuleContext_1$) {
  (0, _inherits2.default)(ParseContext, _ParserRuleContext_1$);
  var _super2 = _createSuper(ParseContext);
  function ParseContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, ParseContext);
    return _super2.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(ParseContext, [{
    key: "alternation",
    value: function alternation() {
      return this.getRuleContext(0, AlternationContext);
    }
  }, {
    key: "EOF",
    value: function EOF() {
      return this.getToken(CommonRegexParser.EOF, 0);
    }
  }, {
    key: "ruleIndex",
    get: function get() {
      return CommonRegexParser.RULE_parse;
    }
    // @Override
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterParse) {
        listener.enterParse(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitParse) {
        listener.exitParse(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitParse) {
        return visitor.visitParse(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return ParseContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.ParseContext = ParseContext;
var AlternationContext = /*#__PURE__*/function (_ParserRuleContext_1$2) {
  (0, _inherits2.default)(AlternationContext, _ParserRuleContext_1$2);
  var _super3 = _createSuper(AlternationContext);
  function AlternationContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, AlternationContext);
    return _super3.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(AlternationContext, [{
    key: "expr",
    value: function expr(i) {
      if (i === undefined) {
        return this.getRuleContexts(ExprContext);
      } else {
        return this.getRuleContext(i, ExprContext);
      }
    }
  }, {
    key: "Pipe",
    value: function Pipe(i) {
      if (i === undefined) {
        return this.getTokens(CommonRegexParser.Pipe);
      } else {
        return this.getToken(CommonRegexParser.Pipe, i);
      }
    }
  }, {
    key: "ruleIndex",
    get: function get() {
      return CommonRegexParser.RULE_alternation;
    }
    // @Override
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterAlternation) {
        listener.enterAlternation(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitAlternation) {
        listener.exitAlternation(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitAlternation) {
        return visitor.visitAlternation(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return AlternationContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.AlternationContext = AlternationContext;
var ExprContext = /*#__PURE__*/function (_ParserRuleContext_1$3) {
  (0, _inherits2.default)(ExprContext, _ParserRuleContext_1$3);
  var _super4 = _createSuper(ExprContext);
  function ExprContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, ExprContext);
    return _super4.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(ExprContext, [{
    key: "element",
    value: function element(i) {
      if (i === undefined) {
        return this.getRuleContexts(ElementContext);
      } else {
        return this.getRuleContext(i, ElementContext);
      }
    }
  }, {
    key: "ruleIndex",
    get: function get() {
      return CommonRegexParser.RULE_expr;
    }
    // @Override
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterExpr) {
        listener.enterExpr(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitExpr) {
        listener.exitExpr(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitExpr) {
        return visitor.visitExpr(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return ExprContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.ExprContext = ExprContext;
var ElementContext = /*#__PURE__*/function (_ParserRuleContext_1$4) {
  (0, _inherits2.default)(ElementContext, _ParserRuleContext_1$4);
  var _super5 = _createSuper(ElementContext);
  function ElementContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, ElementContext);
    return _super5.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(ElementContext, [{
    key: "atom",
    value: function atom() {
      return this.getRuleContext(0, AtomContext);
    }
  }, {
    key: "quantifier",
    value: function quantifier() {
      return this.tryGetRuleContext(0, QuantifierContext);
    }
  }, {
    key: "ruleIndex",
    get: function get() {
      return CommonRegexParser.RULE_element;
    }
    // @Override
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterElement) {
        listener.enterElement(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitElement) {
        listener.exitElement(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitElement) {
        return visitor.visitElement(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return ElementContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.ElementContext = ElementContext;
var QuantifierContext = /*#__PURE__*/function (_ParserRuleContext_1$5) {
  (0, _inherits2.default)(QuantifierContext, _ParserRuleContext_1$5);
  var _super6 = _createSuper(QuantifierContext);
  function QuantifierContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, QuantifierContext);
    return _super6.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(QuantifierContext, [{
    key: "QuestionMark",
    value: function QuestionMark() {
      return this.tryGetToken(CommonRegexParser.QuestionMark, 0);
    }
  }, {
    key: "quantifier_type",
    value: function quantifier_type() {
      return this.getRuleContext(0, Quantifier_typeContext);
    }
  }, {
    key: "Plus",
    value: function Plus() {
      return this.tryGetToken(CommonRegexParser.Plus, 0);
    }
  }, {
    key: "Star",
    value: function Star() {
      return this.tryGetToken(CommonRegexParser.Star, 0);
    }
  }, {
    key: "OpenBrace",
    value: function OpenBrace() {
      return this.tryGetToken(CommonRegexParser.OpenBrace, 0);
    }
  }, {
    key: "number",
    value: function number(i) {
      if (i === undefined) {
        return this.getRuleContexts(NumberContext);
      } else {
        return this.getRuleContext(i, NumberContext);
      }
    }
  }, {
    key: "CloseBrace",
    value: function CloseBrace() {
      return this.tryGetToken(CommonRegexParser.CloseBrace, 0);
    }
  }, {
    key: "Comma",
    value: function Comma() {
      return this.tryGetToken(CommonRegexParser.Comma, 0);
    }
  }, {
    key: "ruleIndex",
    get: function get() {
      return CommonRegexParser.RULE_quantifier;
    }
    // @Override
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterQuantifier) {
        listener.enterQuantifier(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitQuantifier) {
        listener.exitQuantifier(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitQuantifier) {
        return visitor.visitQuantifier(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return QuantifierContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.QuantifierContext = QuantifierContext;
var Quantifier_typeContext = /*#__PURE__*/function (_ParserRuleContext_1$6) {
  (0, _inherits2.default)(Quantifier_typeContext, _ParserRuleContext_1$6);
  var _super7 = _createSuper(Quantifier_typeContext);
  function Quantifier_typeContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, Quantifier_typeContext);
    return _super7.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(Quantifier_typeContext, [{
    key: "Plus",
    value: function Plus() {
      return this.tryGetToken(CommonRegexParser.Plus, 0);
    }
  }, {
    key: "QuestionMark",
    value: function QuestionMark() {
      return this.tryGetToken(CommonRegexParser.QuestionMark, 0);
    }
  }, {
    key: "ruleIndex",
    get: function get() {
      return CommonRegexParser.RULE_quantifier_type;
    }
    // @Override
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterQuantifier_type) {
        listener.enterQuantifier_type(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitQuantifier_type) {
        listener.exitQuantifier_type(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitQuantifier_type) {
        return visitor.visitQuantifier_type(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return Quantifier_typeContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.Quantifier_typeContext = Quantifier_typeContext;
var Character_classContext = /*#__PURE__*/function (_ParserRuleContext_1$7) {
  (0, _inherits2.default)(Character_classContext, _ParserRuleContext_1$7);
  var _super8 = _createSuper(Character_classContext);
  function Character_classContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, Character_classContext);
    return _super8.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(Character_classContext, [{
    key: "CharacterClassStart",
    value: function CharacterClassStart() {
      return this.getToken(CommonRegexParser.CharacterClassStart, 0);
    }
  }, {
    key: "Caret",
    value: function Caret() {
      return this.tryGetToken(CommonRegexParser.Caret, 0);
    }
  }, {
    key: "CharacterClassEnd",
    value: function CharacterClassEnd() {
      return this.getToken(CommonRegexParser.CharacterClassEnd, 0);
    }
  }, {
    key: "cc_atom",
    value: function cc_atom(i) {
      if (i === undefined) {
        return this.getRuleContexts(Cc_atomContext);
      } else {
        return this.getRuleContext(i, Cc_atomContext);
      }
    }
  }, {
    key: "ruleIndex",
    get: function get() {
      return CommonRegexParser.RULE_character_class;
    }
    // @Override
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterCharacter_class) {
        listener.enterCharacter_class(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitCharacter_class) {
        listener.exitCharacter_class(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitCharacter_class) {
        return visitor.visitCharacter_class(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return Character_classContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.Character_classContext = Character_classContext;
var CaptureContext = /*#__PURE__*/function (_ParserRuleContext_1$8) {
  (0, _inherits2.default)(CaptureContext, _ParserRuleContext_1$8);
  var _super9 = _createSuper(CaptureContext);
  function CaptureContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, CaptureContext);
    return _super9.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(CaptureContext, [{
    key: "OpenParen",
    value: function OpenParen() {
      return this.getToken(CommonRegexParser.OpenParen, 0);
    }
  }, {
    key: "QuestionMark",
    value: function QuestionMark() {
      return this.tryGetToken(CommonRegexParser.QuestionMark, 0);
    }
  }, {
    key: "LessThan",
    value: function LessThan() {
      return this.tryGetToken(CommonRegexParser.LessThan, 0);
    }
  }, {
    key: "name",
    value: function name() {
      return this.tryGetRuleContext(0, NameContext);
    }
  }, {
    key: "GreaterThan",
    value: function GreaterThan() {
      return this.tryGetToken(CommonRegexParser.GreaterThan, 0);
    }
  }, {
    key: "alternation",
    value: function alternation() {
      return this.getRuleContext(0, AlternationContext);
    }
  }, {
    key: "CloseParen",
    value: function CloseParen() {
      return this.getToken(CommonRegexParser.CloseParen, 0);
    }
  }, {
    key: "ruleIndex",
    get: function get() {
      return CommonRegexParser.RULE_capture;
    }
    // @Override
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterCapture) {
        listener.enterCapture(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitCapture) {
        listener.exitCapture(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitCapture) {
        return visitor.visitCapture(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return CaptureContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.CaptureContext = CaptureContext;
var Non_captureContext = /*#__PURE__*/function (_ParserRuleContext_1$9) {
  (0, _inherits2.default)(Non_captureContext, _ParserRuleContext_1$9);
  var _super10 = _createSuper(Non_captureContext);
  function Non_captureContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, Non_captureContext);
    return _super10.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(Non_captureContext, [{
    key: "OpenParen",
    value: function OpenParen() {
      return this.getToken(CommonRegexParser.OpenParen, 0);
    }
  }, {
    key: "QuestionMark",
    value: function QuestionMark() {
      return this.getToken(CommonRegexParser.QuestionMark, 0);
    }
  }, {
    key: "Colon",
    value: function Colon() {
      return this.getToken(CommonRegexParser.Colon, 0);
    }
  }, {
    key: "alternation",
    value: function alternation() {
      return this.getRuleContext(0, AlternationContext);
    }
  }, {
    key: "CloseParen",
    value: function CloseParen() {
      return this.getToken(CommonRegexParser.CloseParen, 0);
    }
  }, {
    key: "ruleIndex",
    get: function get() {
      return CommonRegexParser.RULE_non_capture;
    }
    // @Override
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterNon_capture) {
        listener.enterNon_capture(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitNon_capture) {
        listener.exitNon_capture(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitNon_capture) {
        return visitor.visitNon_capture(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return Non_captureContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.Non_captureContext = Non_captureContext;
var OptionContext = /*#__PURE__*/function (_ParserRuleContext_1$10) {
  (0, _inherits2.default)(OptionContext, _ParserRuleContext_1$10);
  var _super11 = _createSuper(OptionContext);
  function OptionContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, OptionContext);
    return _super11.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(OptionContext, [{
    key: "OpenParen",
    value: function OpenParen() {
      return this.getToken(CommonRegexParser.OpenParen, 0);
    }
  }, {
    key: "QuestionMark",
    value: function QuestionMark() {
      return this.getToken(CommonRegexParser.QuestionMark, 0);
    }
  }, {
    key: "CloseParen",
    value: function CloseParen() {
      return this.getToken(CommonRegexParser.CloseParen, 0);
    }
  }, {
    key: "option_flag",
    value: function option_flag(i) {
      if (i === undefined) {
        return this.getRuleContexts(Option_flagContext);
      } else {
        return this.getRuleContext(i, Option_flagContext);
      }
    }
  }, {
    key: "ruleIndex",
    get: function get() {
      return CommonRegexParser.RULE_option;
    }
    // @Override
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterOption) {
        listener.enterOption(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitOption) {
        listener.exitOption(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitOption) {
        return visitor.visitOption(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return OptionContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.OptionContext = OptionContext;
var Option_flagContext = /*#__PURE__*/function (_ParserRuleContext_1$11) {
  (0, _inherits2.default)(Option_flagContext, _ParserRuleContext_1$11);
  var _super12 = _createSuper(Option_flagContext);
  function Option_flagContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, Option_flagContext);
    return _super12.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(Option_flagContext, [{
    key: "ILC",
    value: function ILC() {
      return this.tryGetToken(CommonRegexParser.ILC, 0);
    }
  }, {
    key: "MLC",
    value: function MLC() {
      return this.tryGetToken(CommonRegexParser.MLC, 0);
    }
  }, {
    key: "SLC",
    value: function SLC() {
      return this.tryGetToken(CommonRegexParser.SLC, 0);
    }
  }, {
    key: "ruleIndex",
    get: function get() {
      return CommonRegexParser.RULE_option_flag;
    }
    // @Override
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterOption_flag) {
        listener.enterOption_flag(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitOption_flag) {
        listener.exitOption_flag(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitOption_flag) {
        return visitor.visitOption_flag(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return Option_flagContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.Option_flagContext = Option_flagContext;
var AtomContext = /*#__PURE__*/function (_ParserRuleContext_1$12) {
  (0, _inherits2.default)(AtomContext, _ParserRuleContext_1$12);
  var _super13 = _createSuper(AtomContext);
  function AtomContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, AtomContext);
    return _super13.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(AtomContext, [{
    key: "shared_atom",
    value: function shared_atom() {
      return this.tryGetRuleContext(0, Shared_atomContext);
    }
  }, {
    key: "literal",
    value: function literal() {
      return this.tryGetRuleContext(0, LiteralContext);
    }
  }, {
    key: "character_class",
    value: function character_class() {
      return this.tryGetRuleContext(0, Character_classContext);
    }
  }, {
    key: "capture",
    value: function capture() {
      return this.tryGetRuleContext(0, CaptureContext);
    }
  }, {
    key: "non_capture",
    value: function non_capture() {
      return this.tryGetRuleContext(0, Non_captureContext);
    }
  }, {
    key: "option",
    value: function option() {
      return this.tryGetRuleContext(0, OptionContext);
    }
  }, {
    key: "Dot",
    value: function Dot() {
      return this.tryGetToken(CommonRegexParser.Dot, 0);
    }
  }, {
    key: "Caret",
    value: function Caret() {
      return this.tryGetToken(CommonRegexParser.Caret, 0);
    }
  }, {
    key: "EndOfSubject",
    value: function EndOfSubject() {
      return this.tryGetToken(CommonRegexParser.EndOfSubject, 0);
    }
  }, {
    key: "ruleIndex",
    get: function get() {
      return CommonRegexParser.RULE_atom;
    }
    // @Override
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterAtom) {
        listener.enterAtom(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitAtom) {
        listener.exitAtom(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitAtom) {
        return visitor.visitAtom(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return AtomContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.AtomContext = AtomContext;
var Cc_atomContext = /*#__PURE__*/function (_ParserRuleContext_1$13) {
  (0, _inherits2.default)(Cc_atomContext, _ParserRuleContext_1$13);
  var _super14 = _createSuper(Cc_atomContext);
  function Cc_atomContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, Cc_atomContext);
    return _super14.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(Cc_atomContext, [{
    key: "cc_literal",
    value: function cc_literal(i) {
      if (i === undefined) {
        return this.getRuleContexts(Cc_literalContext);
      } else {
        return this.getRuleContext(i, Cc_literalContext);
      }
    }
  }, {
    key: "Hyphen",
    value: function Hyphen() {
      return this.tryGetToken(CommonRegexParser.Hyphen, 0);
    }
  }, {
    key: "shared_atom",
    value: function shared_atom() {
      return this.tryGetRuleContext(0, Shared_atomContext);
    }
  }, {
    key: "ruleIndex",
    get: function get() {
      return CommonRegexParser.RULE_cc_atom;
    }
    // @Override
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterCc_atom) {
        listener.enterCc_atom(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitCc_atom) {
        listener.exitCc_atom(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitCc_atom) {
        return visitor.visitCc_atom(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return Cc_atomContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.Cc_atomContext = Cc_atomContext;
var Shared_atomContext = /*#__PURE__*/function (_ParserRuleContext_1$14) {
  (0, _inherits2.default)(Shared_atomContext, _ParserRuleContext_1$14);
  var _super15 = _createSuper(Shared_atomContext);
  function Shared_atomContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, Shared_atomContext);
    return _super15.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(Shared_atomContext, [{
    key: "ControlChar",
    value: function ControlChar() {
      return this.tryGetToken(CommonRegexParser.ControlChar, 0);
    }
  }, {
    key: "DecimalDigit",
    value: function DecimalDigit() {
      return this.tryGetToken(CommonRegexParser.DecimalDigit, 0);
    }
  }, {
    key: "NotDecimalDigit",
    value: function NotDecimalDigit() {
      return this.tryGetToken(CommonRegexParser.NotDecimalDigit, 0);
    }
  }, {
    key: "CharWithProperty",
    value: function CharWithProperty() {
      return this.tryGetToken(CommonRegexParser.CharWithProperty, 0);
    }
  }, {
    key: "CharWithoutProperty",
    value: function CharWithoutProperty() {
      return this.tryGetToken(CommonRegexParser.CharWithoutProperty, 0);
    }
  }, {
    key: "WhiteSpace",
    value: function WhiteSpace() {
      return this.tryGetToken(CommonRegexParser.WhiteSpace, 0);
    }
  }, {
    key: "NotWhiteSpace",
    value: function NotWhiteSpace() {
      return this.tryGetToken(CommonRegexParser.NotWhiteSpace, 0);
    }
  }, {
    key: "WordChar",
    value: function WordChar() {
      return this.tryGetToken(CommonRegexParser.WordChar, 0);
    }
  }, {
    key: "NotWordChar",
    value: function NotWordChar() {
      return this.tryGetToken(CommonRegexParser.NotWordChar, 0);
    }
  }, {
    key: "ruleIndex",
    get: function get() {
      return CommonRegexParser.RULE_shared_atom;
    }
    // @Override
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterShared_atom) {
        listener.enterShared_atom(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitShared_atom) {
        listener.exitShared_atom(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitShared_atom) {
        return visitor.visitShared_atom(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return Shared_atomContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.Shared_atomContext = Shared_atomContext;
var LiteralContext = /*#__PURE__*/function (_ParserRuleContext_1$15) {
  (0, _inherits2.default)(LiteralContext, _ParserRuleContext_1$15);
  var _super16 = _createSuper(LiteralContext);
  function LiteralContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, LiteralContext);
    return _super16.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(LiteralContext, [{
    key: "shared_literal",
    value: function shared_literal() {
      return this.tryGetRuleContext(0, Shared_literalContext);
    }
  }, {
    key: "CharacterClassEnd",
    value: function CharacterClassEnd() {
      return this.tryGetToken(CommonRegexParser.CharacterClassEnd, 0);
    }
  }, {
    key: "ruleIndex",
    get: function get() {
      return CommonRegexParser.RULE_literal;
    }
    // @Override
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterLiteral) {
        listener.enterLiteral(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitLiteral) {
        listener.exitLiteral(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitLiteral) {
        return visitor.visitLiteral(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return LiteralContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.LiteralContext = LiteralContext;
var Cc_literalContext = /*#__PURE__*/function (_ParserRuleContext_1$16) {
  (0, _inherits2.default)(Cc_literalContext, _ParserRuleContext_1$16);
  var _super17 = _createSuper(Cc_literalContext);
  function Cc_literalContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, Cc_literalContext);
    return _super17.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(Cc_literalContext, [{
    key: "shared_literal",
    value: function shared_literal() {
      return this.tryGetRuleContext(0, Shared_literalContext);
    }
  }, {
    key: "Dot",
    value: function Dot() {
      return this.tryGetToken(CommonRegexParser.Dot, 0);
    }
  }, {
    key: "CharacterClassStart",
    value: function CharacterClassStart() {
      return this.tryGetToken(CommonRegexParser.CharacterClassStart, 0);
    }
  }, {
    key: "Caret",
    value: function Caret() {
      return this.tryGetToken(CommonRegexParser.Caret, 0);
    }
  }, {
    key: "QuestionMark",
    value: function QuestionMark() {
      return this.tryGetToken(CommonRegexParser.QuestionMark, 0);
    }
  }, {
    key: "Plus",
    value: function Plus() {
      return this.tryGetToken(CommonRegexParser.Plus, 0);
    }
  }, {
    key: "Star",
    value: function Star() {
      return this.tryGetToken(CommonRegexParser.Star, 0);
    }
  }, {
    key: "EndOfSubject",
    value: function EndOfSubject() {
      return this.tryGetToken(CommonRegexParser.EndOfSubject, 0);
    }
  }, {
    key: "Pipe",
    value: function Pipe() {
      return this.tryGetToken(CommonRegexParser.Pipe, 0);
    }
  }, {
    key: "OpenParen",
    value: function OpenParen() {
      return this.tryGetToken(CommonRegexParser.OpenParen, 0);
    }
  }, {
    key: "CloseParen",
    value: function CloseParen() {
      return this.tryGetToken(CommonRegexParser.CloseParen, 0);
    }
  }, {
    key: "ruleIndex",
    get: function get() {
      return CommonRegexParser.RULE_cc_literal;
    }
    // @Override
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterCc_literal) {
        listener.enterCc_literal(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitCc_literal) {
        listener.exitCc_literal(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitCc_literal) {
        return visitor.visitCc_literal(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return Cc_literalContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.Cc_literalContext = Cc_literalContext;
var Shared_literalContext = /*#__PURE__*/function (_ParserRuleContext_1$17) {
  (0, _inherits2.default)(Shared_literalContext, _ParserRuleContext_1$17);
  var _super18 = _createSuper(Shared_literalContext);
  function Shared_literalContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, Shared_literalContext);
    return _super18.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(Shared_literalContext, [{
    key: "octal_char",
    value: function octal_char() {
      return this.tryGetRuleContext(0, Octal_charContext);
    }
  }, {
    key: "letter",
    value: function letter() {
      return this.tryGetRuleContext(0, LetterContext);
    }
  }, {
    key: "digit",
    value: function digit() {
      return this.tryGetRuleContext(0, DigitContext);
    }
  }, {
    key: "BellChar",
    value: function BellChar() {
      return this.tryGetToken(CommonRegexParser.BellChar, 0);
    }
  }, {
    key: "EscapeChar",
    value: function EscapeChar() {
      return this.tryGetToken(CommonRegexParser.EscapeChar, 0);
    }
  }, {
    key: "FormFeed",
    value: function FormFeed() {
      return this.tryGetToken(CommonRegexParser.FormFeed, 0);
    }
  }, {
    key: "NewLine",
    value: function NewLine() {
      return this.tryGetToken(CommonRegexParser.NewLine, 0);
    }
  }, {
    key: "CarriageReturn",
    value: function CarriageReturn() {
      return this.tryGetToken(CommonRegexParser.CarriageReturn, 0);
    }
  }, {
    key: "Tab",
    value: function Tab() {
      return this.tryGetToken(CommonRegexParser.Tab, 0);
    }
  }, {
    key: "HexChar",
    value: function HexChar() {
      return this.tryGetToken(CommonRegexParser.HexChar, 0);
    }
  }, {
    key: "Quoted",
    value: function Quoted() {
      return this.tryGetToken(CommonRegexParser.Quoted, 0);
    }
  }, {
    key: "BlockQuoted",
    value: function BlockQuoted() {
      return this.tryGetToken(CommonRegexParser.BlockQuoted, 0);
    }
  }, {
    key: "OpenBrace",
    value: function OpenBrace() {
      return this.tryGetToken(CommonRegexParser.OpenBrace, 0);
    }
  }, {
    key: "CloseBrace",
    value: function CloseBrace() {
      return this.tryGetToken(CommonRegexParser.CloseBrace, 0);
    }
  }, {
    key: "Comma",
    value: function Comma() {
      return this.tryGetToken(CommonRegexParser.Comma, 0);
    }
  }, {
    key: "Hyphen",
    value: function Hyphen() {
      return this.tryGetToken(CommonRegexParser.Hyphen, 0);
    }
  }, {
    key: "LessThan",
    value: function LessThan() {
      return this.tryGetToken(CommonRegexParser.LessThan, 0);
    }
  }, {
    key: "GreaterThan",
    value: function GreaterThan() {
      return this.tryGetToken(CommonRegexParser.GreaterThan, 0);
    }
  }, {
    key: "SingleQuote",
    value: function SingleQuote() {
      return this.tryGetToken(CommonRegexParser.SingleQuote, 0);
    }
  }, {
    key: "Underscore",
    value: function Underscore() {
      return this.tryGetToken(CommonRegexParser.Underscore, 0);
    }
  }, {
    key: "Colon",
    value: function Colon() {
      return this.tryGetToken(CommonRegexParser.Colon, 0);
    }
  }, {
    key: "Hash",
    value: function Hash() {
      return this.tryGetToken(CommonRegexParser.Hash, 0);
    }
  }, {
    key: "Equals",
    value: function Equals() {
      return this.tryGetToken(CommonRegexParser.Equals, 0);
    }
  }, {
    key: "Exclamation",
    value: function Exclamation() {
      return this.tryGetToken(CommonRegexParser.Exclamation, 0);
    }
  }, {
    key: "Ampersand",
    value: function Ampersand() {
      return this.tryGetToken(CommonRegexParser.Ampersand, 0);
    }
  }, {
    key: "OtherChar",
    value: function OtherChar() {
      return this.tryGetToken(CommonRegexParser.OtherChar, 0);
    }
  }, {
    key: "ruleIndex",
    get: function get() {
      return CommonRegexParser.RULE_shared_literal;
    }
    // @Override
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterShared_literal) {
        listener.enterShared_literal(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitShared_literal) {
        listener.exitShared_literal(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitShared_literal) {
        return visitor.visitShared_literal(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return Shared_literalContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.Shared_literalContext = Shared_literalContext;
var NumberContext = /*#__PURE__*/function (_ParserRuleContext_1$18) {
  (0, _inherits2.default)(NumberContext, _ParserRuleContext_1$18);
  var _super19 = _createSuper(NumberContext);
  function NumberContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, NumberContext);
    return _super19.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(NumberContext, [{
    key: "digits",
    value: function digits() {
      return this.getRuleContext(0, DigitsContext);
    }
  }, {
    key: "ruleIndex",
    get: function get() {
      return CommonRegexParser.RULE_number;
    }
    // @Override
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterNumber) {
        listener.enterNumber(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitNumber) {
        listener.exitNumber(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitNumber) {
        return visitor.visitNumber(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return NumberContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.NumberContext = NumberContext;
var Octal_charContext = /*#__PURE__*/function (_ParserRuleContext_1$19) {
  (0, _inherits2.default)(Octal_charContext, _ParserRuleContext_1$19);
  var _super20 = _createSuper(Octal_charContext);
  function Octal_charContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, Octal_charContext);
    return _super20.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(Octal_charContext, [{
    key: "Backslash",
    value: function Backslash() {
      return this.tryGetToken(CommonRegexParser.Backslash, 0);
    }
  }, {
    key: "octal_digit",
    value: function octal_digit(i) {
      if (i === undefined) {
        return this.getRuleContexts(Octal_digitContext);
      } else {
        return this.getRuleContext(i, Octal_digitContext);
      }
    }
  }, {
    key: "D0",
    value: function D0() {
      return this.tryGetToken(CommonRegexParser.D0, 0);
    }
  }, {
    key: "D1",
    value: function D1() {
      return this.tryGetToken(CommonRegexParser.D1, 0);
    }
  }, {
    key: "D2",
    value: function D2() {
      return this.tryGetToken(CommonRegexParser.D2, 0);
    }
  }, {
    key: "D3",
    value: function D3() {
      return this.tryGetToken(CommonRegexParser.D3, 0);
    }
  }, {
    key: "ruleIndex",
    get: function get() {
      return CommonRegexParser.RULE_octal_char;
    }
    // @Override
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterOctal_char) {
        listener.enterOctal_char(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitOctal_char) {
        listener.exitOctal_char(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitOctal_char) {
        return visitor.visitOctal_char(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return Octal_charContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.Octal_charContext = Octal_charContext;
var Octal_digitContext = /*#__PURE__*/function (_ParserRuleContext_1$20) {
  (0, _inherits2.default)(Octal_digitContext, _ParserRuleContext_1$20);
  var _super21 = _createSuper(Octal_digitContext);
  function Octal_digitContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, Octal_digitContext);
    return _super21.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(Octal_digitContext, [{
    key: "D0",
    value: function D0() {
      return this.tryGetToken(CommonRegexParser.D0, 0);
    }
  }, {
    key: "D1",
    value: function D1() {
      return this.tryGetToken(CommonRegexParser.D1, 0);
    }
  }, {
    key: "D2",
    value: function D2() {
      return this.tryGetToken(CommonRegexParser.D2, 0);
    }
  }, {
    key: "D3",
    value: function D3() {
      return this.tryGetToken(CommonRegexParser.D3, 0);
    }
  }, {
    key: "D4",
    value: function D4() {
      return this.tryGetToken(CommonRegexParser.D4, 0);
    }
  }, {
    key: "D5",
    value: function D5() {
      return this.tryGetToken(CommonRegexParser.D5, 0);
    }
  }, {
    key: "D6",
    value: function D6() {
      return this.tryGetToken(CommonRegexParser.D6, 0);
    }
  }, {
    key: "D7",
    value: function D7() {
      return this.tryGetToken(CommonRegexParser.D7, 0);
    }
  }, {
    key: "ruleIndex",
    get: function get() {
      return CommonRegexParser.RULE_octal_digit;
    }
    // @Override
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterOctal_digit) {
        listener.enterOctal_digit(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitOctal_digit) {
        listener.exitOctal_digit(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitOctal_digit) {
        return visitor.visitOctal_digit(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return Octal_digitContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.Octal_digitContext = Octal_digitContext;
var DigitsContext = /*#__PURE__*/function (_ParserRuleContext_1$21) {
  (0, _inherits2.default)(DigitsContext, _ParserRuleContext_1$21);
  var _super22 = _createSuper(DigitsContext);
  function DigitsContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, DigitsContext);
    return _super22.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(DigitsContext, [{
    key: "digit",
    value: function digit(i) {
      if (i === undefined) {
        return this.getRuleContexts(DigitContext);
      } else {
        return this.getRuleContext(i, DigitContext);
      }
    }
  }, {
    key: "ruleIndex",
    get: function get() {
      return CommonRegexParser.RULE_digits;
    }
    // @Override
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterDigits) {
        listener.enterDigits(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitDigits) {
        listener.exitDigits(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitDigits) {
        return visitor.visitDigits(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return DigitsContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.DigitsContext = DigitsContext;
var DigitContext = /*#__PURE__*/function (_ParserRuleContext_1$22) {
  (0, _inherits2.default)(DigitContext, _ParserRuleContext_1$22);
  var _super23 = _createSuper(DigitContext);
  function DigitContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, DigitContext);
    return _super23.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(DigitContext, [{
    key: "D0",
    value: function D0() {
      return this.tryGetToken(CommonRegexParser.D0, 0);
    }
  }, {
    key: "D1",
    value: function D1() {
      return this.tryGetToken(CommonRegexParser.D1, 0);
    }
  }, {
    key: "D2",
    value: function D2() {
      return this.tryGetToken(CommonRegexParser.D2, 0);
    }
  }, {
    key: "D3",
    value: function D3() {
      return this.tryGetToken(CommonRegexParser.D3, 0);
    }
  }, {
    key: "D4",
    value: function D4() {
      return this.tryGetToken(CommonRegexParser.D4, 0);
    }
  }, {
    key: "D5",
    value: function D5() {
      return this.tryGetToken(CommonRegexParser.D5, 0);
    }
  }, {
    key: "D6",
    value: function D6() {
      return this.tryGetToken(CommonRegexParser.D6, 0);
    }
  }, {
    key: "D7",
    value: function D7() {
      return this.tryGetToken(CommonRegexParser.D7, 0);
    }
  }, {
    key: "D8",
    value: function D8() {
      return this.tryGetToken(CommonRegexParser.D8, 0);
    }
  }, {
    key: "D9",
    value: function D9() {
      return this.tryGetToken(CommonRegexParser.D9, 0);
    }
  }, {
    key: "ruleIndex",
    get: function get() {
      return CommonRegexParser.RULE_digit;
    }
    // @Override
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterDigit) {
        listener.enterDigit(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitDigit) {
        listener.exitDigit(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitDigit) {
        return visitor.visitDigit(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return DigitContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.DigitContext = DigitContext;
var NameContext = /*#__PURE__*/function (_ParserRuleContext_1$23) {
  (0, _inherits2.default)(NameContext, _ParserRuleContext_1$23);
  var _super24 = _createSuper(NameContext);
  function NameContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, NameContext);
    return _super24.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(NameContext, [{
    key: "alpha_nums",
    value: function alpha_nums() {
      return this.getRuleContext(0, Alpha_numsContext);
    }
  }, {
    key: "ruleIndex",
    get: function get() {
      return CommonRegexParser.RULE_name;
    }
    // @Override
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterName) {
        listener.enterName(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitName) {
        listener.exitName(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitName) {
        return visitor.visitName(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return NameContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.NameContext = NameContext;
var Alpha_numsContext = /*#__PURE__*/function (_ParserRuleContext_1$24) {
  (0, _inherits2.default)(Alpha_numsContext, _ParserRuleContext_1$24);
  var _super25 = _createSuper(Alpha_numsContext);
  function Alpha_numsContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, Alpha_numsContext);
    return _super25.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(Alpha_numsContext, [{
    key: "letter",
    value: function letter(i) {
      if (i === undefined) {
        return this.getRuleContexts(LetterContext);
      } else {
        return this.getRuleContext(i, LetterContext);
      }
    }
  }, {
    key: "Underscore",
    value: function Underscore(i) {
      if (i === undefined) {
        return this.getTokens(CommonRegexParser.Underscore);
      } else {
        return this.getToken(CommonRegexParser.Underscore, i);
      }
    }
  }, {
    key: "digit",
    value: function digit(i) {
      if (i === undefined) {
        return this.getRuleContexts(DigitContext);
      } else {
        return this.getRuleContext(i, DigitContext);
      }
    }
  }, {
    key: "ruleIndex",
    get: function get() {
      return CommonRegexParser.RULE_alpha_nums;
    }
    // @Override
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterAlpha_nums) {
        listener.enterAlpha_nums(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitAlpha_nums) {
        listener.exitAlpha_nums(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitAlpha_nums) {
        return visitor.visitAlpha_nums(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return Alpha_numsContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.Alpha_numsContext = Alpha_numsContext;
var Non_close_parensContext = /*#__PURE__*/function (_ParserRuleContext_1$25) {
  (0, _inherits2.default)(Non_close_parensContext, _ParserRuleContext_1$25);
  var _super26 = _createSuper(Non_close_parensContext);
  function Non_close_parensContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, Non_close_parensContext);
    return _super26.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(Non_close_parensContext, [{
    key: "non_close_paren",
    value: function non_close_paren(i) {
      if (i === undefined) {
        return this.getRuleContexts(Non_close_parenContext);
      } else {
        return this.getRuleContext(i, Non_close_parenContext);
      }
    }
  }, {
    key: "ruleIndex",
    get: function get() {
      return CommonRegexParser.RULE_non_close_parens;
    }
    // @Override
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterNon_close_parens) {
        listener.enterNon_close_parens(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitNon_close_parens) {
        listener.exitNon_close_parens(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitNon_close_parens) {
        return visitor.visitNon_close_parens(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return Non_close_parensContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.Non_close_parensContext = Non_close_parensContext;
var Non_close_parenContext = /*#__PURE__*/function (_ParserRuleContext_1$26) {
  (0, _inherits2.default)(Non_close_parenContext, _ParserRuleContext_1$26);
  var _super27 = _createSuper(Non_close_parenContext);
  function Non_close_parenContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, Non_close_parenContext);
    return _super27.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(Non_close_parenContext, [{
    key: "CloseParen",
    value: function CloseParen() {
      return this.getToken(CommonRegexParser.CloseParen, 0);
    }
  }, {
    key: "ruleIndex",
    get: function get() {
      return CommonRegexParser.RULE_non_close_paren;
    }
    // @Override
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterNon_close_paren) {
        listener.enterNon_close_paren(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitNon_close_paren) {
        listener.exitNon_close_paren(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitNon_close_paren) {
        return visitor.visitNon_close_paren(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return Non_close_parenContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.Non_close_parenContext = Non_close_parenContext;
var LetterContext = /*#__PURE__*/function (_ParserRuleContext_1$27) {
  (0, _inherits2.default)(LetterContext, _ParserRuleContext_1$27);
  var _super28 = _createSuper(LetterContext);
  function LetterContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, LetterContext);
    return _super28.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(LetterContext, [{
    key: "ALC",
    value: function ALC() {
      return this.tryGetToken(CommonRegexParser.ALC, 0);
    }
  }, {
    key: "BLC",
    value: function BLC() {
      return this.tryGetToken(CommonRegexParser.BLC, 0);
    }
  }, {
    key: "CLC",
    value: function CLC() {
      return this.tryGetToken(CommonRegexParser.CLC, 0);
    }
  }, {
    key: "DLC",
    value: function DLC() {
      return this.tryGetToken(CommonRegexParser.DLC, 0);
    }
  }, {
    key: "ELC",
    value: function ELC() {
      return this.tryGetToken(CommonRegexParser.ELC, 0);
    }
  }, {
    key: "FLC",
    value: function FLC() {
      return this.tryGetToken(CommonRegexParser.FLC, 0);
    }
  }, {
    key: "GLC",
    value: function GLC() {
      return this.tryGetToken(CommonRegexParser.GLC, 0);
    }
  }, {
    key: "HLC",
    value: function HLC() {
      return this.tryGetToken(CommonRegexParser.HLC, 0);
    }
  }, {
    key: "ILC",
    value: function ILC() {
      return this.tryGetToken(CommonRegexParser.ILC, 0);
    }
  }, {
    key: "JLC",
    value: function JLC() {
      return this.tryGetToken(CommonRegexParser.JLC, 0);
    }
  }, {
    key: "KLC",
    value: function KLC() {
      return this.tryGetToken(CommonRegexParser.KLC, 0);
    }
  }, {
    key: "LLC",
    value: function LLC() {
      return this.tryGetToken(CommonRegexParser.LLC, 0);
    }
  }, {
    key: "MLC",
    value: function MLC() {
      return this.tryGetToken(CommonRegexParser.MLC, 0);
    }
  }, {
    key: "NLC",
    value: function NLC() {
      return this.tryGetToken(CommonRegexParser.NLC, 0);
    }
  }, {
    key: "OLC",
    value: function OLC() {
      return this.tryGetToken(CommonRegexParser.OLC, 0);
    }
  }, {
    key: "PLC",
    value: function PLC() {
      return this.tryGetToken(CommonRegexParser.PLC, 0);
    }
  }, {
    key: "QLC",
    value: function QLC() {
      return this.tryGetToken(CommonRegexParser.QLC, 0);
    }
  }, {
    key: "RLC",
    value: function RLC() {
      return this.tryGetToken(CommonRegexParser.RLC, 0);
    }
  }, {
    key: "SLC",
    value: function SLC() {
      return this.tryGetToken(CommonRegexParser.SLC, 0);
    }
  }, {
    key: "TLC",
    value: function TLC() {
      return this.tryGetToken(CommonRegexParser.TLC, 0);
    }
  }, {
    key: "ULC",
    value: function ULC() {
      return this.tryGetToken(CommonRegexParser.ULC, 0);
    }
  }, {
    key: "VLC",
    value: function VLC() {
      return this.tryGetToken(CommonRegexParser.VLC, 0);
    }
  }, {
    key: "WLC",
    value: function WLC() {
      return this.tryGetToken(CommonRegexParser.WLC, 0);
    }
  }, {
    key: "XLC",
    value: function XLC() {
      return this.tryGetToken(CommonRegexParser.XLC, 0);
    }
  }, {
    key: "YLC",
    value: function YLC() {
      return this.tryGetToken(CommonRegexParser.YLC, 0);
    }
  }, {
    key: "ZLC",
    value: function ZLC() {
      return this.tryGetToken(CommonRegexParser.ZLC, 0);
    }
  }, {
    key: "AUC",
    value: function AUC() {
      return this.tryGetToken(CommonRegexParser.AUC, 0);
    }
  }, {
    key: "BUC",
    value: function BUC() {
      return this.tryGetToken(CommonRegexParser.BUC, 0);
    }
  }, {
    key: "CUC",
    value: function CUC() {
      return this.tryGetToken(CommonRegexParser.CUC, 0);
    }
  }, {
    key: "DUC",
    value: function DUC() {
      return this.tryGetToken(CommonRegexParser.DUC, 0);
    }
  }, {
    key: "EUC",
    value: function EUC() {
      return this.tryGetToken(CommonRegexParser.EUC, 0);
    }
  }, {
    key: "FUC",
    value: function FUC() {
      return this.tryGetToken(CommonRegexParser.FUC, 0);
    }
  }, {
    key: "GUC",
    value: function GUC() {
      return this.tryGetToken(CommonRegexParser.GUC, 0);
    }
  }, {
    key: "HUC",
    value: function HUC() {
      return this.tryGetToken(CommonRegexParser.HUC, 0);
    }
  }, {
    key: "IUC",
    value: function IUC() {
      return this.tryGetToken(CommonRegexParser.IUC, 0);
    }
  }, {
    key: "JUC",
    value: function JUC() {
      return this.tryGetToken(CommonRegexParser.JUC, 0);
    }
  }, {
    key: "KUC",
    value: function KUC() {
      return this.tryGetToken(CommonRegexParser.KUC, 0);
    }
  }, {
    key: "LUC",
    value: function LUC() {
      return this.tryGetToken(CommonRegexParser.LUC, 0);
    }
  }, {
    key: "MUC",
    value: function MUC() {
      return this.tryGetToken(CommonRegexParser.MUC, 0);
    }
  }, {
    key: "NUC",
    value: function NUC() {
      return this.tryGetToken(CommonRegexParser.NUC, 0);
    }
  }, {
    key: "OUC",
    value: function OUC() {
      return this.tryGetToken(CommonRegexParser.OUC, 0);
    }
  }, {
    key: "PUC",
    value: function PUC() {
      return this.tryGetToken(CommonRegexParser.PUC, 0);
    }
  }, {
    key: "QUC",
    value: function QUC() {
      return this.tryGetToken(CommonRegexParser.QUC, 0);
    }
  }, {
    key: "RUC",
    value: function RUC() {
      return this.tryGetToken(CommonRegexParser.RUC, 0);
    }
  }, {
    key: "SUC",
    value: function SUC() {
      return this.tryGetToken(CommonRegexParser.SUC, 0);
    }
  }, {
    key: "TUC",
    value: function TUC() {
      return this.tryGetToken(CommonRegexParser.TUC, 0);
    }
  }, {
    key: "UUC",
    value: function UUC() {
      return this.tryGetToken(CommonRegexParser.UUC, 0);
    }
  }, {
    key: "VUC",
    value: function VUC() {
      return this.tryGetToken(CommonRegexParser.VUC, 0);
    }
  }, {
    key: "WUC",
    value: function WUC() {
      return this.tryGetToken(CommonRegexParser.WUC, 0);
    }
  }, {
    key: "XUC",
    value: function XUC() {
      return this.tryGetToken(CommonRegexParser.XUC, 0);
    }
  }, {
    key: "YUC",
    value: function YUC() {
      return this.tryGetToken(CommonRegexParser.YUC, 0);
    }
  }, {
    key: "ZUC",
    value: function ZUC() {
      return this.tryGetToken(CommonRegexParser.ZUC, 0);
    }
  }, {
    key: "ruleIndex",
    get: function get() {
      return CommonRegexParser.RULE_letter;
    }
    // @Override
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterLetter) {
        listener.enterLetter(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitLetter) {
        listener.exitLetter(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitLetter) {
        return visitor.visitLetter(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return LetterContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.LetterContext = LetterContext;

},{"@babel/runtime/helpers/assertThisInitialized":229,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"antlr4ts/NoViableAltException":284,"antlr4ts/Parser":285,"antlr4ts/ParserRuleContext":287,"antlr4ts/RecognitionException":290,"antlr4ts/Token":296,"antlr4ts/VocabularyImpl":298,"antlr4ts/atn/ATNDeserializer":303,"antlr4ts/atn/ParserATNSimulator":340,"antlr4ts/misc/Utils":385,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.string.match.js":627}],199:[function(require,module,exports){
"use strict";

function __export(m) {
  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
__export(require("./CommonRegexLexer"));
__export(require("./CommonRegexParser"));

},{"./CommonRegexLexer":197,"./CommonRegexParser":198}],200:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * locale info of decimal, thousands, grouping and currency.
 */
exports.localeInfo = {
  'ar-MA': {
    currency: ["\u062F.\u0645. ", ''],
    decimal: ',',
    thousands: '.',
    grouping: [3]
  },
  'en-IN': {
    currency: ["\u20B9", ''],
    decimal: '.',
    thousands: ',',
    grouping: [3, 2, 2, 2, 2, 2, 2, 2, 2, 2]
  },
  'ar-BH': {
    currency: ['', " \u062F.\u0628."],
    decimal: "\u066B",
    thousands: "\u066C",
    numerals: ["\u0660", "\u0661", "\u0662", "\u0663", "\u0664", "\u0665", "\u0666", "\u0667", "\u0668", "\u0669"],
    grouping: [3]
  },
  'ar-PS': {
    currency: ["\u20AA ", ''],
    decimal: "\u066B",
    thousands: "\u066C",
    numerals: ["\u0660", "\u0661", "\u0662", "\u0663", "\u0664", "\u0665", "\u0666", "\u0667", "\u0668", "\u0669"],
    grouping: [3]
  },
  'en-IE': {
    currency: ["\u20AC", ''],
    decimal: '.',
    thousands: ',',
    grouping: [3]
  },
  'it-IT': {
    currency: ["\u20AC", ''],
    decimal: ',',
    thousands: '.',
    grouping: [3]
  },
  'ar-EG': {
    currency: ['', " \u062C.\u0645."],
    decimal: "\u066B",
    thousands: "\u066C",
    numerals: ["\u0660", "\u0661", "\u0662", "\u0663", "\u0664", "\u0665", "\u0666", "\u0667", "\u0668", "\u0669"],
    grouping: [3]
  },
  'ar-IQ': {
    currency: ['', " \u062F.\u0639."],
    decimal: "\u066B",
    thousands: "\u066C",
    numerals: ["\u0660", "\u0661", "\u0662", "\u0663", "\u0664", "\u0665", "\u0666", "\u0667", "\u0668", "\u0669"],
    grouping: [3]
  },
  'ar-EH': {
    currency: ["\u062F.\u0645. ", ''],
    decimal: '.',
    thousands: ',',
    grouping: [3]
  },
  'ar-AE': {
    currency: ['', " \u062F.\u0625."],
    decimal: "\u066B",
    thousands: "\u066C",
    numerals: ["\u0660", "\u0661", "\u0662", "\u0663", "\u0664", "\u0665", "\u0666", "\u0667", "\u0668", "\u0669"],
    grouping: [3]
  },
  'ar-MR': {
    currency: ['', " \u0623.\u0645."],
    decimal: "\u066B",
    thousands: "\u066C",
    numerals: ["\u0660", "\u0661", "\u0662", "\u0663", "\u0664", "\u0665", "\u0666", "\u0667", "\u0668", "\u0669"],
    grouping: [3]
  },
  'uk-UA': {
    currency: ['', "\xA0\u20B4."],
    decimal: ',',
    thousands: "\xA0",
    grouping: [3]
  },
  'ca-ES': {
    currency: ['', "\xA0\u20AC"],
    decimal: ',',
    thousands: '.',
    grouping: [3]
  },
  'sv-SE': {
    currency: ['', ' kr'],
    decimal: ',',
    thousands: "\xA0",
    grouping: [3]
  },
  'ja-JP': {
    currency: ['', "\u5186"],
    decimal: '.',
    thousands: ',',
    grouping: [3]
  },
  'es-ES': {
    currency: ['', "\xA0\u20AC"],
    decimal: ',',
    thousands: '.',
    grouping: [3]
  },
  'fi-FI': {
    currency: ['', "\xA0\u20AC"],
    decimal: ',',
    thousands: "\xA0",
    grouping: [3]
  },
  'ar-DZ': {
    currency: ["\u062F.\u062C. ", ''],
    decimal: ',',
    thousands: '.',
    grouping: [3]
  },
  'en-GB': {
    currency: ["\xA3", ''],
    decimal: '.',
    thousands: ',',
    grouping: [3]
  },
  'cs-CZ': {
    currency: ['', "\xA0K\u010D"],
    decimal: ',',
    thousands: "\xA0",
    grouping: [3]
  },
  'ar-TD': {
    currency: ["\u200FFCFA ", ''],
    decimal: "\u066B",
    thousands: "\u066C",
    numerals: ["\u0660", "\u0661", "\u0662", "\u0663", "\u0664", "\u0665", "\u0666", "\u0667", "\u0668", "\u0669"],
    grouping: [3]
  },
  'de-CH': {
    currency: ['', "\xA0CHF"],
    decimal: ',',
    thousands: "'",
    grouping: [3]
  },
  'nl-NL': {
    currency: ["\u20AC\xA0", ''],
    decimal: ',',
    thousands: '.',
    grouping: [3]
  },
  'es-BO': {
    currency: ["Bs\xA0", ''],
    decimal: ',',
    percent: "\u202F%",
    thousands: '.',
    grouping: [3]
  },
  'ar-SY': {
    currency: ['', " \u0644.\u0633."],
    decimal: "\u066B",
    thousands: "\u066C",
    numerals: ["\u0660", "\u0661", "\u0662", "\u0663", "\u0664", "\u0665", "\u0666", "\u0667", "\u0668", "\u0669"],
    grouping: [3]
  },
  'ar-JO': {
    currency: ['', " \u062F.\u0623."],
    decimal: "\u066B",
    thousands: "\u066C",
    numerals: ["\u0660", "\u0661", "\u0662", "\u0663", "\u0664", "\u0665", "\u0666", "\u0667", "\u0668", "\u0669"],
    grouping: [3]
  },
  'en-CA': {
    currency: ['$', ''],
    decimal: '.',
    thousands: ',',
    grouping: [3]
  },
  'ar-ER': {
    currency: ['Nfk ', ''],
    decimal: "\u066B",
    thousands: "\u066C",
    numerals: ["\u0660", "\u0661", "\u0662", "\u0663", "\u0664", "\u0665", "\u0666", "\u0667", "\u0668", "\u0669"],
    grouping: [3]
  },
  'ar-LB': {
    currency: ['', " \u0644.\u0644."],
    decimal: "\u066B",
    thousands: "\u066C",
    numerals: ["\u0660", "\u0661", "\u0662", "\u0663", "\u0664", "\u0665", "\u0666", "\u0667", "\u0668", "\u0669"],
    grouping: [3]
  },
  'fr-CA': {
    currency: ['', '$'],
    decimal: ',',
    thousands: "\xA0",
    grouping: [3]
  },
  'ar-TN': {
    currency: ["\u062F.\u062A. ", ''],
    decimal: ',',
    thousands: '.',
    grouping: [3]
  },
  'ar-YE': {
    currency: ['', " \u0631.\u0649."],
    decimal: "\u066B",
    thousands: "\u066C",
    numerals: ["\u0660", "\u0661", "\u0662", "\u0663", "\u0664", "\u0665", "\u0666", "\u0667", "\u0668", "\u0669"],
    grouping: [3]
  },
  'ru-RU': {
    currency: ['', "\xA0\u0440\u0443\u0431."],
    decimal: ',',
    thousands: "\xA0",
    grouping: [3]
  },
  'en-US': {
    currency: ['$', ''],
    decimal: '.',
    thousands: ',',
    grouping: [3]
  },
  'ar-SS': {
    currency: ["\xA3 ", ''],
    decimal: "\u066B",
    thousands: "\u066C",
    numerals: ["\u0660", "\u0661", "\u0662", "\u0663", "\u0664", "\u0665", "\u0666", "\u0667", "\u0668", "\u0669"],
    grouping: [3]
  },
  'ar-SO': {
    currency: ["\u200FS ", ''],
    decimal: "\u066B",
    thousands: "\u066C",
    numerals: ["\u0660", "\u0661", "\u0662", "\u0663", "\u0664", "\u0665", "\u0666", "\u0667", "\u0668", "\u0669"],
    grouping: [3]
  },
  'hu-HU': {
    currency: ['', "\xA0Ft"],
    decimal: ',',
    thousands: "\xA0",
    grouping: [3]
  },
  'pt-BR': {
    currency: ['R$', ''],
    decimal: ',',
    thousands: '.',
    grouping: [3]
  },
  'ar-DJ': {
    currency: ["\u200FFdj ", ''],
    decimal: "\u066B",
    thousands: "\u066C",
    numerals: ["\u0660", "\u0661", "\u0662", "\u0663", "\u0664", "\u0665", "\u0666", "\u0667", "\u0668", "\u0669"],
    grouping: [3]
  },
  'ar-SD': {
    currency: ['', " \u062C.\u0633."],
    decimal: "\u066B",
    thousands: "\u066C",
    numerals: ["\u0660", "\u0661", "\u0662", "\u0663", "\u0664", "\u0665", "\u0666", "\u0667", "\u0668", "\u0669"],
    grouping: [3]
  },
  'ar-001': {
    currency: ['', ''],
    decimal: "\u066B",
    thousands: "\u066C",
    numerals: ["\u0660", "\u0661", "\u0662", "\u0663", "\u0664", "\u0665", "\u0666", "\u0667", "\u0668", "\u0669"],
    grouping: [3]
  },
  'ar-LY': {
    currency: ["\u062F.\u0644. ", ''],
    decimal: ',',
    thousands: '.',
    grouping: [3]
  },
  'ar-SA': {
    currency: ['', " \u0631.\u0633."],
    decimal: "\u066B",
    thousands: "\u066C",
    numerals: ["\u0660", "\u0661", "\u0662", "\u0663", "\u0664", "\u0665", "\u0666", "\u0667", "\u0668", "\u0669"],
    grouping: [3]
  },
  'ar-KW': {
    currency: ['', " \u062F.\u0643."],
    decimal: "\u066B",
    thousands: "\u066C",
    numerals: ["\u0660", "\u0661", "\u0662", "\u0663", "\u0664", "\u0665", "\u0666", "\u0667", "\u0668", "\u0669"],
    grouping: [3]
  },
  'pl-PL': {
    currency: ['', "z\u0142"],
    decimal: ',',
    thousands: '.',
    grouping: [3]
  },
  'ar-QA': {
    currency: ['', " \u0631.\u0642."],
    decimal: "\u066B",
    thousands: "\u066C",
    numerals: ["\u0660", "\u0661", "\u0662", "\u0663", "\u0664", "\u0665", "\u0666", "\u0667", "\u0668", "\u0669"],
    grouping: [3]
  },
  'mk-MK': {
    currency: ['', "\xA0\u0434\u0435\u043D."],
    decimal: ',',
    thousands: '.',
    grouping: [3]
  },
  'ko-KR': {
    currency: ["\u20A9", ''],
    decimal: '.',
    thousands: ',',
    grouping: [3]
  },
  'es-MX': {
    currency: ['$', ''],
    decimal: '.',
    thousands: ',',
    grouping: [3]
  },
  'ar-IL': {
    currency: ["\u20AA ", ''],
    decimal: "\u066B",
    thousands: "\u066C",
    numerals: ["\u0660", "\u0661", "\u0662", "\u0663", "\u0664", "\u0665", "\u0666", "\u0667", "\u0668", "\u0669"],
    grouping: [3]
  },
  'zh-CN': {
    currency: ["\xA5", ''],
    decimal: '.',
    thousands: ',',
    grouping: [3]
  },
  'de-DE': {
    currency: ['', "\xA0\u20AC"],
    decimal: ',',
    thousands: '.',
    grouping: [3]
  },
  'ar-OM': {
    currency: ['', " \u0631.\u0639."],
    decimal: "\u066B",
    thousands: "\u066C",
    numerals: ["\u0660", "\u0661", "\u0662", "\u0663", "\u0664", "\u0665", "\u0666", "\u0667", "\u0668", "\u0669"],
    grouping: [3]
  },
  'fr-FR': {
    currency: ['', "\xA0\u20AC"],
    decimal: ',',
    percent: "\u202F%",
    thousands: "\xA0",
    grouping: [3]
  },
  'ar-KM': {
    currency: ['', " \u0641.\u062C.\u0642."],
    decimal: "\u066B",
    thousands: "\u066C",
    numerals: ["\u0660", "\u0661", "\u0662", "\u0663", "\u0664", "\u0665", "\u0666", "\u0667", "\u0668", "\u0669"],
    grouping: [3]
  },
  'he-IL': {
    currency: ["\u20AA", ''],
    decimal: '.',
    thousands: ',',
    grouping: [3]
  }
};

},{}],201:[function(require,module,exports){
"use strict";

function __export(m) {
  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", {
  value: true
});
__export(require("./simpleObjectMemory"));
__export(require("./stackedMemory"));

},{"./simpleObjectMemory":202,"./stackedMemory":203}],202:[function(require,module,exports){
"use strict";

require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.map.js");
require("core-js/modules/es.array.filter.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.split.js");
require("core-js/modules/es.string.starts-with.js");
require("core-js/modules/es.string.ends-with.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.weak-set.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.map.js");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var extensions_1 = require("../extensions");
var functionUtils_internal_1 = require("../functionUtils.internal");
/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Simple implement of MemoryInterface
 */
var SimpleObjectMemory = /*#__PURE__*/function () {
  /**
   * Initializes a new instance of the [SimpleObjectMemory](xref:adaptive-expressions.SimpleObjectMemory) class.
   * This wraps a simple object as [MemoryInterface](xref:adaptive-expressions.MemoryInterface).
   *
   * @param memory The object to wrap.
   */
  function SimpleObjectMemory(memory) {
    (0, _classCallCheck2.default)(this, SimpleObjectMemory);
    this.memory = undefined;
    this.memory = memory;
  }
  /**
   * Transfer a common object to simple memory.
   *
   * @param obj Common object.
   * @returns Simple memory instance.
   */
  (0, _createClass2.default)(SimpleObjectMemory, [{
    key: "getValue",
    value:
    /**
     * Gets the value from a given path.
     *
     * @param path Given path.
     * @returns The value in the given path or undefined.
     */
    function getValue(path) {
      if (this.memory === undefined || path.length === 0) {
        return undefined;
      }
      var parts = path.split(/[.[\]]+/).filter(function (u) {
        return u !== undefined && u !== '';
      }).map(function (u) {
        if (u.startsWith('"') && u.endsWith('"') || u.startsWith("'") && u.endsWith("'")) {
          return u.substr(1, u.length - 2);
        } else {
          return u;
        }
      });
      var value;
      var curScope = this.memory;
      var _iterator = _createForOfIteratorHelper(parts),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var part = _step.value;
          var error = void 0;
          var idx = parseInt(part);
          if (!isNaN(idx) && Array.isArray(curScope)) {
            var _functionUtils_intern = functionUtils_internal_1.InternalFunctionUtils.accessIndex(curScope, idx);
            value = _functionUtils_intern.value;
            error = _functionUtils_intern.error;
          } else {
            var _functionUtils_intern2 = functionUtils_internal_1.InternalFunctionUtils.accessProperty(curScope, part);
            value = _functionUtils_intern2.value;
            error = _functionUtils_intern2.error;
          }
          if (error) {
            return undefined;
          }
          curScope = value;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return value;
    }
    /**
     * In this simple object scope, we don't allow you to set a path in which some parts in middle don't exist
     * for example
     * if you set dialog.a.b = x, but dialog.a don't exist, this will result in an error
     * because we can't and shouldn't smart create structure in the middle
     * you can implement a customzied Scope that support such behavior
     *
     * @param path Memory path.
     * @param input Value to set.
     */
  }, {
    key: "setValue",
    value: function setValue(path, input) {
      if (this.memory === undefined) {
        return;
      }
      var parts = path.split(/[.[\]]+/).filter(function (u) {
        return u !== undefined && u !== '';
      }).map(function (u) {
        if (u.startsWith('"') && u.endsWith('"') || u.startsWith("'") && u.endsWith("'")) {
          return u.substr(1, u.length - 2);
        } else {
          return u;
        }
      });
      var curScope = this.memory;
      var curPath = '';
      var error = undefined;
      // find the 2nd last value, ie, the container
      for (var i = 0; i < parts.length - 1; i++) {
        var _idx = parseInt(parts[i]);
        if (!isNaN(_idx) && Array.isArray(curScope)) {
          curPath = "[".concat(parts[i], "]");
          var _functionUtils_intern3 = functionUtils_internal_1.InternalFunctionUtils.accessIndex(curScope, _idx);
          curScope = _functionUtils_intern3.value;
          error = _functionUtils_intern3.error;
        } else {
          curPath = ".".concat(parts[i]);
          var _functionUtils_intern4 = functionUtils_internal_1.InternalFunctionUtils.accessProperty(curScope, parts[i]);
          curScope = _functionUtils_intern4.value;
          error = _functionUtils_intern4.error;
        }
        if (error) {
          return;
        }
        if (curScope === undefined) {
          curPath = curPath.replace(/(^\.*)/g, '');
          return;
        }
      }
      // set the last value
      var idx = parseInt(parts[parts.length - 1]);
      if (!isNaN(idx)) {
        if (Array.isArray(curScope)) {
          if (idx > curScope.length) {
            error = "".concat(idx, " index out of range");
          } else if (idx === curScope.length) {
            curScope.push(input);
          } else {
            curScope[idx] = input;
          }
        } else {
          error = 'set value for an index to a non-list object';
        }
        if (error) {
          return;
        }
      } else {
        error = this.setProperty(curScope, parts[parts.length - 1], input).error;
        if (error) {
          return;
        }
      }
      return;
    }
    /**
     * Returns the version info of [SimpleObjectMemory](xref:adaptive-expressions.SimpleObjectMemory).
     *
     * @returns A string value representing the version info.
     */
  }, {
    key: "version",
    value: function version() {
      return this.toString();
    }
    /**
     * Returns a string that represents the current [SimpleObjectMemory](xref:adaptive-expressions.SimpleObjectMemory) object.
     *
     * @returns A string value representing the current [SimpleObjectMemory](xref:adaptive-expressions.SimpleObjectMemory) object.
     */
  }, {
    key: "toString",
    value: function toString() {
      return JSON.stringify(this.memory, this.getCircularReplacer());
    }
    /**
     * @private
     */
  }, {
    key: "getCircularReplacer",
    value: function getCircularReplacer() {
      var seen = new WeakSet();
      // eslint-disable-next-line @typescript-eslint/ban-types
      return function (_key, value) {
        if ((0, _typeof2.default)(value) === 'object' && value) {
          if (seen.has(value)) {
            return;
          }
          seen.add(value);
        }
        return value;
      };
    }
    /**
     * @private
     */
  }, {
    key: "setProperty",
    value: function setProperty(instance, property, value) {
      var result = value;
      if (instance instanceof Map) {
        instance.set(property, value);
      } else {
        instance[property] = value;
      }
      return {
        value: result,
        error: undefined
      };
    }
  }], [{
    key: "wrap",
    value: function wrap(obj) {
      if (extensions_1.Extensions.isMemoryInterface(obj)) {
        return obj;
      }
      return new SimpleObjectMemory(obj);
    }
  }]);
  return SimpleObjectMemory;
}();
exports.SimpleObjectMemory = SimpleObjectMemory;

},{"../extensions":193,"../functionUtils.internal":195,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.filter.js":572,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.map.js":579,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.map.js":587,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.ends-with.js":623,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.string.replace.js":629,"core-js/modules/es.string.split.js":631,"core-js/modules/es.string.starts-with.js":632,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/es.weak-set.js":674,"core-js/modules/web.dom-collections.iterator.js":677}],203:[function(require,module,exports){
"use strict";

require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapNativeSuper"));
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Stack implements of MemoryInterface.
 * Memory variables have a hierarchical relationship.
 */
var StackedMemory = /*#__PURE__*/function (_Array) {
  (0, _inherits2.default)(StackedMemory, _Array);
  var _super = _createSuper(StackedMemory);
  function StackedMemory() {
    (0, _classCallCheck2.default)(this, StackedMemory);
    return _super.apply(this, arguments);
  }
  (0, _createClass2.default)(StackedMemory, [{
    key: "getValue",
    value:
    /**
     * Gets the value from a given path.
     *
     * @param path Given path.
     * @returns The value from the given path if found, otherwise, undefined.
     */
    function getValue(path) {
      if (this.length === 0) {
        return undefined;
      } else {
        var _iterator = _createForOfIteratorHelper(Array.from(this).reverse()),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var memory = _step.value;
            if (memory.getValue(path) !== undefined) {
              return memory.getValue(path);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return undefined;
      }
    }
    /**
     * Sets value to a given path.
     *
     * @param _path Memory path.
     * @param _value Value to set.
     */
  }, {
    key: "setValue",
    value: function setValue(_path, _value) {
      throw new Error("Can't set value to ".concat(_path, ", stacked memory is read-only"));
    }
    /**
     * Gets the version of the current [StackedMemory](xref:adaptive-expressions.StackedMemory).
     *
     * @returns A string value representing the version.
     */
  }, {
    key: "version",
    value: function version() {
      return '0';
    }
  }], [{
    key: "wrap",
    value:
    /**
     * Wraps an object that implements [MemoryInterface](xref:adaptive-expressions.MemoryInterface) into a [StackedMemory](xref:adaptive-expressions.StackedMemory) object.
     *
     * @param memory An object that implements [MemoryInterface](xref:adaptive-expressions.MemoryInterface).
     * @returns A [StackedMemory](xref:adaptive-expressions.StackedMemory) object.
     */
    function wrap(memory) {
      if (memory instanceof StackedMemory) {
        return memory;
      } else {
        var stackedMemory = new StackedMemory();
        stackedMemory.push(memory);
        return stackedMemory;
      }
    }
  }]);
  return StackedMemory;
}( /*#__PURE__*/(0, _wrapNativeSuper2.default)(Array));
exports.StackedMemory = StackedMemory;

},{"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/wrapNativeSuper":254,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],204:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Options used to define evaluation behaviors.
 */
var Options = /*#__PURE__*/(0, _createClass2.default)(
/**
 * Initializes a new instance of the [Options](xref:adaptive-expressions.Options) class.
 *
 * @param opt Optional. An [Options](xref:adaptive-expressions.Options) instance.
 */
function Options(opt) {
  (0, _classCallCheck2.default)(this, Options);
  this.nullSubstitution = opt ? opt.nullSubstitution : undefined;
  this.locale = opt ? opt.locale : undefined;
});
exports.Options = Options;

},{"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237}],205:[function(require,module,exports){
"use strict";

require("core-js/modules/es.reflect.construct.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.regexp.constructor.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.array.concat.js");
require("core-js/modules/es.string.starts-with.js");
require("core-js/modules/es.string.ends-with.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.string.trim.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.weak-map.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result["default"] = mod;
  return result;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
/* eslint-disable security/detect-object-injection */
/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var antlr4ts_1 = require("antlr4ts");
var tree_1 = require("antlr4ts/tree");
var constant_1 = require("../constant");
var expression_1 = require("../expression");
var expressionType_1 = require("../expressionType");
var generated_1 = require("./generated");
var ep = __importStar(require("./generated/ExpressionAntlrParser"));
var parseErrorListener_1 = require("./parseErrorListener");
var functionUtils_1 = require("../functionUtils");
/**
 * Parser to turn strings into Expression
 */
var ExpressionParser = /*#__PURE__*/function () {
  /**
   * Initializes a new instance of the [ExpressionParser](xref:adaptive-expressions.ExpressionParser) class.
   *
   * @param lookup [EvaluatorLookup](xref:adaptive-expressions.EvaluatorLookup) for information from type string.
   */
  function ExpressionParser(lookup) {
    (0, _classCallCheck2.default)(this, ExpressionParser);
    this.ExpressionTransformer = /*#__PURE__*/function (_tree_1$AbstractParse) {
      (0, _inherits2.default)(_class, _tree_1$AbstractParse);
      var _super = _createSuper(_class);
      function _class(lookup) {
        var _this;
        (0, _classCallCheck2.default)(this, _class);
        _this = _super.call(this);
        _this.escapeRegex = new RegExp(/\\[^\r\n]?/g);
        _this._lookupFunction = undefined;
        _this.transform = function (context) {
          return _this.visit(context);
        };
        _this.visitParenthesisExp = function (context) {
          return _this.visit(context.expression());
        };
        _this.defaultResult = function () {
          return new constant_1.Constant('');
        };
        _this.makeExpression = function (functionType) {
          var _expression_1$Express;
          if (!_this._lookupFunction(functionType)) {
            throw new Error("".concat(functionType, " does not have an evaluator, it's not a built-in function or a custom function."));
          }
          for (var _len = arguments.length, children = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            children[_key - 1] = arguments[_key];
          }
          return (_expression_1$Express = expression_1.Expression).makeExpression.apply(_expression_1$Express, [functionType, _this._lookupFunction(functionType)].concat(children));
        };
        _this._lookupFunction = lookup;
        return _this;
      }
      (0, _createClass2.default)(_class, [{
        key: "visitUnaryOpExp",
        value: function visitUnaryOpExp(context) {
          var unaryOperationName = context.getChild(0).text;
          var operand = this.visit(context.expression());
          if (unaryOperationName === expressionType_1.ExpressionType.Subtract || unaryOperationName === expressionType_1.ExpressionType.Add) {
            return this.makeExpression(unaryOperationName, new constant_1.Constant(0), operand);
          }
          return this.makeExpression(unaryOperationName, operand);
        }
      }, {
        key: "visitBinaryOpExp",
        value: function visitBinaryOpExp(context) {
          var binaryOperationName = context.getChild(1).text;
          var left = this.visit(context.expression(0));
          var right = this.visit(context.expression(1));
          return this.makeExpression(binaryOperationName, left, right);
        }
      }, {
        key: "visitTripleOpExp",
        value: function visitTripleOpExp(context) {
          var conditionalExpression = this.visit(context.expression(0));
          var left = this.visit(context.expression(1));
          var right = this.visit(context.expression(2));
          return this.makeExpression(expressionType_1.ExpressionType.If, conditionalExpression, left, right);
        }
      }, {
        key: "visitFuncInvokeExp",
        value: function visitFuncInvokeExp(context) {
          var parameters = this.processArgsList(context.argsList());
          // Remove the check to check primaryExpression is just an IDENTIFIER to support "." in template name
          var functionName = context.primaryExpression().text;
          if (context.NON() !== undefined) {
            functionName += context.NON().text;
          }
          return this.makeExpression.apply(this, [functionName].concat((0, _toConsumableArray2.default)(parameters)));
        }
      }, {
        key: "visitIdAtom",
        value: function visitIdAtom(context) {
          var result;
          var symbol = context.text;
          if (symbol === 'false') {
            result = new constant_1.Constant(false);
          } else if (symbol === 'true') {
            result = new constant_1.Constant(true);
          } else if (symbol === 'null') {
            result = new constant_1.Constant(null);
          } else if (symbol === 'undefined') {
            result = new constant_1.Constant(undefined);
          } else {
            result = this.makeExpression(expressionType_1.ExpressionType.Accessor, new constant_1.Constant(symbol));
          }
          return result;
        }
      }, {
        key: "visitIndexAccessExp",
        value: function visitIndexAccessExp(context) {
          var property = this.visit(context.expression());
          var instance = this.visit(context.primaryExpression());
          return this.makeExpression(expressionType_1.ExpressionType.Element, instance, property);
        }
      }, {
        key: "visitMemberAccessExp",
        value: function visitMemberAccessExp(context) {
          var property = context.IDENTIFIER().text;
          var instance = this.visit(context.primaryExpression());
          return this.makeExpression(expressionType_1.ExpressionType.Accessor, new constant_1.Constant(property), instance);
        }
      }, {
        key: "visitNumericAtom",
        value: function visitNumericAtom(context) {
          var numberValue = parseFloat(context.text);
          if (functionUtils_1.FunctionUtils.isNumber(numberValue)) {
            return new constant_1.Constant(numberValue);
          }
          throw new Error("".concat(context.text, " is not a number."));
        }
      }, {
        key: "visitArrayCreationExp",
        value: function visitArrayCreationExp(context) {
          var parameters = this.processArgsList(context.argsList());
          return this.makeExpression.apply(this, [expressionType_1.ExpressionType.CreateArray].concat((0, _toConsumableArray2.default)(parameters)));
        }
      }, {
        key: "visitStringAtom",
        value: function visitStringAtom(context) {
          var text = context.text;
          if (text.startsWith("'") && text.endsWith("'")) {
            text = text.substr(1, text.length - 2).replace(/\\'/g, "'");
          } else if (text.startsWith('"') && text.endsWith('"')) {
            // start with ""
            text = text.substr(1, text.length - 2).replace(/\\"/g, '"');
          } else {
            throw new Error("Invalid string ".concat(text));
          }
          return new constant_1.Constant(this.evalEscape(text));
        }
      }, {
        key: "visitJsonCreationExp",
        value: function visitJsonCreationExp(context) {
          var expr = this.makeExpression(expressionType_1.ExpressionType.Json, new constant_1.Constant('{}'));
          if (context.keyValuePairList()) {
            var _iterator = _createForOfIteratorHelper(context.keyValuePairList().keyValuePair()),
              _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var kvPair = _step.value;
                var key = '';
                var keyNode = kvPair.key().children[0];
                if (keyNode instanceof tree_1.TerminalNode) {
                  if (keyNode.symbol.type === ep.ExpressionAntlrParser.IDENTIFIER) {
                    key = keyNode.text;
                  } else {
                    key = keyNode.text.substring(1, keyNode.text.length - 1);
                  }
                }
                expr = this.makeExpression(expressionType_1.ExpressionType.SetProperty, expr, new constant_1.Constant(key), this.visit(kvPair.expression()));
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
          }
          return expr;
        }
      }, {
        key: "visitStringInterpolationAtom",
        value: function visitStringInterpolationAtom(context) {
          var children = [new constant_1.Constant('')];
          var _iterator2 = _createForOfIteratorHelper(context.stringInterpolation().children),
            _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var node = _step2.value;
              if (node instanceof tree_1.TerminalNode) {
                switch (node.symbol.type) {
                  case ep.ExpressionAntlrParser.TEMPLATE:
                    {
                      var expressionString = this.trimExpression(node.text);
                      children.push(expression_1.Expression.parse(expressionString, this._lookupFunction));
                      break;
                    }
                  case ep.ExpressionAntlrParser.ESCAPE_CHARACTER:
                    {
                      children.push(new constant_1.Constant(node.text.replace(/\\`/g, '`').replace(/\\\$/g, '$')));
                      break;
                    }
                  default:
                    break;
                }
              } else {
                children.push(new constant_1.Constant(node.text));
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
          return this.makeExpression.apply(this, [expressionType_1.ExpressionType.Concat].concat(children));
        }
      }, {
        key: "processArgsList",
        value: function processArgsList(context) {
          var result = [];
          if (!context) {
            return result;
          }
          var _iterator3 = _createForOfIteratorHelper(context.children),
            _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var child = _step3.value;
              if (child instanceof ep.LambdaContext) {
                var evalParam = this.makeExpression(expressionType_1.ExpressionType.Accessor, new constant_1.Constant(child.IDENTIFIER().text));
                var evalFun = this.visit(child.expression());
                result.push(evalParam);
                result.push(evalFun);
              } else if (child instanceof ep.ExpressionContext) {
                result.push(this.visit(child));
              }
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
          return result;
        }
      }, {
        key: "trimExpression",
        value: function trimExpression(expression) {
          var result = expression.trim();
          if (result.startsWith('$')) {
            result = result.substr(1);
          }
          result = result.trim();
          if (result.startsWith('{') && result.endsWith('}')) {
            result = result.substr(1, result.length - 2);
          }
          return result.trim();
        }
      }, {
        key: "evalEscape",
        value: function evalEscape(text) {
          var validCharactersDict = {
            '\\r': '\r',
            '\\n': '\n',
            '\\t': '\t',
            '\\\\': '\\'
          };
          return text.replace(this.escapeRegex, function (sub) {
            if (sub in validCharactersDict) {
              return validCharactersDict[sub];
            } else {
              return sub;
            }
          });
        }
      }]);
      return _class;
    }(tree_1.AbstractParseTreeVisitor);
    this.EvaluatorLookup = lookup || expression_1.Expression.lookup;
  }
  /**
   * @protected
   * Parse the expression to ANTLR lexer and parser.
   * @param expression The input string expression.
   * @returns A ParseTree.
   */
  (0, _createClass2.default)(ExpressionParser, [{
    key: "parse",
    value:
    /**
     * Parse the input into an expression.
     *
     * @param expression Expression to parse.
     * @returns Expression tree.
     */
    function parse(expression) {
      if (expression == null || expression === '') {
        return new constant_1.Constant('');
      } else {
        return new this.ExpressionTransformer(this.EvaluatorLookup).transform(ExpressionParser.antlrParse(expression));
      }
    }
  }], [{
    key: "antlrParse",
    value: function antlrParse(expression) {
      if (ExpressionParser.expressionDict.has({
        key: expression
      })) {
        return ExpressionParser.expressionDict.get({
          key: expression
        });
      }
      var inputStream = new antlr4ts_1.ANTLRInputStream(expression);
      var lexer = new generated_1.ExpressionAntlrLexer(inputStream);
      lexer.removeErrorListeners();
      var tokenStream = new antlr4ts_1.CommonTokenStream(lexer);
      var parser = new generated_1.ExpressionAntlrParser(tokenStream);
      parser.removeErrorListeners();
      parser.addErrorListener(parseErrorListener_1.ParseErrorListener.Instance);
      parser.buildParseTree = true;
      var expressionContext;
      var file = parser.file();
      if (file !== undefined) {
        expressionContext = file.expression();
      }
      ExpressionParser.expressionDict.set({
        key: expression
      }, expressionContext);
      return expressionContext;
    }
  }]);
  return ExpressionParser;
}();
ExpressionParser.expressionDict = new WeakMap();
exports.ExpressionParser = ExpressionParser;

},{"../constant":167,"../expression":179,"../expressionType":192,"../functionUtils":196,"./generated":208,"./generated/ExpressionAntlrParser":207,"./parseErrorListener":210,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/toConsumableArray":249,"antlr4ts":368,"antlr4ts/tree":393,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.constructor.js":617,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.ends-with.js":623,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.string.replace.js":629,"core-js/modules/es.string.starts-with.js":632,"core-js/modules/es.string.trim.js":634,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/es.weak-map.js":673,"core-js/modules/web.dom-collections.iterator.js":677}],206:[function(require,module,exports){
"use strict";

// Generated from src/parser/ExpressionAntlrLexer.g4 by ANTLR 4.7.3-SNAPSHOT
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result["default"] = mod;
  return result;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var ATNDeserializer_1 = require("antlr4ts/atn/ATNDeserializer");
var Lexer_1 = require("antlr4ts/Lexer");
var LexerATNSimulator_1 = require("antlr4ts/atn/LexerATNSimulator");
var VocabularyImpl_1 = require("antlr4ts/VocabularyImpl");
var Utils = __importStar(require("antlr4ts/misc/Utils"));
var ExpressionAntlrLexer = /*#__PURE__*/function (_Lexer_1$Lexer) {
  (0, _inherits2.default)(ExpressionAntlrLexer, _Lexer_1$Lexer);
  var _super = _createSuper(ExpressionAntlrLexer);
  function ExpressionAntlrLexer(input) {
    var _this;
    (0, _classCallCheck2.default)(this, ExpressionAntlrLexer);
    _this = _super.call(this, input);
    // tslint:enable:no-trailing-whitespace
    _this.ignoreWS = true; // usually we ignore whitespace, but inside stringInterpolation, whitespace is significant
    _this._interp = new LexerATNSimulator_1.LexerATNSimulator(ExpressionAntlrLexer._ATN, (0, _assertThisInitialized2.default)(_this));
    return _this;
  }
  // @Override
  // @NotNull
  (0, _createClass2.default)(ExpressionAntlrLexer, [{
    key: "vocabulary",
    get: function get() {
      return ExpressionAntlrLexer.VOCABULARY;
    }
    // @Override
  }, {
    key: "grammarFileName",
    get: function get() {
      return "ExpressionAntlrLexer.g4";
    }
    // @Override
  }, {
    key: "ruleNames",
    get: function get() {
      return ExpressionAntlrLexer.ruleNames;
    }
    // @Override
  }, {
    key: "serializedATN",
    get: function get() {
      return ExpressionAntlrLexer._serializedATN;
    }
    // @Override
  }, {
    key: "channelNames",
    get: function get() {
      return ExpressionAntlrLexer.channelNames;
    }
    // @Override
  }, {
    key: "modeNames",
    get: function get() {
      return ExpressionAntlrLexer.modeNames;
    }
    // @Override
  }, {
    key: "action",
    value: function action(_localctx, ruleIndex, actionIndex) {
      switch (ruleIndex) {
        case 3:
          this.STRING_INTERPOLATION_START_action(_localctx, actionIndex);
          break;
        case 38:
          this.STRING_INTERPOLATION_END_action(_localctx, actionIndex);
          break;
      }
    }
  }, {
    key: "STRING_INTERPOLATION_START_action",
    value: function STRING_INTERPOLATION_START_action(_localctx, actionIndex) {
      switch (actionIndex) {
        case 0:
          this.ignoreWS = false;
          break;
      }
    }
  }, {
    key: "STRING_INTERPOLATION_END_action",
    value: function STRING_INTERPOLATION_END_action(_localctx, actionIndex) {
      switch (actionIndex) {
        case 1:
          this.ignoreWS = true;
          break;
      }
    }
    // @Override
  }, {
    key: "sempred",
    value: function sempred(_localctx, ruleIndex, predIndex) {
      switch (ruleIndex) {
        case 33:
          return this.WHITESPACE_sempred(_localctx, predIndex);
      }
      return true;
    }
  }, {
    key: "WHITESPACE_sempred",
    value: function WHITESPACE_sempred(_localctx, predIndex) {
      switch (predIndex) {
        case 0:
          return this.ignoreWS;
      }
      return true;
    }
  }], [{
    key: "_ATN",
    get: function get() {
      if (!ExpressionAntlrLexer.__ATN) {
        ExpressionAntlrLexer.__ATN = new ATNDeserializer_1.ATNDeserializer().deserialize(Utils.toCharArray(ExpressionAntlrLexer._serializedATN));
      }
      return ExpressionAntlrLexer.__ATN;
    }
  }]);
  return ExpressionAntlrLexer;
}(Lexer_1.Lexer);
ExpressionAntlrLexer.STRING_INTERPOLATION_START = 1;
ExpressionAntlrLexer.PLUS = 2;
ExpressionAntlrLexer.SUBSTRACT = 3;
ExpressionAntlrLexer.NON = 4;
ExpressionAntlrLexer.XOR = 5;
ExpressionAntlrLexer.ASTERISK = 6;
ExpressionAntlrLexer.SLASH = 7;
ExpressionAntlrLexer.PERCENT = 8;
ExpressionAntlrLexer.DOUBLE_EQUAL = 9;
ExpressionAntlrLexer.NOT_EQUAL = 10;
ExpressionAntlrLexer.SINGLE_AND = 11;
ExpressionAntlrLexer.DOUBLE_AND = 12;
ExpressionAntlrLexer.DOUBLE_VERTICAL_CYLINDER = 13;
ExpressionAntlrLexer.LESS_THAN = 14;
ExpressionAntlrLexer.MORE_THAN = 15;
ExpressionAntlrLexer.LESS_OR_EQUAl = 16;
ExpressionAntlrLexer.MORE_OR_EQUAL = 17;
ExpressionAntlrLexer.OPEN_BRACKET = 18;
ExpressionAntlrLexer.CLOSE_BRACKET = 19;
ExpressionAntlrLexer.DOT = 20;
ExpressionAntlrLexer.OPEN_SQUARE_BRACKET = 21;
ExpressionAntlrLexer.CLOSE_SQUARE_BRACKET = 22;
ExpressionAntlrLexer.OPEN_CURLY_BRACKET = 23;
ExpressionAntlrLexer.CLOSE_CURLY_BRACKET = 24;
ExpressionAntlrLexer.COMMA = 25;
ExpressionAntlrLexer.COLON = 26;
ExpressionAntlrLexer.ARROW = 27;
ExpressionAntlrLexer.NULL_COALESCE = 28;
ExpressionAntlrLexer.QUESTION_MARK = 29;
ExpressionAntlrLexer.NUMBER = 30;
ExpressionAntlrLexer.WHITESPACE = 31;
ExpressionAntlrLexer.IDENTIFIER = 32;
ExpressionAntlrLexer.NEWLINE = 33;
ExpressionAntlrLexer.STRING = 34;
ExpressionAntlrLexer.INVALID_TOKEN_DEFAULT_MODE = 35;
ExpressionAntlrLexer.TEMPLATE = 36;
ExpressionAntlrLexer.ESCAPE_CHARACTER = 37;
ExpressionAntlrLexer.TEXT_CONTENT = 38;
ExpressionAntlrLexer.STRING_INTERPOLATION_MODE = 1;
// tslint:disable:no-trailing-whitespace
ExpressionAntlrLexer.channelNames = ["DEFAULT_TOKEN_CHANNEL", "HIDDEN"];
// tslint:disable:no-trailing-whitespace
ExpressionAntlrLexer.modeNames = ["DEFAULT_MODE", "STRING_INTERPOLATION_MODE"];
ExpressionAntlrLexer.ruleNames = ["LETTER", "DIGIT", "OBJECT_DEFINITION", "STRING_INTERPOLATION_START", "PLUS", "SUBSTRACT", "NON", "XOR", "ASTERISK", "SLASH", "PERCENT", "DOUBLE_EQUAL", "NOT_EQUAL", "SINGLE_AND", "DOUBLE_AND", "DOUBLE_VERTICAL_CYLINDER", "LESS_THAN", "MORE_THAN", "LESS_OR_EQUAl", "MORE_OR_EQUAL", "OPEN_BRACKET", "CLOSE_BRACKET", "DOT", "OPEN_SQUARE_BRACKET", "CLOSE_SQUARE_BRACKET", "OPEN_CURLY_BRACKET", "CLOSE_CURLY_BRACKET", "COMMA", "COLON", "ARROW", "NULL_COALESCE", "QUESTION_MARK", "NUMBER", "WHITESPACE", "IDENTIFIER", "NEWLINE", "STRING", "INVALID_TOKEN_DEFAULT_MODE", "STRING_INTERPOLATION_END", "TEMPLATE", "ESCAPE_CHARACTER", "TEXT_CONTENT"];
ExpressionAntlrLexer._LITERAL_NAMES = [undefined, undefined, "'+'", "'-'", "'!'", "'^'", "'*'", "'/'", "'%'", "'=='", undefined, "'&'", "'&&'", "'||'", "'<'", "'>'", "'<='", "'>='", "'('", "')'", "'.'", "'['", "']'", "'{'", "'}'", "','", "':'", "'=>'", "'??'", "'?'"];
ExpressionAntlrLexer._SYMBOLIC_NAMES = [undefined, "STRING_INTERPOLATION_START", "PLUS", "SUBSTRACT", "NON", "XOR", "ASTERISK", "SLASH", "PERCENT", "DOUBLE_EQUAL", "NOT_EQUAL", "SINGLE_AND", "DOUBLE_AND", "DOUBLE_VERTICAL_CYLINDER", "LESS_THAN", "MORE_THAN", "LESS_OR_EQUAl", "MORE_OR_EQUAL", "OPEN_BRACKET", "CLOSE_BRACKET", "DOT", "OPEN_SQUARE_BRACKET", "CLOSE_SQUARE_BRACKET", "OPEN_CURLY_BRACKET", "CLOSE_CURLY_BRACKET", "COMMA", "COLON", "ARROW", "NULL_COALESCE", "QUESTION_MARK", "NUMBER", "WHITESPACE", "IDENTIFIER", "NEWLINE", "STRING", "INVALID_TOKEN_DEFAULT_MODE", "TEMPLATE", "ESCAPE_CHARACTER", "TEXT_CONTENT"];
ExpressionAntlrLexer.VOCABULARY = new VocabularyImpl_1.VocabularyImpl(ExpressionAntlrLexer._LITERAL_NAMES, ExpressionAntlrLexer._SYMBOLIC_NAMES, []);
ExpressionAntlrLexer._serializedATN = "\x03\uC91D\uCABA\u058D\uAFBA\u4F53\u0607\uEA8B\uC241\x02(\u010F\b\x01" + "\b\x01\x04\x02\t\x02\x04\x03\t\x03\x04\x04\t\x04\x04\x05\t\x05\x04\x06" + "\t\x06\x04\x07\t\x07\x04\b\t\b\x04\t\t\t\x04\n\t\n\x04\v\t\v\x04\f\t\f" + "\x04\r\t\r\x04\x0E\t\x0E\x04\x0F\t\x0F\x04\x10\t\x10\x04\x11\t\x11\x04" + "\x12\t\x12\x04\x13\t\x13\x04\x14\t\x14\x04\x15\t\x15\x04\x16\t\x16\x04" + "\x17\t\x17\x04\x18\t\x18\x04\x19\t\x19\x04\x1A\t\x1A\x04\x1B\t\x1B\x04" + "\x1C\t\x1C\x04\x1D\t\x1D\x04\x1E\t\x1E\x04\x1F\t\x1F\x04 \t \x04!\t!\x04" + "\"\t\"\x04#\t#\x04$\t$\x04%\t%\x04&\t&\x04\'\t\'\x04(\t(\x04)\t)\x04*" + "\t*\x04+\t+\x03\x02\x03\x02\x03\x03\x03\x03\x03\x04\x03\x04\x03\x04\x03" + "\x04\x05\x04a\n\x04\x03\x04\x03\x04\x03\x04\x03\x04\x06\x04g\n\x04\r\x04" + "\x0E\x04h\x07\x04k\n\x04\f\x04\x0E\x04n\v\x04\x03\x04\x03\x04\x03\x05" + "\x03\x05\x03\x05\x03\x05\x03\x05\x03\x06\x03\x06\x03\x07\x03\x07\x03\b" + "\x03\b\x03\t\x03\t\x03\n\x03\n\x03\v\x03\v\x03\f\x03\f\x03\r\x03\r\x03" + "\r\x03\x0E\x03\x0E\x03\x0E\x03\x0E\x05\x0E\x8C\n\x0E\x03\x0F\x03\x0F\x03" + "\x10\x03\x10\x03\x10\x03\x11\x03\x11\x03\x11\x03\x12\x03\x12\x03\x13\x03" + "\x13\x03\x14\x03\x14\x03\x14\x03\x15\x03\x15\x03\x15\x03\x16\x03\x16\x03" + "\x17\x03\x17\x03\x18\x03\x18\x03\x19\x03\x19\x03\x1A\x03\x1A\x03\x1B\x03" + "\x1B\x03\x1C\x03\x1C\x03\x1D\x03\x1D\x03\x1E\x03\x1E\x03\x1F\x03\x1F\x03" + "\x1F\x03 \x03 \x03 \x03!\x03!\x03\"\x06\"\xBB\n\"\r\"\x0E\"\xBC\x03\"" + "\x03\"\x06\"\xC1\n\"\r\"\x0E\"\xC2\x05\"\xC5\n\"\x03#\x03#\x03#\x03#\x03" + "#\x03$\x03$\x03$\x03$\x03$\x05$\xD1\n$\x03$\x03$\x03$\x07$\xD6\n$\f$\x0E" + "$\xD9\v$\x03%\x05%\xDC\n%\x03%\x03%\x03%\x03%\x03&\x03&\x03&\x03&\x07" + "&\xE6\n&\f&\x0E&\xE9\v&\x03&\x03&\x03&\x03&\x03&\x07&\xF0\n&\f&\x0E&\xF3" + "\v&\x03&\x05&\xF6\n&\x03\'\x03\'\x03(\x03(\x03(\x03(\x03(\x03(\x03)\x03" + ")\x03)\x03)\x03)\x06)\u0105\n)\r)\x0E)\u0106\x03)\x03)\x03*\x03*\x03*" + "\x03+\x03+\x04\xE7\xF1\x02\x02,\x04\x02\x02\x06\x02\x02\b\x02\x02\n\x02" + "\x03\f\x02\x04\x0E\x02\x05\x10\x02\x06\x12\x02\x07\x14\x02\b\x16\x02\t" + "\x18\x02\n\x1A\x02\v\x1C\x02\f\x1E\x02\r \x02\x0E\"\x02\x0F$\x02\x10&" + "\x02\x11(\x02\x12*\x02\x13,\x02\x14.\x02\x150\x02\x162\x02\x174\x02\x18" + "6\x02\x198\x02\x1A:\x02\x1B<\x02\x1C>\x02\x1D@\x02\x1EB\x02\x1FD\x02 " + "F\x02!H\x02\"J\x02#L\x02$N\x02%P\x02\x02R\x02&T\x02\'V\x02(\x04\x02\x03" + "\f\x04\x02C\\c|\x03\x022;\t\x02\f\f\x0F\x0F$$))bb}}\x7F\x7F\x06\x02\v" + "\x0B\"\"\xA2\xA2\uFF01\uFF01\x05\x02%%BBaa\x04\x02))^^\x03\x02))\x04\x02" + "$$^^\x03\x02$$\x04\x02&&bb\x02\u0123\x02\n\x03\x02\x02\x02\x02\f\x03\x02" + "\x02\x02\x02\x0E\x03\x02\x02\x02\x02\x10\x03\x02\x02\x02\x02\x12\x03\x02" + "\x02\x02\x02\x14\x03\x02\x02\x02\x02\x16\x03\x02\x02\x02\x02\x18\x03\x02" + "\x02\x02\x02\x1A\x03\x02\x02\x02\x02\x1C\x03\x02\x02\x02\x02\x1E\x03\x02" + "\x02\x02\x02 \x03\x02\x02\x02\x02\"\x03\x02\x02\x02\x02$\x03\x02\x02\x02" + "\x02&\x03\x02\x02\x02\x02(\x03\x02\x02\x02\x02*\x03\x02\x02\x02\x02,\x03" + "\x02\x02\x02\x02.\x03\x02\x02\x02\x020\x03\x02\x02\x02\x022\x03\x02\x02" + "\x02\x024\x03\x02\x02\x02\x026\x03\x02\x02\x02\x028\x03\x02\x02\x02\x02" + ":\x03\x02\x02\x02\x02<\x03\x02\x02\x02\x02>\x03\x02\x02\x02\x02@\x03\x02" + "\x02\x02\x02B\x03\x02\x02\x02\x02D\x03\x02\x02\x02\x02F\x03\x02\x02\x02" + "\x02H\x03\x02\x02\x02\x02J\x03\x02\x02\x02\x02L\x03\x02\x02\x02\x02N\x03" + "\x02\x02\x02\x03P\x03\x02\x02\x02\x03R\x03\x02\x02\x02\x03T\x03\x02\x02" + "\x02\x03V\x03\x02\x02\x02\x04X\x03\x02\x02\x02\x06Z\x03\x02\x02\x02\b" + "\\\x03\x02\x02\x02\nq\x03\x02\x02\x02\fv\x03\x02\x02\x02\x0Ex\x03\x02" + "\x02\x02\x10z\x03\x02\x02\x02\x12|\x03\x02\x02\x02\x14~\x03\x02\x02\x02" + "\x16\x80\x03\x02\x02\x02\x18\x82\x03\x02\x02\x02\x1A\x84\x03\x02\x02\x02" + "\x1C\x8B\x03\x02\x02\x02\x1E\x8D\x03\x02\x02\x02 \x8F\x03\x02\x02\x02" + "\"\x92\x03\x02\x02\x02$\x95\x03\x02\x02\x02&\x97\x03\x02\x02\x02(\x99" + "\x03\x02\x02\x02*\x9C\x03\x02\x02\x02,\x9F\x03\x02\x02\x02.\xA1\x03\x02" + "\x02\x020\xA3\x03\x02\x02\x022\xA5\x03\x02\x02\x024\xA7\x03\x02\x02\x02" + "6\xA9\x03\x02\x02\x028\xAB\x03\x02\x02\x02:\xAD\x03\x02\x02\x02<\xAF\x03" + "\x02\x02\x02>\xB1\x03\x02\x02\x02@\xB4\x03\x02\x02\x02B\xB7\x03\x02\x02" + "\x02D\xBA\x03\x02\x02\x02F\xC6\x03\x02\x02\x02H\xD0\x03\x02\x02\x02J\xDB" + "\x03\x02\x02\x02L\xF5\x03\x02\x02\x02N\xF7\x03\x02\x02\x02P\xF9\x03\x02" + "\x02\x02R\xFF\x03\x02\x02\x02T\u010A\x03\x02\x02\x02V\u010D\x03\x02\x02" + "\x02XY\t\x02\x02\x02Y\x05\x03\x02\x02\x02Z[\t\x03\x02\x02[\x07\x03\x02" + "\x02\x02\\l\x07}\x02\x02]k\x05F#\x02^a\x05H$\x02_a\x05L&\x02`^\x03\x02" + "\x02\x02`_\x03\x02\x02\x02ab\x03\x02\x02\x02bf\x07<\x02\x02cg\x05L&\x02" + "dg\n\x04\x02\x02eg\x05\b\x04\x02fc\x03\x02\x02\x02fd\x03\x02\x02\x02f" + "e\x03\x02\x02\x02gh\x03\x02\x02\x02hf\x03\x02\x02\x02hi\x03\x02\x02\x02" + "ik\x03\x02\x02\x02j]\x03\x02\x02\x02j`\x03\x02\x02\x02kn\x03\x02\x02\x02" + "lj\x03\x02\x02\x02lm\x03\x02\x02\x02mo\x03\x02\x02\x02nl\x03\x02\x02\x02" + "op\x07\x7F\x02\x02p\t\x03\x02\x02\x02qr\x07b\x02\x02rs\b\x05\x02\x02s" + "t\x03\x02\x02\x02tu\b\x05\x03\x02u\v\x03\x02\x02\x02vw\x07-\x02\x02w\r" + "\x03\x02\x02\x02xy\x07/\x02\x02y\x0F\x03\x02\x02\x02z{\x07#\x02\x02{\x11" + "\x03\x02\x02\x02|}\x07`\x02\x02}\x13\x03\x02\x02\x02~\x7F\x07,\x02\x02" + "\x7F\x15\x03\x02\x02\x02\x80\x81\x071\x02\x02\x81\x17\x03\x02\x02\x02" + "\x82\x83\x07\'\x02\x02\x83\x19\x03\x02\x02\x02\x84\x85\x07?\x02\x02\x85" + "\x86\x07?\x02\x02\x86\x1B\x03\x02\x02\x02\x87\x88\x07#\x02\x02\x88\x8C" + "\x07?\x02\x02\x89\x8A\x07>\x02\x02\x8A\x8C\x07@\x02\x02\x8B\x87\x03\x02" + "\x02\x02\x8B\x89\x03\x02\x02\x02\x8C\x1D\x03\x02\x02\x02\x8D\x8E\x07(" + "\x02\x02\x8E\x1F\x03\x02\x02\x02\x8F\x90\x07(\x02\x02\x90\x91\x07(\x02" + "\x02\x91!\x03\x02\x02\x02\x92\x93\x07~\x02\x02\x93\x94\x07~\x02\x02\x94" + "#\x03\x02\x02\x02\x95\x96\x07>\x02\x02\x96%\x03\x02\x02\x02\x97\x98\x07" + "@\x02\x02\x98\'\x03\x02\x02\x02\x99\x9A\x07>\x02\x02\x9A\x9B\x07?\x02" + "\x02\x9B)\x03\x02\x02\x02\x9C\x9D\x07@\x02\x02\x9D\x9E\x07?\x02\x02\x9E" + "+\x03\x02\x02\x02\x9F\xA0\x07*\x02\x02\xA0-\x03\x02\x02\x02\xA1\xA2\x07" + "+\x02\x02\xA2/\x03\x02\x02\x02\xA3\xA4\x070\x02\x02\xA41\x03\x02\x02\x02" + "\xA5\xA6\x07]\x02\x02\xA63\x03\x02\x02\x02\xA7\xA8\x07_\x02\x02\xA85\x03" + "\x02\x02\x02\xA9\xAA\x07}\x02\x02\xAA7\x03\x02\x02\x02\xAB\xAC\x07\x7F" + "\x02\x02\xAC9\x03\x02\x02\x02\xAD\xAE\x07.\x02\x02\xAE;\x03\x02\x02\x02" + "\xAF\xB0\x07<\x02\x02\xB0=\x03\x02\x02\x02\xB1\xB2\x07?\x02\x02\xB2\xB3" + "\x07@\x02\x02\xB3?\x03\x02\x02\x02\xB4\xB5\x07A\x02\x02\xB5\xB6\x07A\x02" + "\x02\xB6A\x03\x02\x02\x02\xB7\xB8\x07A\x02\x02\xB8C\x03\x02\x02\x02\xB9" + "\xBB\x05\x06\x03\x02\xBA\xB9\x03\x02\x02\x02\xBB\xBC\x03\x02\x02\x02\xBC" + "\xBA\x03\x02\x02\x02\xBC\xBD\x03\x02\x02\x02\xBD\xC4\x03\x02\x02\x02\xBE" + "\xC0\x070\x02\x02\xBF\xC1\x05\x06\x03\x02\xC0\xBF\x03\x02\x02\x02\xC1" + "\xC2\x03\x02\x02\x02\xC2\xC0\x03\x02\x02\x02\xC2\xC3\x03\x02\x02\x02\xC3" + "\xC5\x03\x02\x02\x02\xC4\xBE\x03\x02\x02\x02\xC4\xC5\x03\x02\x02\x02\xC5" + "E\x03\x02\x02\x02\xC6\xC7\t\x05\x02\x02\xC7\xC8\x06#\x02\x02\xC8\xC9\x03" + "\x02\x02\x02\xC9\xCA\b#\x04\x02\xCAG\x03\x02\x02\x02\xCB\xD1\x05\x04\x02" + "\x02\xCC\xD1\t\x06\x02\x02\xCD\xCE\x07B\x02\x02\xCE\xD1\x07B\x02\x02\xCF" + "\xD1\x04&\'\x02\xD0\xCB\x03\x02\x02\x02\xD0\xCC\x03\x02\x02\x02\xD0\xCD" + "\x03\x02\x02\x02\xD0\xCF\x03\x02\x02\x02\xD1\xD7\x03\x02\x02\x02\xD2\xD6" + "\x05\x04\x02\x02\xD3\xD6\x05\x06\x03\x02\xD4\xD6\x07a\x02\x02\xD5\xD2" + "\x03\x02\x02\x02\xD5\xD3\x03\x02\x02\x02\xD5\xD4\x03\x02\x02\x02\xD6\xD9" + "\x03\x02\x02\x02\xD7\xD5\x03\x02\x02\x02\xD7\xD8\x03\x02\x02\x02\xD8I" + "\x03\x02\x02\x02\xD9\xD7\x03\x02\x02\x02\xDA\xDC\x07\x0F\x02\x02\xDB\xDA" + "\x03\x02\x02\x02\xDB\xDC\x03\x02\x02\x02\xDC\xDD\x03\x02\x02\x02\xDD\xDE" + "\x07\f\x02\x02\xDE\xDF\x03\x02\x02\x02\xDF\xE0\b%\x04\x02\xE0K\x03\x02" + "\x02\x02\xE1\xE7\x07)\x02\x02\xE2\xE3\x07^\x02\x02\xE3\xE6\t\x07\x02\x02" + "\xE4\xE6\n\b\x02\x02\xE5\xE2\x03\x02\x02\x02\xE5\xE4\x03\x02\x02\x02\xE6" + "\xE9\x03\x02\x02\x02\xE7\xE8\x03\x02\x02\x02\xE7\xE5\x03\x02\x02\x02\xE8" + "\xEA\x03\x02\x02\x02\xE9\xE7\x03\x02\x02\x02\xEA\xF6\x07)\x02\x02\xEB" + "\xF1\x07$\x02\x02\xEC\xED\x07^\x02\x02\xED\xF0\t\t\x02\x02\xEE\xF0\n\n" + "\x02\x02\xEF\xEC\x03\x02\x02\x02\xEF\xEE\x03\x02\x02\x02\xF0\xF3\x03\x02" + "\x02\x02\xF1\xF2\x03\x02\x02\x02\xF1\xEF\x03\x02\x02\x02\xF2\xF4\x03\x02" + "\x02\x02\xF3\xF1\x03\x02\x02\x02\xF4\xF6\x07$\x02\x02\xF5\xE1\x03\x02" + "\x02\x02\xF5\xEB\x03\x02\x02\x02\xF6M\x03\x02\x02\x02\xF7\xF8\v\x02\x02" + "\x02\xF8O\x03\x02\x02\x02\xF9\xFA\x07b\x02\x02\xFA\xFB\b(\x05\x02\xFB" + "\xFC\x03\x02\x02\x02\xFC\xFD\b(\x06\x02\xFD\xFE\b(\x07\x02\xFEQ\x03\x02" + "\x02\x02\xFF\u0100\x07&\x02\x02\u0100\u0104\x07}\x02\x02\u0101\u0105\x05" + "L&\x02\u0102\u0105\x05\b\x04\x02\u0103\u0105\n\x04\x02\x02\u0104\u0101" + "\x03\x02\x02\x02\u0104\u0102\x03\x02\x02\x02\u0104\u0103\x03\x02\x02\x02" + "\u0105\u0106\x03\x02\x02\x02\u0106\u0104\x03\x02\x02\x02\u0106\u0107\x03" + "\x02\x02\x02\u0107\u0108\x03\x02\x02\x02\u0108\u0109\x07\x7F\x02\x02\u0109" + "S\x03\x02\x02\x02\u010A\u010B\x07^\x02\x02\u010B\u010C\t\x0B\x02\x02\u010C" + "U\x03\x02\x02\x02\u010D\u010E\x0B\x02\x02\x02\u010EW\x03\x02\x02\x02\x18" + "\x02\x03`fhjl\x8B\xBC\xC2\xC4\xD0\xD5\xD7\xDB\xE5\xE7\xEF\xF1\xF5\u0104" + "\u0106\b\x03\x05\x02\x07\x03\x02\b\x02\x02\x03(\x03\t\x03\x02\x06\x02" + "\x02";
exports.ExpressionAntlrLexer = ExpressionAntlrLexer;

},{"@babel/runtime/helpers/assertThisInitialized":229,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"antlr4ts/Lexer":280,"antlr4ts/VocabularyImpl":298,"antlr4ts/atn/ATNDeserializer":303,"antlr4ts/atn/LexerATNSimulator":324,"antlr4ts/misc/Utils":385,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],207:[function(require,module,exports){
"use strict";

// Generated from src/parser/ExpressionAntlrParser.g4 by ANTLR 4.7.3-SNAPSHOT
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.match.js");
var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result["default"] = mod;
  return result;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var ATN_1 = require("antlr4ts/atn/ATN");
var ATNDeserializer_1 = require("antlr4ts/atn/ATNDeserializer");
var FailedPredicateException_1 = require("antlr4ts/FailedPredicateException");
var NoViableAltException_1 = require("antlr4ts/NoViableAltException");
var Parser_1 = require("antlr4ts/Parser");
var ParserRuleContext_1 = require("antlr4ts/ParserRuleContext");
var ParserATNSimulator_1 = require("antlr4ts/atn/ParserATNSimulator");
var RecognitionException_1 = require("antlr4ts/RecognitionException");
var Token_1 = require("antlr4ts/Token");
var VocabularyImpl_1 = require("antlr4ts/VocabularyImpl");
var Utils = __importStar(require("antlr4ts/misc/Utils"));
var ExpressionAntlrParser = /*#__PURE__*/function (_Parser_1$Parser) {
  (0, _inherits2.default)(ExpressionAntlrParser, _Parser_1$Parser);
  var _super = _createSuper(ExpressionAntlrParser);
  function ExpressionAntlrParser(input) {
    var _this;
    (0, _classCallCheck2.default)(this, ExpressionAntlrParser);
    _this = _super.call(this, input);
    _this._interp = new ParserATNSimulator_1.ParserATNSimulator(ExpressionAntlrParser._ATN, (0, _assertThisInitialized2.default)(_this));
    return _this;
  }
  // @Override
  // @NotNull
  (0, _createClass2.default)(ExpressionAntlrParser, [{
    key: "vocabulary",
    get: function get() {
      return ExpressionAntlrParser.VOCABULARY;
    }
    // tslint:enable:no-trailing-whitespace
    // @Override
  }, {
    key: "grammarFileName",
    get: function get() {
      return "ExpressionAntlrParser.g4";
    }
    // @Override
  }, {
    key: "ruleNames",
    get: function get() {
      return ExpressionAntlrParser.ruleNames;
    }
    // @Override
  }, {
    key: "serializedATN",
    get: function get() {
      return ExpressionAntlrParser._serializedATN;
    }
    // @RuleVersion(0)
  }, {
    key: "file",
    value: function file() {
      var _localctx = new FileContext(this._ctx, this.state);
      this.enterRule(_localctx, 0, ExpressionAntlrParser.RULE_file);
      try {
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 20;
          this.expression(0);
          this.state = 21;
          this.match(ExpressionAntlrParser.EOF);
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
  }, {
    key: "expression",
    value: function expression(_p) {
      if (_p === undefined) {
        _p = 0;
      }
      var _parentctx = this._ctx;
      var _parentState = this.state;
      var _localctx = new ExpressionContext(this._ctx, _parentState);
      var _prevctx = _localctx;
      var _startState = 2;
      this.enterRecursionRule(_localctx, 2, ExpressionAntlrParser.RULE_expression, _p);
      var _la;
      try {
        var _alt;
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 27;
          this._errHandler.sync(this);
          switch (this._input.LA(1)) {
            case ExpressionAntlrParser.PLUS:
            case ExpressionAntlrParser.SUBSTRACT:
            case ExpressionAntlrParser.NON:
              {
                _localctx = new UnaryOpExpContext(_localctx);
                this._ctx = _localctx;
                _prevctx = _localctx;
                this.state = 24;
                _la = this._input.LA(1);
                if (!((_la & ~0x1F) === 0 && (1 << _la & (1 << ExpressionAntlrParser.PLUS | 1 << ExpressionAntlrParser.SUBSTRACT | 1 << ExpressionAntlrParser.NON)) !== 0)) {
                  this._errHandler.recoverInline(this);
                } else {
                  if (this._input.LA(1) === Token_1.Token.EOF) {
                    this.matchedEOF = true;
                  }
                  this._errHandler.reportMatch(this);
                  this.consume();
                }
                this.state = 25;
                this.expression(12);
              }
              break;
            case ExpressionAntlrParser.STRING_INTERPOLATION_START:
            case ExpressionAntlrParser.OPEN_BRACKET:
            case ExpressionAntlrParser.OPEN_SQUARE_BRACKET:
            case ExpressionAntlrParser.OPEN_CURLY_BRACKET:
            case ExpressionAntlrParser.NUMBER:
            case ExpressionAntlrParser.IDENTIFIER:
            case ExpressionAntlrParser.STRING:
              {
                _localctx = new PrimaryExpContext(_localctx);
                this._ctx = _localctx;
                _prevctx = _localctx;
                this.state = 26;
                this.primaryExpression(0);
              }
              break;
            default:
              throw new NoViableAltException_1.NoViableAltException(this);
          }
          this._ctx._stop = this._input.tryLT(-1);
          this.state = 64;
          this._errHandler.sync(this);
          _alt = this.interpreter.adaptivePredict(this._input, 2, this._ctx);
          while (_alt !== 2 && _alt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
            if (_alt === 1) {
              if (this._parseListeners != null) {
                this.triggerExitRuleEvent();
              }
              _prevctx = _localctx;
              {
                this.state = 62;
                this._errHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this._input, 1, this._ctx)) {
                  case 1:
                    {
                      _localctx = new BinaryOpExpContext(new ExpressionContext(_parentctx, _parentState));
                      this.pushNewRecursionContext(_localctx, _startState, ExpressionAntlrParser.RULE_expression);
                      this.state = 29;
                      if (!this.precpred(this._ctx, 11)) {
                        throw new FailedPredicateException_1.FailedPredicateException(this, "this.precpred(this._ctx, 11)");
                      }
                      this.state = 30;
                      this.match(ExpressionAntlrParser.XOR);
                      this.state = 31;
                      this.expression(11);
                    }
                    break;
                  case 2:
                    {
                      _localctx = new BinaryOpExpContext(new ExpressionContext(_parentctx, _parentState));
                      this.pushNewRecursionContext(_localctx, _startState, ExpressionAntlrParser.RULE_expression);
                      this.state = 32;
                      if (!this.precpred(this._ctx, 10)) {
                        throw new FailedPredicateException_1.FailedPredicateException(this, "this.precpred(this._ctx, 10)");
                      }
                      this.state = 33;
                      _la = this._input.LA(1);
                      if (!((_la & ~0x1F) === 0 && (1 << _la & (1 << ExpressionAntlrParser.ASTERISK | 1 << ExpressionAntlrParser.SLASH | 1 << ExpressionAntlrParser.PERCENT)) !== 0)) {
                        this._errHandler.recoverInline(this);
                      } else {
                        if (this._input.LA(1) === Token_1.Token.EOF) {
                          this.matchedEOF = true;
                        }
                        this._errHandler.reportMatch(this);
                        this.consume();
                      }
                      this.state = 34;
                      this.expression(11);
                    }
                    break;
                  case 3:
                    {
                      _localctx = new BinaryOpExpContext(new ExpressionContext(_parentctx, _parentState));
                      this.pushNewRecursionContext(_localctx, _startState, ExpressionAntlrParser.RULE_expression);
                      this.state = 35;
                      if (!this.precpred(this._ctx, 9)) {
                        throw new FailedPredicateException_1.FailedPredicateException(this, "this.precpred(this._ctx, 9)");
                      }
                      this.state = 36;
                      _la = this._input.LA(1);
                      if (!(_la === ExpressionAntlrParser.PLUS || _la === ExpressionAntlrParser.SUBSTRACT)) {
                        this._errHandler.recoverInline(this);
                      } else {
                        if (this._input.LA(1) === Token_1.Token.EOF) {
                          this.matchedEOF = true;
                        }
                        this._errHandler.reportMatch(this);
                        this.consume();
                      }
                      this.state = 37;
                      this.expression(10);
                    }
                    break;
                  case 4:
                    {
                      _localctx = new BinaryOpExpContext(new ExpressionContext(_parentctx, _parentState));
                      this.pushNewRecursionContext(_localctx, _startState, ExpressionAntlrParser.RULE_expression);
                      this.state = 38;
                      if (!this.precpred(this._ctx, 8)) {
                        throw new FailedPredicateException_1.FailedPredicateException(this, "this.precpred(this._ctx, 8)");
                      }
                      this.state = 39;
                      _la = this._input.LA(1);
                      if (!(_la === ExpressionAntlrParser.DOUBLE_EQUAL || _la === ExpressionAntlrParser.NOT_EQUAL)) {
                        this._errHandler.recoverInline(this);
                      } else {
                        if (this._input.LA(1) === Token_1.Token.EOF) {
                          this.matchedEOF = true;
                        }
                        this._errHandler.reportMatch(this);
                        this.consume();
                      }
                      this.state = 40;
                      this.expression(9);
                    }
                    break;
                  case 5:
                    {
                      _localctx = new BinaryOpExpContext(new ExpressionContext(_parentctx, _parentState));
                      this.pushNewRecursionContext(_localctx, _startState, ExpressionAntlrParser.RULE_expression);
                      this.state = 41;
                      if (!this.precpred(this._ctx, 7)) {
                        throw new FailedPredicateException_1.FailedPredicateException(this, "this.precpred(this._ctx, 7)");
                      }
                      {
                        this.state = 42;
                        this.match(ExpressionAntlrParser.SINGLE_AND);
                      }
                      this.state = 43;
                      this.expression(8);
                    }
                    break;
                  case 6:
                    {
                      _localctx = new BinaryOpExpContext(new ExpressionContext(_parentctx, _parentState));
                      this.pushNewRecursionContext(_localctx, _startState, ExpressionAntlrParser.RULE_expression);
                      this.state = 44;
                      if (!this.precpred(this._ctx, 6)) {
                        throw new FailedPredicateException_1.FailedPredicateException(this, "this.precpred(this._ctx, 6)");
                      }
                      this.state = 45;
                      _la = this._input.LA(1);
                      if (!((_la & ~0x1F) === 0 && (1 << _la & (1 << ExpressionAntlrParser.LESS_THAN | 1 << ExpressionAntlrParser.MORE_THAN | 1 << ExpressionAntlrParser.LESS_OR_EQUAl | 1 << ExpressionAntlrParser.MORE_OR_EQUAL)) !== 0)) {
                        this._errHandler.recoverInline(this);
                      } else {
                        if (this._input.LA(1) === Token_1.Token.EOF) {
                          this.matchedEOF = true;
                        }
                        this._errHandler.reportMatch(this);
                        this.consume();
                      }
                      this.state = 46;
                      this.expression(7);
                    }
                    break;
                  case 7:
                    {
                      _localctx = new BinaryOpExpContext(new ExpressionContext(_parentctx, _parentState));
                      this.pushNewRecursionContext(_localctx, _startState, ExpressionAntlrParser.RULE_expression);
                      this.state = 47;
                      if (!this.precpred(this._ctx, 5)) {
                        throw new FailedPredicateException_1.FailedPredicateException(this, "this.precpred(this._ctx, 5)");
                      }
                      this.state = 48;
                      this.match(ExpressionAntlrParser.DOUBLE_AND);
                      this.state = 49;
                      this.expression(6);
                    }
                    break;
                  case 8:
                    {
                      _localctx = new BinaryOpExpContext(new ExpressionContext(_parentctx, _parentState));
                      this.pushNewRecursionContext(_localctx, _startState, ExpressionAntlrParser.RULE_expression);
                      this.state = 50;
                      if (!this.precpred(this._ctx, 4)) {
                        throw new FailedPredicateException_1.FailedPredicateException(this, "this.precpred(this._ctx, 4)");
                      }
                      this.state = 51;
                      this.match(ExpressionAntlrParser.DOUBLE_VERTICAL_CYLINDER);
                      this.state = 52;
                      this.expression(5);
                    }
                    break;
                  case 9:
                    {
                      _localctx = new BinaryOpExpContext(new ExpressionContext(_parentctx, _parentState));
                      this.pushNewRecursionContext(_localctx, _startState, ExpressionAntlrParser.RULE_expression);
                      this.state = 53;
                      if (!this.precpred(this._ctx, 3)) {
                        throw new FailedPredicateException_1.FailedPredicateException(this, "this.precpred(this._ctx, 3)");
                      }
                      this.state = 54;
                      this.match(ExpressionAntlrParser.NULL_COALESCE);
                      this.state = 55;
                      this.expression(4);
                    }
                    break;
                  case 10:
                    {
                      _localctx = new TripleOpExpContext(new ExpressionContext(_parentctx, _parentState));
                      this.pushNewRecursionContext(_localctx, _startState, ExpressionAntlrParser.RULE_expression);
                      this.state = 56;
                      if (!this.precpred(this._ctx, 2)) {
                        throw new FailedPredicateException_1.FailedPredicateException(this, "this.precpred(this._ctx, 2)");
                      }
                      this.state = 57;
                      this.match(ExpressionAntlrParser.QUESTION_MARK);
                      this.state = 58;
                      this.expression(0);
                      this.state = 59;
                      this.match(ExpressionAntlrParser.COLON);
                      this.state = 60;
                      this.expression(3);
                    }
                    break;
                }
              }
            }
            this.state = 66;
            this._errHandler.sync(this);
            _alt = this.interpreter.adaptivePredict(this._input, 2, this._ctx);
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.unrollRecursionContexts(_parentctx);
      }
      return _localctx;
    }
    // @RuleVersion(0)
  }, {
    key: "primaryExpression",
    value: function primaryExpression(_p) {
      if (_p === undefined) {
        _p = 0;
      }
      var _parentctx = this._ctx;
      var _parentState = this.state;
      var _localctx = new PrimaryExpressionContext(this._ctx, _parentState);
      var _prevctx = _localctx;
      var _startState = 4;
      this.enterRecursionRule(_localctx, 4, ExpressionAntlrParser.RULE_primaryExpression, _p);
      var _la;
      try {
        var _alt;
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 86;
          this._errHandler.sync(this);
          switch (this._input.LA(1)) {
            case ExpressionAntlrParser.OPEN_BRACKET:
              {
                _localctx = new ParenthesisExpContext(_localctx);
                this._ctx = _localctx;
                _prevctx = _localctx;
                this.state = 68;
                this.match(ExpressionAntlrParser.OPEN_BRACKET);
                this.state = 69;
                this.expression(0);
                this.state = 70;
                this.match(ExpressionAntlrParser.CLOSE_BRACKET);
              }
              break;
            case ExpressionAntlrParser.OPEN_SQUARE_BRACKET:
              {
                _localctx = new ArrayCreationExpContext(_localctx);
                this._ctx = _localctx;
                _prevctx = _localctx;
                this.state = 72;
                this.match(ExpressionAntlrParser.OPEN_SQUARE_BRACKET);
                this.state = 74;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if ((_la & ~0x1F) === 0 && (1 << _la & (1 << ExpressionAntlrParser.STRING_INTERPOLATION_START | 1 << ExpressionAntlrParser.PLUS | 1 << ExpressionAntlrParser.SUBSTRACT | 1 << ExpressionAntlrParser.NON | 1 << ExpressionAntlrParser.OPEN_BRACKET | 1 << ExpressionAntlrParser.OPEN_SQUARE_BRACKET | 1 << ExpressionAntlrParser.OPEN_CURLY_BRACKET | 1 << ExpressionAntlrParser.NUMBER)) !== 0 || _la === ExpressionAntlrParser.IDENTIFIER || _la === ExpressionAntlrParser.STRING) {
                  {
                    this.state = 73;
                    this.argsList();
                  }
                }
                this.state = 76;
                this.match(ExpressionAntlrParser.CLOSE_SQUARE_BRACKET);
              }
              break;
            case ExpressionAntlrParser.OPEN_CURLY_BRACKET:
              {
                _localctx = new JsonCreationExpContext(_localctx);
                this._ctx = _localctx;
                _prevctx = _localctx;
                this.state = 77;
                this.match(ExpressionAntlrParser.OPEN_CURLY_BRACKET);
                this.state = 79;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if (_la === ExpressionAntlrParser.IDENTIFIER || _la === ExpressionAntlrParser.STRING) {
                  {
                    this.state = 78;
                    this.keyValuePairList();
                  }
                }
                this.state = 81;
                this.match(ExpressionAntlrParser.CLOSE_CURLY_BRACKET);
              }
              break;
            case ExpressionAntlrParser.NUMBER:
              {
                _localctx = new NumericAtomContext(_localctx);
                this._ctx = _localctx;
                _prevctx = _localctx;
                this.state = 82;
                this.match(ExpressionAntlrParser.NUMBER);
              }
              break;
            case ExpressionAntlrParser.STRING:
              {
                _localctx = new StringAtomContext(_localctx);
                this._ctx = _localctx;
                _prevctx = _localctx;
                this.state = 83;
                this.match(ExpressionAntlrParser.STRING);
              }
              break;
            case ExpressionAntlrParser.IDENTIFIER:
              {
                _localctx = new IdAtomContext(_localctx);
                this._ctx = _localctx;
                _prevctx = _localctx;
                this.state = 84;
                this.match(ExpressionAntlrParser.IDENTIFIER);
              }
              break;
            case ExpressionAntlrParser.STRING_INTERPOLATION_START:
              {
                _localctx = new StringInterpolationAtomContext(_localctx);
                this._ctx = _localctx;
                _prevctx = _localctx;
                this.state = 85;
                this.stringInterpolation();
              }
              break;
            default:
              throw new NoViableAltException_1.NoViableAltException(this);
          }
          this._ctx._stop = this._input.tryLT(-1);
          this.state = 107;
          this._errHandler.sync(this);
          _alt = this.interpreter.adaptivePredict(this._input, 9, this._ctx);
          while (_alt !== 2 && _alt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
            if (_alt === 1) {
              if (this._parseListeners != null) {
                this.triggerExitRuleEvent();
              }
              _prevctx = _localctx;
              {
                this.state = 105;
                this._errHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this._input, 8, this._ctx)) {
                  case 1:
                    {
                      _localctx = new MemberAccessExpContext(new PrimaryExpressionContext(_parentctx, _parentState));
                      this.pushNewRecursionContext(_localctx, _startState, ExpressionAntlrParser.RULE_primaryExpression);
                      this.state = 88;
                      if (!this.precpred(this._ctx, 3)) {
                        throw new FailedPredicateException_1.FailedPredicateException(this, "this.precpred(this._ctx, 3)");
                      }
                      this.state = 89;
                      this.match(ExpressionAntlrParser.DOT);
                      this.state = 90;
                      this.match(ExpressionAntlrParser.IDENTIFIER);
                    }
                    break;
                  case 2:
                    {
                      _localctx = new FuncInvokeExpContext(new PrimaryExpressionContext(_parentctx, _parentState));
                      this.pushNewRecursionContext(_localctx, _startState, ExpressionAntlrParser.RULE_primaryExpression);
                      this.state = 91;
                      if (!this.precpred(this._ctx, 2)) {
                        throw new FailedPredicateException_1.FailedPredicateException(this, "this.precpred(this._ctx, 2)");
                      }
                      this.state = 93;
                      this._errHandler.sync(this);
                      _la = this._input.LA(1);
                      if (_la === ExpressionAntlrParser.NON) {
                        {
                          this.state = 92;
                          this.match(ExpressionAntlrParser.NON);
                        }
                      }
                      this.state = 95;
                      this.match(ExpressionAntlrParser.OPEN_BRACKET);
                      this.state = 97;
                      this._errHandler.sync(this);
                      _la = this._input.LA(1);
                      if ((_la & ~0x1F) === 0 && (1 << _la & (1 << ExpressionAntlrParser.STRING_INTERPOLATION_START | 1 << ExpressionAntlrParser.PLUS | 1 << ExpressionAntlrParser.SUBSTRACT | 1 << ExpressionAntlrParser.NON | 1 << ExpressionAntlrParser.OPEN_BRACKET | 1 << ExpressionAntlrParser.OPEN_SQUARE_BRACKET | 1 << ExpressionAntlrParser.OPEN_CURLY_BRACKET | 1 << ExpressionAntlrParser.NUMBER)) !== 0 || _la === ExpressionAntlrParser.IDENTIFIER || _la === ExpressionAntlrParser.STRING) {
                        {
                          this.state = 96;
                          this.argsList();
                        }
                      }
                      this.state = 99;
                      this.match(ExpressionAntlrParser.CLOSE_BRACKET);
                    }
                    break;
                  case 3:
                    {
                      _localctx = new IndexAccessExpContext(new PrimaryExpressionContext(_parentctx, _parentState));
                      this.pushNewRecursionContext(_localctx, _startState, ExpressionAntlrParser.RULE_primaryExpression);
                      this.state = 100;
                      if (!this.precpred(this._ctx, 1)) {
                        throw new FailedPredicateException_1.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                      }
                      this.state = 101;
                      this.match(ExpressionAntlrParser.OPEN_SQUARE_BRACKET);
                      this.state = 102;
                      this.expression(0);
                      this.state = 103;
                      this.match(ExpressionAntlrParser.CLOSE_SQUARE_BRACKET);
                    }
                    break;
                }
              }
            }
            this.state = 109;
            this._errHandler.sync(this);
            _alt = this.interpreter.adaptivePredict(this._input, 9, this._ctx);
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.unrollRecursionContexts(_parentctx);
      }
      return _localctx;
    }
    // @RuleVersion(0)
  }, {
    key: "stringInterpolation",
    value: function stringInterpolation() {
      var _localctx = new StringInterpolationContext(this._ctx, this.state);
      this.enterRule(_localctx, 6, ExpressionAntlrParser.RULE_stringInterpolation);
      var _la;
      try {
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 110;
          this.match(ExpressionAntlrParser.STRING_INTERPOLATION_START);
          this.state = 116;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          while ((_la - 36 & ~0x1F) === 0 && (1 << _la - 36 & (1 << ExpressionAntlrParser.TEMPLATE - 36 | 1 << ExpressionAntlrParser.ESCAPE_CHARACTER - 36 | 1 << ExpressionAntlrParser.TEXT_CONTENT - 36)) !== 0) {
            {
              this.state = 114;
              this._errHandler.sync(this);
              switch (this._input.LA(1)) {
                case ExpressionAntlrParser.ESCAPE_CHARACTER:
                  {
                    this.state = 111;
                    this.match(ExpressionAntlrParser.ESCAPE_CHARACTER);
                  }
                  break;
                case ExpressionAntlrParser.TEMPLATE:
                  {
                    this.state = 112;
                    this.match(ExpressionAntlrParser.TEMPLATE);
                  }
                  break;
                case ExpressionAntlrParser.TEXT_CONTENT:
                  {
                    this.state = 113;
                    this.textContent();
                  }
                  break;
                default:
                  throw new NoViableAltException_1.NoViableAltException(this);
              }
            }
            this.state = 118;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
          }
          this.state = 119;
          this.match(ExpressionAntlrParser.STRING_INTERPOLATION_START);
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
  }, {
    key: "textContent",
    value: function textContent() {
      var _localctx = new TextContentContext(this._ctx, this.state);
      this.enterRule(_localctx, 8, ExpressionAntlrParser.RULE_textContent);
      try {
        var _alt;
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 122;
          this._errHandler.sync(this);
          _alt = 1;
          do {
            switch (_alt) {
              case 1:
                {
                  {
                    this.state = 121;
                    this.match(ExpressionAntlrParser.TEXT_CONTENT);
                  }
                }
                break;
              default:
                throw new NoViableAltException_1.NoViableAltException(this);
            }
            this.state = 124;
            this._errHandler.sync(this);
            _alt = this.interpreter.adaptivePredict(this._input, 12, this._ctx);
          } while (_alt !== 2 && _alt !== ATN_1.ATN.INVALID_ALT_NUMBER);
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
  }, {
    key: "argsList",
    value: function argsList() {
      var _localctx = new ArgsListContext(this._ctx, this.state);
      this.enterRule(_localctx, 10, ExpressionAntlrParser.RULE_argsList);
      var _la;
      try {
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 128;
          this._errHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this._input, 13, this._ctx)) {
            case 1:
              {
                this.state = 126;
                this.lambda();
              }
              break;
            case 2:
              {
                this.state = 127;
                this.expression(0);
              }
              break;
          }
          this.state = 137;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          while (_la === ExpressionAntlrParser.COMMA) {
            {
              {
                this.state = 130;
                this.match(ExpressionAntlrParser.COMMA);
                this.state = 133;
                this._errHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this._input, 14, this._ctx)) {
                  case 1:
                    {
                      this.state = 131;
                      this.lambda();
                    }
                    break;
                  case 2:
                    {
                      this.state = 132;
                      this.expression(0);
                    }
                    break;
                }
              }
            }
            this.state = 139;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
  }, {
    key: "lambda",
    value: function lambda() {
      var _localctx = new LambdaContext(this._ctx, this.state);
      this.enterRule(_localctx, 12, ExpressionAntlrParser.RULE_lambda);
      try {
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 140;
          this.match(ExpressionAntlrParser.IDENTIFIER);
          this.state = 141;
          this.match(ExpressionAntlrParser.ARROW);
          this.state = 142;
          this.expression(0);
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
  }, {
    key: "keyValuePairList",
    value: function keyValuePairList() {
      var _localctx = new KeyValuePairListContext(this._ctx, this.state);
      this.enterRule(_localctx, 14, ExpressionAntlrParser.RULE_keyValuePairList);
      var _la;
      try {
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 144;
          this.keyValuePair();
          this.state = 149;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          while (_la === ExpressionAntlrParser.COMMA) {
            {
              {
                this.state = 145;
                this.match(ExpressionAntlrParser.COMMA);
                this.state = 146;
                this.keyValuePair();
              }
            }
            this.state = 151;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
  }, {
    key: "keyValuePair",
    value: function keyValuePair() {
      var _localctx = new KeyValuePairContext(this._ctx, this.state);
      this.enterRule(_localctx, 16, ExpressionAntlrParser.RULE_keyValuePair);
      try {
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 152;
          this.key();
          this.state = 153;
          this.match(ExpressionAntlrParser.COLON);
          this.state = 154;
          this.expression(0);
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
  }, {
    key: "key",
    value: function key() {
      var _localctx = new KeyContext(this._ctx, this.state);
      this.enterRule(_localctx, 18, ExpressionAntlrParser.RULE_key);
      var _la;
      try {
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 156;
          _la = this._input.LA(1);
          if (!(_la === ExpressionAntlrParser.IDENTIFIER || _la === ExpressionAntlrParser.STRING)) {
            this._errHandler.recoverInline(this);
          } else {
            if (this._input.LA(1) === Token_1.Token.EOF) {
              this.matchedEOF = true;
            }
            this._errHandler.reportMatch(this);
            this.consume();
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException_1.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
  }, {
    key: "sempred",
    value: function sempred(_localctx, ruleIndex, predIndex) {
      switch (ruleIndex) {
        case 1:
          return this.expression_sempred(_localctx, predIndex);
        case 2:
          return this.primaryExpression_sempred(_localctx, predIndex);
      }
      return true;
    }
  }, {
    key: "expression_sempred",
    value: function expression_sempred(_localctx, predIndex) {
      switch (predIndex) {
        case 0:
          return this.precpred(this._ctx, 11);
        case 1:
          return this.precpred(this._ctx, 10);
        case 2:
          return this.precpred(this._ctx, 9);
        case 3:
          return this.precpred(this._ctx, 8);
        case 4:
          return this.precpred(this._ctx, 7);
        case 5:
          return this.precpred(this._ctx, 6);
        case 6:
          return this.precpred(this._ctx, 5);
        case 7:
          return this.precpred(this._ctx, 4);
        case 8:
          return this.precpred(this._ctx, 3);
        case 9:
          return this.precpred(this._ctx, 2);
      }
      return true;
    }
  }, {
    key: "primaryExpression_sempred",
    value: function primaryExpression_sempred(_localctx, predIndex) {
      switch (predIndex) {
        case 10:
          return this.precpred(this._ctx, 3);
        case 11:
          return this.precpred(this._ctx, 2);
        case 12:
          return this.precpred(this._ctx, 1);
      }
      return true;
    }
  }], [{
    key: "_ATN",
    get: function get() {
      if (!ExpressionAntlrParser.__ATN) {
        ExpressionAntlrParser.__ATN = new ATNDeserializer_1.ATNDeserializer().deserialize(Utils.toCharArray(ExpressionAntlrParser._serializedATN));
      }
      return ExpressionAntlrParser.__ATN;
    }
  }]);
  return ExpressionAntlrParser;
}(Parser_1.Parser);
ExpressionAntlrParser.STRING_INTERPOLATION_START = 1;
ExpressionAntlrParser.PLUS = 2;
ExpressionAntlrParser.SUBSTRACT = 3;
ExpressionAntlrParser.NON = 4;
ExpressionAntlrParser.XOR = 5;
ExpressionAntlrParser.ASTERISK = 6;
ExpressionAntlrParser.SLASH = 7;
ExpressionAntlrParser.PERCENT = 8;
ExpressionAntlrParser.DOUBLE_EQUAL = 9;
ExpressionAntlrParser.NOT_EQUAL = 10;
ExpressionAntlrParser.SINGLE_AND = 11;
ExpressionAntlrParser.DOUBLE_AND = 12;
ExpressionAntlrParser.DOUBLE_VERTICAL_CYLINDER = 13;
ExpressionAntlrParser.LESS_THAN = 14;
ExpressionAntlrParser.MORE_THAN = 15;
ExpressionAntlrParser.LESS_OR_EQUAl = 16;
ExpressionAntlrParser.MORE_OR_EQUAL = 17;
ExpressionAntlrParser.OPEN_BRACKET = 18;
ExpressionAntlrParser.CLOSE_BRACKET = 19;
ExpressionAntlrParser.DOT = 20;
ExpressionAntlrParser.OPEN_SQUARE_BRACKET = 21;
ExpressionAntlrParser.CLOSE_SQUARE_BRACKET = 22;
ExpressionAntlrParser.OPEN_CURLY_BRACKET = 23;
ExpressionAntlrParser.CLOSE_CURLY_BRACKET = 24;
ExpressionAntlrParser.COMMA = 25;
ExpressionAntlrParser.COLON = 26;
ExpressionAntlrParser.ARROW = 27;
ExpressionAntlrParser.NULL_COALESCE = 28;
ExpressionAntlrParser.QUESTION_MARK = 29;
ExpressionAntlrParser.NUMBER = 30;
ExpressionAntlrParser.WHITESPACE = 31;
ExpressionAntlrParser.IDENTIFIER = 32;
ExpressionAntlrParser.NEWLINE = 33;
ExpressionAntlrParser.STRING = 34;
ExpressionAntlrParser.INVALID_TOKEN_DEFAULT_MODE = 35;
ExpressionAntlrParser.TEMPLATE = 36;
ExpressionAntlrParser.ESCAPE_CHARACTER = 37;
ExpressionAntlrParser.TEXT_CONTENT = 38;
ExpressionAntlrParser.RULE_file = 0;
ExpressionAntlrParser.RULE_expression = 1;
ExpressionAntlrParser.RULE_primaryExpression = 2;
ExpressionAntlrParser.RULE_stringInterpolation = 3;
ExpressionAntlrParser.RULE_textContent = 4;
ExpressionAntlrParser.RULE_argsList = 5;
ExpressionAntlrParser.RULE_lambda = 6;
ExpressionAntlrParser.RULE_keyValuePairList = 7;
ExpressionAntlrParser.RULE_keyValuePair = 8;
ExpressionAntlrParser.RULE_key = 9;
// tslint:disable:no-trailing-whitespace
ExpressionAntlrParser.ruleNames = ["file", "expression", "primaryExpression", "stringInterpolation", "textContent", "argsList", "lambda", "keyValuePairList", "keyValuePair", "key"];
ExpressionAntlrParser._LITERAL_NAMES = [undefined, undefined, "'+'", "'-'", "'!'", "'^'", "'*'", "'/'", "'%'", "'=='", undefined, "'&'", "'&&'", "'||'", "'<'", "'>'", "'<='", "'>='", "'('", "')'", "'.'", "'['", "']'", "'{'", "'}'", "','", "':'", "'=>'", "'??'", "'?'"];
ExpressionAntlrParser._SYMBOLIC_NAMES = [undefined, "STRING_INTERPOLATION_START", "PLUS", "SUBSTRACT", "NON", "XOR", "ASTERISK", "SLASH", "PERCENT", "DOUBLE_EQUAL", "NOT_EQUAL", "SINGLE_AND", "DOUBLE_AND", "DOUBLE_VERTICAL_CYLINDER", "LESS_THAN", "MORE_THAN", "LESS_OR_EQUAl", "MORE_OR_EQUAL", "OPEN_BRACKET", "CLOSE_BRACKET", "DOT", "OPEN_SQUARE_BRACKET", "CLOSE_SQUARE_BRACKET", "OPEN_CURLY_BRACKET", "CLOSE_CURLY_BRACKET", "COMMA", "COLON", "ARROW", "NULL_COALESCE", "QUESTION_MARK", "NUMBER", "WHITESPACE", "IDENTIFIER", "NEWLINE", "STRING", "INVALID_TOKEN_DEFAULT_MODE", "TEMPLATE", "ESCAPE_CHARACTER", "TEXT_CONTENT"];
ExpressionAntlrParser.VOCABULARY = new VocabularyImpl_1.VocabularyImpl(ExpressionAntlrParser._LITERAL_NAMES, ExpressionAntlrParser._SYMBOLIC_NAMES, []);
ExpressionAntlrParser._serializedATN = "\x03\uC91D\uCABA\u058D\uAFBA\u4F53\u0607\uEA8B\uC241\x03(\xA1\x04\x02" + "\t\x02\x04\x03\t\x03\x04\x04\t\x04\x04\x05\t\x05\x04\x06\t\x06\x04\x07" + "\t\x07\x04\b\t\b\x04\t\t\t\x04\n\t\n\x04\v\t\v\x03\x02\x03\x02\x03\x02" + "\x03\x03\x03\x03\x03\x03\x03\x03\x05\x03\x1E\n\x03\x03\x03\x03\x03\x03" + "\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03" + "\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03" + "\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03" + "\x03\x03\x03\x03\x03\x03\x03\x07\x03A\n\x03\f\x03\x0E\x03D\v\x03\x03\x04" + "\x03\x04\x03\x04\x03\x04\x03\x04\x03\x04\x03\x04\x05\x04M\n\x04\x03\x04" + "\x03\x04\x03\x04\x05\x04R\n\x04\x03\x04\x03\x04\x03\x04\x03\x04\x03\x04" + "\x05\x04Y\n\x04\x03\x04\x03\x04\x03\x04\x03\x04\x03\x04\x05\x04`\n\x04" + "\x03\x04\x03\x04\x05\x04d\n\x04\x03\x04\x03\x04\x03\x04\x03\x04\x03\x04" + "\x03\x04\x07\x04l\n\x04\f\x04\x0E\x04o\v\x04\x03\x05\x03\x05\x03\x05\x03" + "\x05\x07\x05u\n\x05\f\x05\x0E\x05x\v\x05\x03\x05\x03\x05\x03\x06\x06\x06" + "}\n\x06\r\x06\x0E\x06~\x03\x07\x03\x07\x05\x07\x83\n\x07\x03\x07\x03\x07" + "\x03\x07\x05\x07\x88\n\x07\x07\x07\x8A\n\x07\f\x07\x0E\x07\x8D\v\x07\x03" + "\b\x03\b\x03\b\x03\b\x03\t\x03\t\x03\t\x07\t\x96\n\t\f\t\x0E\t\x99\v\t" + "\x03\n\x03\n\x03\n\x03\n\x03\v\x03\v\x03\v\x02\x02\x04\x04\x06\f\x02\x02" + "\x04\x02\x06\x02\b\x02\n\x02\f\x02\x0E\x02\x10\x02\x12\x02\x14\x02\x02" + "\b\x03\x02\x04\x06\x03\x02\b\n\x03\x02\x04\x05\x03\x02\v\f\x03\x02\x10" + "\x13\x04\x02\"\"$$\x02\xB6\x02\x16\x03\x02\x02\x02\x04\x1D\x03\x02\x02" + "\x02\x06X\x03\x02\x02\x02\bp\x03\x02\x02\x02\n|\x03\x02\x02\x02\f\x82" + "\x03\x02\x02\x02\x0E\x8E\x03\x02\x02\x02\x10\x92\x03\x02\x02\x02\x12\x9A" + "\x03\x02\x02\x02\x14\x9E\x03\x02\x02\x02\x16\x17\x05\x04\x03\x02\x17\x18" + "\x07\x02\x02\x03\x18\x03\x03\x02\x02\x02\x19\x1A\b\x03\x01\x02\x1A\x1B" + "\t\x02\x02\x02\x1B\x1E\x05\x04\x03\x0E\x1C\x1E\x05\x06\x04\x02\x1D\x19" + "\x03\x02\x02\x02\x1D\x1C\x03\x02\x02\x02\x1EB\x03\x02\x02\x02\x1F \f\r" + "\x02\x02 !\x07\x07\x02\x02!A\x05\x04\x03\r\"#\f\f\x02\x02#$\t\x03\x02" + "\x02$A\x05\x04\x03\r%&\f\v\x02\x02&\'\t\x04\x02\x02\'A\x05\x04\x03\f(" + ")\f\n\x02\x02)*\t\x05\x02\x02*A\x05\x04\x03\v+,\f\t\x02\x02,-\x07\r\x02" + "\x02-A\x05\x04\x03\n./\f\b\x02\x02/0\t\x06\x02\x020A\x05\x04\x03\t12\f" + "\x07\x02\x0223\x07\x0E\x02\x023A\x05\x04\x03\b45\f\x06\x02\x0256\x07\x0F" + "\x02\x026A\x05\x04\x03\x0778\f\x05\x02\x0289\x07\x1E\x02\x029A\x05\x04" + "\x03\x06:;\f\x04\x02\x02;<\x07\x1F\x02\x02<=\x05\x04\x03\x02=>\x07\x1C" + "\x02\x02>?\x05\x04\x03\x05?A\x03\x02\x02\x02@\x1F\x03\x02\x02\x02@\"\x03" + "\x02\x02\x02@%\x03\x02\x02\x02@(\x03\x02\x02\x02@+\x03\x02\x02\x02@.\x03" + "\x02\x02\x02@1\x03\x02\x02\x02@4\x03\x02\x02\x02@7\x03\x02\x02\x02@:\x03" + "\x02\x02\x02AD\x03\x02\x02\x02B@\x03\x02\x02\x02BC\x03\x02\x02\x02C\x05" + "\x03\x02\x02\x02DB\x03\x02\x02\x02EF\b\x04\x01\x02FG\x07\x14\x02\x02G" + "H\x05\x04\x03\x02HI\x07\x15\x02\x02IY\x03\x02\x02\x02JL\x07\x17\x02\x02" + "KM\x05\f\x07\x02LK\x03\x02\x02\x02LM\x03\x02\x02\x02MN\x03\x02\x02\x02" + "NY\x07\x18\x02\x02OQ\x07\x19\x02\x02PR\x05\x10\t\x02QP\x03\x02\x02\x02" + "QR\x03\x02\x02\x02RS\x03\x02\x02\x02SY\x07\x1A\x02\x02TY\x07 \x02\x02" + "UY\x07$\x02\x02VY\x07\"\x02\x02WY\x05\b\x05\x02XE\x03\x02\x02\x02XJ\x03" + "\x02\x02\x02XO\x03\x02\x02\x02XT\x03\x02\x02\x02XU\x03\x02\x02\x02XV\x03" + "\x02\x02\x02XW\x03\x02\x02\x02Ym\x03\x02\x02\x02Z[\f\x05\x02\x02[\\\x07" + "\x16\x02\x02\\l\x07\"\x02\x02]_\f\x04\x02\x02^`\x07\x06\x02\x02_^\x03" + "\x02\x02\x02_`\x03\x02\x02\x02`a\x03\x02\x02\x02ac\x07\x14\x02\x02bd\x05" + "\f\x07\x02cb\x03\x02\x02\x02cd\x03\x02\x02\x02de\x03\x02\x02\x02el\x07" + "\x15\x02\x02fg\f\x03\x02\x02gh\x07\x17\x02\x02hi\x05\x04\x03\x02ij\x07" + "\x18\x02\x02jl\x03\x02\x02\x02kZ\x03\x02\x02\x02k]\x03\x02\x02\x02kf\x03" + "\x02\x02\x02lo\x03\x02\x02\x02mk\x03\x02\x02\x02mn\x03\x02\x02\x02n\x07" + "\x03\x02\x02\x02om\x03\x02\x02\x02pv\x07\x03\x02\x02qu\x07\'\x02\x02r" + "u\x07&\x02\x02su\x05\n\x06\x02tq\x03\x02\x02\x02tr\x03\x02\x02\x02ts\x03" + "\x02\x02\x02ux\x03\x02\x02\x02vt\x03\x02\x02\x02vw\x03\x02\x02\x02wy\x03" + "\x02\x02\x02xv\x03\x02\x02\x02yz\x07\x03\x02\x02z\t\x03\x02\x02\x02{}" + "\x07(\x02\x02|{\x03\x02\x02\x02}~\x03\x02\x02\x02~|\x03\x02\x02\x02~\x7F" + "\x03\x02\x02\x02\x7F\v\x03\x02\x02\x02\x80\x83\x05\x0E\b\x02\x81\x83\x05" + "\x04\x03\x02\x82\x80\x03\x02\x02\x02\x82\x81\x03\x02\x02\x02\x83\x8B\x03" + "\x02\x02\x02\x84\x87\x07\x1B\x02\x02\x85\x88\x05\x0E\b\x02\x86\x88\x05" + "\x04\x03\x02\x87\x85\x03\x02\x02\x02\x87\x86\x03\x02\x02\x02\x88\x8A\x03" + "\x02\x02\x02\x89\x84\x03\x02\x02\x02\x8A\x8D\x03\x02\x02\x02\x8B\x89\x03" + "\x02\x02\x02\x8B\x8C\x03\x02\x02\x02\x8C\r\x03\x02\x02\x02\x8D\x8B\x03" + "\x02\x02\x02\x8E\x8F\x07\"\x02\x02\x8F\x90\x07\x1D\x02\x02\x90\x91\x05" + "\x04\x03\x02\x91\x0F\x03\x02\x02\x02\x92\x97\x05\x12\n\x02\x93\x94\x07" + "\x1B\x02\x02\x94\x96\x05\x12\n\x02\x95\x93\x03\x02\x02\x02\x96\x99\x03" + "\x02\x02\x02\x97\x95\x03\x02\x02\x02\x97\x98\x03\x02\x02\x02\x98\x11\x03" + "\x02\x02\x02\x99\x97\x03\x02\x02\x02\x9A\x9B\x05\x14\v\x02\x9B\x9C\x07" + "\x1C\x02\x02\x9C\x9D\x05\x04\x03\x02\x9D\x13\x03\x02\x02\x02\x9E\x9F\t" + "\x07\x02\x02\x9F\x15\x03\x02\x02\x02\x13\x1D@BLQX_ckmtv~\x82\x87\x8B\x97";
exports.ExpressionAntlrParser = ExpressionAntlrParser;
var FileContext = /*#__PURE__*/function (_ParserRuleContext_1$) {
  (0, _inherits2.default)(FileContext, _ParserRuleContext_1$);
  var _super2 = _createSuper(FileContext);
  function FileContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, FileContext);
    return _super2.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(FileContext, [{
    key: "expression",
    value: function expression() {
      return this.getRuleContext(0, ExpressionContext);
    }
  }, {
    key: "EOF",
    value: function EOF() {
      return this.getToken(ExpressionAntlrParser.EOF, 0);
    }
  }, {
    key: "ruleIndex",
    get: function get() {
      return ExpressionAntlrParser.RULE_file;
    }
    // @Override
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterFile) {
        listener.enterFile(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitFile) {
        listener.exitFile(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitFile) {
        return visitor.visitFile(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return FileContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.FileContext = FileContext;
var ExpressionContext = /*#__PURE__*/function (_ParserRuleContext_1$2) {
  (0, _inherits2.default)(ExpressionContext, _ParserRuleContext_1$2);
  var _super3 = _createSuper(ExpressionContext);
  function ExpressionContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, ExpressionContext);
    return _super3.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(ExpressionContext, [{
    key: "ruleIndex",
    get: function get() {
      return ExpressionAntlrParser.RULE_expression;
    }
  }, {
    key: "copyFrom",
    value: function copyFrom(ctx) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(ExpressionContext.prototype), "copyFrom", this).call(this, ctx);
    }
  }]);
  return ExpressionContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.ExpressionContext = ExpressionContext;
var UnaryOpExpContext = /*#__PURE__*/function (_ExpressionContext) {
  (0, _inherits2.default)(UnaryOpExpContext, _ExpressionContext);
  var _super4 = _createSuper(UnaryOpExpContext);
  function UnaryOpExpContext(ctx) {
    var _this2;
    (0, _classCallCheck2.default)(this, UnaryOpExpContext);
    _this2 = _super4.call(this, ctx.parent, ctx.invokingState);
    _this2.copyFrom(ctx);
    return _this2;
  }
  // @Override
  (0, _createClass2.default)(UnaryOpExpContext, [{
    key: "expression",
    value: function expression() {
      return this.getRuleContext(0, ExpressionContext);
    }
  }, {
    key: "NON",
    value: function NON() {
      return this.tryGetToken(ExpressionAntlrParser.NON, 0);
    }
  }, {
    key: "SUBSTRACT",
    value: function SUBSTRACT() {
      return this.tryGetToken(ExpressionAntlrParser.SUBSTRACT, 0);
    }
  }, {
    key: "PLUS",
    value: function PLUS() {
      return this.tryGetToken(ExpressionAntlrParser.PLUS, 0);
    }
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterUnaryOpExp) {
        listener.enterUnaryOpExp(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitUnaryOpExp) {
        listener.exitUnaryOpExp(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitUnaryOpExp) {
        return visitor.visitUnaryOpExp(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return UnaryOpExpContext;
}(ExpressionContext);
exports.UnaryOpExpContext = UnaryOpExpContext;
var BinaryOpExpContext = /*#__PURE__*/function (_ExpressionContext2) {
  (0, _inherits2.default)(BinaryOpExpContext, _ExpressionContext2);
  var _super5 = _createSuper(BinaryOpExpContext);
  function BinaryOpExpContext(ctx) {
    var _this3;
    (0, _classCallCheck2.default)(this, BinaryOpExpContext);
    _this3 = _super5.call(this, ctx.parent, ctx.invokingState);
    _this3.copyFrom(ctx);
    return _this3;
  }
  // @Override
  (0, _createClass2.default)(BinaryOpExpContext, [{
    key: "expression",
    value: function expression(i) {
      if (i === undefined) {
        return this.getRuleContexts(ExpressionContext);
      } else {
        return this.getRuleContext(i, ExpressionContext);
      }
    }
  }, {
    key: "XOR",
    value: function XOR() {
      return this.tryGetToken(ExpressionAntlrParser.XOR, 0);
    }
  }, {
    key: "ASTERISK",
    value: function ASTERISK() {
      return this.tryGetToken(ExpressionAntlrParser.ASTERISK, 0);
    }
  }, {
    key: "SLASH",
    value: function SLASH() {
      return this.tryGetToken(ExpressionAntlrParser.SLASH, 0);
    }
  }, {
    key: "PERCENT",
    value: function PERCENT() {
      return this.tryGetToken(ExpressionAntlrParser.PERCENT, 0);
    }
  }, {
    key: "PLUS",
    value: function PLUS() {
      return this.tryGetToken(ExpressionAntlrParser.PLUS, 0);
    }
  }, {
    key: "SUBSTRACT",
    value: function SUBSTRACT() {
      return this.tryGetToken(ExpressionAntlrParser.SUBSTRACT, 0);
    }
  }, {
    key: "DOUBLE_EQUAL",
    value: function DOUBLE_EQUAL() {
      return this.tryGetToken(ExpressionAntlrParser.DOUBLE_EQUAL, 0);
    }
  }, {
    key: "NOT_EQUAL",
    value: function NOT_EQUAL() {
      return this.tryGetToken(ExpressionAntlrParser.NOT_EQUAL, 0);
    }
  }, {
    key: "SINGLE_AND",
    value: function SINGLE_AND() {
      return this.tryGetToken(ExpressionAntlrParser.SINGLE_AND, 0);
    }
  }, {
    key: "LESS_THAN",
    value: function LESS_THAN() {
      return this.tryGetToken(ExpressionAntlrParser.LESS_THAN, 0);
    }
  }, {
    key: "LESS_OR_EQUAl",
    value: function LESS_OR_EQUAl() {
      return this.tryGetToken(ExpressionAntlrParser.LESS_OR_EQUAl, 0);
    }
  }, {
    key: "MORE_THAN",
    value: function MORE_THAN() {
      return this.tryGetToken(ExpressionAntlrParser.MORE_THAN, 0);
    }
  }, {
    key: "MORE_OR_EQUAL",
    value: function MORE_OR_EQUAL() {
      return this.tryGetToken(ExpressionAntlrParser.MORE_OR_EQUAL, 0);
    }
  }, {
    key: "DOUBLE_AND",
    value: function DOUBLE_AND() {
      return this.tryGetToken(ExpressionAntlrParser.DOUBLE_AND, 0);
    }
  }, {
    key: "DOUBLE_VERTICAL_CYLINDER",
    value: function DOUBLE_VERTICAL_CYLINDER() {
      return this.tryGetToken(ExpressionAntlrParser.DOUBLE_VERTICAL_CYLINDER, 0);
    }
  }, {
    key: "NULL_COALESCE",
    value: function NULL_COALESCE() {
      return this.tryGetToken(ExpressionAntlrParser.NULL_COALESCE, 0);
    }
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterBinaryOpExp) {
        listener.enterBinaryOpExp(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitBinaryOpExp) {
        listener.exitBinaryOpExp(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitBinaryOpExp) {
        return visitor.visitBinaryOpExp(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return BinaryOpExpContext;
}(ExpressionContext);
exports.BinaryOpExpContext = BinaryOpExpContext;
var TripleOpExpContext = /*#__PURE__*/function (_ExpressionContext3) {
  (0, _inherits2.default)(TripleOpExpContext, _ExpressionContext3);
  var _super6 = _createSuper(TripleOpExpContext);
  function TripleOpExpContext(ctx) {
    var _this4;
    (0, _classCallCheck2.default)(this, TripleOpExpContext);
    _this4 = _super6.call(this, ctx.parent, ctx.invokingState);
    _this4.copyFrom(ctx);
    return _this4;
  }
  // @Override
  (0, _createClass2.default)(TripleOpExpContext, [{
    key: "expression",
    value: function expression(i) {
      if (i === undefined) {
        return this.getRuleContexts(ExpressionContext);
      } else {
        return this.getRuleContext(i, ExpressionContext);
      }
    }
  }, {
    key: "QUESTION_MARK",
    value: function QUESTION_MARK() {
      return this.getToken(ExpressionAntlrParser.QUESTION_MARK, 0);
    }
  }, {
    key: "COLON",
    value: function COLON() {
      return this.getToken(ExpressionAntlrParser.COLON, 0);
    }
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterTripleOpExp) {
        listener.enterTripleOpExp(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitTripleOpExp) {
        listener.exitTripleOpExp(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitTripleOpExp) {
        return visitor.visitTripleOpExp(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return TripleOpExpContext;
}(ExpressionContext);
exports.TripleOpExpContext = TripleOpExpContext;
var PrimaryExpContext = /*#__PURE__*/function (_ExpressionContext4) {
  (0, _inherits2.default)(PrimaryExpContext, _ExpressionContext4);
  var _super7 = _createSuper(PrimaryExpContext);
  function PrimaryExpContext(ctx) {
    var _this5;
    (0, _classCallCheck2.default)(this, PrimaryExpContext);
    _this5 = _super7.call(this, ctx.parent, ctx.invokingState);
    _this5.copyFrom(ctx);
    return _this5;
  }
  // @Override
  (0, _createClass2.default)(PrimaryExpContext, [{
    key: "primaryExpression",
    value: function primaryExpression() {
      return this.getRuleContext(0, PrimaryExpressionContext);
    }
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterPrimaryExp) {
        listener.enterPrimaryExp(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitPrimaryExp) {
        listener.exitPrimaryExp(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitPrimaryExp) {
        return visitor.visitPrimaryExp(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return PrimaryExpContext;
}(ExpressionContext);
exports.PrimaryExpContext = PrimaryExpContext;
var PrimaryExpressionContext = /*#__PURE__*/function (_ParserRuleContext_1$3) {
  (0, _inherits2.default)(PrimaryExpressionContext, _ParserRuleContext_1$3);
  var _super8 = _createSuper(PrimaryExpressionContext);
  function PrimaryExpressionContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, PrimaryExpressionContext);
    return _super8.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(PrimaryExpressionContext, [{
    key: "ruleIndex",
    get: function get() {
      return ExpressionAntlrParser.RULE_primaryExpression;
    }
  }, {
    key: "copyFrom",
    value: function copyFrom(ctx) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(PrimaryExpressionContext.prototype), "copyFrom", this).call(this, ctx);
    }
  }]);
  return PrimaryExpressionContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.PrimaryExpressionContext = PrimaryExpressionContext;
var ParenthesisExpContext = /*#__PURE__*/function (_PrimaryExpressionCon) {
  (0, _inherits2.default)(ParenthesisExpContext, _PrimaryExpressionCon);
  var _super9 = _createSuper(ParenthesisExpContext);
  function ParenthesisExpContext(ctx) {
    var _this6;
    (0, _classCallCheck2.default)(this, ParenthesisExpContext);
    _this6 = _super9.call(this, ctx.parent, ctx.invokingState);
    _this6.copyFrom(ctx);
    return _this6;
  }
  // @Override
  (0, _createClass2.default)(ParenthesisExpContext, [{
    key: "OPEN_BRACKET",
    value: function OPEN_BRACKET() {
      return this.getToken(ExpressionAntlrParser.OPEN_BRACKET, 0);
    }
  }, {
    key: "expression",
    value: function expression() {
      return this.getRuleContext(0, ExpressionContext);
    }
  }, {
    key: "CLOSE_BRACKET",
    value: function CLOSE_BRACKET() {
      return this.getToken(ExpressionAntlrParser.CLOSE_BRACKET, 0);
    }
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterParenthesisExp) {
        listener.enterParenthesisExp(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitParenthesisExp) {
        listener.exitParenthesisExp(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitParenthesisExp) {
        return visitor.visitParenthesisExp(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return ParenthesisExpContext;
}(PrimaryExpressionContext);
exports.ParenthesisExpContext = ParenthesisExpContext;
var ArrayCreationExpContext = /*#__PURE__*/function (_PrimaryExpressionCon2) {
  (0, _inherits2.default)(ArrayCreationExpContext, _PrimaryExpressionCon2);
  var _super10 = _createSuper(ArrayCreationExpContext);
  function ArrayCreationExpContext(ctx) {
    var _this7;
    (0, _classCallCheck2.default)(this, ArrayCreationExpContext);
    _this7 = _super10.call(this, ctx.parent, ctx.invokingState);
    _this7.copyFrom(ctx);
    return _this7;
  }
  // @Override
  (0, _createClass2.default)(ArrayCreationExpContext, [{
    key: "OPEN_SQUARE_BRACKET",
    value: function OPEN_SQUARE_BRACKET() {
      return this.getToken(ExpressionAntlrParser.OPEN_SQUARE_BRACKET, 0);
    }
  }, {
    key: "CLOSE_SQUARE_BRACKET",
    value: function CLOSE_SQUARE_BRACKET() {
      return this.getToken(ExpressionAntlrParser.CLOSE_SQUARE_BRACKET, 0);
    }
  }, {
    key: "argsList",
    value: function argsList() {
      return this.tryGetRuleContext(0, ArgsListContext);
    }
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterArrayCreationExp) {
        listener.enterArrayCreationExp(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitArrayCreationExp) {
        listener.exitArrayCreationExp(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitArrayCreationExp) {
        return visitor.visitArrayCreationExp(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return ArrayCreationExpContext;
}(PrimaryExpressionContext);
exports.ArrayCreationExpContext = ArrayCreationExpContext;
var JsonCreationExpContext = /*#__PURE__*/function (_PrimaryExpressionCon3) {
  (0, _inherits2.default)(JsonCreationExpContext, _PrimaryExpressionCon3);
  var _super11 = _createSuper(JsonCreationExpContext);
  function JsonCreationExpContext(ctx) {
    var _this8;
    (0, _classCallCheck2.default)(this, JsonCreationExpContext);
    _this8 = _super11.call(this, ctx.parent, ctx.invokingState);
    _this8.copyFrom(ctx);
    return _this8;
  }
  // @Override
  (0, _createClass2.default)(JsonCreationExpContext, [{
    key: "OPEN_CURLY_BRACKET",
    value: function OPEN_CURLY_BRACKET() {
      return this.getToken(ExpressionAntlrParser.OPEN_CURLY_BRACKET, 0);
    }
  }, {
    key: "CLOSE_CURLY_BRACKET",
    value: function CLOSE_CURLY_BRACKET() {
      return this.getToken(ExpressionAntlrParser.CLOSE_CURLY_BRACKET, 0);
    }
  }, {
    key: "keyValuePairList",
    value: function keyValuePairList() {
      return this.tryGetRuleContext(0, KeyValuePairListContext);
    }
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterJsonCreationExp) {
        listener.enterJsonCreationExp(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitJsonCreationExp) {
        listener.exitJsonCreationExp(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitJsonCreationExp) {
        return visitor.visitJsonCreationExp(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return JsonCreationExpContext;
}(PrimaryExpressionContext);
exports.JsonCreationExpContext = JsonCreationExpContext;
var NumericAtomContext = /*#__PURE__*/function (_PrimaryExpressionCon4) {
  (0, _inherits2.default)(NumericAtomContext, _PrimaryExpressionCon4);
  var _super12 = _createSuper(NumericAtomContext);
  function NumericAtomContext(ctx) {
    var _this9;
    (0, _classCallCheck2.default)(this, NumericAtomContext);
    _this9 = _super12.call(this, ctx.parent, ctx.invokingState);
    _this9.copyFrom(ctx);
    return _this9;
  }
  // @Override
  (0, _createClass2.default)(NumericAtomContext, [{
    key: "NUMBER",
    value: function NUMBER() {
      return this.getToken(ExpressionAntlrParser.NUMBER, 0);
    }
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterNumericAtom) {
        listener.enterNumericAtom(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitNumericAtom) {
        listener.exitNumericAtom(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitNumericAtom) {
        return visitor.visitNumericAtom(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return NumericAtomContext;
}(PrimaryExpressionContext);
exports.NumericAtomContext = NumericAtomContext;
var StringAtomContext = /*#__PURE__*/function (_PrimaryExpressionCon5) {
  (0, _inherits2.default)(StringAtomContext, _PrimaryExpressionCon5);
  var _super13 = _createSuper(StringAtomContext);
  function StringAtomContext(ctx) {
    var _this10;
    (0, _classCallCheck2.default)(this, StringAtomContext);
    _this10 = _super13.call(this, ctx.parent, ctx.invokingState);
    _this10.copyFrom(ctx);
    return _this10;
  }
  // @Override
  (0, _createClass2.default)(StringAtomContext, [{
    key: "STRING",
    value: function STRING() {
      return this.getToken(ExpressionAntlrParser.STRING, 0);
    }
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterStringAtom) {
        listener.enterStringAtom(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitStringAtom) {
        listener.exitStringAtom(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitStringAtom) {
        return visitor.visitStringAtom(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return StringAtomContext;
}(PrimaryExpressionContext);
exports.StringAtomContext = StringAtomContext;
var IdAtomContext = /*#__PURE__*/function (_PrimaryExpressionCon6) {
  (0, _inherits2.default)(IdAtomContext, _PrimaryExpressionCon6);
  var _super14 = _createSuper(IdAtomContext);
  function IdAtomContext(ctx) {
    var _this11;
    (0, _classCallCheck2.default)(this, IdAtomContext);
    _this11 = _super14.call(this, ctx.parent, ctx.invokingState);
    _this11.copyFrom(ctx);
    return _this11;
  }
  // @Override
  (0, _createClass2.default)(IdAtomContext, [{
    key: "IDENTIFIER",
    value: function IDENTIFIER() {
      return this.getToken(ExpressionAntlrParser.IDENTIFIER, 0);
    }
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterIdAtom) {
        listener.enterIdAtom(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitIdAtom) {
        listener.exitIdAtom(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitIdAtom) {
        return visitor.visitIdAtom(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return IdAtomContext;
}(PrimaryExpressionContext);
exports.IdAtomContext = IdAtomContext;
var StringInterpolationAtomContext = /*#__PURE__*/function (_PrimaryExpressionCon7) {
  (0, _inherits2.default)(StringInterpolationAtomContext, _PrimaryExpressionCon7);
  var _super15 = _createSuper(StringInterpolationAtomContext);
  function StringInterpolationAtomContext(ctx) {
    var _this12;
    (0, _classCallCheck2.default)(this, StringInterpolationAtomContext);
    _this12 = _super15.call(this, ctx.parent, ctx.invokingState);
    _this12.copyFrom(ctx);
    return _this12;
  }
  // @Override
  (0, _createClass2.default)(StringInterpolationAtomContext, [{
    key: "stringInterpolation",
    value: function stringInterpolation() {
      return this.getRuleContext(0, StringInterpolationContext);
    }
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterStringInterpolationAtom) {
        listener.enterStringInterpolationAtom(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitStringInterpolationAtom) {
        listener.exitStringInterpolationAtom(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitStringInterpolationAtom) {
        return visitor.visitStringInterpolationAtom(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return StringInterpolationAtomContext;
}(PrimaryExpressionContext);
exports.StringInterpolationAtomContext = StringInterpolationAtomContext;
var MemberAccessExpContext = /*#__PURE__*/function (_PrimaryExpressionCon8) {
  (0, _inherits2.default)(MemberAccessExpContext, _PrimaryExpressionCon8);
  var _super16 = _createSuper(MemberAccessExpContext);
  function MemberAccessExpContext(ctx) {
    var _this13;
    (0, _classCallCheck2.default)(this, MemberAccessExpContext);
    _this13 = _super16.call(this, ctx.parent, ctx.invokingState);
    _this13.copyFrom(ctx);
    return _this13;
  }
  // @Override
  (0, _createClass2.default)(MemberAccessExpContext, [{
    key: "primaryExpression",
    value: function primaryExpression() {
      return this.getRuleContext(0, PrimaryExpressionContext);
    }
  }, {
    key: "DOT",
    value: function DOT() {
      return this.getToken(ExpressionAntlrParser.DOT, 0);
    }
  }, {
    key: "IDENTIFIER",
    value: function IDENTIFIER() {
      return this.getToken(ExpressionAntlrParser.IDENTIFIER, 0);
    }
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterMemberAccessExp) {
        listener.enterMemberAccessExp(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitMemberAccessExp) {
        listener.exitMemberAccessExp(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitMemberAccessExp) {
        return visitor.visitMemberAccessExp(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return MemberAccessExpContext;
}(PrimaryExpressionContext);
exports.MemberAccessExpContext = MemberAccessExpContext;
var FuncInvokeExpContext = /*#__PURE__*/function (_PrimaryExpressionCon9) {
  (0, _inherits2.default)(FuncInvokeExpContext, _PrimaryExpressionCon9);
  var _super17 = _createSuper(FuncInvokeExpContext);
  function FuncInvokeExpContext(ctx) {
    var _this14;
    (0, _classCallCheck2.default)(this, FuncInvokeExpContext);
    _this14 = _super17.call(this, ctx.parent, ctx.invokingState);
    _this14.copyFrom(ctx);
    return _this14;
  }
  // @Override
  (0, _createClass2.default)(FuncInvokeExpContext, [{
    key: "primaryExpression",
    value: function primaryExpression() {
      return this.getRuleContext(0, PrimaryExpressionContext);
    }
  }, {
    key: "OPEN_BRACKET",
    value: function OPEN_BRACKET() {
      return this.getToken(ExpressionAntlrParser.OPEN_BRACKET, 0);
    }
  }, {
    key: "CLOSE_BRACKET",
    value: function CLOSE_BRACKET() {
      return this.getToken(ExpressionAntlrParser.CLOSE_BRACKET, 0);
    }
  }, {
    key: "NON",
    value: function NON() {
      return this.tryGetToken(ExpressionAntlrParser.NON, 0);
    }
  }, {
    key: "argsList",
    value: function argsList() {
      return this.tryGetRuleContext(0, ArgsListContext);
    }
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterFuncInvokeExp) {
        listener.enterFuncInvokeExp(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitFuncInvokeExp) {
        listener.exitFuncInvokeExp(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitFuncInvokeExp) {
        return visitor.visitFuncInvokeExp(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return FuncInvokeExpContext;
}(PrimaryExpressionContext);
exports.FuncInvokeExpContext = FuncInvokeExpContext;
var IndexAccessExpContext = /*#__PURE__*/function (_PrimaryExpressionCon10) {
  (0, _inherits2.default)(IndexAccessExpContext, _PrimaryExpressionCon10);
  var _super18 = _createSuper(IndexAccessExpContext);
  function IndexAccessExpContext(ctx) {
    var _this15;
    (0, _classCallCheck2.default)(this, IndexAccessExpContext);
    _this15 = _super18.call(this, ctx.parent, ctx.invokingState);
    _this15.copyFrom(ctx);
    return _this15;
  }
  // @Override
  (0, _createClass2.default)(IndexAccessExpContext, [{
    key: "primaryExpression",
    value: function primaryExpression() {
      return this.getRuleContext(0, PrimaryExpressionContext);
    }
  }, {
    key: "OPEN_SQUARE_BRACKET",
    value: function OPEN_SQUARE_BRACKET() {
      return this.getToken(ExpressionAntlrParser.OPEN_SQUARE_BRACKET, 0);
    }
  }, {
    key: "expression",
    value: function expression() {
      return this.getRuleContext(0, ExpressionContext);
    }
  }, {
    key: "CLOSE_SQUARE_BRACKET",
    value: function CLOSE_SQUARE_BRACKET() {
      return this.getToken(ExpressionAntlrParser.CLOSE_SQUARE_BRACKET, 0);
    }
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterIndexAccessExp) {
        listener.enterIndexAccessExp(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitIndexAccessExp) {
        listener.exitIndexAccessExp(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitIndexAccessExp) {
        return visitor.visitIndexAccessExp(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return IndexAccessExpContext;
}(PrimaryExpressionContext);
exports.IndexAccessExpContext = IndexAccessExpContext;
var StringInterpolationContext = /*#__PURE__*/function (_ParserRuleContext_1$4) {
  (0, _inherits2.default)(StringInterpolationContext, _ParserRuleContext_1$4);
  var _super19 = _createSuper(StringInterpolationContext);
  function StringInterpolationContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, StringInterpolationContext);
    return _super19.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(StringInterpolationContext, [{
    key: "STRING_INTERPOLATION_START",
    value: function STRING_INTERPOLATION_START(i) {
      if (i === undefined) {
        return this.getTokens(ExpressionAntlrParser.STRING_INTERPOLATION_START);
      } else {
        return this.getToken(ExpressionAntlrParser.STRING_INTERPOLATION_START, i);
      }
    }
  }, {
    key: "ESCAPE_CHARACTER",
    value: function ESCAPE_CHARACTER(i) {
      if (i === undefined) {
        return this.getTokens(ExpressionAntlrParser.ESCAPE_CHARACTER);
      } else {
        return this.getToken(ExpressionAntlrParser.ESCAPE_CHARACTER, i);
      }
    }
  }, {
    key: "TEMPLATE",
    value: function TEMPLATE(i) {
      if (i === undefined) {
        return this.getTokens(ExpressionAntlrParser.TEMPLATE);
      } else {
        return this.getToken(ExpressionAntlrParser.TEMPLATE, i);
      }
    }
  }, {
    key: "textContent",
    value: function textContent(i) {
      if (i === undefined) {
        return this.getRuleContexts(TextContentContext);
      } else {
        return this.getRuleContext(i, TextContentContext);
      }
    }
  }, {
    key: "ruleIndex",
    get: function get() {
      return ExpressionAntlrParser.RULE_stringInterpolation;
    }
    // @Override
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterStringInterpolation) {
        listener.enterStringInterpolation(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitStringInterpolation) {
        listener.exitStringInterpolation(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitStringInterpolation) {
        return visitor.visitStringInterpolation(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return StringInterpolationContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.StringInterpolationContext = StringInterpolationContext;
var TextContentContext = /*#__PURE__*/function (_ParserRuleContext_1$5) {
  (0, _inherits2.default)(TextContentContext, _ParserRuleContext_1$5);
  var _super20 = _createSuper(TextContentContext);
  function TextContentContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, TextContentContext);
    return _super20.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(TextContentContext, [{
    key: "TEXT_CONTENT",
    value: function TEXT_CONTENT(i) {
      if (i === undefined) {
        return this.getTokens(ExpressionAntlrParser.TEXT_CONTENT);
      } else {
        return this.getToken(ExpressionAntlrParser.TEXT_CONTENT, i);
      }
    }
  }, {
    key: "ruleIndex",
    get: function get() {
      return ExpressionAntlrParser.RULE_textContent;
    }
    // @Override
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterTextContent) {
        listener.enterTextContent(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitTextContent) {
        listener.exitTextContent(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitTextContent) {
        return visitor.visitTextContent(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return TextContentContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.TextContentContext = TextContentContext;
var ArgsListContext = /*#__PURE__*/function (_ParserRuleContext_1$6) {
  (0, _inherits2.default)(ArgsListContext, _ParserRuleContext_1$6);
  var _super21 = _createSuper(ArgsListContext);
  function ArgsListContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, ArgsListContext);
    return _super21.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(ArgsListContext, [{
    key: "lambda",
    value: function lambda(i) {
      if (i === undefined) {
        return this.getRuleContexts(LambdaContext);
      } else {
        return this.getRuleContext(i, LambdaContext);
      }
    }
  }, {
    key: "expression",
    value: function expression(i) {
      if (i === undefined) {
        return this.getRuleContexts(ExpressionContext);
      } else {
        return this.getRuleContext(i, ExpressionContext);
      }
    }
  }, {
    key: "COMMA",
    value: function COMMA(i) {
      if (i === undefined) {
        return this.getTokens(ExpressionAntlrParser.COMMA);
      } else {
        return this.getToken(ExpressionAntlrParser.COMMA, i);
      }
    }
  }, {
    key: "ruleIndex",
    get: function get() {
      return ExpressionAntlrParser.RULE_argsList;
    }
    // @Override
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterArgsList) {
        listener.enterArgsList(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitArgsList) {
        listener.exitArgsList(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitArgsList) {
        return visitor.visitArgsList(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return ArgsListContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.ArgsListContext = ArgsListContext;
var LambdaContext = /*#__PURE__*/function (_ParserRuleContext_1$7) {
  (0, _inherits2.default)(LambdaContext, _ParserRuleContext_1$7);
  var _super22 = _createSuper(LambdaContext);
  function LambdaContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, LambdaContext);
    return _super22.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(LambdaContext, [{
    key: "IDENTIFIER",
    value: function IDENTIFIER() {
      return this.getToken(ExpressionAntlrParser.IDENTIFIER, 0);
    }
  }, {
    key: "ARROW",
    value: function ARROW() {
      return this.getToken(ExpressionAntlrParser.ARROW, 0);
    }
  }, {
    key: "expression",
    value: function expression() {
      return this.getRuleContext(0, ExpressionContext);
    }
  }, {
    key: "ruleIndex",
    get: function get() {
      return ExpressionAntlrParser.RULE_lambda;
    }
    // @Override
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterLambda) {
        listener.enterLambda(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitLambda) {
        listener.exitLambda(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitLambda) {
        return visitor.visitLambda(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return LambdaContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.LambdaContext = LambdaContext;
var KeyValuePairListContext = /*#__PURE__*/function (_ParserRuleContext_1$8) {
  (0, _inherits2.default)(KeyValuePairListContext, _ParserRuleContext_1$8);
  var _super23 = _createSuper(KeyValuePairListContext);
  function KeyValuePairListContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, KeyValuePairListContext);
    return _super23.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(KeyValuePairListContext, [{
    key: "keyValuePair",
    value: function keyValuePair(i) {
      if (i === undefined) {
        return this.getRuleContexts(KeyValuePairContext);
      } else {
        return this.getRuleContext(i, KeyValuePairContext);
      }
    }
  }, {
    key: "COMMA",
    value: function COMMA(i) {
      if (i === undefined) {
        return this.getTokens(ExpressionAntlrParser.COMMA);
      } else {
        return this.getToken(ExpressionAntlrParser.COMMA, i);
      }
    }
  }, {
    key: "ruleIndex",
    get: function get() {
      return ExpressionAntlrParser.RULE_keyValuePairList;
    }
    // @Override
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterKeyValuePairList) {
        listener.enterKeyValuePairList(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitKeyValuePairList) {
        listener.exitKeyValuePairList(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitKeyValuePairList) {
        return visitor.visitKeyValuePairList(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return KeyValuePairListContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.KeyValuePairListContext = KeyValuePairListContext;
var KeyValuePairContext = /*#__PURE__*/function (_ParserRuleContext_1$9) {
  (0, _inherits2.default)(KeyValuePairContext, _ParserRuleContext_1$9);
  var _super24 = _createSuper(KeyValuePairContext);
  function KeyValuePairContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, KeyValuePairContext);
    return _super24.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(KeyValuePairContext, [{
    key: "key",
    value: function key() {
      return this.getRuleContext(0, KeyContext);
    }
  }, {
    key: "COLON",
    value: function COLON() {
      return this.getToken(ExpressionAntlrParser.COLON, 0);
    }
  }, {
    key: "expression",
    value: function expression() {
      return this.getRuleContext(0, ExpressionContext);
    }
  }, {
    key: "ruleIndex",
    get: function get() {
      return ExpressionAntlrParser.RULE_keyValuePair;
    }
    // @Override
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterKeyValuePair) {
        listener.enterKeyValuePair(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitKeyValuePair) {
        listener.exitKeyValuePair(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitKeyValuePair) {
        return visitor.visitKeyValuePair(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return KeyValuePairContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.KeyValuePairContext = KeyValuePairContext;
var KeyContext = /*#__PURE__*/function (_ParserRuleContext_1$10) {
  (0, _inherits2.default)(KeyContext, _ParserRuleContext_1$10);
  var _super25 = _createSuper(KeyContext);
  function KeyContext(parent, invokingState) {
    (0, _classCallCheck2.default)(this, KeyContext);
    return _super25.call(this, parent, invokingState);
  }
  // @Override
  (0, _createClass2.default)(KeyContext, [{
    key: "IDENTIFIER",
    value: function IDENTIFIER() {
      return this.tryGetToken(ExpressionAntlrParser.IDENTIFIER, 0);
    }
  }, {
    key: "STRING",
    value: function STRING() {
      return this.tryGetToken(ExpressionAntlrParser.STRING, 0);
    }
  }, {
    key: "ruleIndex",
    get: function get() {
      return ExpressionAntlrParser.RULE_key;
    }
    // @Override
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      if (listener.enterKey) {
        listener.enterKey(this);
      }
    }
    // @Override
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      if (listener.exitKey) {
        listener.exitKey(this);
      }
    }
    // @Override
  }, {
    key: "accept",
    value: function accept(visitor) {
      if (visitor.visitKey) {
        return visitor.visitKey(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  }]);
  return KeyContext;
}(ParserRuleContext_1.ParserRuleContext);
exports.KeyContext = KeyContext;

},{"@babel/runtime/helpers/assertThisInitialized":229,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/get":234,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"antlr4ts/FailedPredicateException":276,"antlr4ts/NoViableAltException":284,"antlr4ts/Parser":285,"antlr4ts/ParserRuleContext":287,"antlr4ts/RecognitionException":290,"antlr4ts/Token":296,"antlr4ts/VocabularyImpl":298,"antlr4ts/atn/ATN":299,"antlr4ts/atn/ATNDeserializer":303,"antlr4ts/atn/ParserATNSimulator":340,"antlr4ts/misc/Utils":385,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.string.match.js":627}],208:[function(require,module,exports){
"use strict";

function __export(m) {
  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
__export(require("./ExpressionAntlrLexer"));
__export(require("./ExpressionAntlrParser"));

},{"./ExpressionAntlrLexer":206,"./ExpressionAntlrParser":207}],209:[function(require,module,exports){
"use strict";

function __export(m) {
  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
__export(require("./parseErrorListener"));
__export(require("./expressionParser"));
__export(require("./util"));
__export(require("./generated"));

},{"./expressionParser":205,"./generated":208,"./parseErrorListener":210,"./util":211}],210:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.concat.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
Object.defineProperty(exports, "__esModule", {
  value: true
});
// tslint:disable-next-line: completed-docs
/**
 * Expression parser error listener.
 */
var ParseErrorListener = /*#__PURE__*/function () {
  function ParseErrorListener() {
    (0, _classCallCheck2.default)(this, ParseErrorListener);
  }
  (0, _createClass2.default)(ParseErrorListener, [{
    key: "syntaxError",
    value:
    /**
     * Throws a syntax error based on the current context.
     *
     * @param _recognizer An Antlr4 runtime recognizer.
     * @param _offendingSymbol The token violating the lexer rules.
     * @param line The line number where the error occurred.
     * @param charPositionInLine The position of character in the line where the error occurred.
     * @param _msg The error message.
     * @param _e The `RecognitionException`.
     */
    function syntaxError(_recognizer, _offendingSymbol, line, charPositionInLine, _msg, _e) {
      var syntaxErrorMessage = 'Invalid expression format.';
      throw Error("syntax error at line ".concat(line, ":").concat(charPositionInLine, " ").concat(syntaxErrorMessage));
    }
  }]);
  return ParseErrorListener;
}();
ParseErrorListener.Instance = new ParseErrorListener();
exports.ParseErrorListener = ParseErrorListener;

},{"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"core-js/modules/es.array.concat.js":569}],211:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.regexp.constructor.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.string.trim.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
Object.defineProperty(exports, "__esModule", {
  value: true
});
/* eslint-disable security/detect-non-literal-regexp */
/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * util class
 */
var Util = /*#__PURE__*/function () {
  function Util() {
    (0, _classCallCheck2.default)(this, Util);
  }
  (0, _createClass2.default)(Util, null, [{
    key: "trim",
    value:
    /**
     * trim char.
     *
     * @param str input string.
     * @param char trim character.
     * @returns The trimmed char.
     */
    function trim(str, char) {
      if (char !== undefined) {
        return str.replace(new RegExp(''.concat('^\\', char, '+|\\', char, '+$'), 'g'), '');
      }
      return str.trim();
    }
  }]);
  return Util;
}();
exports.Util = Util;

},{"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"core-js/modules/es.regexp.constructor.js":617,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.replace.js":629,"core-js/modules/es.string.trim.js":634}],212:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Error listener for Regex.
 */
var RegexErrorListener = /*#__PURE__*/function () {
  function RegexErrorListener() {
    (0, _classCallCheck2.default)(this, RegexErrorListener);
  }
  (0, _createClass2.default)(RegexErrorListener, [{
    key: "syntaxError",
    value:
    /**
     * Upon syntax error, notify any interested parties.
     *
     * @param _recognizer What parser got the error. From this object, you can access the context as well as the input stream.
     * @param _offendingSymbol Offending token in the input token stream, unless recognizer is a lexer, then it's null.
     * @param _line Line number in the input where the error occurred.
     * @param _charPositionInLine Character position within the line where the error occurred.
     * @param _msg Message to emit.
     * @param _e Exception generated by the parser that led to the reporting of an error.
     */
    function syntaxError(_recognizer, _offendingSymbol, _line, _charPositionInLine, _msg, _e) {
      throw Error('Regular expression is invalid.');
    }
  }]);
  return RegexErrorListener;
}();
RegexErrorListener.Instance = new RegexErrorListener();
exports.RegexErrorListener = RegexErrorListener;

},{"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237}],213:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Type expected from evalating an expression.
 */
var ReturnType;
(function (ReturnType) {
  /**
   * True or false boolean value.
   */
  ReturnType[ReturnType["Boolean"] = 1] = "Boolean";
  /**
   * Numerical value like int, float, double, ...
   */
  ReturnType[ReturnType["Number"] = 2] = "Number";
  /**
   * Any value is possible.
   */
  ReturnType[ReturnType["Object"] = 4] = "Object";
  /**
   * String value.
   */
  ReturnType[ReturnType["String"] = 8] = "String";
  /**
   * Array value.
   */
  ReturnType[ReturnType["Array"] = 16] = "Array";
})(ReturnType = exports.ReturnType || (exports.ReturnType = {}));

},{}],214:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.includes.js");
require("core-js/modules/es.string.includes.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.split.js");
require("core-js/modules/es.array.concat.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.map.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Time zone converter.
 * (1) From Windows (.NET) timezone to iana timezone.
 * (2) From iana timezone to windows (.NET) timezone.
 * windows ref: https://support.microsoft.com/en-us/help/22803/daylight-saving-time.
 * iana ref: https://www.iana.org/time-zones.
 */
var TimeZoneConverter = /*#__PURE__*/function () {
  function TimeZoneConverter() {
    (0, _classCallCheck2.default)(this, TimeZoneConverter);
  }
  (0, _createClass2.default)(TimeZoneConverter, null, [{
    key: "ianaToWindows",
    value:
    /**
     * convert IANA timezone format to windows timezone format.
     *
     * @param ianaTimeZoneId IANA timezone format.
     * @returns windows timezone format.
     */
    function ianaToWindows(ianaTimeZoneId) {
      this.loadData();
      if (this.ianaToWindowsMap.has(ianaTimeZoneId)) {
        return this.ianaToWindowsMap.get(ianaTimeZoneId);
      }
      return ianaTimeZoneId;
    }
    /**
     * Convert windows timezone to iana timezone.
     *
     * @param windowsTimeZoneId Windows timezone format.
     * @returns Iana timezone format.
     */
  }, {
    key: "windowsToIana",
    value: function windowsToIana(windowsTimeZoneId) {
      this.loadData();
      if (this.windowsToIanaMap.has("001|".concat(windowsTimeZoneId))) {
        return this.windowsToIanaMap.get("001|".concat(windowsTimeZoneId));
      }
      return windowsTimeZoneId;
    }
    /**
     * Verify the string is windows timezone or iana string
     *
     * @param timezoneStr time zone string
     * @returns is the string is time zone string
     */
  }, {
    key: "verifyTimeZoneStr",
    value: function verifyTimeZoneStr(timezoneStr) {
      this.loadData();
      return this.validTimezonStr.includes(timezoneStr);
    }
    /**
     * @private
     */
  }, {
    key: "loadData",
    value: function loadData() {
      var data = this.mappingString;
      var lines = data.split(this.seperator);
      var _iterator = _createForOfIteratorHelper(lines),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var line = _step.value;
          var tokens = line.split(',');
          var windowsID = tokens[0];
          var territory = tokens[1];
          var ianaIDs = tokens[2].split(' ');
          var _iterator2 = _createForOfIteratorHelper(ianaIDs),
            _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var ianaID = _step2.value;
              if (!this.ianaToWindowsMap.has(ianaID)) {
                this.ianaToWindowsMap.set(ianaID, windowsID);
              }
              if (!this.validTimezonStr.includes(ianaID)) {
                this.validTimezonStr.push(ianaID);
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
          if (!this.windowsToIanaMap.has("".concat(territory, "|").concat(windowsID))) {
            this.windowsToIanaMap.set("".concat(territory, "|").concat(windowsID), ianaIDs[0]);
          }
          if (!this.validTimezonStr.includes(windowsID)) {
            this.validTimezonStr.push(windowsID);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }]);
  return TimeZoneConverter;
}();
TimeZoneConverter.ianaToWindowsMap = new Map();
TimeZoneConverter.windowsToIanaMap = new Map();
TimeZoneConverter.validTimezonStr = [];
TimeZoneConverter.seperator = '    ';
TimeZoneConverter.mappingString = 'AUS Central Standard Time,001,Australia/Darwin\
    AUS Central Standard Time,AU,Australia/Darwin\
    AUS Eastern Standard Time,001,Australia/Sydney\
    AUS Eastern Standard Time,AU,Australia/Sydney Australia/Melbourne\
    Afghanistan Standard Time,001,Asia/Kabul\
    Afghanistan Standard Time,AF,Asia/Kabul\
    Alaskan Standard Time,001,America/Anchorage\
    Alaskan Standard Time,US,America/Anchorage America/Juneau America/Metlakatla America/Nome America/Sitka America/Yakutat\
    Aleutian Standard Time,001,America/Adak\
    Aleutian Standard Time,US,America/Adak\
    Altai Standard Time,001,Asia/Barnaul\
    Altai Standard Time,RU,Asia/Barnaul\
    Arab Standard Time,001,Asia/Riyadh\
    Arab Standard Time,BH,Asia/Qatar\
    Arab Standard Time,KW,Asia/Riyadh\
    Arab Standard Time,QA,Asia/Qatar\
    Arab Standard Time,SA,Asia/Riyadh\
    Arab Standard Time,YE,Asia/Riyadh\
    Arabian Standard Time,001,Asia/Dubai\
    Arabian Standard Time,AE,Asia/Dubai\
    Arabian Standard Time,OM,Asia/Dubai\
    Arabian Standard Time,ZZ,Etc/GMT-4\
    Arabic Standard Time,001,Asia/Baghdad\
    Arabic Standard Time,IQ,Asia/Baghdad\
    Argentina Standard Time,001,America/Argentina/Buenos_Aires\
    Argentina Standard Time,AR,America/Argentina/Buenos_Aires America/Argentina/La_Rioja America/Argentina/Rio_Gallegos America/Argentina/Salta America/Argentina/San_Juan America/Argentina/San_Luis America/Argentina/Tucuman America/Argentina/Ushuaia America/Argentina/Catamarca America/Argentina/Cordoba America/Argentina/Jujuy America/Argentina/Mendoza\
    Astrakhan Standard Time,001,Europe/Astrakhan\
    Astrakhan Standard Time,RU,Europe/Astrakhan Europe/Ulyanovsk\
    Atlantic Standard Time,001,America/Halifax\
    Atlantic Standard Time,BM,Atlantic/Bermuda\
    Atlantic Standard Time,CA,America/Halifax America/Glace_Bay America/Goose_Bay America/Moncton\
    Atlantic Standard Time,GL,America/Thule\
    Aus Central W. Standard Time,001,Australia/Eucla\
    Aus Central W. Standard Time,AU,Australia/Eucla\
    Azerbaijan Standard Time,001,Asia/Baku\
    Azerbaijan Standard Time,AZ,Asia/Baku\
    Azores Standard Time,001,Atlantic/Azores\
    Azores Standard Time,GL,America/Scoresbysund\
    Azores Standard Time,PT,Atlantic/Azores\
    Bahia Standard Time,001,America/Bahia\
    Bahia Standard Time,BR,America/Bahia\
    Bangladesh Standard Time,001,Asia/Dhaka\
    Bangladesh Standard Time,BD,Asia/Dhaka\
    Bangladesh Standard Time,BT,Asia/Thimphu\
    Belarus Standard Time,001,Europe/Minsk\
    Belarus Standard Time,BY,Europe/Minsk\
    Bougainville Standard Time,001,Pacific/Bougainville\
    Bougainville Standard Time,PG,Pacific/Bougainville\
    Canada Central Standard Time,001,America/Regina\
    Canada Central Standard Time,CA,America/Regina America/Swift_Current\
    Cape Verde Standard Time,001,Atlantic/Cape_Verde\
    Cape Verde Standard Time,CV,Atlantic/Cape_Verde\
    Cape Verde Standard Time,ZZ,Etc/GMT+1\
    Caucasus Standard Time,001,Asia/Yerevan\
    Caucasus Standard Time,AM,Asia/Yerevan\
    Cen. Australia Standard Time,001,Australia/Adelaide\
    Cen. Australia Standard Time,AU,Australia/Adelaide Australia/Broken_Hill\
    Central America Standard Time,001,America/Guatemala\
    Central America Standard Time,BZ,America/Belize\
    Central America Standard Time,CR,America/Costa_Rica\
    Central America Standard Time,EC,Pacific/Galapagos\
    Central America Standard Time,GT,America/Guatemala\
    Central America Standard Time,HN,America/Tegucigalpa\
    Central America Standard Time,NI,America/Managua\
    Central America Standard Time,SV,America/El_Salvador\
    Central America Standard Time,ZZ,Etc/GMT+6\
    Central Asia Standard Time,001,Asia/Almaty\
    Central Asia Standard Time,AQ,Antarctica/Vostok\
    Central Asia Standard Time,CN,Asia/Urumqi\
    Central Asia Standard Time,DG,Indian/Chagos\
    Central Asia Standard Time,IO,Indian/Chagos\
    Central Asia Standard Time,KG,Asia/Bishkek\
    Central Asia Standard Time,KZ,Asia/Almaty Asia/Qyzylorda\
    Central Asia Standard Time,ZZ,Etc/GMT-6\
    Central Brazilian Standard Time,001,America/Cuiaba\
    Central Brazilian Standard Time,BR,America/Cuiaba America/Campo_Grande\
    Central Europe Standard Time,001,Europe/Budapest\
    Central Europe Standard Time,AL,Europe/Tirane\
    Central Europe Standard Time,CZ,Europe/Prague\
    Central Europe Standard Time,HU,Europe/Budapest\
    Central Europe Standard Time,ME,Europe/Belgrade\
    Central Europe Standard Time,RS,Europe/Belgrade\
    Central Europe Standard Time,SI,Europe/Belgrade\
    Central Europe Standard Time,SK,Europe/Prague\
    Central Europe Standard Time,XK,Europe/Belgrade\
    Central European Standard Time,001,Europe/Warsaw\
    Central European Standard Time,BA,Europe/Belgrade\
    Central European Standard Time,HR,Europe/Belgrade\
    Central European Standard Time,MK,Europe/Belgrade\
    Central European Standard Time,PL,Europe/Warsaw\
    Central Pacific Standard Time,001,Pacific/Guadalcanal\
    Central Pacific Standard Time,AU,Antarctica/Macquarie\
    Central Pacific Standard Time,FM,Pacific/Pohnpei Pacific/Kosrae\
    Central Pacific Standard Time,NC,Pacific/Noumea\
    Central Pacific Standard Time,SB,Pacific/Guadalcanal\
    Central Pacific Standard Time,VU,Pacific/Efate\
    Central Pacific Standard Time,ZZ,Etc/GMT-11\
    Central Standard Time (Mexico),001,America/Mexico_City\
    Central Standard Time (Mexico),MX,America/Mexico_City America/Bahia_Banderas America/Merida America/Monterrey\
    Central Standard Time,001,America/Chicago\
    Central Standard Time,CA,America/Winnipeg America/Rainy_River America/Rankin_Inlet America/Resolute\
    Central Standard Time,MX,America/Matamoros\
    Central Standard Time,US,America/Chicago America/Indiana/Knox America/Indiana/Tell_City America/Menominee America/North_Dakota/Beulah America/North_Dakota/Center America/North_Dakota/New_Salem\
    Central Standard Time,ZZ,CST6CDT\
    Chatham Islands Standard Time,001,Pacific/Chatham\
    Chatham Islands Standard Time,NZ,Pacific/Chatham\
    China Standard Time,001,Asia/Shanghai\
    China Standard Time,CN,Asia/Shanghai\
    China Standard Time,HK,Asia/Hong_Kong\
    China Standard Time,MO,Asia/Macau\
    Cuba Standard Time,001,America/Havana\
    Cuba Standard Time,CU,America/Havana\
    Dateline Standard Time,001,Etc/GMT+12\
    Dateline Standard Time,ZZ,Etc/GMT+12\
    E. Africa Standard Time,001,Africa/Nairobi\
    E. Africa Standard Time,AQ,Antarctica/Syowa\
    E. Africa Standard Time,DJ,Africa/Nairobi\
    E. Africa Standard Time,ER,Africa/Nairobi\
    E. Africa Standard Time,ET,Africa/Nairobi\
    E. Africa Standard Time,KE,Africa/Nairobi\
    E. Africa Standard Time,KM,Africa/Nairobi\
    E. Africa Standard Time,MG,Africa/Nairobi\
    E. Africa Standard Time,SO,Africa/Nairobi\
    E. Africa Standard Time,SS,Africa/Juba\
    E. Africa Standard Time,TZ,Africa/Nairobi\
    E. Africa Standard Time,UG,Africa/Nairobi\
    E. Africa Standard Time,YT,Africa/Nairobi\
    E. Africa Standard Time,ZZ,Etc/GMT-3\
    E. Australia Standard Time,001,Australia/Brisbane\
    E. Australia Standard Time,AU,Australia/Brisbane Australia/Lindeman\
    E. Europe Standard Time,001,Europe/Chisinau\
    E. Europe Standard Time,MD,Europe/Chisinau\
    E. South America Standard Time,001,America/Sao_Paulo\
    E. South America Standard Time,BR,America/Sao_Paulo\
    Easter Island Standard Time,001,Pacific/Easter\
    Easter Island Standard Time,CL,Pacific/Easter\
    Eastern Standard Time (Mexico),001,America/Cancun\
    Eastern Standard Time (Mexico),MX,America/Cancun\
    Eastern Standard Time,001,America/New_York\
    Eastern Standard Time,BS,America/Nassau\
    Eastern Standard Time,CA,America/Toronto America/Iqaluit America/Nipigon America/Pangnirtung America/Thunder_Bay\
    Eastern Standard Time,US,America/New_York America/Detroit America/Indiana/Petersburg America/Indiana/Vincennes America/Indiana/Winamac America/Kentucky/Monticello America/Kentucky/Louisville\
    Eastern Standard Time,ZZ,EST5EDT\
    Egypt Standard Time,001,Africa/Cairo\
    Egypt Standard Time,EG,Africa/Cairo\
    Ekaterinburg Standard Time,001,Asia/Yekaterinburg\
    Ekaterinburg Standard Time,RU,Asia/Yekaterinburg\
    FLE Standard Time,001,Europe/Kiev\
    FLE Standard Time,AX,Europe/Helsinki\
    FLE Standard Time,BG,Europe/Sofia\
    FLE Standard Time,EE,Europe/Tallinn\
    FLE Standard Time,FI,Europe/Helsinki\
    FLE Standard Time,LT,Europe/Vilnius\
    FLE Standard Time,LV,Europe/Riga\
    FLE Standard Time,UA,Europe/Kiev Europe/Uzhgorod Europe/Zaporozhye\
    Fiji Standard Time,001,Pacific/Fiji\
    Fiji Standard Time,FJ,Pacific/Fiji\
    GMT Standard Time,001,Europe/London\
    GMT Standard Time,ES,Atlantic/Canary\
    GMT Standard Time,FO,Atlantic/Faroe\
    GMT Standard Time,GB,Europe/London\
    GMT Standard Time,GG,Europe/London\
    GMT Standard Time,IC,Atlantic/Canary\
    GMT Standard Time,IE,Europe/Dublin\
    GMT Standard Time,IM,Europe/London\
    GMT Standard Time,JE,Europe/London\
    GMT Standard Time,PT,Europe/Lisbon Atlantic/Madeira\
    GTB Standard Time,001,Europe/Bucharest\
    GTB Standard Time,CY,Asia/Nicosia Asia/Famagusta\
    GTB Standard Time,GR,Europe/Athens\
    GTB Standard Time,RO,Europe/Bucharest\
    Georgian Standard Time,001,Asia/Tbilisi\
    Georgian Standard Time,GE,Asia/Tbilisi\
    Greenland Standard Time,001,America/Godthab\
    Greenland Standard Time,GL,America/Godthab\
    Greenwich Standard Time,001,Atlantic/Reykjavik\
    Greenwich Standard Time,AC,Atlantic/St_Helena\
    Greenwich Standard Time,BF,Africa/Abidjan\
    Greenwich Standard Time,CI,Africa/Abidjan\
    Greenwich Standard Time,GH,Africa/Accra\
    Greenwich Standard Time,GM,Africa/Abidjan\
    Greenwich Standard Time,GN,Africa/Abidjan\
    Greenwich Standard Time,GW,Africa/Bissau\
    Greenwich Standard Time,IS,Atlantic/Reykjavik\
    Greenwich Standard Time,LR,Africa/Monrovia\
    Greenwich Standard Time,ML,Africa/Abidjan\
    Greenwich Standard Time,MR,Africa/Abidjan\
    Greenwich Standard Time,SH,Africa/Abidjan\
    Greenwich Standard Time,SL,Africa/Abidjan\
    Greenwich Standard Time,SN,Africa/Abidjan\
    Greenwich Standard Time,TA,Atlantic/St_Helena\
    Greenwich Standard Time,TG,Africa/Abidjan\
    Haiti Standard Time,001,America/Port-au-Prince\
    Haiti Standard Time,HT,America/Port-au-Prince\
    Hawaiian Standard Time,001,Pacific/Honolulu\
    Hawaiian Standard Time,CK,Pacific/Rarotonga\
    Hawaiian Standard Time,PF,Pacific/Tahiti\
    Hawaiian Standard Time,UM,Pacific/Honolulu\
    Hawaiian Standard Time,US,Pacific/Honolulu\
    Hawaiian Standard Time,ZZ,Etc/GMT+10\
    India Standard Time,001,Asia/Kolkata\
    India Standard Time,IN,Asia/Kolkata\
    Iran Standard Time,001,Asia/Tehran\
    Iran Standard Time,IR,Asia/Tehran\
    Israel Standard Time,001,Asia/Jerusalem\
    Israel Standard Time,IL,Asia/Jerusalem\
    Jordan Standard Time,001,Asia/Amman\
    Jordan Standard Time,JO,Asia/Amman\
    Kaliningrad Standard Time,001,Europe/Kaliningrad\
    Kaliningrad Standard Time,RU,Europe/Kaliningrad\
    Kamchatka Standard Time,001,Asia/Kamchatka\
    Korea Standard Time,001,Asia/Seoul\
    Korea Standard Time,KR,Asia/Seoul\
    Libya Standard Time,001,Africa/Tripoli\
    Libya Standard Time,LY,Africa/Tripoli\
    Line Islands Standard Time,001,Pacific/Kiritimati\
    Line Islands Standard Time,KI,Pacific/Kiritimati\
    Line Islands Standard Time,ZZ,Etc/GMT-14\
    Lord Howe Standard Time,001,Australia/Lord_Howe\
    Lord Howe Standard Time,AU,Australia/Lord_Howe\
    Magadan Standard Time,001,Asia/Magadan\
    Magadan Standard Time,RU,Asia/Magadan\
    Magallanes Standard Time,001,America/Punta_Arenas\
    Magallanes Standard Time,AQ,Antarctica/Palmer\
    Magallanes Standard Time,CL,America/Punta_Arenas\
    Marquesas Standard Time,001,Pacific/Marquesas\
    Marquesas Standard Time,PF,Pacific/Marquesas\
    Mauritius Standard Time,001,Indian/Mauritius\
    Mauritius Standard Time,MU,Indian/Mauritius\
    Mauritius Standard Time,RE,Indian/Reunion\
    Mauritius Standard Time,SC,Indian/Mahe\
    Mid-Atlantic Standard Time,001,Etc/GMT+2\
    Middle East Standard Time,001,Asia/Beirut\
    Middle East Standard Time,LB,Asia/Beirut\
    Montevideo Standard Time,001,America/Montevideo\
    Montevideo Standard Time,UY,America/Montevideo\
    Morocco Standard Time,001,Africa/Casablanca\
    Morocco Standard Time,EH,Africa/El_Aaiun\
    Morocco Standard Time,MA,Africa/Casablanca\
    Mountain Standard Time (Mexico),001,America/Chihuahua\
    Mountain Standard Time (Mexico),MX,America/Chihuahua America/Mazatlan\
    Mountain Standard Time,001,America/Denver\
    Mountain Standard Time,CA,America/Edmonton America/Cambridge_Bay America/Inuvik America/Yellowknife\
    Mountain Standard Time,MX,America/Ojinaga\
    Mountain Standard Time,US,America/Denver America/Boise\
    Mountain Standard Time,ZZ,MST7MDT\
    Myanmar Standard Time,001,Asia/Yangon\
    Myanmar Standard Time,CC,Indian/Cocos\
    Myanmar Standard Time,MM,Asia/Yangon\
    N. Central Asia Standard Time,001,Asia/Novosibirsk\
    N. Central Asia Standard Time,RU,Asia/Novosibirsk\
    Namibia Standard Time,001,Africa/Windhoek\
    Namibia Standard Time,NA,Africa/Windhoek\
    Nepal Standard Time,001,Asia/Kathmandu\
    Nepal Standard Time,NP,Asia/Kathmandu\
    New Zealand Standard Time,001,Pacific/Auckland\
    New Zealand Standard Time,AQ,Pacific/Auckland\
    New Zealand Standard Time,NZ,Pacific/Auckland\
    Newfoundland Standard Time,001,America/St_Johns\
    Newfoundland Standard Time,CA,America/St_Johns\
    Norfolk Standard Time,001,Pacific/Norfolk\
    Norfolk Standard Time,NF,Pacific/Norfolk\
    North Asia East Standard Time,001,Asia/Irkutsk\
    North Asia East Standard Time,RU,Asia/Irkutsk\
    North Asia Standard Time,001,Asia/Krasnoyarsk\
    North Asia Standard Time,RU,Asia/Krasnoyarsk Asia/Novokuznetsk\
    North Korea Standard Time,001,Asia/Pyongyang\
    North Korea Standard Time,KP,Asia/Pyongyang\
    Omsk Standard Time,001,Asia/Omsk\
    Omsk Standard Time,RU,Asia/Omsk\
    Pacific SA Standard Time,001,America/Santiago\
    Pacific SA Standard Time,CL,America/Santiago\
    Pacific Standard Time (Mexico),001,America/Tijuana\
    Pacific Standard Time (Mexico),MX,America/Tijuana\
    Pacific Standard Time,001,America/Los_Angeles\
    Pacific Standard Time,CA,America/Vancouver America/Dawson America/Whitehorse\
    Pacific Standard Time,US,America/Los_Angeles\
    Pacific Standard Time,ZZ,PST8PDT\
    Pakistan Standard Time,001,Asia/Karachi\
    Pakistan Standard Time,PK,Asia/Karachi\
    Paraguay Standard Time,001,America/Asuncion\
    Paraguay Standard Time,PY,America/Asuncion\
    Romance Standard Time,001,Europe/Paris\
    Romance Standard Time,BE,Europe/Brussels\
    Romance Standard Time,DK,Europe/Copenhagen\
    Romance Standard Time,EA,Africa/Ceuta\
    Romance Standard Time,ES,Europe/Madrid Africa/Ceuta\
    Romance Standard Time,FR,Europe/Paris\
    Russia Time Zone 10,001,Asia/Srednekolymsk\
    Russia Time Zone 10,RU,Asia/Srednekolymsk\
    Russia Time Zone 11,001,Asia/Kamchatka\
    Russia Time Zone 11,RU,Asia/Kamchatka Asia/Anadyr\
    Russia Time Zone 3,001,Europe/Samara\
    Russia Time Zone 3,RU,Europe/Samara\
    Russian Standard Time,001,Europe/Moscow\
    Russian Standard Time,RU,Europe/Moscow Europe/Kirov Europe/Volgograd\
    Russian Standard Time,UA,Europe/Simferopol\
    SA Eastern Standard Time,001,America/Cayenne\
    SA Eastern Standard Time,AQ,Antarctica/Rothera\
    SA Eastern Standard Time,BR,America/Fortaleza America/Belem America/Maceio America/Recife America/Santarem\
    SA Eastern Standard Time,FK,Atlantic/Stanley\
    SA Eastern Standard Time,GF,America/Cayenne\
    SA Eastern Standard Time,SR,America/Paramaribo\
    SA Eastern Standard Time,ZZ,Etc/GMT+3\
    SA Pacific Standard Time,001,America/Bogota\
    SA Pacific Standard Time,BR,America/Rio_Branco America/Eirunepe\
    SA Pacific Standard Time,CA,America/Atikokan\
    SA Pacific Standard Time,CO,America/Bogota\
    SA Pacific Standard Time,EC,America/Guayaquil\
    SA Pacific Standard Time,JM,America/Jamaica\
    SA Pacific Standard Time,KY,America/Panama\
    SA Pacific Standard Time,PA,America/Panama\
    SA Pacific Standard Time,PE,America/Lima\
    SA Pacific Standard Time,ZZ,Etc/GMT+5\
    SA Western Standard Time,001,America/La_Paz\
    SA Western Standard Time,AG,America/Port_of_Spain\
    SA Western Standard Time,AI,America/Port_of_Spain\
    SA Western Standard Time,AW,America/Curacao\
    SA Western Standard Time,BB,America/Barbados\
    SA Western Standard Time,BL,America/Port_of_Spain\
    SA Western Standard Time,BO,America/La_Paz\
    SA Western Standard Time,BQ,America/Curacao\
    SA Western Standard Time,BR,America/Manaus America/Boa_Vista America/Porto_Velho\
    SA Western Standard Time,CA,America/Blanc-Sablon\
    SA Western Standard Time,CW,America/Curacao\
    SA Western Standard Time,DM,America/Port_of_Spain\
    SA Western Standard Time,DO,America/Santo_Domingo\
    SA Western Standard Time,GD,America/Port_of_Spain\
    SA Western Standard Time,GP,America/Port_of_Spain\
    SA Western Standard Time,GY,America/Guyana\
    SA Western Standard Time,KN,America/Port_of_Spain\
    SA Western Standard Time,LC,America/Port_of_Spain\
    SA Western Standard Time,MF,America/Port_of_Spain\
    SA Western Standard Time,MQ,America/Martinique\
    SA Western Standard Time,MS,America/Port_of_Spain\
    SA Western Standard Time,PR,America/Puerto_Rico\
    SA Western Standard Time,SX,America/Curacao\
    SA Western Standard Time,TT,America/Port_of_Spain\
    SA Western Standard Time,VC,America/Port_of_Spain\
    SA Western Standard Time,VG,America/Port_of_Spain\
    SA Western Standard Time,VI,America/Port_of_Spain\
    SA Western Standard Time,ZZ,Etc/GMT+4\
    SE Asia Standard Time,001,Asia/Bangkok\
    SE Asia Standard Time,AQ,Antarctica/Davis\
    SE Asia Standard Time,CX,Indian/Christmas\
    SE Asia Standard Time,ID,Asia/Jakarta Asia/Pontianak\
    SE Asia Standard Time,KH,Asia/Bangkok\
    SE Asia Standard Time,LA,Asia/Bangkok\
    SE Asia Standard Time,TH,Asia/Bangkok\
    SE Asia Standard Time,VN,Asia/Ho_Chi_Minh\
    SE Asia Standard Time,ZZ,Etc/GMT-7\
    Saint Pierre Standard Time,001,America/Miquelon\
    Saint Pierre Standard Time,PM,America/Miquelon\
    Sakhalin Standard Time,001,Asia/Sakhalin\
    Sakhalin Standard Time,RU,Asia/Sakhalin\
    Samoa Standard Time,001,Pacific/Apia\
    Samoa Standard Time,WS,Pacific/Apia\
    Sao Tome Standard Time,001,Africa/Sao_Tome\
    Sao Tome Standard Time,ST,Africa/Sao_Tome\
    Saratov Standard Time,001,Europe/Saratov\
    Saratov Standard Time,RU,Europe/Saratov\
    Singapore Standard Time,001,Asia/Singapore\
    Singapore Standard Time,BN,Asia/Brunei\
    Singapore Standard Time,ID,Asia/Makassar\
    Singapore Standard Time,MY,Asia/Kuala_Lumpur Asia/Kuching\
    Singapore Standard Time,PH,Asia/Manila\
    Singapore Standard Time,SG,Asia/Singapore\
    Singapore Standard Time,ZZ,Etc/GMT-8\
    South Africa Standard Time,001,Africa/Johannesburg\
    South Africa Standard Time,BI,Africa/Maputo\
    South Africa Standard Time,BW,Africa/Maputo\
    South Africa Standard Time,CD,Africa/Maputo\
    South Africa Standard Time,LS,Africa/Johannesburg\
    South Africa Standard Time,MW,Africa/Maputo\
    South Africa Standard Time,MZ,Africa/Maputo\
    South Africa Standard Time,RW,Africa/Maputo\
    South Africa Standard Time,SZ,Africa/Johannesburg\
    South Africa Standard Time,ZA,Africa/Johannesburg\
    South Africa Standard Time,ZM,Africa/Maputo\
    South Africa Standard Time,ZW,Africa/Maputo\
    South Africa Standard Time,ZZ,Etc/GMT-2\
    Sri Lanka Standard Time,001,Asia/Colombo\
    Sri Lanka Standard Time,LK,Asia/Colombo\
    Sudan Standard Time,001,Africa/Khartoum\
    Sudan Standard Time,SD,Africa/Khartoum\
    Syria Standard Time,001,Asia/Damascus\
    Syria Standard Time,SY,Asia/Damascus\
    Taipei Standard Time,001,Asia/Taipei\
    Taipei Standard Time,TW,Asia/Taipei\
    Tasmania Standard Time,001,Australia/Hobart\
    Tasmania Standard Time,AU,Australia/Hobart Australia/Currie\
    Tocantins Standard Time,001,America/Araguaina\
    Tocantins Standard Time,BR,America/Araguaina\
    Tokyo Standard Time,001,Asia/Tokyo\
    Tokyo Standard Time,ID,Asia/Jayapura\
    Tokyo Standard Time,JP,Asia/Tokyo\
    Tokyo Standard Time,PW,Pacific/Palau\
    Tokyo Standard Time,TL,Asia/Dili\
    Tokyo Standard Time,ZZ,Etc/GMT-9\
    Tomsk Standard Time,001,Asia/Tomsk\
    Tomsk Standard Time,RU,Asia/Tomsk\
    Tonga Standard Time,001,Pacific/Tongatapu\
    Tonga Standard Time,TO,Pacific/Tongatapu\
    Transbaikal Standard Time,001,Asia/Chita\
    Transbaikal Standard Time,RU,Asia/Chita\
    Turkey Standard Time,001,Europe/Istanbul\
    Turkey Standard Time,TR,Europe/Istanbul\
    Turks And Caicos Standard Time,001,America/Grand_Turk\
    Turks And Caicos Standard Time,TC,America/Grand_Turk\
    US Eastern Standard Time,001,America/Indiana/Indianapolis\
    US Eastern Standard Time,US,America/Indiana/Indianapolis America/Indiana/Marengo America/Indiana/Vevay\
    US Mountain Standard Time,001,America/Phoenix\
    US Mountain Standard Time,CA,America/Dawson_Creek America/Creston America/Fort_Nelson\
    US Mountain Standard Time,MX,America/Hermosillo\
    US Mountain Standard Time,US,America/Phoenix\
    US Mountain Standard Time,ZZ,Etc/GMT+7\
    UTC+12,001,Etc/GMT-12\
    UTC+12,KI,Pacific/Tarawa\
    UTC+12,MH,Pacific/Majuro Pacific/Kwajalein\
    UTC+12,NR,Pacific/Nauru\
    UTC+12,TV,Pacific/Funafuti\
    UTC+12,UM,Pacific/Wake\
    UTC+12,WF,Pacific/Wallis\
    UTC+12,ZZ,Etc/GMT-12\
    UTC+13,001,Etc/GMT-13\
    UTC+13,KI,Pacific/Enderbury\
    UTC+13,TK,Pacific/Fakaofo\
    UTC+13,ZZ,Etc/GMT-13\
    UTC,001,Etc/UTC\
    UTC,GL,America/Danmarkshavn\
    UTC,ZZ,Etc/UTC\
    UTC-02,001,Etc/GMT+2\
    UTC-02,BR,America/Noronha\
    UTC-02,GS,Atlantic/South_Georgia\
    UTC-02,ZZ,Etc/GMT+2\
    UTC-08,001,Etc/GMT+8\
    UTC-08,PN,Pacific/Pitcairn\
    UTC-08,ZZ,Etc/GMT+8\
    UTC-09,001,Etc/GMT+9\
    UTC-09,PF,Pacific/Gambier\
    UTC-09,ZZ,Etc/GMT+9\
    UTC-11,001,Etc/GMT+11\
    UTC-11,AS,Pacific/Pago_Pago\
    UTC-11,NU,Pacific/Niue\
    UTC-11,UM,Pacific/Pago_Pago\
    UTC-11,ZZ,Etc/GMT+11\
    Ulaanbaatar Standard Time,001,Asia/Ulaanbaatar\
    Ulaanbaatar Standard Time,MN,Asia/Ulaanbaatar Asia/Choibalsan\
    Venezuela Standard Time,001,America/Caracas\
    Venezuela Standard Time,VE,America/Caracas\
    Vladivostok Standard Time,001,Asia/Vladivostok\
    Vladivostok Standard Time,RU,Asia/Vladivostok Asia/Ust-Nera\
    W. Australia Standard Time,001,Australia/Perth\
    W. Australia Standard Time,AQ,Antarctica/Casey\
    W. Australia Standard Time,AU,Australia/Perth\
    W. Central Africa Standard Time,001,Africa/Lagos\
    W. Central Africa Standard Time,AO,Africa/Lagos\
    W. Central Africa Standard Time,BJ,Africa/Lagos\
    W. Central Africa Standard Time,CD,Africa/Lagos\
    W. Central Africa Standard Time,CF,Africa/Lagos\
    W. Central Africa Standard Time,CG,Africa/Lagos\
    W. Central Africa Standard Time,CM,Africa/Lagos\
    W. Central Africa Standard Time,DZ,Africa/Algiers\
    W. Central Africa Standard Time,GA,Africa/Lagos\
    W. Central Africa Standard Time,GQ,Africa/Lagos\
    W. Central Africa Standard Time,NE,Africa/Lagos\
    W. Central Africa Standard Time,NG,Africa/Lagos\
    W. Central Africa Standard Time,TD,Africa/Ndjamena\
    W. Central Africa Standard Time,TN,Africa/Tunis\
    W. Central Africa Standard Time,ZZ,Etc/GMT-1\
    W. Europe Standard Time,001,Europe/Berlin\
    W. Europe Standard Time,AD,Europe/Andorra\
    W. Europe Standard Time,AT,Europe/Vienna\
    W. Europe Standard Time,CH,Europe/Zurich\
    W. Europe Standard Time,DE,Europe/Berlin Europe/Zurich\
    W. Europe Standard Time,GI,Europe/Gibraltar\
    W. Europe Standard Time,IT,Europe/Rome\
    W. Europe Standard Time,LI,Europe/Zurich\
    W. Europe Standard Time,LU,Europe/Luxembourg\
    W. Europe Standard Time,MC,Europe/Monaco\
    W. Europe Standard Time,MT,Europe/Malta\
    W. Europe Standard Time,NL,Europe/Amsterdam\
    W. Europe Standard Time,NO,Europe/Oslo\
    W. Europe Standard Time,SE,Europe/Stockholm\
    W. Europe Standard Time,SJ,Europe/Oslo\
    W. Europe Standard Time,SM,Europe/Rome\
    W. Europe Standard Time,VA,Europe/Rome\
    W. Mongolia Standard Time,001,Asia/Hovd\
    W. Mongolia Standard Time,MN,Asia/Hovd\
    West Asia Standard Time,001,Asia/Tashkent\
    West Asia Standard Time,AQ,Antarctica/Mawson\
    West Asia Standard Time,KZ,Asia/Oral Asia/Aqtau Asia/Aqtobe Asia/Atyrau\
    West Asia Standard Time,MV,Indian/Maldives\
    West Asia Standard Time,TF,Indian/Kerguelen\
    West Asia Standard Time,TJ,Asia/Dushanbe\
    West Asia Standard Time,TM,Asia/Ashgabat\
    West Asia Standard Time,UZ,Asia/Tashkent Asia/Samarkand\
    West Asia Standard Time,ZZ,Etc/GMT-5\
    West Bank Standard Time,001,Asia/Hebron\
    West Bank Standard Time,PS,Asia/Hebron Asia/Gaza\
    West Pacific Standard Time,001,Pacific/Port_Moresby\
    West Pacific Standard Time,AQ,Antarctica/DumontDUrville\
    West Pacific Standard Time,FM,Pacific/Chuuk\
    West Pacific Standard Time,GU,Pacific/Guam\
    West Pacific Standard Time,MP,Pacific/Guam\
    West Pacific Standard Time,PG,Pacific/Port_Moresby\
    West Pacific Standard Time,ZZ,Etc/GMT-10\
    Yakutsk Standard Time,001,Asia/Yakutsk\
    Yakutsk Standard Time,RU,Asia/Yakutsk Asia/Khandyga';
exports.TimeZoneConverter = TimeZoneConverter;

},{"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.includes.js":576,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.map.js":587,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.includes.js":625,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.string.split.js":631,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],215:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.reflect.construct.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.map.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.string.repeat.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/web.dom-collections.for-each.js");
require("core-js/modules/es.array.concat.js");
require("core-js/modules/es.array.join.js");
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expression_1 = require("../expression");
var expressionType_1 = require("../expressionType");
var relationshipType_1 = require("./relationshipType");
/**
 * A canonical normal form expression.
 */
var Clause = /*#__PURE__*/function (_expression_1$Express) {
  (0, _inherits2.default)(Clause, _expression_1$Express);
  var _super = _createSuper(Clause);
  /**
   * Initializes a new instance of the `Clause` class.
   *
   * @param clauseOrExpression A clause, expression or an array of expressions to initialize a `Clause`.
   */
  function Clause(clauseOrExpression) {
    var _this;
    (0, _classCallCheck2.default)(this, Clause);
    _this = _super.call(this, expressionType_1.ExpressionType.And, undefined);
    /**
     * Gets or sets the anyBinding dictionary.
     */
    _this.anyBindings = new Map();
    /**
     * Gets or sets whether the clause is subsumed.
     */
    _this.subsumed = false;
    if (clauseOrExpression) {
      if (Array.isArray(clauseOrExpression)) {
        var children = clauseOrExpression;
        _this.children = children;
      } else if (clauseOrExpression instanceof Clause) {
        var fromClause = clauseOrExpression;
        _this.children = (0, _toConsumableArray2.default)(fromClause.children);
        var _iterator = _createForOfIteratorHelper(fromClause.anyBindings.entries()),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _step$value = (0, _slicedToArray2.default)(_step.value, 2),
              key = _step$value[0],
              value = _step$value[1];
            _this.anyBindings.set(key, value);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      } else if (clauseOrExpression instanceof expression_1.Expression) {
        var expression = clauseOrExpression;
        _this.children.push(expression);
      }
    }
    return _this;
  }
  /**
   * Gets a string that represents the current clause.
   *
   * @param builder An array of string to build the string of clause.
   * @param indent An integer represents the number of spaces at the start of a line.
   * @returns A string that represents the current clause.
   */
  (0, _createClass2.default)(Clause, [{
    key: "toString",
    value: function toString() {
      var builder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      builder.push(' '.repeat(indent));
      if (this.subsumed) {
        builder.push('*');
      }
      builder.push('(');
      var first = true;
      var _iterator2 = _createForOfIteratorHelper(this.children),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var child = _step2.value;
          if (first) {
            first = false;
          } else {
            builder.push(' && ');
          }
          builder.push(child.toString());
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      builder.push(')');
      if (this._ignored) {
        builder.push(' ignored(');
        builder.push(this._ignored.toString());
        builder.push(')');
      }
      this.anyBindings.forEach(function (value, key) {
        builder.push(" ".concat(key, "->").concat(value));
      });
      return builder.join('');
    }
    /**
     * Compares the current `Clause` with another `Clause`.
     *
     * @param other The other `Clause` to compare.
     * @param comparers A comparer, which is a dictionary of `PredicateComparer` with string keys.
     * @returns A `RelationshipType` value between two `Clause` instances.
     */
  }, {
    key: "relationship",
    value: function relationship(other, comparers) {
      var soFar = relationshipType_1.RelationshipType.incomparable;
      var shorter = this;
      var shorterCount = shorter.children.length;
      var longer = other;
      var longerCount = longer.children.length;
      var swapped = false;
      if (longerCount < shorterCount) {
        longer = this;
        shorter = other;
        var tmp = longerCount;
        longerCount = shorterCount;
        shorterCount = tmp;
        swapped = true;
      }
      if (shorterCount === 0) {
        if (longerCount === 0) {
          soFar = relationshipType_1.RelationshipType.equal;
        } else {
          soFar = relationshipType_1.RelationshipType.generalizes;
        }
      } else {
        // If every one of shorter predicates is equal or superset of one in longer, then shorter is a superset of longer
        var _iterator3 = _createForOfIteratorHelper(shorter.children),
          _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var shortPredicate = _step3.value;
            var shorterRel = relationshipType_1.RelationshipType.incomparable;
            var _iterator4 = _createForOfIteratorHelper(longer.children),
              _step4;
            try {
              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                var longPredicate = _step4.value;
                shorterRel = this._relationship(shortPredicate, longPredicate, comparers);
                if (shorterRel !== relationshipType_1.RelationshipType.incomparable) {
                  // Found related predicates
                  break;
                }
              }
            } catch (err) {
              _iterator4.e(err);
            } finally {
              _iterator4.f();
            }
            if (shorterRel === relationshipType_1.RelationshipType.incomparable) {
              // Predicate in shorter is incomparable so done
              soFar = relationshipType_1.RelationshipType.incomparable;
              break;
            } else {
              if (soFar === relationshipType_1.RelationshipType.incomparable) {
                soFar = shorterRel;
              }
              if (soFar === relationshipType_1.RelationshipType.equal) {
                if (shorterRel === relationshipType_1.RelationshipType.generalizes || shorterRel === relationshipType_1.RelationshipType.specializes && shorterCount === longerCount || shorterRel === relationshipType_1.RelationshipType.equal) {
                  soFar = shorterRel;
                } else {
                  break;
                }
              } else if (soFar != shorterRel) {
                // Not continued with sub/super so incomparable
                break;
              }
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        if (shorterCount !== longerCount) {
          switch (soFar) {
            case relationshipType_1.RelationshipType.equal:
            case relationshipType_1.RelationshipType.generalizes:
              soFar = relationshipType_1.RelationshipType.generalizes;
              break;
            default:
              soFar = relationshipType_1.RelationshipType.incomparable;
              break;
          }
        }
        soFar = this._bindingRelationship(soFar, shorter, longer);
      }
      return this._swap(soFar, swapped);
    }
    /**
     * Determines whether the current `Clause` matches with another `Clause`.
     *
     * @param clause The other `Clause` instance to compare with.
     * @param memory The scope for looking up variables.
     * @returns A boolean value indicating whether the two clauses are matches.
     */
  }, {
    key: "matches",
    value: function matches(clause, memory) {
      var matched = false;
      if (clause.deepEquals(this)) {
        matched = true;
        if (this._ignored) {
          var _this$_ignored$tryEva = this._ignored.tryEvaluate(memory),
            match = _this$_ignored$tryEva.value,
            error = _this$_ignored$tryEva.error;
          matched = !error && match;
        }
      }
      return matched;
    }
    /**
     * Splits ignored child expressions.
     */
  }, {
    key: "splitIgnores",
    value: function splitIgnores() {
      var children = [];
      var ignores = [];
      for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i];
        if (child.type === expressionType_1.ExpressionType.Ignore) {
          ignores.push(child);
        } else {
          children.push(child);
        }
      }
      this.children = children;
      if (ignores.length > 0) {
        var _expression_1$Express2;
        this._ignored = (_expression_1$Express2 = expression_1.Expression).andExpression.apply(_expression_1$Express2, ignores);
      }
    }
  }, {
    key: "_bindingRelationship",
    value: function _bindingRelationship(soFar, shorterClause, longerClause) {
      if (soFar === relationshipType_1.RelationshipType.equal) {
        var swapped = false;
        var shorter = shorterClause.anyBindings;
        var longer = longerClause.anyBindings;
        if (shorterClause.anyBindings.size > longerClause.anyBindings.size) {
          shorter = longerClause.anyBindings;
          longer = shorterClause.anyBindings;
          swapped = true;
        }
        var _iterator5 = _createForOfIteratorHelper(shorter.entries()),
          _step5;
        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var _step5$value = (0, _slicedToArray2.default)(_step5.value, 2),
              shorterKey = _step5$value[0],
              shorterValue = _step5$value[1];
            var found = false;
            var _iterator6 = _createForOfIteratorHelper(longer.entries()),
              _step6;
            try {
              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                var _step6$value = (0, _slicedToArray2.default)(_step6.value, 2),
                  longerKey = _step6$value[0],
                  longerValue = _step6$value[1];
                if (shorterKey === longerKey && shorterValue === longerValue) {
                  found = true;
                  break;
                }
              }
            } catch (err) {
              _iterator6.e(err);
            } finally {
              _iterator6.f();
            }
            if (!found) {
              soFar = relationshipType_1.RelationshipType.incomparable;
            }
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
        if (soFar === relationshipType_1.RelationshipType.equal && shorter.size < longer.size) {
          soFar = relationshipType_1.RelationshipType.specializes;
        }
        soFar = this._swap(soFar, swapped);
      }
      return soFar;
    }
  }, {
    key: "_swap",
    value: function _swap(soFar, swapped) {
      var reln = soFar;
      if (swapped) {
        switch (soFar) {
          case relationshipType_1.RelationshipType.specializes:
            reln = relationshipType_1.RelationshipType.generalizes;
            break;
          case relationshipType_1.RelationshipType.generalizes:
            reln = relationshipType_1.RelationshipType.specializes;
            break;
        }
      }
      return reln;
    }
  }, {
    key: "_relationship",
    value: function _relationship(expr, other, comparers) {
      var relationship = relationshipType_1.RelationshipType.incomparable;
      var root = expr;
      var rootOther = other;
      if (expr.type === expressionType_1.ExpressionType.Not && other.type === expressionType_1.ExpressionType.Not) {
        root = expr.children[0];
        rootOther = other.children[0];
      }
      var comparer;
      if (root.type === other.type) {
        comparer = comparers[root.type];
      }
      if (comparer) {
        relationship = comparer.relationship(root, rootOther);
      } else {
        relationship = expr.deepEquals(other) ? relationshipType_1.RelationshipType.equal : relationshipType_1.RelationshipType.incomparable;
      }
      return relationship;
    }
  }]);
  return Clause;
}(expression_1.Expression);
exports.Clause = Clause;

},{"../expression":179,"../expressionType":192,"./relationshipType":219,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/slicedToArray":247,"@babel/runtime/helpers/toConsumableArray":249,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.join.js":578,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.map.js":587,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.string.repeat.js":628,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.for-each.js":676,"core-js/modules/web.dom-collections.iterator.js":677}],216:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
function __export(m) {
  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", {
  value: true
});
__export(require("./clause"));
__export(require("./node"));
__export(require("./quantifier"));
__export(require("./relationshipType"));
__export(require("./trigger"));
__export(require("./triggerTree"));

},{"./clause":215,"./node":217,"./quantifier":218,"./relationshipType":219,"./trigger":220,"./triggerTree":221}],217:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.set.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.map.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.array.find.js");
require("core-js/modules/es.array.splice.js");
require("core-js/modules/es.array.find-index.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var clause_1 = require("./clause");
var relationshipType_1 = require("./relationshipType");
var Operation;
(function (Operation) {
  Operation["none"] = "none";
  Operation["found"] = "found";
  Operation["added"] = "added";
  Operation["removed"] = "removed";
  Operation["inserted"] = "inserted";
})(Operation || (Operation = {}));
/**
 * Node in a trigger tree.
 */
var Node = /*#__PURE__*/function () {
  /**
   * Intializes a new instance of the `Node` class.
   *
   * @param clause The logical conjunction this node represents.
   * @param tree The trigger tree this node is found in.
   * @param trigger The trigger to initialize this node.
   */
  function Node(clause, tree, trigger) {
    (0, _classCallCheck2.default)(this, Node);
    this._allTriggers = [];
    this._triggers = [];
    this._specializations = [];
    this.clause = new clause_1.Clause(clause);
    this.tree = tree;
    if (trigger) {
      this._allTriggers.push(trigger);
      this._triggers.push(trigger);
    }
  }
  /**
   * Gets all of the most specific triggers that contains the `Clause` in this node.
   *
   * @returns All of the most specific triggers that contains the `Clause` in this node.
   */
  (0, _createClass2.default)(Node, [{
    key: "triggers",
    get: function get() {
      return this._triggers;
    }
    /**
     * Gets all triggers that contain the `Clause` in this node.
     *
     * @returns All triggers that contain the `Clause` in this node.
     */
  }, {
    key: "allTriggers",
    get: function get() {
      return this._allTriggers;
    }
    /**
     * Gets specialized children of this node.
     *
     * @returns Specialized children of this node.
     */
  }, {
    key: "specializations",
    get: function get() {
      return this._specializations;
    }
    /**
     * Gets a string that represents the current node.
     *
     * @param builder An array of string to build the string of node.
     * @param indent An integer representing the number of spaces at the start of a line.
     * @returns A string that represents the current node.
     */
  }, {
    key: "toString",
    value: function toString() {
      var builder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.clause.toString(builder, indent);
    }
    /**
     * Identify the relationship between two nodes.
     *
     * @param other Node to compare against.
     * @returns Relationship between this node an the other.
     */
  }, {
    key: "relationship",
    value: function relationship(other) {
      return this.clause.relationship(other.clause, this.tree.comparers);
    }
    /**
     * Gets the most specific matches below this node.
     *
     * @param state Frame to evaluate against.
     * @returns List of the most specific matches found.
     */
  }, {
    key: "matches",
    value: function matches(state) {
      var matches = new Set();
      this._matches(state, matches, new Map());
      return Array.from(matches);
    }
    /**
     * Adds a child node.
     *
     * @param triggerNode The node to be added.
     * @returns Whether adding node operation is successful.
     */
  }, {
    key: "addNode",
    value: function addNode(triggerNode) {
      return this._addNode(triggerNode, new Map()) === Operation.added;
    }
    /**
     * Removes a trigger from node.
     *
     * @param trigger The trigger to be removed.
     * @returns Whether removing trigger operation is successful.
     */
  }, {
    key: "removeTrigger",
    value: function removeTrigger(trigger) {
      return this._removeTrigger(trigger, new Set());
    }
  }, {
    key: "_addNode",
    value: function _addNode(triggerNode, ops) {
      var _this = this;
      if (ops.has(this)) {
        return Operation.none;
      }
      var op = Operation.none;
      var trigger = triggerNode.triggers[0];
      var relationship = this.relationship(triggerNode);
      switch (relationship) {
        case relationshipType_1.RelationshipType.equal:
          {
            // Ensure action is not already there
            var found = this._allTriggers.find(function (existing) {
              return trigger.action != undefined && trigger.action === existing.action;
            }) !== undefined;
            op = Operation.found;
            if (!found) {
              this._allTriggers.push(trigger);
              var add = true;
              for (var i = 0; i < this._triggers.length;) {
                var existing = this._triggers[i];
                var reln = trigger.relationship(existing, this.tree.comparers);
                if (reln === relationshipType_1.RelationshipType.generalizes) {
                  add = false;
                  break;
                } else if (reln === relationshipType_1.RelationshipType.specializes) {
                  this._triggers.splice(i, 1);
                } else {
                  ++i;
                }
              }
              if (add) {
                this._triggers.push(trigger);
              }
              op = Operation.added;
            }
            break;
          }
        case relationshipType_1.RelationshipType.incomparable:
          var _iterator = _createForOfIteratorHelper(this._specializations),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var child = _step.value;
              child._addNode(triggerNode, ops);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          break;
        case relationshipType_1.RelationshipType.specializes:
          triggerNode._addSpecialization(this);
          op = Operation.inserted;
          break;
        case relationshipType_1.RelationshipType.generalizes:
          {
            var foundOne = false;
            var removals;
            for (var _i = 0; _i < this._specializations.length; _i++) {
              var _child = this._specializations[_i];
              var childOp = _child._addNode(triggerNode, ops);
              if (childOp != Operation.none) {
                foundOne = true;
                if (childOp === Operation.inserted) {
                  if (!removals) {
                    removals = [];
                  }
                  removals.push(_child);
                  op = Operation.added;
                } else {
                  op = childOp;
                }
              }
            }
            if (removals) {
              var _iterator2 = _createForOfIteratorHelper(removals),
                _step2;
              try {
                var _loop = function _loop() {
                  var removal = _step2.value;
                  var removed = _this._specializations.findIndex(function (item) {
                    return item === removal;
                  });
                  if (removed >= 0) {
                    _this._specializations.splice(removed, 1);
                  }
                };
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  _loop();
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
              this._specializations.push(triggerNode);
            }
            if (!foundOne) {
              this._specializations.push(triggerNode);
              op = Operation.added;
            }
            break;
          }
      }
      // Prevent visiting this node again
      ops.set(this, op);
      return op;
    }
  }, {
    key: "_matches",
    value: function _matches(state, matches, matched) {
      var found = matched.get(this);
      if (found) {
        return true;
      }
      found = false;
      var _iterator3 = _createForOfIteratorHelper(this._specializations),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var child = _step3.value;
          if (child._matches(state, matches, matched)) {
            found = true;
          }
        }
        // No child matched so we might
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      if (!found) {
        var _this$clause$tryEvalu = this.clause.tryEvaluate(state),
          match = _this$clause$tryEvalu.value,
          error = _this$clause$tryEvalu.error;
        if (!error && match) {
          var _iterator4 = _createForOfIteratorHelper(this.triggers),
            _step4;
          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var trigger = _step4.value;
              if (trigger.matches(this.clause, state)) {
                matches.add(trigger);
                found = true;
              }
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
        }
      }
      matched.set(this, found);
      return found;
    }
  }, {
    key: "_removeTrigger",
    value: function _removeTrigger(trigger, visited) {
      var _this2 = this;
      if (visited.has(this)) {
        return false;
      }
      visited.add(this);
      var removed = false;
      // Remove from allTriggers and triggers
      var allTriggerIndex = this._allTriggers.findIndex(function (item) {
        return item === trigger;
      });
      if (allTriggerIndex >= 0) {
        // We found the trigger somewhere in the tree
        this._allTriggers.splice(allTriggerIndex, 1);
        removed = true;
        var triggerIndex = this._triggers.findIndex(function (item) {
          return item === trigger;
        });
        if (triggerIndex >= 0) {
          this._triggers.splice(triggerIndex, 1);
          var _iterator5 = _createForOfIteratorHelper(this._allTriggers),
            _step5;
          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              var candidate = _step5.value;
              var add = true;
              var _iterator6 = _createForOfIteratorHelper(this._triggers),
                _step6;
              try {
                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                  var existing = _step6.value;
                  var reln = candidate.relationship(existing, this.tree.comparers);
                  if (reln === relationshipType_1.RelationshipType.equal || reln === relationshipType_1.RelationshipType.generalizes) {
                    add = false;
                    break;
                  }
                }
              } catch (err) {
                _iterator6.e(err);
              } finally {
                _iterator6.f();
              }
              if (add) {
                this._triggers.push(candidate);
              }
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
        }
      }
      // Remove from any children
      var removals;
      for (var i = 0; i < this._specializations.length; i++) {
        var child = this._specializations[i];
        var childRemoved = child._removeTrigger(trigger, visited);
        if (childRemoved) {
          removed = true;
        }
        if (child.triggers.length === 0) {
          if (!removals) {
            removals = [];
          }
          removals.push(child);
        }
      }
      if (removals) {
        // Remove children if no triggers left
        var _iterator7 = _createForOfIteratorHelper(removals),
          _step7;
        try {
          var _loop2 = function _loop2() {
            var removal = _step7.value;
            var removedIndex = _this2._specializations.findIndex(function (item) {
              return item === removal;
            });
            if (removedIndex >= 0) {
              _this2._specializations.splice(removedIndex, 1);
              var _iterator8 = _createForOfIteratorHelper(removal.specializations),
                _step8;
              try {
                for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
                  var specialization = _step8.value;
                  var _add = true;
                  var _iterator9 = _createForOfIteratorHelper(_this2._specializations),
                    _step9;
                  try {
                    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
                      var parent = _step9.value;
                      var _reln = parent.relationship(specialization);
                      if (_reln === relationshipType_1.RelationshipType.generalizes) {
                        _add = false;
                        break;
                      }
                    }
                  } catch (err) {
                    _iterator9.e(err);
                  } finally {
                    _iterator9.f();
                  }
                  if (_add) {
                    _this2._specializations.push(specialization);
                  }
                }
              } catch (err) {
                _iterator8.e(err);
              } finally {
                _iterator8.f();
              }
            }
          };
          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
            _loop2();
          }
        } catch (err) {
          _iterator7.e(err);
        } finally {
          _iterator7.f();
        }
      }
      return removed;
    }
  }, {
    key: "_addSpecialization",
    value: function _addSpecialization(specialization) {
      var _this3 = this;
      var added = false;
      var removals;
      var skip = false;
      for (var i = 0; i < this._specializations.length; i++) {
        var child = this._specializations[i];
        var reln = specialization.relationship(child);
        if (reln === relationshipType_1.RelationshipType.equal) {
          skip = true;
          break;
        }
        if (reln === relationshipType_1.RelationshipType.generalizes) {
          if (!removals) {
            removals = [];
          }
          removals.push(child);
        } else if (reln === relationshipType_1.RelationshipType.specializes) {
          skip = true;
          break;
        }
      }
      if (!skip) {
        if (removals) {
          var _iterator10 = _createForOfIteratorHelper(removals),
            _step10;
          try {
            var _loop3 = function _loop3() {
              var removal = _step10.value;
              // Don't need to add back because specialization already has them
              var removed = _this3._specializations.findIndex(function (item) {
                return item === removal;
              });
              if (removed >= 0) {
                specialization._addSpecialization(_this3._specializations[removed]);
                _this3._specializations.splice(removed, 1);
              }
            };
            for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
              _loop3();
            }
          } catch (err) {
            _iterator10.e(err);
          } finally {
            _iterator10.f();
          }
        }
        this._specializations.push(specialization);
        added = true;
      }
      return added;
    }
  }]);
  return Node;
}();
exports.Node = Node;

},{"./clause":215,"./relationshipType":219,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"core-js/modules/es.array.find-index.js":573,"core-js/modules/es.array.find.js":574,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.array.splice.js":582,"core-js/modules/es.function.name.js":584,"core-js/modules/es.map.js":587,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.set.js":621,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],218:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.concat.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Type of quantifier for expanding trigger expressions.
 */
var QuantifierType;
(function (QuantifierType) {
  /**
   * Within a clause, duplicate any predicate with variable for each possible binding.
   */
  QuantifierType["all"] = "all";
  /**
   * Create a new clause for each possible binding of variable.
   */
  QuantifierType["any"] = "any";
})(QuantifierType = exports.QuantifierType || (exports.QuantifierType = {}));
/**
 * Quantifier for allowing runtime expansion of expressions.
 */
var Quantifier = /*#__PURE__*/function () {
  /**
   * Initializes a new instance of the `Quantifier` class.
   *
   * @param variable Name of variable to replace.
   * @param type Type of quantifier.
   * @param bindings Possible bindings for variable.
   */
  function Quantifier(variable, type, bindings) {
    (0, _classCallCheck2.default)(this, Quantifier);
    this.variable = variable;
    this.type = type;
    this.bindings = bindings;
  }
  /**
   * @returns A string that represents the quantifier.
   */
  (0, _createClass2.default)(Quantifier, [{
    key: "toString",
    value: function toString() {
      return "".concat(this.type, " ").concat(this.variable, " ").concat(this.bindings.length);
    }
  }]);
  return Quantifier;
}();
exports.Quantifier = Quantifier;

},{"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"core-js/modules/es.array.concat.js":569}],219:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Relationship between trigger expressions.
 */
var RelationshipType;
(function (RelationshipType) {
  /**
   * First argument specializes the second, i.e. applies to a subset of the states the second argument covers.
   */
  RelationshipType["specializes"] = "specializes";
  /**
   * First and second argument are the same expression.
   */
  RelationshipType["equal"] = "equal";
  /**
   * First argument generalizes the second, i.e. applies to a superset of the states the second argument covers.
   */
  RelationshipType["generalizes"] = "generalizes";
  /**
   * Connot tell how the first and second arguments relate.
   */
  RelationshipType["incomparable"] = "incomparable";
})(RelationshipType = exports.RelationshipType || (exports.RelationshipType = {}));

},{}],220:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _construct2 = _interopRequireDefault(require("@babel/runtime/helpers/construct"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
require("core-js/modules/es.array.map.js");
require("core-js/modules/es.array.concat.js");
require("core-js/modules/es.array.find.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.string.repeat.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.array.join.js");
require("core-js/modules/es.array.splice.js");
require("core-js/modules/web.dom-collections.for-each.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var clause_1 = require("./clause");
var constant_1 = require("../constant");
var expression_1 = require("../expression");
var expressionType_1 = require("../expressionType");
var quantifier_1 = require("./quantifier");
var relationshipType_1 = require("./relationshipType");
/**
 * Rewrite the expression by pushing not down to the leaves.
 *
 * @param expression Expression to rewrite.
 * @param inNot .
 * @returns The rewritten expression.
 */
var pushDownNot = function pushDownNot(expression) {
  var inNot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var newExpr = expression;
  var negation = expression.evaluator.negation;
  switch (expression.type) {
    case expressionType_1.ExpressionType.And:
    case expressionType_1.ExpressionType.Or:
      {
        var children = expression.children.map(function (child) {
          return pushDownNot(child, inNot);
        });
        if (children.length === 1) {
          newExpr = children[0];
        } else {
          var _expression_1$Express;
          newExpr = (_expression_1$Express = expression_1.Expression).makeExpression.apply(_expression_1$Express, [expression.type === expressionType_1.ExpressionType.And ? inNot ? expressionType_1.ExpressionType.Or : expressionType_1.ExpressionType.And : inNot ? expressionType_1.ExpressionType.And : expressionType_1.ExpressionType.Or, undefined].concat((0, _toConsumableArray2.default)(children)));
        }
        break;
      }
    case expressionType_1.ExpressionType.Not:
      newExpr = pushDownNot(expression.children[0], !inNot);
      break;
    default:
      if (inNot) {
        if (negation) {
          if (expression.type === negation.type) {
            var _expression_1$Express2;
            // Pass through like optional/ignore
            newExpr = (_expression_1$Express2 = expression_1.Expression).makeExpression.apply(_expression_1$Express2, [undefined, negation].concat((0, _toConsumableArray2.default)(expression.children.map(function (child) {
              return pushDownNot(child, true);
            }))));
          } else {
            var _expression_1$Express3;
            // Replace with negation and stop
            newExpr = (_expression_1$Express3 = expression_1.Expression).makeExpression.apply(_expression_1$Express3, [undefined, negation].concat((0, _toConsumableArray2.default)(expression.children)));
          }
        } else {
          // Keep not
          newExpr = expression_1.Expression.makeExpression(expressionType_1.ExpressionType.Not, undefined, expression);
        }
      }
      break;
  }
  return newExpr;
};
/**
 * A trigger is a combination of a trigger expression and the corresponding action.
 */
var Trigger = /*#__PURE__*/function () {
  /**
   * Intializes a new instance of the `Trigger` class.
   *
   * @param tree Trigger tree that contains this trigger.
   * @param expression Expression for when the trigger action is possible.
   * @param action Action to take when a trigger matches.
   * @param quantifiers Quantifiers to dynamically expand the expression.
   */
  function Trigger(tree, expression, action) {
    (0, _classCallCheck2.default)(this, Trigger);
    this._tree = tree;
    this.action = action;
    this.originalExpression = expression;
    for (var _len = arguments.length, quantifiers = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      quantifiers[_key - 3] = arguments[_key];
    }
    this._quantifiers = quantifiers;
    if (expression) {
      var normalForm = pushDownNot(expression);
      this._clauses = this._generateClauses(normalForm);
      this._removeDuplicatedPredicates();
      this._optimizeClauses();
      this._expandQuantifiers();
      this._removeDuplicates();
      this._markSubsumedClauses();
      this._splitIgnores();
    } else {
      this._clauses = [];
    }
  }
  /**
   * Gets list of expressions converted into Disjunctive Normal Form where ! is pushed to the leaves and
   * there is an implicit || between clauses and && within a clause.
   *
   * @returns The list of clauses.
   */
  (0, _createClass2.default)(Trigger, [{
    key: "clauses",
    get: function get() {
      return this._clauses;
    }
    /**
     * Determines the relationship between current instance and another `Trigger` instance.
     *
     * @param other The other Trigger instance.
     * @param comparers The comparer dictionary.
     * @returns A `RelationshipType` value.
     */
  }, {
    key: "relationship",
    value: function relationship(other, comparers) {
      var result;
      var first = this._relationship(this, other, comparers);
      var second = this._relationship(other, this, comparers);
      if (first === relationshipType_1.RelationshipType.equal) {
        if (second === relationshipType_1.RelationshipType.equal) {
          // All first clauses == second clauses
          result = relationshipType_1.RelationshipType.equal;
        } else {
          // All first clauses found in second
          result = relationshipType_1.RelationshipType.specializes;
        }
      } else if (first === relationshipType_1.RelationshipType.specializes) {
        // All first clauses specializes or equal a second clause
        result = relationshipType_1.RelationshipType.specializes;
      } else if (second === relationshipType_1.RelationshipType.equal || second === relationshipType_1.RelationshipType.specializes) {
        // All second clauses are equal or specialize a first clause
        result = relationshipType_1.RelationshipType.generalizes;
      } else {
        // All other cases are in comparable
        result = relationshipType_1.RelationshipType.incomparable;
      }
      return result;
    }
    /**
     * Determines whether there is a member in the current `Clause` that matches the nodeClause parameter.
     *
     * @param nodeClause The other Clause instance to match.
     * @param state The scope for looking up variables.
     * @returns A boolean value inidicating whether there is a member matches.
     */
  }, {
    key: "matches",
    value: function matches(nodeClause, state) {
      return this.clauses.find(function (clause) {
        return clause.matches(nodeClause, state);
      }) !== undefined;
    }
    /**
     * Gets a string that represents the current trigger.
     *
     * @param builder An array of string to build the string of trigger.
     * @param indent An integer represents the number of spaces at the start of a line.
     * @returns A string that represents the current trigger.
     */
  }, {
    key: "toString",
    value: function toString() {
      var builder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      builder.push(' '.repeat(indent));
      if (this._clauses.length > 0) {
        var first = true;
        var _iterator = _createForOfIteratorHelper(this._clauses),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var clause = _step.value;
            if (first) {
              first = false;
            } else {
              builder.push('\n');
              builder.push(' '.repeat(indent));
              builder.push('|| ');
            }
            builder.push(clause.toString());
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      } else {
        builder.push('<Empty>');
      }
      return builder.join('');
    }
  }, {
    key: "_relationship",
    value: function _relationship(trigger, other, comparers) {
      var soFar = relationshipType_1.RelationshipType.incomparable;
      var _iterator2 = _createForOfIteratorHelper(trigger.clauses),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var clause = _step2.value;
          if (!clause.subsumed) {
            // Check other for = or clause that is specialized
            var clauseSoFar = relationshipType_1.RelationshipType.incomparable;
            var _iterator3 = _createForOfIteratorHelper(other.clauses),
              _step3;
            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var second = _step3.value;
                if (!second.subsumed) {
                  var reln = clause.relationship(second, comparers);
                  if (reln === relationshipType_1.RelationshipType.equal || reln === relationshipType_1.RelationshipType.specializes) {
                    clauseSoFar = reln;
                    break;
                  }
                }
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
            if (clauseSoFar === relationshipType_1.RelationshipType.incomparable) {
              // Some clause is not comparable
              soFar = relationshipType_1.RelationshipType.incomparable;
              break;
            }
            if (clauseSoFar === relationshipType_1.RelationshipType.equal) {
              if (soFar === relationshipType_1.RelationshipType.incomparable) {
                // Start on equal clause
                soFar = clauseSoFar;
              }
            } else if (clauseSoFar === relationshipType_1.RelationshipType.specializes) {
              // Either going from incomparable or equal to specializes
              soFar = clauseSoFar;
            }
          }
        }
        // Either incomparable, equal or specializes
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return soFar;
    }
  }, {
    key: "_generateClauses",
    value: function _generateClauses(expression) {
      switch (expression.type) {
        case expressionType_1.ExpressionType.And:
          {
            // Need to combine every combination of clauses
            var soFar = [];
            var first = true;
            for (var i = 0; i < expression.children.length; i++) {
              var child = expression.children[i];
              var clauses = this._generateClauses(child);
              if (clauses.length === 0) {
                // Encountered false
                soFar = [];
                break;
              }
              if (first) {
                var _soFar;
                (_soFar = soFar).push.apply(_soFar, (0, _toConsumableArray2.default)(clauses));
                first = false;
              } else {
                var newClauses = [];
                var _iterator4 = _createForOfIteratorHelper(soFar),
                  _step4;
                try {
                  for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                    var old = _step4.value;
                    var _iterator5 = _createForOfIteratorHelper(clauses),
                      _step5;
                    try {
                      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                        var clause = _step5.value;
                        var children = [];
                        children.push.apply(children, (0, _toConsumableArray2.default)(old.children));
                        children.push.apply(children, (0, _toConsumableArray2.default)(clause.children));
                        newClauses.push(new clause_1.Clause(children));
                      }
                    } catch (err) {
                      _iterator5.e(err);
                    } finally {
                      _iterator5.f();
                    }
                  }
                } catch (err) {
                  _iterator4.e(err);
                } finally {
                  _iterator4.f();
                }
                soFar = newClauses;
              }
            }
            return soFar;
          }
        case expressionType_1.ExpressionType.Or:
          {
            var _clauses = [];
            for (var _i = 0; _i < expression.children.length; _i++) {
              var _child = expression.children[_i];
              _clauses.push.apply(_clauses, (0, _toConsumableArray2.default)(this._generateClauses(_child)));
            }
            return _clauses;
          }
        case expressionType_1.ExpressionType.Optional:
          return [new clause_1.Clause()].concat((0, _toConsumableArray2.default)(this._generateClauses(expression.children[0])));
        default:
          // True becomes empty expression and false drops clause
          if (expression instanceof constant_1.Constant && typeof expression.value === 'boolean') {
            return expression.value ? [new clause_1.Clause()] : [];
          } else {
            return [new clause_1.Clause(expression)];
          }
      }
    }
    /**
     * Remove any duplicate predicates within a clause.
     * NOTE: This is annoying but expression hash codes of deepEquals expressions are different.
     */
  }, {
    key: "_removeDuplicatedPredicates",
    value: function _removeDuplicatedPredicates() {
      // Rewrite clauses to remove duplicated tests
      for (var i = 0; i < this._clauses.length; ++i) {
        var clause = this._clauses[i];
        var children = [];
        for (var p = 0; p < clause.children.length; ++p) {
          var pred = clause.children[p];
          var found = false;
          for (var q = p + 1; q < clause.children.length; ++q) {
            if (pred.deepEquals(clause.children[q])) {
              found = true;
              break;
            }
          }
          if (!found) {
            children.push(pred);
          }
        }
        this._clauses[i] = new clause_1.Clause(children);
      }
    }
    /**
     * Mark clauses that are more specific than another clause as subsumed and also remove any = clauses.
     */
  }, {
    key: "_markSubsumedClauses",
    value: function _markSubsumedClauses() {
      for (var i = 0; i < this._clauses.length; ++i) {
        var clause = this._clauses[i];
        if (!clause.subsumed) {
          for (var j = i + 1; j < this._clauses.length; ++j) {
            var other = this._clauses[j];
            if (!other.subsumed) {
              var reln = clause.relationship(other, this._tree.comparers);
              if (reln === relationshipType_1.RelationshipType.equal) {
                this._clauses.splice(j, 1);
                --j;
              } else {
                if (reln === relationshipType_1.RelationshipType.specializes) {
                  clause.subsumed = true;
                  break;
                }
                if (reln === relationshipType_1.RelationshipType.generalizes) {
                  other.subsumed = true;
                }
              }
            }
          }
        }
      }
    }
  }, {
    key: "_splitIgnores",
    value: function _splitIgnores() {
      for (var i = 0; i < this._clauses.length; i++) {
        this._clauses[i].splitIgnores();
      }
    }
  }, {
    key: "_optimizeClauses",
    value: function _optimizeClauses() {
      var _this = this;
      this._clauses.forEach(function (clause) {
        _this._tree.optimizers.forEach(function (optimizer) {
          optimizer.optimize(clause);
        });
      });
    }
  }, {
    key: "_expandQuantifiers",
    value: function _expandQuantifiers() {
      if (this._quantifiers && this._quantifiers.length > 0) {
        for (var i = 0; i < this._quantifiers.length; i++) {
          var quantifier = this._quantifiers[i];
          var newClauses = [];
          for (var j = 0; j < this._clauses.length; j++) {
            var clause = this._clauses[j];
            newClauses.push.apply(newClauses, (0, _toConsumableArray2.default)(this._expandQuantifiersWithClause(quantifier, clause)));
          }
          this._clauses = newClauses;
        }
      }
    }
  }, {
    key: "_expandQuantifiersWithClause",
    value: function _expandQuantifiersWithClause(quantifier, clause) {
      var results = [];
      if (quantifier.type === quantifier_1.QuantifierType.all) {
        var children = [];
        if (quantifier.bindings.length > 0) {
          for (var i = 0; i < clause.children.length; i++) {
            var predicate = clause.children[i];
            for (var j = 0; j < quantifier.bindings.length; j++) {
              var binding = quantifier.bindings[j];
              var _this$_substituteVari = this._substituteVariable(quantifier.variable, binding, predicate),
                newPredicate = _this$_substituteVari.expression,
                changed = _this$_substituteVari.changed;
              children.push(newPredicate);
              if (!changed) {
                // No change to first predicate, so can stop
                break;
              }
            }
          }
        } else {
          // Empty quantifier is trivially true so remove any predicate that refers to quantifier
          for (var _i2 = 0; _i2 < clause.children.length; _i2++) {
            var _predicate = clause.children[_i2];
            var _this$_substituteVari2 = this._substituteVariable(quantifier.variable, '', _predicate),
              _changed = _this$_substituteVari2.changed;
            if (!_changed) {
              children.push(_predicate);
            }
          }
        }
        results.push(new clause_1.Clause(children));
      } else {
        if (quantifier.bindings.length > 0) {
          var _changed2 = false;
          for (var _i3 = 0; _i3 < quantifier.bindings.length; _i3++) {
            var _binding = quantifier.bindings[_i3];
            var newClause = new clause_1.Clause(clause);
            var _children = [];
            for (var _j = 0; _j < clause.children.length; _j++) {
              var _predicate2 = clause.children[_j];
              var _this$_substituteVari3 = this._substituteVariable(quantifier.variable, _binding, _predicate2),
                _newPredicate = _this$_substituteVari3.expression,
                predicateChanged = _this$_substituteVari3.changed;
              _changed2 = _changed2 || predicateChanged;
              _children.push(_newPredicate);
            }
            if (_changed2) {
              newClause.anyBindings.set(quantifier.variable, _binding);
            }
            newClause.children = [].concat(_children);
            results.push(newClause);
            if (!_changed2) {
              break;
            }
          }
        } else {
          // Keep clause if does not contain any binding
          var _changed3 = false;
          for (var _i4 = 0; _i4 < clause.children.length; _i4++) {
            var _predicate3 = clause.children[_i4];
            var _this$_substituteVari4 = this._substituteVariable(quantifier.variable, '', _predicate3),
              _predicateChanged = _this$_substituteVari4.changed;
            if (_predicateChanged) {
              _changed3 = true;
              break;
            }
          }
          if (!_changed3) {
            results.push(clause);
          }
        }
      }
      return results;
    }
  }, {
    key: "_substituteVariable",
    value: function _substituteVariable(variable, binding, expression) {
      var newExpr = expression;
      var changed = false;
      if (expression.type === expressionType_1.ExpressionType.Accessor && expression.children.length === 1 && expression.children[0] instanceof constant_1.Constant && typeof expression.children[0].value === 'string' && expression.children[0].value === variable) {
        newExpr = expression_1.Expression.makeExpression(expressionType_1.ExpressionType.Accessor, undefined, new constant_1.Constant(binding));
        changed = true;
      } else {
        var children = [];
        for (var i = 0; i < expression.children.length; i++) {
          var child = expression.children[i];
          var _this$_substituteVari5 = this._substituteVariable(variable, binding, child),
            childExpr = _this$_substituteVari5.expression,
            childChanged = _this$_substituteVari5.changed;
          children.push(childExpr);
          changed = changed || childChanged;
        }
        if (changed) {
          newExpr = (0, _construct2.default)(expression_1.Expression, [undefined, expression.evaluator].concat(children));
        }
      }
      return {
        expression: newExpr,
        changed: changed
      };
    }
  }, {
    key: "_removeDuplicates",
    value: function _removeDuplicates() {
      var _iterator6 = _createForOfIteratorHelper(this._clauses),
        _step6;
      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var clause = _step6.value;
          // NOTE: This is quadratic in clause length but GetHashCode is not equal for expressions and we expect the number of clauses to be small.
          var predicates = (0, _toConsumableArray2.default)(clause.children);
          for (var i = 0; i < predicates.length; ++i) {
            var first = predicates[i];
            for (var j = i + 1; j < predicates.length;) {
              var second = predicates[j];
              if (first.deepEquals(second)) {
                predicates.splice(j, 1);
              } else {
                ++j;
              }
            }
          }
          clause.children = (0, _toConsumableArray2.default)(predicates);
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
    }
  }]);
  return Trigger;
}();
exports.Trigger = Trigger;

},{"../constant":167,"../expression":179,"../expressionType":192,"./clause":215,"./quantifier":218,"./relationshipType":219,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/construct":231,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/toConsumableArray":249,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.array.find.js":574,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.join.js":578,"core-js/modules/es.array.map.js":579,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.array.splice.js":582,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.string.repeat.js":628,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.for-each.js":676,"core-js/modules/web.dom-collections.iterator.js":677}],221:[function(require,module,exports){
"use strict";

/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.concat.js");
require("core-js/modules/es.array.join.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.set.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.regexp.to-string.js");
var _construct2 = _interopRequireDefault(require("@babel/runtime/helpers/construct"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var expression_1 = require("../expression");
var clause_1 = require("./clause");
var node_1 = require("./node");
var relationshipType_1 = require("./relationshipType");
var trigger_1 = require("./trigger");
/**
 * A trigger tree organizes evaluators according to generalization/specialization in order to make it easier to use rules.
 */
var TriggerTree = /*#__PURE__*/function () {
  /**
   * Intializes a new instance of the `TriggerTree` class.
   */
  function TriggerTree() {
    (0, _classCallCheck2.default)(this, TriggerTree);
    /**
     * A list of `Optimizer` for optimizing claues.
     */
    this.optimizers = [];
    /**
     * A dictionary of `PredicateComparer` values, with string keys.
     */
    this.comparers = {};
    /**
     * The total number of triggers.
     */
    this.totalTriggers = 0;
    this.root = new node_1.Node(new clause_1.Clause(), this);
  }
  /**
   * @returns A string the represents the current object.
   */
  (0, _createClass2.default)(TriggerTree, [{
    key: "toString",
    value: function toString() {
      return "TriggerTree with ".concat(this.totalTriggers, " triggers");
    }
    /**
     * Add a trigger expression to the tree.
     *
     * @param stringOrExpression Trigger to add.
     * @param action Action when triggered.
     * @param quantifiers Quantifiers to use when expanding expressions.
     * @returns New trigger.
     */
  }, {
    key: "addTrigger",
    value: function addTrigger(stringOrExpression, action) {
      var expression = typeof stringOrExpression === 'string' ? expression_1.Expression.parse(stringOrExpression) : stringOrExpression;
      for (var _len = arguments.length, quantifiers = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        quantifiers[_key - 2] = arguments[_key];
      }
      var trigger = (0, _construct2.default)(trigger_1.Trigger, [this, expression, action].concat(quantifiers));
      var added = false;
      if (trigger.clauses.length) {
        var _iterator = _createForOfIteratorHelper(trigger.clauses),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var clause = _step.value;
            var newNode = new node_1.Node(clause, this, trigger);
            if (this.root.addNode(newNode)) {
              added = true;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
      if (added) {
        ++this.totalTriggers;
      }
      return trigger;
    }
    /**
     * Remove trigger from tree.
     *
     * @param trigger Trigger to remove.
     * @returns True if removed trigger.
     */
  }, {
    key: "removeTrigger",
    value: function removeTrigger(trigger) {
      var result = this.root.removeTrigger(trigger);
      if (result) {
        --this.totalTriggers;
      }
      return result;
    }
    /**
     * Generates a string describing the tree.
     *
     * @param indent Current indent level.
     * @returns String describing the tree.
     */
  }, {
    key: "treeToString",
    value: function treeToString() {
      var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var builder = [];
      this._treeToString(builder, this.root, indent);
      return builder.join('');
    }
    /**
     * Return the possible matches given the current state.
     *
     * @param state State to evaluate against.
     * @returns List of possible matches.
     */
  }, {
    key: "matches",
    value: function matches(state) {
      return this.root.matches(state);
    }
    /**
     * Verify the tree meets specialization/generalization invariants.
     *
     * @returns Bad node if found.
     */
  }, {
    key: "verifyTree",
    value: function verifyTree() {
      return this._verifyTree(this.root, new Set());
    }
  }, {
    key: "_verifyTree",
    value: function _verifyTree(node, visited) {
      var badNode;
      if (!visited.has(node)) {
        visited.add(node);
        for (var i = 0; !badNode && i < node.specializations.length; ++i) {
          var first = node.specializations[i];
          if (node.relationship(first) !== relationshipType_1.RelationshipType.generalizes) {
            badNode = node;
          } else {
            this._verifyTree(node.specializations[i], visited);
            for (var j = i + 1; j < node.specializations.length; ++j) {
              var second = node.specializations[j];
              if (first.relationship(second) !== relationshipType_1.RelationshipType.incomparable) {
                badNode = node;
                break;
              }
            }
          }
        }
      }
      return badNode;
    }
  }, {
    key: "_treeToString",
    value: function _treeToString(builder, node, indent) {
      node.toString(builder, indent);
      builder.push(" [".concat(node.triggers.length, "]"));
      builder.push('\n');
      var _iterator2 = _createForOfIteratorHelper(node.specializations),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var child = _step2.value;
          this._treeToString(builder, child, indent + 2);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }]);
  return TriggerTree;
}();
exports.TriggerTree = TriggerTree;

},{"../expression":179,"./clause":215,"./node":217,"./relationshipType":219,"./trigger":220,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/construct":231,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.join.js":578,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.set.js":621,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],222:[function(require,module,exports){
"use strict";

require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.number.constructor.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.match.js");
require("core-js/modules/es.string.starts-with.js");
require("core-js/modules/es.string.ends-with.js");
require("core-js/modules/es.object.assign.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.set.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.array.concat.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.string.trim.js");
require("core-js/modules/es.array.splice.js");
require("core-js/modules/es.array.sort.js");
require("core-js/modules/es.array.filter.js");
require("core-js/modules/es.array.map.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var microsoftRecognizersTextDataTypesTimexExpression = function (exports) {
  'use strict';

  // Copyright (c) Microsoft Corporation. All rights reserved.
  var Time = /*#__PURE__*/function () {
    function Time(hour, minute, second) {
      (0, _classCallCheck2.default)(this, Time);
      if (arguments.length === 1) {
        this.hour = Math.floor(hour / 3600000);
        this.minute = Math.floor((hour - this.hour * 3600000) / 60000);
        this.second = (hour - this.hour * 3600000 - this.minute * 60000) / 1000;
      } else {
        this.hour = hour;
        this.minute = minute;
        this.second = second;
      }
    }
    (0, _createClass2.default)(Time, [{
      key: "getTime",
      value: function getTime() {
        return this.second * 1000 + this.minute * 60000 + this.hour * 3600000;
      }
    }]);
    return Time;
  }();
  var Time_1 = Time;
  var time = {
    Time: Time_1
  };

  // Copyright (c) Microsoft Corporation. All rights reserved.

  var value = function value(s) {
    return s;
  };
  var isTrue = function isTrue() {
    return true;
  };
  var zero = function zero() {
    return 0;
  };
  var timexRegex = {
    date: [
    // date
    {
      regex: /^(\d\d\d\d)-(\d\d)-(\d\d)$/,
      props: {
        year: Number,
        month: Number,
        dayOfMonth: Number
      }
    }, {
      regex: /^XXXX-WXX-(\d)$/,
      props: {
        dayOfWeek: Number
      }
    }, {
      regex: /^XXXX-(\d\d)-(\d\d)$/,
      props: {
        month: Number,
        dayOfMonth: Number
      }
    },
    // daterange
    {
      regex: /^(\d\d\d\d)$/,
      props: {
        year: Number
      }
    }, {
      regex: /^(\d\d\d\d)-(\d\d)$/,
      props: {
        year: Number,
        month: Number
      }
    }, {
      regex: /^(SP|SU|FA|WI)$/,
      props: {
        season: value
      }
    }, {
      regex: /^(\d\d\d\d)-(SP|SU|FA|WI)$/,
      props: {
        year: Number,
        season: value
      }
    }, {
      regex: /^(\d\d\d\d)-W(\d\d)$/,
      props: {
        year: Number,
        weekOfYear: Number
      }
    }, {
      regex: /^(\d\d\d\d)-W(\d\d)-WE$/,
      props: {
        year: Number,
        weekOfYear: Number,
        weekend: isTrue
      }
    }, {
      regex: /^XXXX-(\d\d)$/,
      props: {
        month: Number
      }
    }, {
      regex: /^XXXX-(\d\d)-W(\d\d)$/,
      props: {
        month: Number,
        weekOfMonth: Number
      }
    }, {
      regex: /^XXXX-(\d\d)-WXX-(\d)-(\d)$/,
      props: {
        month: Number,
        weekOfMonth: Number,
        dayOfWeek: Number
      }
    }],
    time: [
    // time
    {
      regex: /^T(\d\d)$/,
      props: {
        hour: Number,
        minute: zero,
        second: zero
      }
    }, {
      regex: /^T(\d\d):(\d\d)$/,
      props: {
        hour: Number,
        minute: Number,
        second: zero
      }
    }, {
      regex: /^T(\d\d):(\d\d):(\d\d)$/,
      props: {
        hour: Number,
        minute: Number,
        second: Number
      }
    },
    // timerange
    {
      regex: /^T(DT|NI|MO|AF|EV)$/,
      props: {
        partOfDay: value
      }
    }],
    period: [{
      regex: /^P(\d*\.?\d+)(Y|M|W|D)$/,
      props: {
        amount: Number,
        dateUnit: value
      }
    }, {
      regex: /^PT(\d*\.?\d+)(H|M|S)$/,
      props: {
        amount: Number,
        timeUnit: value
      }
    }]
  };
  var tryExtract = function tryExtract(entry, timex, result) {
    var regexResult = timex.match(entry.regex);
    if (!regexResult) {
      return false;
    }
    var index = 1;
    for (var name in entry.props) {
      var val = regexResult[index++];
      result[name] = entry.props[name](val);
    }
    return true;
  };
  var extract = function extract(name, timex, result) {
    var _iterator = _createForOfIteratorHelper(timexRegex[name]),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var entry = _step.value;
        if (tryExtract(entry, timex, result)) {
          return true;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return false;
  };
  var extract_1 = extract;
  var timexRegex_1 = {
    extract: extract_1
  };

  // Copyright (c) Microsoft Corporation. All rights reserved.

  var parseString = function parseString(timex, obj) {
    // a reference to the present
    if (timex === 'PRESENT_REF') {
      obj.now = true;
    }
    // duration
    else if (timex.startsWith('P')) {
      extractDuration(timex, obj);
    }
    // range indicated with start and end dates and a duration
    else if (timex.startsWith('(') && timex.endsWith(')')) {
      extractStartEndRange(timex, obj);
    }
    // date and time and their respective ranges
    else {
      extractDateTime(timex, obj);
    }
  };
  var extractDuration = function extractDuration(s, obj) {
    var extracted = {};
    timexRegex_1.extract('period', s, extracted);
    if (extracted.dateUnit) {
      obj[{
        Y: 'years',
        M: 'months',
        W: 'weeks',
        D: 'days'
      }[extracted.dateUnit]] = extracted.amount;
    } else if (extracted.timeUnit) {
      obj[{
        H: 'hours',
        M: 'minutes',
        S: 'seconds'
      }[extracted.timeUnit]] = extracted.amount;
    }
  };
  var extractStartEndRange = function extractStartEndRange(s, obj) {
    var parts = s.substring(1, s.length - 1).split(',');
    if (parts.length === 3) {
      extractDateTime(parts[0], obj);
      extractDuration(parts[2], obj);
    }
  };
  var extractDateTime = function extractDateTime(s, obj) {
    var indexOfT = s.indexOf('T');
    if (indexOfT === -1) {
      timexRegex_1.extract('date', s, obj);
    } else {
      timexRegex_1.extract('date', s.substr(0, indexOfT), obj);
      timexRegex_1.extract('time', s.substr(indexOfT), obj);
    }
  };
  var fromObject = function fromObject(source, obj) {
    Object.assign(obj, source);
    if ('hour' in obj) {
      if (!('minute' in obj)) {
        obj.minute = 0;
      }
      if (!('second' in obj)) {
        obj.second = 0;
      }
    }
  };
  var timexParsing = {
    parseString: parseString,
    fromObject: fromObject
  };

  // Copyright (c) Microsoft Corporation. All rights reserved.

  var isPresent = function isPresent(obj) {
    return obj.now === true;
  };
  var isDuration = function isDuration(obj) {
    return 'years' in obj || 'months' in obj || 'weeks' in obj || 'days' in obj || 'hours' in obj || 'minutes' in obj || 'seconds' in obj;
  };
  var isTime = function isTime(obj) {
    return 'hour' in obj && 'minute' in obj && 'second' in obj;
  };
  var isDate = function isDate(obj) {
    return 'month' in obj && 'dayOfMonth' in obj || 'dayOfWeek' in obj;
  };
  var isTimeRange = function isTimeRange(obj) {
    return 'partOfDay' in obj;
  };
  var isDateRange = function isDateRange(obj) {
    return 'year' in obj && !('dayOfMonth' in obj) || 'year' in obj && 'month' in obj && !('dayOfMonth' in obj) || 'month' in obj && !('dayOfMonth' in obj) || 'season' in obj || 'weekOfYear' in obj || 'weekOfMonth' in obj;
  };
  var isDefinite = function isDefinite(obj) {
    return 'year' in obj && 'month' in obj && 'dayOfMonth' in obj;
  };
  var infer = function infer(obj) {
    var types = new Set();
    if (isPresent(obj)) {
      types.add('present');
    }
    if (isDefinite(obj)) {
      types.add('definite');
    }
    if (isDate(obj)) {
      types.add('date');
    }
    if (isDateRange(obj)) {
      types.add('daterange');
    }
    if (isDuration(obj)) {
      types.add('duration');
    }
    if (isTime(obj)) {
      types.add('time');
    }
    if (isTimeRange(obj)) {
      types.add('timerange');
    }
    if (types.has('present')) {
      types.add('date');
      types.add('time');
    }
    if (types.has('time') && types.has('duration')) {
      types.add('timerange');
    }
    if (types.has('date') && types.has('time')) {
      types.add('datetime');
    }
    if (types.has('date') && types.has('duration')) {
      types.add('daterange');
    }
    if (types.has('datetime') && types.has('duration')) {
      types.add('datetimerange');
    }
    if (types.has('date') && types.has('timerange')) {
      types.add('datetimerange');
    }
    return types;
  };
  var infer_1 = infer;
  var timexInference = {
    infer: infer_1
  };

  // Copyright (c) Microsoft Corporation. All rights reserved.

  var cloneDate = function cloneDate(date) {
    var result = new Date();
    result.setTime(date.getTime());
    return result;
  };
  var tomorrow = function tomorrow(date) {
    var result = cloneDate(date);
    result.setDate(result.getDate() + 1);
    return result;
  };
  var yesterday = function yesterday(date) {
    var result = cloneDate(date);
    result.setDate(result.getDate() - 1);
    return result;
  };
  var datePartEquals = function datePartEquals(dateX, dateY) {
    return dateX.getFullYear() === dateY.getFullYear() && dateX.getMonth() === dateY.getMonth() && dateX.getDate() === dateY.getDate();
  };
  var isDateInWeek = function isDateInWeek(date, startOfWeek) {
    var d = cloneDate(startOfWeek);
    for (var i = 0; i < 7; i++) {
      if (datePartEquals(date, d)) {
        return true;
      }
      d = tomorrow(d);
    }
    return false;
  };
  var isThisWeek = function isThisWeek(date, referenceDate) {
    var startOfThisWeek = cloneDate(referenceDate);
    startOfThisWeek.setDate(startOfThisWeek.getDate() - startOfThisWeek.getDay());
    return isDateInWeek(date, startOfThisWeek);
  };
  var isNextWeek = function isNextWeek(date, referenceDate) {
    var startOfNextWeek = cloneDate(referenceDate);
    startOfNextWeek.setDate(startOfNextWeek.getDate() + (7 - startOfNextWeek.getDay()));
    return isDateInWeek(date, startOfNextWeek);
  };
  var isLastWeek = function isLastWeek(date, referenceDate) {
    var startOfLastWeek = cloneDate(referenceDate);
    startOfLastWeek.setDate(startOfLastWeek.getDate() - (7 + startOfLastWeek.getDay()));
    return isDateInWeek(date, startOfLastWeek);
  };
  var weekOfYear = function weekOfYear(date) {
    var ds = new Date(date.getFullYear(), 0);
    var de = new Date(date.getFullYear(), date.getMonth(), date.getDate());
    var weeks = 1;
    while (ds.getTime() < de.getTime()) {
      var jsDayOfWeek = ds.getDay();
      var isoDayOfWeek = jsDayOfWeek == 0 ? 7 : jsDayOfWeek;
      if (isoDayOfWeek === 7) {
        weeks++;
      }
      ds.setDate(ds.getDate() + 1);
    }
    return weeks;
  };
  var fixedFormatNumber$1 = function fixedFormatNumber$1(n, size) {
    var s = n.toString();
    var zeros = '';
    var np = size - s.length;
    for (var i = 0; i < np; i++) {
      zeros += '0';
    }
    return "".concat(zeros).concat(s);
  };
  var dateOfLastDay = function dateOfLastDay(day, referenceDate) {
    var result = cloneDate(referenceDate);
    result.setDate(result.getDate() - 1);
    while (result.getDay() !== day) {
      result.setDate(result.getDate() - 1);
    }
    return result;
  };
  var dateOfNextDay = function dateOfNextDay(day, referenceDate) {
    var result = cloneDate(referenceDate);
    do {
      result.setDate(result.getDate() + 1);
    } while (result.getDay() !== day);
    return result;
  };
  var datesMatchingDay = function datesMatchingDay(day, start, end) {
    var result = [];
    var d = cloneDate(start);
    while (!datePartEquals(d, end)) {
      if (d.getDay() === day) {
        result.push(cloneDate(d));
      }
      d.setDate(d.getDate() + 1);
    }
    return result;
  };
  var timexDateHelpers = {
    tomorrow: tomorrow,
    yesterday: yesterday,
    datePartEquals: datePartEquals,
    isThisWeek: isThisWeek,
    isNextWeek: isNextWeek,
    isLastWeek: isLastWeek,
    weekOfYear: weekOfYear,
    fixedFormatNumber: fixedFormatNumber$1,
    dateOfLastDay: dateOfLastDay,
    dateOfNextDay: dateOfNextDay,
    datesMatchingDay: datesMatchingDay
  };

  // Copyright (c) Microsoft Corporation. All rights reserved.

  var Time$1 = time.Time;
  var cloneDateTime = function cloneDateTime(timex) {
    var result = Object.assign({}, timex);
    delete result.years;
    delete result.months;
    delete result.weeks;
    delete result.days;
    delete result.hours;
    delete result.minutes;
    delete result.seconds;
    return result;
  };
  var cloneDuration = function cloneDuration(timex) {
    var result = Object.assign({}, timex);
    delete result.year;
    delete result.month;
    delete result.dayOfMonth;
    delete result.dayOfWeek;
    delete result.weekOfYear;
    delete result.weekOfMonth;
    delete result.season;
    delete result.hour;
    delete result.minute;
    delete result.second;
    delete result.weekend;
    delete result.partOfDay;
    return result;
  };
  var timexDateAdd$1 = function timexDateAdd$1(start, duration) {
    if ('dayOfWeek' in start) {
      var end = Object.assign({}, start);
      if ('days' in duration) {
        end.dayOfWeek += duration.days;
      }
      return end;
    }
    if ('month' in start && 'dayOfMonth' in start) {
      var durationDays = duration.days;
      if (durationDays === undefined && duration.weeks !== undefined) {
        durationDays = 7 * duration.weeks;
      }
      if (durationDays !== undefined) {
        if ('year' in start) {
          var d = new Date(start.year, start.month - 1, start.dayOfMonth, 0, 0, 0);
          for (var i = 0; i < durationDays; i++) {
            d.setDate(d.getDate() + 1);
          }
          return {
            year: d.getFullYear(),
            month: d.getMonth() + 1,
            dayOfMonth: d.getDate()
          };
        } else {
          var _d = new Date(2001, start.month - 1, start.dayOfMonth, 0, 0, 0);
          for (var _i = 0; _i < durationDays; _i++) {
            _d.setDate(_d.getDate() + 1);
          }
          return {
            month: _d.getMonth() + 1,
            dayOfMonth: _d.getDate()
          };
        }
      }
      if ('years' in duration) {
        if ('year' in start) {
          return {
            year: start.year + duration.years,
            month: start.month,
            dayOfMonth: start.dayOfMonth
          };
        }
      }
      if ('months' in duration) {
        if ('month' in start) {
          return {
            year: start.year,
            month: start.month + duration.months,
            dayOfMonth: start.dayOfMonth
          };
        }
      }
    }
    return start;
  };
  var timexTimeAdd$1 = function timexTimeAdd$1(start, duration) {
    if ('hours' in duration) {
      var result = Object.assign({}, start);
      result.hour += duration.hours;
      if (result.hour > 23) {
        var _days = Math.floor(result.hour / 24);
        var hour = result.hour % 24;
        result.hour = hour;
        if ('year' in result && 'month' in result && 'dayOfMonth' in result) {
          var d = new Date(result.year, result.month - 1, result.dayOfMonth, 0, 0, 0);
          for (var i = 0; i < _days; i++) {
            d.setDate(d.getDate() + 1);
          }
          result.year = d.getFullYear();
          result.month = d.getMonth() + 1;
          result.dayOfMonth = d.getDate();
          return result;
        }
        if ('dayOfWeek' in result) {
          result.dayOfWeek += _days;
          return result;
        }
      }
      return result;
    }
    if ('minutes' in duration) {
      var _result = Object.assign({}, start);
      _result.minute += duration.minutes;
      if (_result.minute > 59) {
        _result.hour++;
        _result.minute = 0;
      }
      return _result;
    }
    return start;
  };
  var timexDateTimeAdd$1 = function timexDateTimeAdd$1(start, duration) {
    return timexTimeAdd$1(timexDateAdd$1(start, duration), duration);
  };
  var expandDateTimeRange = function expandDateTimeRange(timex) {
    var types = 'types' in timex ? timex.types : timexInference.infer(timex);
    if (types.has('duration')) {
      var start = cloneDateTime(timex);
      var duration = cloneDuration(timex);
      return {
        start: start,
        end: timexDateTimeAdd$1(start, duration),
        duration: duration
      };
    } else {
      if ('year' in timex) {
        var range = {
          start: {
            year: timex.year
          },
          end: {}
        };
        if ('month' in timex) {
          range.start.month = timex.month;
          range.start.dayOfMonth = 1;
          range.end.year = timex.year;
          range.end.month = timex.month + 1;
          range.end.dayOfMonth = 1;
        } else {
          range.start.month = 1;
          range.start.dayOfMonth = 1;
          range.end.year = timex.year + 1;
          range.end.month = 1;
          range.end.dayOfMonth = 1;
        }
        return range;
      }
    }
    return {
      start: {},
      end: {}
    };
  };
  var timeAdd = function timeAdd(start, duration) {
    var hours = duration.hours || 0;
    var minutes = duration.minutes || 0;
    var seconds = duration.seconds || 0;
    return {
      hour: start.hour + hours,
      minute: start.minute + minutes,
      second: start.second + seconds
    };
  };
  var expandTimeRange = function expandTimeRange(timex) {
    if (!timex.types.has('timerange')) {
      throw new exception('argument must be a timerange');
    }
    if (timex.partOfDay !== undefined) {
      switch (timex.partOfDay) {
        case 'DT':
          timex = {
            hour: 8,
            minute: 0,
            second: 0,
            hours: 10,
            minutes: 0,
            seconds: 0
          };
          break;
        case 'MO':
          timex = {
            hour: 8,
            minute: 0,
            second: 0,
            hours: 4,
            minutes: 0,
            seconds: 0
          };
          break;
        case 'AF':
          timex = {
            hour: 12,
            minute: 0,
            second: 0,
            hours: 4,
            minutes: 0,
            seconds: 0
          };
          break;
        case 'EV':
          timex = {
            hour: 16,
            minute: 0,
            second: 0,
            hours: 4,
            minutes: 0,
            seconds: 0
          };
          break;
        case 'NI':
          timex = {
            hour: 20,
            minute: 0,
            second: 0,
            hours: 4,
            minutes: 0,
            seconds: 0
          };
          break;
        default:
          throw new exception('unrecognized part of day timerange');
      }
    }
    var start = {
      hour: timex.hour,
      minute: timex.minute,
      second: timex.second
    };
    var duration = cloneDuration(timex);
    return {
      start: start,
      end: timeAdd(start, duration),
      duration: duration
    };
  };
  var dateFromTimex = function dateFromTimex(timex) {
    var year = 'year' in timex ? timex.year : 2001;
    var month = 'month' in timex ? timex.month - 1 : 0;
    var date = 'dayOfMonth' in timex ? timex.dayOfMonth : 1;
    var hour = 'hour' in timex ? timex.hour : 0;
    var minute = 'minute' in timex ? timex.minute : 0;
    var second = 'second' in timex ? timex.second : 0;
    return new Date(year, month, date, hour, minute, second);
  };
  var timeFromTimex = function timeFromTimex(timex) {
    var hour = timex.hour || 0;
    var minute = timex.minute || 0;
    var second = timex.second || 0;
    return new Time$1(hour, minute, second);
  };
  var dateRangeFromTimex = function dateRangeFromTimex(timex) {
    var expanded = expandDateTimeRange(timex);
    return {
      start: dateFromTimex(expanded.start),
      end: dateFromTimex(expanded.end)
    };
  };
  var timeRangeFromTimex = function timeRangeFromTimex(timex) {
    var expanded = expandTimeRange(timex);
    return {
      start: timeFromTimex(expanded.start),
      end: timeFromTimex(expanded.end)
    };
  };
  var timexHelpers = {
    expandDateTimeRange: expandDateTimeRange,
    expandTimeRange: expandTimeRange,
    dateFromTimex: dateFromTimex,
    timeFromTimex: timeFromTimex,
    dateRangeFromTimex: dateRangeFromTimex,
    timeRangeFromTimex: timeRangeFromTimex,
    timexTimeAdd: timexTimeAdd$1,
    timexDateTimeAdd: timexDateTimeAdd$1
  };

  // Copyright (c) Microsoft Corporation. All rights reserved.

  var fixedFormatNumber = timexDateHelpers.fixedFormatNumber;
  var formatDuration = function formatDuration(timex) {
    if ('years' in timex) {
      return "P".concat(timex.years, "Y");
    }
    if ('months' in timex) {
      return "P".concat(timex.months, "M");
    }
    if ('weeks' in timex) {
      return "P".concat(timex.weeks, "W");
    }
    if ('days' in timex) {
      return "P".concat(timex.days, "D");
    }
    if ('hours' in timex) {
      return "PT".concat(timex.hours, "H");
    }
    if ('minutes' in timex) {
      return "PT".concat(timex.minutes, "M");
    }
    if ('seconds' in timex) {
      return "PT".concat(timex.seconds, "S");
    }
    return '';
  };
  var formatTime = function formatTime(timex) {
    if (timex.minute === 0 && timex.second === 0) {
      return "T".concat(fixedFormatNumber(timex.hour, 2));
    }
    if (timex.second === 0) {
      return "T".concat(fixedFormatNumber(timex.hour, 2), ":").concat(fixedFormatNumber(timex.minute, 2));
    }
    return "T".concat(fixedFormatNumber(timex.hour, 2), ":").concat(fixedFormatNumber(timex.minute, 2), ":").concat(fixedFormatNumber(timex.second, 2));
  };
  var formatDate = function formatDate(timex) {
    if ('year' in timex && 'month' in timex && 'dayOfMonth' in timex) {
      return "".concat(fixedFormatNumber(timex.year, 4), "-").concat(fixedFormatNumber(timex.month, 2), "-").concat(fixedFormatNumber(timex.dayOfMonth, 2));
    }
    if ('month' in timex && 'dayOfMonth' in timex) {
      return "XXXX-".concat(fixedFormatNumber(timex.month, 2), "-").concat(fixedFormatNumber(timex.dayOfMonth, 2));
    }
    if ('dayOfWeek' in timex) {
      return "XXXX-WXX-".concat(timex.dayOfWeek);
    }
    return '';
  };
  var formatDateRange = function formatDateRange(timex) {
    if ('year' in timex && 'weekOfYear' in timex && 'weekend' in timex) {
      return "".concat(fixedFormatNumber(timex.year, 4), "-W").concat(fixedFormatNumber(timex.weekOfYear, 2), "-WE");
    }
    if ('year' in timex && 'weekOfYear' in timex) {
      return "".concat(fixedFormatNumber(timex.year, 4), "-W").concat(fixedFormatNumber(timex.weekOfYear, 2));
    }
    if ('year' in timex && 'season' in timex) {
      return "".concat(fixedFormatNumber(timex.year, 4), "-").concat(timex.season);
    }
    if ('season' in timex) {
      return "".concat(timex.season);
    }
    if ('year' in timex && 'month' in timex) {
      return "".concat(fixedFormatNumber(timex.year, 4), "-").concat(fixedFormatNumber(timex.month, 2));
    }
    if ('year' in timex) {
      return "".concat(fixedFormatNumber(timex.year, 4));
    }
    if ('month' in timex && 'weekOfMonth' in timex && 'dayOfWeek' in timex) {
      return "XXXX-".concat(fixedFormatNumber(timex.month, 2), "-WXX-").concat(timex.weekOfMonth, "-").concat(timex.dayOfWeek);
    }
    if ('month' in timex && 'weekOfMonth' in timex) {
      return "XXXX-".concat(fixedFormatNumber(timex.month, 2), "-WXX-").concat(timex.weekOfMonth);
    }
    if ('month' in timex) {
      return "XXXX-".concat(fixedFormatNumber(timex.month, 2));
    }
    return '';
  };
  var formatTimeRange = function formatTimeRange(timex) {
    if ('partOfDay' in timex) {
      return "T".concat(timex.partOfDay);
    }
    return '';
  };
  var format = function format(timex) {
    var types = 'types' in timex ? timex.types : timexInference.infer(timex);
    if (types.has('present')) {
      return 'PRESENT_REF';
    }
    if ((types.has('datetimerange') || types.has('daterange') || types.has('timerange')) && types.has('duration')) {
      var range = timexHelpers.expandDateTimeRange(timex);
      return "(".concat(format(range.start), ",").concat(format(range.end), ",").concat(format(range.duration), ")");
    }
    if (types.has('datetimerange')) {
      return "".concat(formatDate(timex)).concat(formatTimeRange(timex));
    }
    if (types.has('daterange')) {
      return "".concat(formatDateRange(timex));
    }
    if (types.has('timerange')) {
      return "".concat(formatTimeRange(timex));
    }
    if (types.has('datetime')) {
      return "".concat(formatDate(timex)).concat(formatTime(timex));
    }
    if (types.has('duration')) {
      return "".concat(formatDuration(timex));
    }
    if (types.has('date')) {
      return "".concat(formatDate(timex));
    }
    if (types.has('time')) {
      return "".concat(formatTime(timex));
    }
    return '';
  };
  var format_1 = format;
  var timexFormat = {
    format: format_1
  };

  // Copyright (c) Microsoft Corporation. All rights reserved.

  var days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
  var months = ['January', 'Februrary', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
  var dateAbbreviation = {
    0: 'th',
    1: 'st',
    2: 'nd',
    3: 'rd',
    4: 'th',
    5: 'th',
    6: 'th',
    7: 'th',
    8: 'th',
    9: 'th'
  };
  var hours = ['midnight', '1AM', '2AM', '3AM', '4AM', '5AM', '6AM', '7AM', '8AM', '9AM', '10AM', '11AM', 'midday', '1PM', '2PM', '3PM', '4PM', '5PM', '6PM', '7PM', '8PM', '9PM', '10PM', '11PM'];
  var seasons = {
    SP: 'spring',
    SU: 'summer',
    FA: 'fall',
    WI: 'winter'
  };
  var weeks = ['first', 'second', 'third', 'forth'];
  var dayParts = {
    DT: 'daytime',
    NI: 'night',
    MO: 'morning',
    AF: 'afternoon',
    EV: 'evening'
  };
  var timexConstants = {
    days: days,
    months: months,
    dateAbbreviation: dateAbbreviation,
    hours: hours,
    seasons: seasons,
    weeks: weeks,
    dayParts: dayParts
  };

  // Copyright (c) Microsoft Corporation. All rights reserved.

  var convertDate = function convertDate(timex) {
    if ('dayOfWeek' in timex) {
      return timexConstants.days[timex.dayOfWeek - 1];
    }
    var month = timexConstants.months[timex.month - 1];
    var date = timex.dayOfMonth.toString();
    var abbreviation = timexConstants.dateAbbreviation[date.slice(-1)];
    if ('year' in timex) {
      return "".concat(date).concat(abbreviation, " ").concat(month, " ").concat(timex.year).trim();
    }
    return "".concat(date).concat(abbreviation, " ").concat(month);
  };
  var convertTime = function convertTime(timex) {
    if (timex.hour === 0 && timex.minute === 0 && timex.second === 0) {
      return 'midnight';
    }
    if (timex.hour === 12 && timex.minute === 0 && timex.second === 0) {
      return 'midday';
    }
    var pad = function pad(s) {
      return s.length === 1 ? '0' + s : s;
    };
    var hour = timex.hour === 0 ? '12' : timex.hour > 12 ? (timex.hour - 12).toString() : timex.hour.toString();
    var minute = timex.minute === 0 && timex.second === 0 ? '' : ':' + pad(timex.minute.toString());
    var second = timex.second === 0 ? '' : ':' + pad(timex.second.toString());
    var period = timex.hour < 12 ? 'AM' : 'PM';
    return "".concat(hour).concat(minute).concat(second).concat(period);
  };
  var convertDurationPropertyToString = function convertDurationPropertyToString(timex, property, includeSingleCount) {
    var propertyName = property + 's';
    var value = timex[propertyName];
    if (value !== undefined) {
      if (value === 1) {
        return includeSingleCount ? '1 ' + property : property;
      } else {
        return "".concat(value, " ").concat(property, "s");
      }
    }
    return false;
  };
  var convertTimexDurationToString = function convertTimexDurationToString(timex, includeSingleCount) {
    return convertDurationPropertyToString(timex, 'year', includeSingleCount) || convertDurationPropertyToString(timex, 'month', includeSingleCount) || convertDurationPropertyToString(timex, 'week', includeSingleCount) || convertDurationPropertyToString(timex, 'day', includeSingleCount) || convertDurationPropertyToString(timex, 'hour', includeSingleCount) || convertDurationPropertyToString(timex, 'minute', includeSingleCount) || convertDurationPropertyToString(timex, 'second', includeSingleCount);
  };
  var convertDuration = function convertDuration(timex) {
    return convertTimexDurationToString(timex, true);
  };
  var convertDateRange = function convertDateRange(timex) {
    var season = 'season' in timex ? timexConstants.seasons[timex.season] : '';
    var year = 'year' in timex ? timex.year.toString() : '';
    if ('weekOfYear' in timex) {
      if (timex.weekend) {
        return '';
      } else {
        return '';
      }
    }
    if ('month' in timex) {
      var month = "".concat(timexConstants.months[timex.month - 1]);
      if ('weekOfMonth' in timex) {
        return "".concat(timexConstants.weeks[timex.weekOfMonth - 1], " week of ").concat(month);
      } else {
        return "".concat(month, " ").concat(year).trim();
      }
    }
    return "".concat(season, " ").concat(year).trim();
  };
  var convertTimeRange = function convertTimeRange(timex) {
    return timexConstants.dayParts[timex.partOfDay];
  };
  var convertDateTime = function convertDateTime(timex) {
    return "".concat(convertTime(timex), " ").concat(convertDate(timex));
  };
  var convertDateTimeRange = function convertDateTimeRange(timex) {
    if (timex.types.has('timerange')) {
      return "".concat(convertDate(timex), " ").concat(convertTimeRange(timex));
    }
    // date + time + duration
    // - OR - 
    // date + duration
    return '';
  };
  var convertTimexToString = function convertTimexToString(timex) {
    var types = 'types' in timex ? timex.types : timexInference.infer(timex);
    if (types.has('present')) {
      return 'now';
    }
    if (types.has('datetimerange')) {
      return convertDateTimeRange(timex);
    }
    if (types.has('daterange')) {
      return convertDateRange(timex);
    }
    if (types.has('duration')) {
      return convertDuration(timex);
    }
    if (types.has('timerange')) {
      return convertTimeRange(timex);
    }

    // TODO: where appropriate delegate most the formatting delegate to Date.toLocaleString(options)
    if (types.has('datetime')) {
      return convertDateTime(timex);
    }
    if (types.has('date')) {
      return convertDate(timex);
    }
    if (types.has('time')) {
      return convertTime(timex);
    }
    return '';
  };
  var convertTimexSetToString = function convertTimexSetToString(timexSet) {
    var timex = timexSet.timex;
    if (timex.types.has('duration')) {
      return "every ".concat(convertTimexDurationToString(timex, false));
    } else {
      return "every ".concat(convertTimexToString(timex));
    }
  };
  var timexConvert$2 = {
    convertDate: convertDate,
    convertTime: convertTime,
    convertTimexToString: convertTimexToString,
    convertTimexSetToString: convertTimexSetToString
  };

  // Copyright (c) Microsoft Corporation. All rights reserved.

  var timexConvert = {
    convertTimexToString: timexConvert$2.convertTimexToString,
    convertTimexSetToString: timexConvert$2.convertTimexSetToString
  };

  // Copyright (c) Microsoft Corporation. All rights reserved.

  var getDateDay = function getDateDay(day) {
    var index = day === 0 ? 6 : day - 1;
    return timexConstants.days[index];
  };
  var convertDate$1 = function convertDate$1(timex, date) {
    if ('year' in timex && 'month' in timex && 'dayOfMonth' in timex) {
      var timexDate = new Date(timex.year, timex.month - 1, timex.dayOfMonth);
      if (timexDateHelpers.datePartEquals(timexDate, date)) {
        return 'today';
      }
      var _tomorrow = timexDateHelpers.tomorrow(date);
      if (timexDateHelpers.datePartEquals(timexDate, _tomorrow)) {
        return 'tomorrow';
      }
      var _yesterday = timexDateHelpers.yesterday(date);
      if (timexDateHelpers.datePartEquals(timexDate, _yesterday)) {
        return 'yesterday';
      }
      if (timexDateHelpers.isThisWeek(timexDate, date)) {
        return "this ".concat(getDateDay(timexDate.getDay()));
      }
      if (timexDateHelpers.isNextWeek(timexDate, date)) {
        return "next ".concat(getDateDay(timexDate.getDay()));
      }
      if (timexDateHelpers.isLastWeek(timexDate, date)) {
        return "last ".concat(getDateDay(timexDate.getDay()));
      }
    }
    return timexConvert$2.convertDate(timex);
  };
  var convertDateTime$1 = function convertDateTime$1(timex, date) {
    return "".concat(convertDate$1(timex, date), " ").concat(timexConvert$2.convertTime(timex));
  };
  var convertDateRange$1 = function convertDateRange$1(timex, date) {
    if ('year' in timex) {
      var year = date.getFullYear();
      if (timex.year === year) {
        if ('weekOfYear' in timex) {
          var _thisWeek = timexDateHelpers.weekOfYear(date);
          if (_thisWeek === timex.weekOfYear) {
            return timex.weekend ? 'this weekend' : 'this week';
          }
          if (_thisWeek === timex.weekOfYear + 1) {
            return timex.weekend ? 'last weekend' : 'last week';
          }
          if (_thisWeek === timex.weekOfYear - 1) {
            return timex.weekend ? 'next weekend' : 'next week';
          }
        }
        if ('month' in timex) {
          var isoMonth = date.getMonth() + 1;
          if (timex.month === isoMonth) {
            return 'this month';
          }
          if (timex.month === isoMonth + 1) {
            return 'next month';
          }
          if (timex.month === isoMonth - 1) {
            return 'last month';
          }
        }
        return 'season' in timex ? "this ".concat(timexConstants.seasons[timex.season]) : 'this year';
      }
      if (timex.year === year + 1) {
        return 'season' in timex ? "next ".concat(timexConstants.seasons[timex.season]) : 'next year';
      }
      if (timex.year === year - 1) {
        return 'season' in timex ? "last ".concat(timexConstants.seasons[timex.season]) : 'last year';
      }
    }
    return '';
  };
  var convertDateTimeRange$1 = function convertDateTimeRange$1(timex, date) {
    if ('year' in timex && 'month' in timex && 'dayOfMonth' in timex) {
      var timexDate = new Date(timex.year, timex.month - 1, timex.dayOfMonth);
      if ('partOfDay' in timex) {
        if (timexDateHelpers.datePartEquals(timexDate, date)) {
          if (timex.partOfDay === 'NI') {
            return 'tonight';
          } else {
            return "this ".concat(timexConstants.dayParts[timex.partOfDay]);
          }
        }
        var _tomorrow2 = timexDateHelpers.tomorrow(date);
        if (timexDateHelpers.datePartEquals(timexDate, _tomorrow2)) {
          return "tomorrow ".concat(timexConstants.dayParts[timex.partOfDay]);
        }
        var _yesterday2 = timexDateHelpers.yesterday(date);
        if (timexDateHelpers.datePartEquals(timexDate, _yesterday2)) {
          return "yesterday ".concat(timexConstants.dayParts[timex.partOfDay]);
        }
        if (timexDateHelpers.isNextWeek(timexDate, date)) {
          return "next ".concat(getDateDay(timexDate.getDay()), " ").concat(timexConstants.dayParts[timex.partOfDay]);
        }
        if (timexDateHelpers.isLastWeek(timexDate, date)) {
          return "last ".concat(getDateDay(timexDate.getDay()), " ").concat(timexConstants.dayParts[timex.partOfDay]);
        }
      }
    }
    return '';
  };
  var convertTimexToStringRelative$1 = function convertTimexToStringRelative$1(timex, date) {
    var types = 'types' in timex ? timex.types : timexInference.infer(timex);
    if (types.has('datetimerange')) {
      return convertDateTimeRange$1(timex, date);
    }
    if (types.has('daterange')) {
      return convertDateRange$1(timex, date);
    }
    if (types.has('datetime')) {
      return convertDateTime$1(timex, date);
    }
    if (types.has('date')) {
      return convertDate$1(timex, date);
    }
    return timexConvert$2.convertTimexToString(timex);
  };
  var convertTimexToStringRelative_1 = convertTimexToStringRelative$1;
  var timexRelativeConvert$2 = {
    convertTimexToStringRelative: convertTimexToStringRelative_1
  };

  // Copyright (c) Microsoft Corporation. All rights reserved.

  var convertTimexToStringRelative = timexRelativeConvert$2.convertTimexToStringRelative;
  var timexRelativeConvert = {
    convertTimexToStringRelative: convertTimexToStringRelative
  };

  // Copyright (c) Microsoft Corporation. All rights reserved.
  var TimexProperty = /*#__PURE__*/function () {
    function TimexProperty(timex) {
      (0, _classCallCheck2.default)(this, TimexProperty);
      if (typeof timex === 'string') {
        timexParsing.parseString(timex, this);
      } else {
        timexParsing.fromObject(timex, this);
      }
      // TODO: constructing a Timex from a Timex should be very cheap
    }
    (0, _createClass2.default)(TimexProperty, [{
      key: "timex",
      get: function get() {
        return timexFormat.format(this);
      }
    }, {
      key: "types",
      get: function get() {
        return timexInference.infer(this);
      }
    }, {
      key: "toString",
      value: function toString() {
        return timexConvert.convertTimexToString(this);
      }

      // TODO: consider [locales[, options]] similar to Date.toLocaleString([locales[, options]])
    }, {
      key: "toNaturalLanguage",
      value: function toNaturalLanguage(referenceDate) {
        return timexRelativeConvert.convertTimexToStringRelative(this, referenceDate);
      }
    }], [{
      key: "fromDate",
      value: function fromDate(date) {
        return new TimexProperty({
          year: date.getFullYear(),
          month: date.getMonth() + 1,
          dayOfMonth: date.getDate()
        });
      }
    }, {
      key: "fromDateTime",
      value: function fromDateTime(date) {
        return new TimexProperty({
          year: date.getFullYear(),
          month: date.getMonth() + 1,
          dayOfMonth: date.getDate(),
          hour: date.getHours(),
          minute: date.getMinutes(),
          second: date.getSeconds()
        });
      }
    }, {
      key: "fromTime",
      value: function fromTime(time) {
        return new TimexProperty(time);
      }
    }]);
    return TimexProperty;
  }();
  var TimexProperty_1 = TimexProperty;
  var timexProperty = {
    TimexProperty: TimexProperty_1
  };

  // Copyright (c) Microsoft Corporation. All rights reserved.

  var TimexProperty$1 = timexProperty.TimexProperty;
  var TimexSet = /*#__PURE__*/(0, _createClass2.default)(function TimexSet(timex) {
    (0, _classCallCheck2.default)(this, TimexSet);
    this.timex = new TimexProperty$1(timex);
  });
  var TimexSet_1 = TimexSet;
  var timexSet = {
    TimexSet: TimexSet_1
  };

  // Copyright (c) Microsoft Corporation. All rights reserved.

  var TimexProperty$2 = timexProperty.TimexProperty;
  var today = function today(date) {
    return TimexProperty$2.fromDate(date || new Date()).timex;
  };
  var tomorrow$1 = function tomorrow$1(date) {
    var d = date === undefined ? new Date() : new Date(date.getTime());
    d.setDate(d.getDate() + 1);
    return TimexProperty$2.fromDate(d).timex;
  };
  var yesterday$1 = function yesterday$1(date) {
    var d = date === undefined ? new Date() : new Date(date.getTime());
    d.setDate(d.getDate() - 1);
    return TimexProperty$2.fromDate(d).timex;
  };
  var weekFromToday = function weekFromToday(date) {
    var d = date === undefined ? new Date() : new Date(date.getTime());
    return new TimexProperty$2(Object.assign(TimexProperty$2.fromDate(d), {
      days: 7
    })).timex;
  };
  var weekBackFromToday = function weekBackFromToday(date) {
    var d = date === undefined ? new Date() : new Date(date.getTime());
    d.setDate(d.getDate() - 7);
    return new TimexProperty$2(Object.assign(TimexProperty$2.fromDate(d), {
      days: 7
    })).timex;
  };
  var thisWeek = function thisWeek(date) {
    var d = date === undefined ? new Date() : new Date(date.getTime());
    d.setDate(d.getDate() - 7);
    var start = timexDateHelpers.dateOfNextDay(1, d);
    return new TimexProperty$2(Object.assign(TimexProperty$2.fromDate(start), {
      days: 7
    })).timex;
  };
  var nextWeek = function nextWeek(date) {
    var d = date === undefined ? new Date() : new Date(date.getTime());
    var start = timexDateHelpers.dateOfNextDay(1, d);
    return new TimexProperty$2(Object.assign(TimexProperty$2.fromDate(start), {
      days: 7
    })).timex;
  };
  var lastWeek = function lastWeek(date) {
    var d = date === undefined ? new Date() : new Date(date.getTime());
    var start = timexDateHelpers.dateOfLastDay(1, d);
    start.setDate(start.getDate() - 7);
    return new TimexProperty$2(Object.assign(TimexProperty$2.fromDate(start), {
      days: 7
    })).timex;
  };
  var nextWeeksFromToday = function nextWeeksFromToday(n, date) {
    var d = date === undefined ? new Date() : new Date(date.getTime());
    return new TimexProperty$2(Object.assign(TimexProperty$2.fromDate(d), {
      days: 7 * n
    })).timex;
  };

  // The following constants are consistent with the Recognizer results
  var monday = 'XXXX-WXX-1';
  var tuesday = 'XXXX-WXX-2';
  var wednesday = 'XXXX-WXX-3';
  var thursday = 'XXXX-WXX-4';
  var friday = 'XXXX-WXX-5';
  var saturday = 'XXXX-WXX-6';
  var sunday = 'XXXX-WXX-7';
  var morning = '(T08,T12,PT4H)';
  var afternoon = '(T12,T16,PT4H)';
  var evening = '(T16,T20,PT4H)';
  var daytime = '(T08,T18,PT10H)';
  var timexCreator = {
    today: today,
    tomorrow: tomorrow$1,
    yesterday: yesterday$1,
    weekFromToday: weekFromToday,
    weekBackFromToday: weekBackFromToday,
    thisWeek: thisWeek,
    nextWeek: nextWeek,
    lastWeek: lastWeek,
    nextWeeksFromToday: nextWeeksFromToday,
    monday: monday,
    tuesday: tuesday,
    wednesday: wednesday,
    thursday: thursday,
    friday: friday,
    saturday: saturday,
    sunday: sunday,
    morning: morning,
    afternoon: afternoon,
    evening: evening,
    daytime: daytime
  };

  // Copyright (c) Microsoft Corporation. All rights reserved.

  var isOverlapping = function isOverlapping(r1, r2) {
    return r1.end.getTime() > r2.start.getTime() && r1.start.getTime() <= r2.start.getTime() || r1.start.getTime() < r2.end.getTime() && r1.start.getTime() >= r2.start.getTime();
  };
  var collapseOverlapping = function collapseOverlapping(r1, r2, T) {
    return {
      start: new T(Math.max(r1.start.getTime(), r2.start.getTime())),
      end: new T(Math.min(r1.end.getTime(), r2.end.getTime()))
    };
  };
  var innerCollapse = function innerCollapse(ranges, T) {
    if (ranges.length === 1) {
      return false;
    }
    for (var i = 0; i < ranges.length; i++) {
      var r1 = ranges[i];
      for (var j = i + 1; j < ranges.length; j++) {
        var r2 = ranges[j];
        if (isOverlapping(r1, r2)) {
          ranges.splice(i, 1);
          ranges.splice(j - 1, 1);
          ranges.push(collapseOverlapping(r1, r2, T));
          return true;
        }
      }
    }
    return false;
  };
  var collapse = function collapse(ranges, T) {
    var r = ranges.slice(0);
    while (innerCollapse(r, T));
    r.sort(function (a, b) {
      return a.start.getTime() - b.start.getTime();
    });
    return r;
  };
  var timexConstraintsHelper = {
    collapse: collapse,
    isOverlapping: isOverlapping
  };

  // Copyright (c) Microsoft Corporation. All rights reserved.

  var Time$2 = time.Time;
  var TimexProperty$3 = timexProperty.TimexProperty;
  var resolveDefiniteAgainstConstraint = function resolveDefiniteAgainstConstraint(timex, constraint) {
    var timexDate = timexHelpers.dateFromTimex(timex);
    if (timexDate.getTime() >= constraint.start.getTime() && timexDate.getTime() < constraint.end.getTime()) {
      return [timex.timex];
    }
    return [];
  };
  var resolveDateAgainstConstraint = function resolveDateAgainstConstraint(timex, constraint) {
    if ('month' in timex && 'dayOfMonth' in timex) {
      var result = [];
      for (var year = constraint.start.getFullYear(); year <= constraint.end.getFullYear(); year++) {
        var r = resolveDefiniteAgainstConstraint(new TimexProperty$3(Object.assign({}, timex, {
          year: year
        })), constraint);
        if (r.length > 0) {
          result.push(r[0]);
        }
      }
      return result;
    }
    if ('dayOfWeek' in timex) {
      var day = timex.dayOfWeek === 7 ? 0 : timex.dayOfWeek;
      var dates = timexDateHelpers.datesMatchingDay(day, constraint.start, constraint.end);
      var _result2 = [];
      var _iterator2 = _createForOfIteratorHelper(dates),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var d = _step2.value;
          var t = Object.assign({}, timex);
          delete t.dayOfWeek;
          var _r = new TimexProperty$3(Object.assign({}, t, {
            year: d.getFullYear(),
            month: d.getMonth() + 1,
            dayOfMonth: d.getDate()
          }));
          _result2.push(_r.timex);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return _result2;
    }
    return [];
  };
  var resolveDate = function resolveDate(timex, constraints) {
    var result = [];
    var _iterator3 = _createForOfIteratorHelper(constraints),
      _step3;
    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var constraint = _step3.value;
        Array.prototype.push.apply(result, resolveDateAgainstConstraint(timex, constraint));
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
    return result;
  };
  var resolveTimeAgainstConstraint = function resolveTimeAgainstConstraint(timex, constraint) {
    var t = new Time$2(timex.hour, timex.minute, timex.second);
    if (t.getTime() >= constraint.start.getTime() && t.getTime() < constraint.end.getTime()) {
      return [timex.timex];
    }
    return [];
  };
  var resolveTime = function resolveTime(timex, constraints) {
    var result = [];
    var _iterator4 = _createForOfIteratorHelper(constraints),
      _step4;
    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var constraint = _step4.value;
        Array.prototype.push.apply(result, resolveTimeAgainstConstraint(timex, constraint));
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }
    return result;
  };
  var removeDuplicates = function removeDuplicates(array) {
    var seen = new Set();
    return array.filter(function (item) {
      return seen.has(item) ? false : seen.add(item);
    });
  };
  var resolveByDateRangeConstraints = function resolveByDateRangeConstraints(candidates, timexConstraints) {
    var dateRangeConstraints = timexConstraints.filter(function (timex) {
      return timex.types.has('daterange');
    }).map(function (timex) {
      return timexHelpers.dateRangeFromTimex(timex);
    });
    var collapsedDateRanges = timexConstraintsHelper.collapse(dateRangeConstraints, Date);
    if (collapsedDateRanges.length === 0) {
      return candidates;
    }
    var resolution = [];
    var _iterator5 = _createForOfIteratorHelper(candidates),
      _step5;
    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        var timex = _step5.value;
        var r = resolveDate(new TimexProperty$3(timex), collapsedDateRanges);
        Array.prototype.push.apply(resolution, r);
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }
    return removeDuplicates(resolution);
  };
  var resolveByTimeConstraints = function resolveByTimeConstraints(candidates, timexConstraints) {
    var times = timexConstraints.filter(function (timex) {
      return timex.types.has('time');
    }).map(function (timex) {
      return timexHelpers.timeFromTimex(timex);
    });
    if (times.length === 0) {
      return candidates;
    }
    var resolution = [];
    var _iterator6 = _createForOfIteratorHelper(candidates.map(function (t) {
        return new TimexProperty$3(t);
      })),
      _step6;
    try {
      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
        var timex = _step6.value;
        if (timex.types.has('date') && !timex.types.has('time')) {
          var _iterator7 = _createForOfIteratorHelper(times),
            _step7;
          try {
            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
              var time$$2 = _step7.value;
              timex.hour = time$$2.hour;
              timex.minute = time$$2.minute;
              timex.second = time$$2.second;
              resolution.push(timex.timex);
            }
          } catch (err) {
            _iterator7.e(err);
          } finally {
            _iterator7.f();
          }
        } else {
          resolution.push(timex.timex);
        }
      }
    } catch (err) {
      _iterator6.e(err);
    } finally {
      _iterator6.f();
    }
    return removeDuplicates(resolution);
  };
  var resolveByTimeRangeConstraints = function resolveByTimeRangeConstraints(candidates, timexConstraints) {
    var timeRangeConstraints = timexConstraints.filter(function (timex) {
      return timex.types.has('timerange');
    }).map(function (timex) {
      return timexHelpers.timeRangeFromTimex(timex);
    });
    var collapsedTimeRanges = timexConstraintsHelper.collapse(timeRangeConstraints, Time$2);
    if (collapsedTimeRanges.length === 0) {
      return candidates;
    }
    var resolution = [];
    var _iterator8 = _createForOfIteratorHelper(candidates),
      _step8;
    try {
      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
        var timex = _step8.value;
        var t = new TimexProperty$3(timex);
        if (t.types.has('timerange')) {
          var r = resolveTimeRange(t, collapsedTimeRanges);
          Array.prototype.push.apply(resolution, r);
        } else if (t.types.has('time')) {
          var _r2 = resolveTime(t, collapsedTimeRanges);
          Array.prototype.push.apply(resolution, _r2);
        }
      }
    } catch (err) {
      _iterator8.e(err);
    } finally {
      _iterator8.f();
    }
    return removeDuplicates(resolution);
  };
  var resolveTimeRange = function resolveTimeRange(timex, constraints) {
    var candidate = timexHelpers.timeRangeFromTimex(timex);
    var result = [];
    var _iterator9 = _createForOfIteratorHelper(constraints),
      _step9;
    try {
      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
        var constraint = _step9.value;
        if (timexConstraintsHelper.isOverlapping(candidate, constraint)) {
          var start = Math.max(candidate.start.getTime(), constraint.start.getTime());
          var time$$2 = new Time$2(start);

          // TODO: refer to comments in C# - consider first classing this clone/overwrite behavior
          var resolved = new TimexProperty$3(timex.timex);
          delete resolved.partOfDay;
          delete resolved.seconds;
          delete resolved.minutes;
          delete resolved.hours;
          resolved.second = time$$2.second;
          resolved.minute = time$$2.minute;
          resolved.hour = time$$2.hour;
          result.push(resolved.timex);
        }
      }
    } catch (err) {
      _iterator9.e(err);
    } finally {
      _iterator9.f();
    }
    return result;
  };
  var resolveDuration = function resolveDuration(candidate, constraints) {
    var results = [];
    var _iterator10 = _createForOfIteratorHelper(constraints),
      _step10;
    try {
      for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
        var constraint = _step10.value;
        if (constraint.types.has('datetime')) {
          results.push(new TimexProperty$3(timexHelpers.timexDateTimeAdd(constraint, candidate)));
        } else if (constraint.types.has('time')) {
          results.push(new TimexProperty$3(timexHelpers.timexTimeAdd(constraint, candidate)));
        }
      }
    } catch (err) {
      _iterator10.e(err);
    } finally {
      _iterator10.f();
    }
    return results;
  };
  var resolveDurations = function resolveDurations(candidates, constraints) {
    var results = [];
    var _iterator11 = _createForOfIteratorHelper(candidates),
      _step11;
    try {
      for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
        var candidate = _step11.value;
        var timex = new TimexProperty$3(candidate);
        if (timex.types.has('duration')) {
          var r = resolveDuration(timex, constraints);
          var _iterator12 = _createForOfIteratorHelper(r),
            _step12;
          try {
            for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
              var resolved = _step12.value;
              results.push(resolved.timex);
            }
          } catch (err) {
            _iterator12.e(err);
          } finally {
            _iterator12.f();
          }
        } else {
          results.push(candidate);
        }
      }
    } catch (err) {
      _iterator11.e(err);
    } finally {
      _iterator11.f();
    }
    return results;
  };
  var evaluate = function evaluate(candidates, constraints) {
    var timexConstraints = constraints.map(function (x) {
      return new TimexProperty$3(x);
    });
    var candidatesWithDurationsResolved = resolveDurations(candidates, timexConstraints);
    var candidatesAccordingToDate = resolveByDateRangeConstraints(candidatesWithDurationsResolved, timexConstraints);
    var candidatesWithAddedTime = resolveByTimeConstraints(candidatesAccordingToDate, timexConstraints);
    var candidatesFilteredByTime = resolveByTimeRangeConstraints(candidatesWithAddedTime, timexConstraints);
    var timexResults = candidatesFilteredByTime.map(function (x) {
      return new TimexProperty$3(x);
    });
    return timexResults;
  };
  var timexRangeResolver = {
    evaluate: evaluate
  };

  // Copyright (c) Microsoft Corporation. All rights reserved.

  var fixedFormatNumber$2 = timexDateHelpers.fixedFormatNumber;
  var dateValue = function dateValue(obj) {
    if (obj.year !== undefined && obj.month !== undefined && obj.dayOfMonth !== undefined) {
      return "".concat(fixedFormatNumber$2(obj.year, 4), "-").concat(fixedFormatNumber$2(obj.month, 2), "-").concat(fixedFormatNumber$2(obj.dayOfMonth, 2));
    }
    return '';
  };
  var timeValue = function timeValue(obj) {
    if (obj.hour !== undefined && obj.minute !== undefined && obj.second !== undefined) {
      return "".concat(fixedFormatNumber$2(obj.hour, 2), ":").concat(fixedFormatNumber$2(obj.minute, 2), ":").concat(fixedFormatNumber$2(obj.second, 2));
    }
    return '';
  };
  var datetimeValue = function datetimeValue(obj) {
    return "".concat(dateValue(obj), " ").concat(timeValue(obj));
  };
  var durationValue = function durationValue(obj) {
    if (obj.years !== undefined) {
      return (31536000 * obj.years).toString();
    }
    if (obj.months !== undefined) {
      return (2592000 * obj.months).toString();
    }
    if (obj.weeks !== undefined) {
      return (604800 * obj.weeks).toString();
    }
    if (obj.days !== undefined) {
      return (86400 * obj.days).toString();
    }
    if (obj.hours !== undefined) {
      return (3600 * obj.hours).toString();
    }
    if (obj.minutes !== undefined) {
      return (60 * obj.minutes).toString();
    }
    if (obj.seconds !== undefined) {
      return obj.seconds.toString();
    }
    return '';
  };
  var timexValue = {
    dateValue: dateValue,
    timeValue: timeValue,
    datetimeValue: datetimeValue,
    durationValue: durationValue
  };

  // Copyright (c) Microsoft Corporation. All rights reserved.

  var TimexProperty$4 = timexProperty.TimexProperty;
  var dateOfLastDay$1 = timexDateHelpers.dateOfLastDay;
  var dateOfNextDay$1 = timexDateHelpers.dateOfNextDay;
  var resolveDefiniteTime = function resolveDefiniteTime(timex, date) {
    return [{
      timex: timex.timex,
      type: 'datetime',
      value: "".concat(timexValue.dateValue(timex), " ").concat(timexValue.timeValue(timex))
    }];
  };
  var resolveDefinite$1 = function resolveDefinite$1(timex, date) {
    return [{
      timex: timex.timex,
      type: 'date',
      value: timexValue.dateValue(timex)
    }];
  };
  var lastDateValue = function lastDateValue(timex, date) {
    if (timex.month !== undefined && timex.dayOfMonth !== undefined) {
      return timexValue.dateValue({
        year: date.getFullYear() - 1,
        month: timex.month,
        dayOfMonth: timex.dayOfMonth
      });
    }
    if (timex.dayOfWeek !== undefined) {
      var day = timex.dayOfWeek === 7 ? 0 : timex.dayOfWeek;
      var result = dateOfLastDay$1(day, date);
      return timexValue.dateValue({
        year: result.getFullYear(),
        month: result.getMonth() + 1,
        dayOfMonth: result.getDate()
      });
    }
  };
  var nextDateValue = function nextDateValue(timex, date) {
    if (timex.month !== undefined && timex.dayOfMonth !== undefined) {
      return timexValue.dateValue({
        year: date.getFullYear(),
        month: timex.month,
        dayOfMonth: timex.dayOfMonth
      });
    }
    if (timex.dayOfWeek !== undefined) {
      var day = timex.dayOfWeek === 7 ? 0 : timex.dayOfWeek;
      var result = dateOfNextDay$1(day, date);
      return timexValue.dateValue({
        year: result.getFullYear(),
        month: result.getMonth() + 1,
        dayOfMonth: result.getDate()
      });
    }
  };
  var resolveDate$1 = function resolveDate$1(timex, date) {
    return [{
      timex: timex.timex,
      type: 'date',
      value: lastDateValue(timex, date)
    }, {
      timex: timex.timex,
      type: 'date',
      value: nextDateValue(timex, date)
    }];
  };
  var resolveTime$1 = function resolveTime$1(timex) {
    return [{
      timex: timex.timex,
      type: 'time',
      value: timexValue.timeValue(timex)
    }];
  };
  var resolveDuration$1 = function resolveDuration$1(timex) {
    return [{
      timex: timex.timex,
      type: 'duration',
      value: timexValue.durationValue(timex)
    }];
  };
  var weekDateRange = function weekDateRange(year, weekOfYear) {
    var dateInWeek = new Date(year, 0, 1);
    dateInWeek.setDate(dateInWeek.getDate() + (weekOfYear - 1) * 7);
    var start = dateOfLastDay$1(1, dateInWeek);
    dateInWeek.setDate(dateInWeek.getDate() + 7);
    var end = dateOfLastDay$1(1, dateInWeek);
    return {
      start: timexValue.dateValue({
        year: start.getFullYear(),
        month: start.getMonth() + 1,
        dayOfMonth: start.getDate()
      }),
      end: timexValue.dateValue({
        year: end.getFullYear(),
        month: end.getMonth() + 1,
        dayOfMonth: end.getDate()
      })
    };
  };
  var monthDateRange = function monthDateRange(year, month) {
    return {
      start: timexValue.dateValue({
        year: year,
        month: month,
        dayOfMonth: 1
      }),
      end: timexValue.dateValue({
        year: year,
        month: month + 1,
        dayOfMonth: 1
      })
    };
  };
  var yearDateRange = function yearDateRange(year) {
    return {
      start: timexValue.dateValue({
        year: year,
        month: 1,
        dayOfMonth: 1
      }),
      end: timexValue.dateValue({
        year: year + 1,
        month: 1,
        dayOfMonth: 1
      })
    };
  };
  var resolveDateRange = function resolveDateRange(timex, date) {
    if ('season' in timex) {
      return [{
        timex: timex.timex,
        type: 'daterange',
        value: 'not resolved'
      }];
    } else {
      if (timex.year !== undefined && timex.month !== undefined) {
        var dateRange = monthDateRange(timex.year, timex.month);
        return [{
          timex: timex.timex,
          type: 'daterange',
          start: dateRange.start,
          end: dateRange.end
        }];
      }
      if (timex.year !== undefined && timex.weekOfYear !== undefined) {
        var _dateRange = weekDateRange(timex.year, timex.weekOfYear);
        return [{
          timex: timex.timex,
          type: 'daterange',
          start: _dateRange.start,
          end: _dateRange.end
        }];
      }
      if (timex.month !== undefined) {
        var y = date.getFullYear();
        var lastYearDateRange = monthDateRange(y - 1, timex.month);
        var thisYearDateRange = monthDateRange(y, timex.month);
        return [{
          timex: timex.timex,
          type: 'daterange',
          start: lastYearDateRange.start,
          end: lastYearDateRange.end
        }, {
          timex: timex.timex,
          type: 'daterange',
          start: thisYearDateRange.start,
          end: thisYearDateRange.end
        }];
      }
      if (timex.year !== undefined) {
        var _dateRange2 = yearDateRange(timex.year);
        return [{
          timex: timex.timex,
          type: 'daterange',
          start: _dateRange2.start,
          end: _dateRange2.end
        }];
      }
      return [];
    }
  };
  var partOfDayTimeRange = function partOfDayTimeRange(timex) {
    switch (timex.partOfDay) {
      case 'MO':
        return {
          start: '08:00:00',
          end: '12:00:00'
        };
      case 'AF':
        return {
          start: '12:00:00',
          end: '16:00:00'
        };
      case 'EV':
        return {
          start: '16:00:00',
          end: '20:00:00'
        };
      case 'NI':
        return {
          start: '20:00:00',
          end: '24:00:00'
        };
    }
    return {
      start: 'not resolved',
      end: 'not resolved'
    };
  };
  var resolveTimeRange$1 = function resolveTimeRange$1(timex, date) {
    if ('partOfDay' in timex) {
      var range = partOfDayTimeRange(timex);
      return [{
        timex: timex.timex,
        type: 'timerange',
        start: range.start,
        end: range.end
      }];
    } else {
      var _range = timexHelpers.expandTimeRange(timex);
      return [{
        timex: timex.timex,
        type: 'timerange',
        start: timexValue.timeValue(_range.start),
        end: timexValue.timeValue(_range.end)
      }];
    }
  };
  var resolveDateTime = function resolveDateTime(timex, date) {
    var resolvedDates = resolveDate$1(timex, date);
    var _iterator13 = _createForOfIteratorHelper(resolvedDates),
      _step13;
    try {
      for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
        var resolved = _step13.value;
        resolved.type = 'datetime';
        resolved.value = "".concat(resolved.value, " ").concat(timexValue.timeValue(timex));
      }
    } catch (err) {
      _iterator13.e(err);
    } finally {
      _iterator13.f();
    }
    return resolvedDates;
  };
  var resolveDateTimeRange = function resolveDateTimeRange(timex) {
    if ('partOfDay' in timex) {
      var date = timexValue.dateValue(timex);
      var timeRange = partOfDayTimeRange(timex);
      return [{
        timex: timex.timex,
        type: 'datetimerange',
        start: "".concat(date, " ").concat(timeRange.start),
        end: "".concat(date, " ").concat(timeRange.end)
      }];
    } else {
      var range = timexHelpers.expandDateTimeRange(timex);
      return [{
        timex: timex.timex,
        type: 'datetimerange',
        start: "".concat(timexValue.dateValue(range.start), " ").concat(timexValue.timeValue(range.start)),
        end: "".concat(timexValue.dateValue(range.end), " ").concat(timexValue.timeValue(range.end))
      }];
    }
  };
  var resolveDefiniteDateRange = function resolveDefiniteDateRange(timex) {
    var range = timexHelpers.expandDateTimeRange(timex);
    return [{
      timex: timex.timex,
      type: 'daterange',
      start: "".concat(timexValue.dateValue(range.start)),
      end: "".concat(timexValue.dateValue(range.end))
    }];
  };
  var resolveTimex = function resolveTimex(timex, date) {
    var types = 'types' in timex ? timex.types : timexInference.infer(timex);
    if (types.has('datetimerange')) {
      return resolveDateTimeRange(timex);
    }
    if (types.has('definite') && types.has('time')) {
      return resolveDefiniteTime(timex, date);
    }
    if (types.has('definite') && types.has('daterange')) {
      return resolveDefiniteDateRange(timex, date);
    }
    if (types.has('definite')) {
      return resolveDefinite$1(timex, date);
    }
    if (types.has('daterange')) {
      return resolveDateRange(timex, date);
    }
    if (types.has('timerange')) {
      return resolveTimeRange$1(timex);
    }
    if (types.has('datetime')) {
      return resolveDateTime(timex, date);
    }
    if (types.has('duration')) {
      return resolveDuration$1(timex);
    }
    if (types.has('date')) {
      return resolveDate$1(timex, date);
    }
    if (types.has('time')) {
      return resolveTime$1(timex);
    }
    return [];
  };
  var resolve = function resolve(timexArray, date) {
    var resolution = {
      values: []
    };
    var _iterator14 = _createForOfIteratorHelper(timexArray),
      _step14;
    try {
      for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
        var timex = _step14.value;
        var t = new TimexProperty$4(timex);
        var r = resolveTimex(t, date);
        Array.prototype.push.apply(resolution.values, r);
      }
    } catch (err) {
      _iterator14.e(err);
    } finally {
      _iterator14.f();
    }
    return resolution;
  };
  var timexResolver = {
    resolve: resolve
  };

  // Copyright (c) Microsoft Corporation. All rights reserved.

  var datatypesDateTime = {
    Time: time.Time,
    TimexProperty: timexProperty.TimexProperty,
    TimexSet: timexSet.TimexSet,
    creator: timexCreator,
    resolver: timexRangeResolver,
    valueResolver: timexResolver
  };
  var datatypesDateTime_1 = datatypesDateTime.Time;
  var datatypesDateTime_2 = datatypesDateTime.TimexProperty;
  var datatypesDateTime_3 = datatypesDateTime.TimexSet;
  var datatypesDateTime_4 = datatypesDateTime.creator;
  var datatypesDateTime_5 = datatypesDateTime.resolver;
  var datatypesDateTime_6 = datatypesDateTime.valueResolver;
  exports['default'] = datatypesDateTime;
  exports.Time = datatypesDateTime_1;
  exports.TimexProperty = datatypesDateTime_2;
  exports.TimexSet = datatypesDateTime_3;
  exports.creator = datatypesDateTime_4;
  exports.resolver = datatypesDateTime_5;
  exports.valueResolver = datatypesDateTime_6;
  return exports;
}({});

},{"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.array.filter.js":572,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.map.js":579,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.array.sort.js":581,"core-js/modules/es.array.splice.js":582,"core-js/modules/es.function.name.js":584,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.object.assign.js":601,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.set.js":621,"core-js/modules/es.string.ends-with.js":623,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.string.match.js":627,"core-js/modules/es.string.starts-with.js":632,"core-js/modules/es.string.trim.js":634,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],223:[function(require,module,exports){
'use strict';

// A linked list to keep track of recently-used-ness
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/web.dom-collections.for-each.js");
require("core-js/modules/es.array.map.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.map.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.array.filter.js");
var Yallist = require('yallist');
var MAX = Symbol('max');
var LENGTH = Symbol('length');
var LENGTH_CALCULATOR = Symbol('lengthCalculator');
var ALLOW_STALE = Symbol('allowStale');
var MAX_AGE = Symbol('maxAge');
var DISPOSE = Symbol('dispose');
var NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet');
var LRU_LIST = Symbol('lruList');
var CACHE = Symbol('cache');
var UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet');
var naiveLength = function naiveLength() {
  return 1;
};

// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
var LRUCache = /*#__PURE__*/function () {
  function LRUCache(options) {
    (0, _classCallCheck2.default)(this, LRUCache);
    if (typeof options === 'number') options = {
      max: options
    };
    if (!options) options = {};
    if (options.max && (typeof options.max !== 'number' || options.max < 0)) throw new TypeError('max must be a non-negative number');
    // Kind of weird to have a default max of Infinity, but oh well.
    var max = this[MAX] = options.max || Infinity;
    var lc = options.length || naiveLength;
    this[LENGTH_CALCULATOR] = typeof lc !== 'function' ? naiveLength : lc;
    this[ALLOW_STALE] = options.stale || false;
    if (options.maxAge && typeof options.maxAge !== 'number') throw new TypeError('maxAge must be a number');
    this[MAX_AGE] = options.maxAge || 0;
    this[DISPOSE] = options.dispose;
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
    this.reset();
  }

  // resize the cache when the max changes.
  (0, _createClass2.default)(LRUCache, [{
    key: "max",
    get: function get() {
      return this[MAX];
    },
    set: function set(mL) {
      if (typeof mL !== 'number' || mL < 0) throw new TypeError('max must be a non-negative number');
      this[MAX] = mL || Infinity;
      trim(this);
    }
  }, {
    key: "allowStale",
    get: function get() {
      return this[ALLOW_STALE];
    },
    set: function set(allowStale) {
      this[ALLOW_STALE] = !!allowStale;
    }
  }, {
    key: "maxAge",
    get: function get() {
      return this[MAX_AGE];
    }

    // resize the cache when the lengthCalculator changes.
    ,
    set: function set(mA) {
      if (typeof mA !== 'number') throw new TypeError('maxAge must be a non-negative number');
      this[MAX_AGE] = mA;
      trim(this);
    }
  }, {
    key: "lengthCalculator",
    get: function get() {
      return this[LENGTH_CALCULATOR];
    },
    set: function set(lC) {
      var _this = this;
      if (typeof lC !== 'function') lC = naiveLength;
      if (lC !== this[LENGTH_CALCULATOR]) {
        this[LENGTH_CALCULATOR] = lC;
        this[LENGTH] = 0;
        this[LRU_LIST].forEach(function (hit) {
          hit.length = _this[LENGTH_CALCULATOR](hit.value, hit.key);
          _this[LENGTH] += hit.length;
        });
      }
      trim(this);
    }
  }, {
    key: "length",
    get: function get() {
      return this[LENGTH];
    }
  }, {
    key: "itemCount",
    get: function get() {
      return this[LRU_LIST].length;
    }
  }, {
    key: "rforEach",
    value: function rforEach(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this[LRU_LIST].tail; walker !== null;) {
        var prev = walker.prev;
        forEachStep(this, fn, walker, thisp);
        walker = prev;
      }
    }
  }, {
    key: "forEach",
    value: function forEach(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this[LRU_LIST].head; walker !== null;) {
        var next = walker.next;
        forEachStep(this, fn, walker, thisp);
        walker = next;
      }
    }
  }, {
    key: "keys",
    value: function keys() {
      return this[LRU_LIST].toArray().map(function (k) {
        return k.key;
      });
    }
  }, {
    key: "values",
    value: function values() {
      return this[LRU_LIST].toArray().map(function (k) {
        return k.value;
      });
    }
  }, {
    key: "reset",
    value: function reset() {
      var _this2 = this;
      if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
        this[LRU_LIST].forEach(function (hit) {
          return _this2[DISPOSE](hit.key, hit.value);
        });
      }
      this[CACHE] = new Map(); // hash of items by key
      this[LRU_LIST] = new Yallist(); // list of items in order of use recency
      this[LENGTH] = 0; // length of items in the list
    }
  }, {
    key: "dump",
    value: function dump() {
      var _this3 = this;
      return this[LRU_LIST].map(function (hit) {
        return isStale(_this3, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        };
      }).toArray().filter(function (h) {
        return h;
      });
    }
  }, {
    key: "dumpLru",
    value: function dumpLru() {
      return this[LRU_LIST];
    }
  }, {
    key: "set",
    value: function set(key, value, maxAge) {
      maxAge = maxAge || this[MAX_AGE];
      if (maxAge && typeof maxAge !== 'number') throw new TypeError('maxAge must be a number');
      var now = maxAge ? Date.now() : 0;
      var len = this[LENGTH_CALCULATOR](value, key);
      if (this[CACHE].has(key)) {
        if (len > this[MAX]) {
          _del(this, this[CACHE].get(key));
          return false;
        }
        var node = this[CACHE].get(key);
        var item = node.value;

        // dispose of the old one before overwriting
        // split out into 2 ifs for better coverage tracking
        if (this[DISPOSE]) {
          if (!this[NO_DISPOSE_ON_SET]) this[DISPOSE](key, item.value);
        }
        item.now = now;
        item.maxAge = maxAge;
        item.value = value;
        this[LENGTH] += len - item.length;
        item.length = len;
        this.get(key);
        trim(this);
        return true;
      }
      var hit = new Entry(key, value, len, now, maxAge);

      // oversized objects fall out of cache automatically.
      if (hit.length > this[MAX]) {
        if (this[DISPOSE]) this[DISPOSE](key, value);
        return false;
      }
      this[LENGTH] += hit.length;
      this[LRU_LIST].unshift(hit);
      this[CACHE].set(key, this[LRU_LIST].head);
      trim(this);
      return true;
    }
  }, {
    key: "has",
    value: function has(key) {
      if (!this[CACHE].has(key)) return false;
      var hit = this[CACHE].get(key).value;
      return !isStale(this, hit);
    }
  }, {
    key: "get",
    value: function get(key) {
      return _get(this, key, true);
    }
  }, {
    key: "peek",
    value: function peek(key) {
      return _get(this, key, false);
    }
  }, {
    key: "pop",
    value: function pop() {
      var node = this[LRU_LIST].tail;
      if (!node) return null;
      _del(this, node);
      return node.value;
    }
  }, {
    key: "del",
    value: function del(key) {
      _del(this, this[CACHE].get(key));
    }
  }, {
    key: "load",
    value: function load(arr) {
      // reset the cache
      this.reset();
      var now = Date.now();
      // A previous serialized cache has the most recent items first
      for (var l = arr.length - 1; l >= 0; l--) {
        var hit = arr[l];
        var expiresAt = hit.e || 0;
        if (expiresAt === 0)
          // the item was created without expiration in a non aged cache
          this.set(hit.k, hit.v);else {
          var maxAge = expiresAt - now;
          // dont add already expired items
          if (maxAge > 0) {
            this.set(hit.k, hit.v, maxAge);
          }
        }
      }
    }
  }, {
    key: "prune",
    value: function prune() {
      var _this4 = this;
      this[CACHE].forEach(function (value, key) {
        return _get(_this4, key, false);
      });
    }
  }]);
  return LRUCache;
}();
var _get = function _get(self, key, doUse) {
  var node = self[CACHE].get(key);
  if (node) {
    var hit = node.value;
    if (isStale(self, hit)) {
      _del(self, node);
      if (!self[ALLOW_STALE]) return undefined;
    } else {
      if (doUse) {
        if (self[UPDATE_AGE_ON_GET]) node.value.now = Date.now();
        self[LRU_LIST].unshiftNode(node);
      }
    }
    return hit.value;
  }
};
var isStale = function isStale(self, hit) {
  if (!hit || !hit.maxAge && !self[MAX_AGE]) return false;
  var diff = Date.now() - hit.now;
  return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
};
var trim = function trim(self) {
  if (self[LENGTH] > self[MAX]) {
    for (var walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null;) {
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      var prev = walker.prev;
      _del(self, walker);
      walker = prev;
    }
  }
};
var _del = function _del(self, node) {
  if (node) {
    var hit = node.value;
    if (self[DISPOSE]) self[DISPOSE](hit.key, hit.value);
    self[LENGTH] -= hit.length;
    self[CACHE].delete(hit.key);
    self[LRU_LIST].removeNode(node);
  }
};
var Entry = /*#__PURE__*/(0, _createClass2.default)(function Entry(key, value, length, now, maxAge) {
  (0, _classCallCheck2.default)(this, Entry);
  this.key = key;
  this.value = value;
  this.length = length;
  this.now = now;
  this.maxAge = maxAge || 0;
});
var forEachStep = function forEachStep(self, fn, node, thisp) {
  var hit = node.value;
  if (isStale(self, hit)) {
    _del(self, node);
    if (!self[ALLOW_STALE]) hit = undefined;
  }
  if (hit) fn.call(thisp, hit.value, hit.key, self);
};
module.exports = LRUCache;

},{"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"core-js/modules/es.array.filter.js":572,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.map.js":579,"core-js/modules/es.map.js":587,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.promise.js":614,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.for-each.js":676,"core-js/modules/web.dom-collections.iterator.js":677,"yallist":225}],224:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
module.exports = function (Yallist) {
  Yallist.prototype[Symbol.iterator] = /*#__PURE__*/_regenerator.default.mark(function _callee() {
    var walker;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          walker = this.head;
        case 1:
          if (!walker) {
            _context.next = 7;
            break;
          }
          _context.next = 4;
          return walker.value;
        case 4:
          walker = walker.next;
          _context.next = 1;
          break;
        case 7:
        case "end":
          return _context.stop();
      }
    }, _callee, this);
  });
};

},{"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/regenerator":255,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],225:[function(require,module,exports){
'use strict';

require("core-js/modules/es.object.to-string.js");
require("core-js/modules/web.dom-collections.for-each.js");
require("core-js/modules/es.array.map.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.array.splice.js");
module.exports = Yallist;
Yallist.Node = Node;
Yallist.create = Yallist;
function Yallist(list) {
  var self = this;
  if (!(self instanceof Yallist)) {
    self = new Yallist();
  }
  self.tail = null;
  self.head = null;
  self.length = 0;
  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item);
    });
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i]);
    }
  }
  return self;
}
Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list');
  }
  var next = node.next;
  var prev = node.prev;
  if (next) {
    next.prev = prev;
  }
  if (prev) {
    prev.next = next;
  }
  if (node === this.head) {
    this.head = next;
  }
  if (node === this.tail) {
    this.tail = prev;
  }
  node.list.length--;
  node.next = null;
  node.prev = null;
  node.list = null;
  return next;
};
Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return;
  }
  if (node.list) {
    node.list.removeNode(node);
  }
  var head = this.head;
  node.list = this;
  node.next = head;
  if (head) {
    head.prev = node;
  }
  this.head = node;
  if (!this.tail) {
    this.tail = node;
  }
  this.length++;
};
Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return;
  }
  if (node.list) {
    node.list.removeNode(node);
  }
  var tail = this.tail;
  node.list = this;
  node.prev = tail;
  if (tail) {
    tail.next = node;
  }
  this.tail = node;
  if (!this.head) {
    this.head = node;
  }
  this.length++;
};
Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i]);
  }
  return this.length;
};
Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i]);
  }
  return this.length;
};
Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined;
  }
  var res = this.tail.value;
  this.tail = this.tail.prev;
  if (this.tail) {
    this.tail.next = null;
  } else {
    this.head = null;
  }
  this.length--;
  return res;
};
Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined;
  }
  var res = this.head.value;
  this.head = this.head.next;
  if (this.head) {
    this.head.prev = null;
  } else {
    this.tail = null;
  }
  this.length--;
  return res;
};
Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.next;
  }
};
Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.prev;
  }
};
Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next;
  }
  if (i === n && walker !== null) {
    return walker.value;
  }
};
Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev;
  }
  if (i === n && walker !== null) {
    return walker.value;
  }
};
Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist();
  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.next;
  }
  return res;
};
Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist();
  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.prev;
  }
  return res;
};
Yallist.prototype.reduce = function (fn, initial) {
  var acc;
  var walker = this.head;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.head) {
    walker = this.head.next;
    acc = this.head.value;
  } else {
    throw new TypeError('Reduce of empty list with no initial value');
  }
  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i);
    walker = walker.next;
  }
  return acc;
};
Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc;
  var walker = this.tail;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.tail) {
    walker = this.tail.prev;
    acc = this.tail.value;
  } else {
    throw new TypeError('Reduce of empty list with no initial value');
  }
  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i);
    walker = walker.prev;
  }
  return acc;
};
Yallist.prototype.toArray = function () {
  var arr = new Array(this.length);
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.next;
  }
  return arr;
};
Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length);
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.prev;
  }
  return arr;
};
Yallist.prototype.slice = function (from, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from = from || 0;
  if (from < 0) {
    from += this.length;
  }
  var ret = new Yallist();
  if (to < from || to < 0) {
    return ret;
  }
  if (from < 0) {
    from = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next;
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from = from || 0;
  if (from < 0) {
    from += this.length;
  }
  var ret = new Yallist();
  if (to < from || to < 0) {
    return ret;
  }
  if (from < 0) {
    from = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev;
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist.prototype.splice = function (start, deleteCount /*, ...nodes */) {
  if (start > this.length) {
    start = this.length - 1;
  }
  if (start < 0) {
    start = this.length + start;
  }
  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next;
  }
  var ret = [];
  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value);
    walker = this.removeNode(walker);
  }
  if (walker === null) {
    walker = this.tail;
  }
  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev;
  }
  for (var i = 2; i < arguments.length; i++) {
    walker = insert(this, walker, arguments[i]);
  }
  return ret;
};
Yallist.prototype.reverse = function () {
  var head = this.head;
  var tail = this.tail;
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev;
    walker.prev = walker.next;
    walker.next = p;
  }
  this.head = tail;
  this.tail = head;
  return this;
};
function insert(self, node, value) {
  var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);
  if (inserted.next === null) {
    self.tail = inserted;
  }
  if (inserted.prev === null) {
    self.head = inserted;
  }
  self.length++;
  return inserted;
}
function push(self, item) {
  self.tail = new Node(item, self.tail, null, self);
  if (!self.head) {
    self.head = self.tail;
  }
  self.length++;
}
function unshift(self, item) {
  self.head = new Node(item, null, self.head, self);
  if (!self.tail) {
    self.tail = self.head;
  }
  self.length++;
}
function Node(value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list);
  }
  this.list = list;
  this.value = value;
  if (prev) {
    prev.next = this;
    this.prev = prev;
  } else {
    this.prev = null;
  }
  if (next) {
    next.prev = this;
    this.next = next;
  } else {
    this.next = null;
  }
}
try {
  // add if support for Symbol.iterator is present
  require('./iterator.js')(Yallist);
} catch (er) {}

},{"./iterator.js":224,"core-js/modules/es.array.map.js":579,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.array.splice.js":582,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.promise.js":614,"core-js/modules/web.dom-collections.for-each.js":676}],226:[function(require,module,exports){
"use strict";

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{}],227:[function(require,module,exports){
"use strict";

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
module.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{}],228:[function(require,module,exports){
"use strict";

var arrayLikeToArray = require("./arrayLikeToArray.js");
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}
module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{"./arrayLikeToArray.js":226}],229:[function(require,module,exports){
"use strict";

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{}],230:[function(require,module,exports){
"use strict";

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{}],231:[function(require,module,exports){
"use strict";

require("core-js/modules/es.reflect.construct.js");
require("core-js/modules/es.object.to-string.js");
var setPrototypeOf = require("./setPrototypeOf.js");
var isNativeReflectConstruct = require("./isNativeReflectConstruct.js");
function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct.bind(), module.exports.__esModule = true, module.exports["default"] = module.exports;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
  return _construct.apply(null, arguments);
}
module.exports = _construct, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{"./isNativeReflectConstruct.js":239,"./setPrototypeOf.js":246,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],232:[function(require,module,exports){
"use strict";

var toPropertyKey = require("./toPropertyKey.js");
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{"./toPropertyKey.js":251}],233:[function(require,module,exports){
"use strict";

var toPropertyKey = require("./toPropertyKey.js");
function _defineProperty(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{"./toPropertyKey.js":251}],234:[function(require,module,exports){
"use strict";

require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.get.js");
require("core-js/modules/es.object.get-own-property-descriptor.js");
var superPropBase = require("./superPropBase.js");
function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    module.exports = _get = Reflect.get.bind(), module.exports.__esModule = true, module.exports["default"] = module.exports;
  } else {
    module.exports = _get = function _get(target, property, receiver) {
      var base = superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
  return _get.apply(this, arguments);
}
module.exports = _get, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{"./superPropBase.js":248,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.get.js":616}],235:[function(require,module,exports){
"use strict";

require("core-js/modules/es.object.set-prototype-of.js");
require("core-js/modules/es.object.get-prototype-of.js");
function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  return _getPrototypeOf(o);
}
module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{"core-js/modules/es.object.get-prototype-of.js":606,"core-js/modules/es.object.set-prototype-of.js":611}],236:[function(require,module,exports){
"use strict";

var setPrototypeOf = require("./setPrototypeOf.js");
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}
module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{"./setPrototypeOf.js":246}],237:[function(require,module,exports){
"use strict";

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{}],238:[function(require,module,exports){
"use strict";

require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
function _isNativeFunction(fn) {
  try {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  } catch (e) {
    return typeof fn === "function";
  }
}
module.exports = _isNativeFunction, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.to-string.js":620}],239:[function(require,module,exports){
"use strict";

require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
module.exports = _isNativeReflectConstruct, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],240:[function(require,module,exports){
"use strict";

require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.array.from.js");
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],241:[function(require,module,exports){
"use strict";

require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = !0,
      o = !1;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = !1;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = !0, n = r;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
module.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],242:[function(require,module,exports){
"use strict";

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
module.exports = _nonIterableRest, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{}],243:[function(require,module,exports){
"use strict";

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{}],244:[function(require,module,exports){
"use strict";

var _typeof = require("./typeof.js")["default"];
var assertThisInitialized = require("./assertThisInitialized.js");
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return assertThisInitialized(self);
}
module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{"./assertThisInitialized.js":229,"./typeof.js":252}],245:[function(require,module,exports){
"use strict";

require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.symbol.async-iterator.js");
require("core-js/modules/es.symbol.to-string-tag.js");
require("core-js/modules/es.json.to-string-tag.js");
require("core-js/modules/es.math.to-string-tag.js");
require("core-js/modules/es.object.get-prototype-of.js");
require("core-js/modules/web.dom-collections.for-each.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.object.set-prototype-of.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.array.slice.js");
var _typeof = require("./typeof.js")["default"];
function _regeneratorRuntime() {
  "use strict";

  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
  module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
    return e;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function define(t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function value(t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw new Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(_typeof(e) + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function stop() {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw new Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function complete(t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function finish(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    "catch": function _catch(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{"./typeof.js":252,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.json.to-string-tag.js":586,"core-js/modules/es.math.to-string-tag.js":591,"core-js/modules/es.object.get-prototype-of.js":606,"core-js/modules/es.object.set-prototype-of.js":611,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.promise.js":614,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.async-iterator.js":635,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/es.symbol.to-string-tag.js":640,"core-js/modules/web.dom-collections.for-each.js":676,"core-js/modules/web.dom-collections.iterator.js":677}],246:[function(require,module,exports){
"use strict";

require("core-js/modules/es.object.set-prototype-of.js");
function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  return _setPrototypeOf(o, p);
}
module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{"core-js/modules/es.object.set-prototype-of.js":611}],247:[function(require,module,exports){
"use strict";

var arrayWithHoles = require("./arrayWithHoles.js");
var iterableToArrayLimit = require("./iterableToArrayLimit.js");
var unsupportedIterableToArray = require("./unsupportedIterableToArray.js");
var nonIterableRest = require("./nonIterableRest.js");
function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}
module.exports = _slicedToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{"./arrayWithHoles.js":227,"./iterableToArrayLimit.js":241,"./nonIterableRest.js":242,"./unsupportedIterableToArray.js":253}],248:[function(require,module,exports){
"use strict";

var getPrototypeOf = require("./getPrototypeOf.js");
function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = getPrototypeOf(object);
    if (object === null) break;
  }
  return object;
}
module.exports = _superPropBase, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{"./getPrototypeOf.js":235}],249:[function(require,module,exports){
"use strict";

var arrayWithoutHoles = require("./arrayWithoutHoles.js");
var iterableToArray = require("./iterableToArray.js");
var unsupportedIterableToArray = require("./unsupportedIterableToArray.js");
var nonIterableSpread = require("./nonIterableSpread.js");
function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}
module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{"./arrayWithoutHoles.js":228,"./iterableToArray.js":240,"./nonIterableSpread.js":243,"./unsupportedIterableToArray.js":253}],250:[function(require,module,exports){
"use strict";

require("core-js/modules/es.symbol.to-primitive.js");
require("core-js/modules/es.date.to-primitive.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.number.constructor.js");
var _typeof = require("./typeof.js")["default"];
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
module.exports = _toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{"./typeof.js":252,"core-js/modules/es.date.to-primitive.js":583,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.js":638,"core-js/modules/es.symbol.to-primitive.js":639}],251:[function(require,module,exports){
"use strict";

var _typeof = require("./typeof.js")["default"];
var toPrimitive = require("./toPrimitive.js");
function _toPropertyKey(arg) {
  var key = toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
module.exports = _toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{"./toPrimitive.js":250,"./typeof.js":252}],252:[function(require,module,exports){
"use strict";

require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
function _typeof(o) {
  "@babel/helpers - typeof";

  return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(o);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],253:[function(require,module,exports){
"use strict";

require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.regexp.exec.js");
var arrayLikeToArray = require("./arrayLikeToArray.js");
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}
module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{"./arrayLikeToArray.js":226,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626}],254:[function(require,module,exports){
"use strict";

require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.map.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
var getPrototypeOf = require("./getPrototypeOf.js");
var setPrototypeOf = require("./setPrototypeOf.js");
var isNativeFunction = require("./isNativeFunction.js");
var construct = require("./construct.js");
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;
  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !isNativeFunction(Class)) return Class;
    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);
      _cache.set(Class, Wrapper);
    }
    function Wrapper() {
      return construct(Class, arguments, getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return setPrototypeOf(Wrapper, Class);
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  return _wrapNativeSuper(Class);
}
module.exports = _wrapNativeSuper, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{"./construct.js":231,"./getPrototypeOf.js":235,"./isNativeFunction.js":238,"./setPrototypeOf.js":246,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.map.js":587,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.string.iterator.js":626,"core-js/modules/web.dom-collections.iterator.js":677}],255:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/esnext.global-this.js");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
// TODO(Babel 8): Remove this file.

var runtime = require("../helpers/regeneratorRuntime")();
module.exports = runtime;

// Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=
try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  if ((typeof globalThis === "undefined" ? "undefined" : (0, _typeof2.default)(globalThis)) === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}

},{"../helpers/regeneratorRuntime":245,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/esnext.global-this.js":675}],256:[function(require,module,exports){
'use strict';

/**
 * Ponyfill for `Array.prototype.find` which is only available in ES6 runtimes.
 *
 * Works with anything that has a `length` property and index access properties, including NodeList.
 *
 * @template {unknown} T
 * @param {Array<T> | ({length:number, [number]: T})} list
 * @param {function (item: T, index: number, list:Array<T> | ({length:number, [number]: T})):boolean} predicate
 * @param {Partial<Pick<ArrayConstructor['prototype'], 'find'>>?} ac `Array.prototype` by default,
 * 				allows injecting a custom implementation in tests
 * @returns {T | undefined}
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
 * @see https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.find
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.array.find.js");
require("core-js/modules/es.object.to-string.js");
function find(list, predicate, ac) {
  if (ac === undefined) {
    ac = Array.prototype;
  }
  if (list && typeof ac.find === 'function') {
    return ac.find.call(list, predicate);
  }
  for (var i = 0; i < list.length; i++) {
    if (Object.prototype.hasOwnProperty.call(list, i)) {
      var item = list[i];
      if (predicate.call(undefined, item, i, list)) {
        return item;
      }
    }
  }
}

/**
 * "Shallow freezes" an object to render it immutable.
 * Uses `Object.freeze` if available,
 * otherwise the immutability is only in the type.
 *
 * Is used to create "enum like" objects.
 *
 * @template T
 * @param {T} object the object to freeze
 * @param {Pick<ObjectConstructor, 'freeze'> = Object} oc `Object` by default,
 * 				allows to inject custom object constructor for tests
 * @returns {Readonly<T>}
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze
 */
function freeze(object, oc) {
  if (oc === undefined) {
    oc = Object;
  }
  return oc && typeof oc.freeze === 'function' ? oc.freeze(object) : object;
}

/**
 * Since we can not rely on `Object.assign` we provide a simplified version
 * that is sufficient for our needs.
 *
 * @param {Object} target
 * @param {Object | null | undefined} source
 *
 * @returns {Object} target
 * @throws TypeError if target is not an object
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 * @see https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.assign
 */
function assign(target, source) {
  if (target === null || (0, _typeof2.default)(target) !== 'object') {
    throw new TypeError('target is not an object');
  }
  for (var key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      target[key] = source[key];
    }
  }
  return target;
}

/**
 * All mime types that are allowed as input to `DOMParser.parseFromString`
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString#Argument02 MDN
 * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#domparsersupportedtype WHATWG HTML Spec
 * @see DOMParser.prototype.parseFromString
 */
var MIME_TYPE = freeze({
  /**
   * `text/html`, the only mime type that triggers treating an XML document as HTML.
   *
   * @see DOMParser.SupportedType.isHTML
   * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
   * @see https://en.wikipedia.org/wiki/HTML Wikipedia
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
   * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
   */
  HTML: 'text/html',
  /**
   * Helper method to check a mime type if it indicates an HTML document
   *
   * @param {string} [value]
   * @returns {boolean}
   *
   * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
   * @see https://en.wikipedia.org/wiki/HTML Wikipedia
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
   * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
  isHTML: function isHTML(value) {
    return value === MIME_TYPE.HTML;
  },
  /**
   * `application/xml`, the standard mime type for XML documents.
   *
   * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
   * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
   * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
   */
  XML_APPLICATION: 'application/xml',
  /**
   * `text/html`, an alias for `application/xml`.
   *
   * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
   * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
   * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
   */
  XML_TEXT: 'text/xml',
  /**
   * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
   * but is parsed as an XML document.
   *
   * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
   * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
   */
  XML_XHTML_APPLICATION: 'application/xhtml+xml',
  /**
   * `image/svg+xml`,
   *
   * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
   * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
   * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
   */
  XML_SVG_IMAGE: 'image/svg+xml'
});

/**
 * Namespaces that are used in this code base.
 *
 * @see http://www.w3.org/TR/REC-xml-names
 */
var NAMESPACE = freeze({
  /**
   * The XHTML namespace.
   *
   * @see http://www.w3.org/1999/xhtml
   */
  HTML: 'http://www.w3.org/1999/xhtml',
  /**
   * Checks if `uri` equals `NAMESPACE.HTML`.
   *
   * @param {string} [uri]
   *
   * @see NAMESPACE.HTML
   */
  isHTML: function isHTML(uri) {
    return uri === NAMESPACE.HTML;
  },
  /**
   * The SVG namespace.
   *
   * @see http://www.w3.org/2000/svg
   */
  SVG: 'http://www.w3.org/2000/svg',
  /**
   * The `xml:` namespace.
   *
   * @see http://www.w3.org/XML/1998/namespace
   */
  XML: 'http://www.w3.org/XML/1998/namespace',
  /**
   * The `xmlns:` namespace
   *
   * @see https://www.w3.org/2000/xmlns/
   */
  XMLNS: 'http://www.w3.org/2000/xmlns/'
});
exports.assign = assign;
exports.find = find;
exports.freeze = freeze;
exports.MIME_TYPE = MIME_TYPE;
exports.NAMESPACE = NAMESPACE;

},{"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.find.js":574,"core-js/modules/es.object.to-string.js":612}],257:[function(require,module,exports){
"use strict";

require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
var conventions = require("./conventions");
var dom = require('./dom');
var entities = require('./entities');
var sax = require('./sax');
var DOMImplementation = dom.DOMImplementation;
var NAMESPACE = conventions.NAMESPACE;
var ParseError = sax.ParseError;
var XMLReader = sax.XMLReader;

/**
 * Normalizes line ending according to https://www.w3.org/TR/xml11/#sec-line-ends:
 *
 * > XML parsed entities are often stored in computer files which,
 * > for editing convenience, are organized into lines.
 * > These lines are typically separated by some combination
 * > of the characters CARRIAGE RETURN (#xD) and LINE FEED (#xA).
 * >
 * > To simplify the tasks of applications, the XML processor must behave
 * > as if it normalized all line breaks in external parsed entities (including the document entity)
 * > on input, before parsing, by translating all of the following to a single #xA character:
 * >
 * > 1. the two-character sequence #xD #xA
 * > 2. the two-character sequence #xD #x85
 * > 3. the single character #x85
 * > 4. the single character #x2028
 * > 5. any #xD character that is not immediately followed by #xA or #x85.
 *
 * @param {string} input
 * @returns {string}
 */
function normalizeLineEndings(input) {
  return input.replace(/\r[\n\u0085]/g, '\n').replace(/[\r\u0085\u2028]/g, '\n');
}

/**
 * @typedef Locator
 * @property {number} [columnNumber]
 * @property {number} [lineNumber]
 */

/**
 * @typedef DOMParserOptions
 * @property {DOMHandler} [domBuilder]
 * @property {Function} [errorHandler]
 * @property {(string) => string} [normalizeLineEndings] used to replace line endings before parsing
 * 						defaults to `normalizeLineEndings`
 * @property {Locator} [locator]
 * @property {Record<string, string>} [xmlns]
 *
 * @see normalizeLineEndings
 */

/**
 * The DOMParser interface provides the ability to parse XML or HTML source code
 * from a string into a DOM `Document`.
 *
 * _xmldom is different from the spec in that it allows an `options` parameter,
 * to override the default behavior._
 *
 * @param {DOMParserOptions} [options]
 * @constructor
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser
 * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-parsing-and-serialization
 */
function DOMParser(options) {
  this.options = options || {
    locator: {}
  };
}
DOMParser.prototype.parseFromString = function (source, mimeType) {
  var options = this.options;
  var sax = new XMLReader();
  var domBuilder = options.domBuilder || new DOMHandler(); //contentHandler and LexicalHandler
  var errorHandler = options.errorHandler;
  var locator = options.locator;
  var defaultNSMap = options.xmlns || {};
  var isHTML = /\/x?html?$/.test(mimeType); //mimeType.toLowerCase().indexOf('html') > -1;
  var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
  if (locator) {
    domBuilder.setDocumentLocator(locator);
  }
  sax.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
  sax.domBuilder = options.domBuilder || domBuilder;
  if (isHTML) {
    defaultNSMap[''] = NAMESPACE.HTML;
  }
  defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
  var normalize = options.normalizeLineEndings || normalizeLineEndings;
  if (source && typeof source === 'string') {
    sax.parse(normalize(source), defaultNSMap, entityMap);
  } else {
    sax.errorHandler.error('invalid doc source');
  }
  return domBuilder.doc;
};
function buildErrorHandler(errorImpl, domBuilder, locator) {
  if (!errorImpl) {
    if (domBuilder instanceof DOMHandler) {
      return domBuilder;
    }
    errorImpl = domBuilder;
  }
  var errorHandler = {};
  var isCallback = errorImpl instanceof Function;
  locator = locator || {};
  function build(key) {
    var fn = errorImpl[key];
    if (!fn && isCallback) {
      fn = errorImpl.length == 2 ? function (msg) {
        errorImpl(key, msg);
      } : errorImpl;
    }
    errorHandler[key] = fn && function (msg) {
      fn('[xmldom ' + key + ']\t' + msg + _locator(locator));
    } || function () {};
  }
  build('warning');
  build('error');
  build('fatalError');
  return errorHandler;
}

//console.log('#\n\n\n\n\n\n\n####')
/**
 * +ContentHandler+ErrorHandler
 * +LexicalHandler+EntityResolver2
 * -DeclHandler-DTDHandler
 *
 * DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler
 * DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2
 * @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html
 */
function DOMHandler() {
  this.cdata = false;
}
function position(locator, node) {
  node.lineNumber = locator.lineNumber;
  node.columnNumber = locator.columnNumber;
}
/**
 * @see org.xml.sax.ContentHandler#startDocument
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html
 */
DOMHandler.prototype = {
  startDocument: function startDocument() {
    this.doc = new DOMImplementation().createDocument(null, null, null);
    if (this.locator) {
      this.doc.documentURI = this.locator.systemId;
    }
  },
  startElement: function startElement(namespaceURI, localName, qName, attrs) {
    var doc = this.doc;
    var el = doc.createElementNS(namespaceURI, qName || localName);
    var len = attrs.length;
    appendElement(this, el);
    this.currentElement = el;
    this.locator && position(this.locator, el);
    for (var i = 0; i < len; i++) {
      var namespaceURI = attrs.getURI(i);
      var value = attrs.getValue(i);
      var qName = attrs.getQName(i);
      var attr = doc.createAttributeNS(namespaceURI, qName);
      this.locator && position(attrs.getLocator(i), attr);
      attr.value = attr.nodeValue = value;
      el.setAttributeNode(attr);
    }
  },
  endElement: function endElement(namespaceURI, localName, qName) {
    var current = this.currentElement;
    var tagName = current.tagName;
    this.currentElement = current.parentNode;
  },
  startPrefixMapping: function startPrefixMapping(prefix, uri) {},
  endPrefixMapping: function endPrefixMapping(prefix) {},
  processingInstruction: function processingInstruction(target, data) {
    var ins = this.doc.createProcessingInstruction(target, data);
    this.locator && position(this.locator, ins);
    appendElement(this, ins);
  },
  ignorableWhitespace: function ignorableWhitespace(ch, start, length) {},
  characters: function characters(chars, start, length) {
    chars = _toString.apply(this, arguments);
    //console.log(chars)
    if (chars) {
      if (this.cdata) {
        var charNode = this.doc.createCDATASection(chars);
      } else {
        var charNode = this.doc.createTextNode(chars);
      }
      if (this.currentElement) {
        this.currentElement.appendChild(charNode);
      } else if (/^\s*$/.test(chars)) {
        this.doc.appendChild(charNode);
        //process xml
      }

      this.locator && position(this.locator, charNode);
    }
  },
  skippedEntity: function skippedEntity(name) {},
  endDocument: function endDocument() {
    this.doc.normalize();
  },
  setDocumentLocator: function setDocumentLocator(locator) {
    if (this.locator = locator) {
      // && !('lineNumber' in locator)){
      locator.lineNumber = 0;
    }
  },
  //LexicalHandler
  comment: function comment(chars, start, length) {
    chars = _toString.apply(this, arguments);
    var comm = this.doc.createComment(chars);
    this.locator && position(this.locator, comm);
    appendElement(this, comm);
  },
  startCDATA: function startCDATA() {
    //used in characters() methods
    this.cdata = true;
  },
  endCDATA: function endCDATA() {
    this.cdata = false;
  },
  startDTD: function startDTD(name, publicId, systemId) {
    var impl = this.doc.implementation;
    if (impl && impl.createDocumentType) {
      var dt = impl.createDocumentType(name, publicId, systemId);
      this.locator && position(this.locator, dt);
      appendElement(this, dt);
      this.doc.doctype = dt;
    }
  },
  /**
   * @see org.xml.sax.ErrorHandler
   * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
   */
  warning: function warning(error) {
    console.warn('[xmldom warning]\t' + error, _locator(this.locator));
  },
  error: function error(_error) {
    console.error('[xmldom error]\t' + _error, _locator(this.locator));
  },
  fatalError: function fatalError(error) {
    throw new ParseError(error, this.locator);
  }
};
function _locator(l) {
  if (l) {
    return '\n@' + (l.systemId || '') + '#[line:' + l.lineNumber + ',col:' + l.columnNumber + ']';
  }
}
function _toString(chars, start, length) {
  if (typeof chars == 'string') {
    return chars.substr(start, length);
  } else {
    //java sax connect width xmldom on rhino(what about: "? && !(chars instanceof String)")
    if (chars.length >= start + length || start) {
      return new java.lang.String(chars, start, length) + '';
    }
    return chars;
  }
}

/*
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html
 * used method of org.xml.sax.ext.LexicalHandler:
 *  #comment(chars, start, length)
 *  #startCDATA()
 *  #endCDATA()
 *  #startDTD(name, publicId, systemId)
 *
 *
 * IGNORED method of org.xml.sax.ext.LexicalHandler:
 *  #endDTD()
 *  #startEntity(name)
 *  #endEntity(name)
 *
 *
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html
 * IGNORED method of org.xml.sax.ext.DeclHandler
 * 	#attributeDecl(eName, aName, type, mode, value)
 *  #elementDecl(name, model)
 *  #externalEntityDecl(name, publicId, systemId)
 *  #internalEntityDecl(name, value)
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html
 * IGNORED method of org.xml.sax.EntityResolver2
 *  #resolveEntity(String name,String publicId,String baseURI,String systemId)
 *  #resolveEntity(publicId, systemId)
 *  #getExternalSubset(name, baseURI)
 * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html
 * IGNORED method of org.xml.sax.DTDHandler
 *  #notationDecl(name, publicId, systemId) {};
 *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};
 */
"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function (key) {
  DOMHandler.prototype[key] = function () {
    return null;
  };
});

/* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */
function appendElement(hander, node) {
  if (!hander.currentElement) {
    hander.doc.appendChild(node);
  } else {
    hander.currentElement.appendChild(node);
  }
} //appendChild and setAttributeNS are preformance key

exports.__DOMHandler = DOMHandler;
exports.normalizeLineEndings = normalizeLineEndings;
exports.DOMParser = DOMParser;

},{"./conventions":256,"./dom":258,"./entities":259,"./sax":261,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.string.replace.js":629}],258:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.array.find.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.array.filter.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.split.js");
require("core-js/modules/es.object.keys.js");
require("core-js/modules/es.array.join.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.array.slice.js");
var conventions = require("./conventions");
var find = conventions.find;
var NAMESPACE = conventions.NAMESPACE;

/**
 * A prerequisite for `[].filter`, to drop elements that are empty
 * @param {string} input
 * @returns {boolean}
 */
function notEmptyString(input) {
  return input !== '';
}
/**
 * @see https://infra.spec.whatwg.org/#split-on-ascii-whitespace
 * @see https://infra.spec.whatwg.org/#ascii-whitespace
 *
 * @param {string} input
 * @returns {string[]} (can be empty)
 */
function splitOnASCIIWhitespace(input) {
  // U+0009 TAB, U+000A LF, U+000C FF, U+000D CR, U+0020 SPACE
  return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
}

/**
 * Adds element as a key to current if it is not already present.
 *
 * @param {Record<string, boolean | undefined>} current
 * @param {string} element
 * @returns {Record<string, boolean | undefined>}
 */
function orderedSetReducer(current, element) {
  if (!current.hasOwnProperty(element)) {
    current[element] = true;
  }
  return current;
}

/**
 * @see https://infra.spec.whatwg.org/#ordered-set
 * @param {string} input
 * @returns {string[]}
 */
function toOrderedSet(input) {
  if (!input) return [];
  var list = splitOnASCIIWhitespace(input);
  return Object.keys(list.reduce(orderedSetReducer, {}));
}

/**
 * Uses `list.indexOf` to implement something like `Array.prototype.includes`,
 * which we can not rely on being available.
 *
 * @param {any[]} list
 * @returns {function(any): boolean}
 */
function arrayIncludes(list) {
  return function (element) {
    return list && list.indexOf(element) !== -1;
  };
}
function copy(src, dest) {
  for (var p in src) {
    if (Object.prototype.hasOwnProperty.call(src, p)) {
      dest[p] = src[p];
    }
  }
}

/**
^\w+\.prototype\.([_\w]+)\s*=\s*((?:.*\{\s*?[\r\n][\s\S]*?^})|\S.*?(?=[;\r\n]));?
^\w+\.prototype\.([_\w]+)\s*=\s*(\S.*?(?=[;\r\n]));?
 */
function _extends(Class, Super) {
  var pt = Class.prototype;
  if (!(pt instanceof Super)) {
    var t = function t() {};
    ;
    t.prototype = Super.prototype;
    t = new t();
    copy(pt, t);
    Class.prototype = pt = t;
  }
  if (pt.constructor != Class) {
    if (typeof Class != 'function') {
      console.error("unknown Class:" + Class);
    }
    pt.constructor = Class;
  }
}

// Node Types
var NodeType = {};
var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
var TEXT_NODE = NodeType.TEXT_NODE = 3;
var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
var NOTATION_NODE = NodeType.NOTATION_NODE = 12;

// ExceptionCode
var ExceptionCode = {};
var ExceptionMessage = {};
var INDEX_SIZE_ERR = ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
var DOMSTRING_SIZE_ERR = ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
var WRONG_DOCUMENT_ERR = ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
var INVALID_CHARACTER_ERR = ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
var NO_DATA_ALLOWED_ERR = ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
var NOT_SUPPORTED_ERR = ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
//level2
var INVALID_STATE_ERR = ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
var SYNTAX_ERR = ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
var INVALID_MODIFICATION_ERR = ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
var NAMESPACE_ERR = ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
var INVALID_ACCESS_ERR = ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);

/**
 * DOM Level 2
 * Object DOMException
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html
 * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html
 */
function DOMException(code, message) {
  if (message instanceof Error) {
    var error = message;
  } else {
    error = this;
    Error.call(this, ExceptionMessage[code]);
    this.message = ExceptionMessage[code];
    if (Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
  }
  error.code = code;
  if (message) this.message = this.message + ": " + message;
  return error;
}
;
DOMException.prototype = Error.prototype;
copy(ExceptionCode, DOMException);

/**
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177
 * The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.
 * The items in the NodeList are accessible via an integral index, starting from 0.
 */
function NodeList() {}
;
NodeList.prototype = {
  /**
   * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
   * @standard level1
   */
  length: 0,
  /**
   * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
   * @standard level1
   * @param index  unsigned long
   *   Index into the collection.
   * @return Node
   * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
   */
  item: function item(index) {
    return index >= 0 && index < this.length ? this[index] : null;
  },
  toString: function toString(isHTML, nodeFilter) {
    for (var buf = [], i = 0; i < this.length; i++) {
      serializeToString(this[i], buf, isHTML, nodeFilter);
    }
    return buf.join('');
  },
  /**
   * @private
   * @param {function (Node):boolean} predicate
   * @returns {Node[]}
   */
  filter: function filter(predicate) {
    return Array.prototype.filter.call(this, predicate);
  },
  /**
   * @private
   * @param {Node} item
   * @returns {number}
   */
  indexOf: function indexOf(item) {
    return Array.prototype.indexOf.call(this, item);
  }
};
function LiveNodeList(node, refresh) {
  this._node = node;
  this._refresh = refresh;
  _updateLiveList(this);
}
function _updateLiveList(list) {
  var inc = list._node._inc || list._node.ownerDocument._inc;
  if (list._inc !== inc) {
    var ls = list._refresh(list._node);
    __set__(list, 'length', ls.length);
    if (!list.$$length || ls.length < list.$$length) {
      for (var i = ls.length; (i in list); i++) {
        if (Object.prototype.hasOwnProperty.call(list, i)) {
          delete list[i];
        }
      }
    }
    copy(ls, list);
    list._inc = inc;
  }
}
LiveNodeList.prototype.item = function (i) {
  _updateLiveList(this);
  return this[i] || null;
};
_extends(LiveNodeList, NodeList);

/**
 * Objects implementing the NamedNodeMap interface are used
 * to represent collections of nodes that can be accessed by name.
 * Note that NamedNodeMap does not inherit from NodeList;
 * NamedNodeMaps are not maintained in any particular order.
 * Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index,
 * but this is simply to allow convenient enumeration of the contents of a NamedNodeMap,
 * and does not imply that the DOM specifies an order to these Nodes.
 * NamedNodeMap objects in the DOM are live.
 * used for attributes or DocumentType entities
 */
function NamedNodeMap() {}
;
function _findNodeIndex(list, node) {
  var i = list.length;
  while (i--) {
    if (list[i] === node) {
      return i;
    }
  }
}
function _addNamedNode(el, list, newAttr, oldAttr) {
  if (oldAttr) {
    list[_findNodeIndex(list, oldAttr)] = newAttr;
  } else {
    list[list.length++] = newAttr;
  }
  if (el) {
    newAttr.ownerElement = el;
    var doc = el.ownerDocument;
    if (doc) {
      oldAttr && _onRemoveAttribute(doc, el, oldAttr);
      _onAddAttribute(doc, el, newAttr);
    }
  }
}
function _removeNamedNode(el, list, attr) {
  //console.log('remove attr:'+attr)
  var i = _findNodeIndex(list, attr);
  if (i >= 0) {
    var lastIndex = list.length - 1;
    while (i < lastIndex) {
      list[i] = list[++i];
    }
    list.length = lastIndex;
    if (el) {
      var doc = el.ownerDocument;
      if (doc) {
        _onRemoveAttribute(doc, el, attr);
        attr.ownerElement = null;
      }
    }
  } else {
    throw new DOMException(NOT_FOUND_ERR, new Error(el.tagName + '@' + attr));
  }
}
NamedNodeMap.prototype = {
  length: 0,
  item: NodeList.prototype.item,
  getNamedItem: function getNamedItem(key) {
    //		if(key.indexOf(':')>0 || key == 'xmlns'){
    //			return null;
    //		}
    //console.log()
    var i = this.length;
    while (i--) {
      var attr = this[i];
      //console.log(attr.nodeName,key)
      if (attr.nodeName == key) {
        return attr;
      }
    }
  },
  setNamedItem: function setNamedItem(attr) {
    var el = attr.ownerElement;
    if (el && el != this._ownerElement) {
      throw new DOMException(INUSE_ATTRIBUTE_ERR);
    }
    var oldAttr = this.getNamedItem(attr.nodeName);
    _addNamedNode(this._ownerElement, this, attr, oldAttr);
    return oldAttr;
  },
  /* returns Node */
  setNamedItemNS: function setNamedItemNS(attr) {
    // raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR
    var el = attr.ownerElement,
      oldAttr;
    if (el && el != this._ownerElement) {
      throw new DOMException(INUSE_ATTRIBUTE_ERR);
    }
    oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
    _addNamedNode(this._ownerElement, this, attr, oldAttr);
    return oldAttr;
  },
  /* returns Node */
  removeNamedItem: function removeNamedItem(key) {
    var attr = this.getNamedItem(key);
    _removeNamedNode(this._ownerElement, this, attr);
    return attr;
  },
  // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR

  //for level2
  removeNamedItemNS: function removeNamedItemNS(namespaceURI, localName) {
    var attr = this.getNamedItemNS(namespaceURI, localName);
    _removeNamedNode(this._ownerElement, this, attr);
    return attr;
  },
  getNamedItemNS: function getNamedItemNS(namespaceURI, localName) {
    var i = this.length;
    while (i--) {
      var node = this[i];
      if (node.localName == localName && node.namespaceURI == namespaceURI) {
        return node;
      }
    }
    return null;
  }
};

/**
 * The DOMImplementation interface represents an object providing methods
 * which are not dependent on any particular document.
 * Such an object is returned by the `Document.implementation` property.
 *
 * __The individual methods describe the differences compared to the specs.__
 *
 * @constructor
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation MDN
 * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490 DOM Level 1 Core (Initial)
 * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-102161490 DOM Level 2 Core
 * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-102161490 DOM Level 3 Core
 * @see https://dom.spec.whatwg.org/#domimplementation DOM Living Standard
 */
function DOMImplementation() {}
DOMImplementation.prototype = {
  /**
   * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
   * The different implementations fairly diverged in what kind of features were reported.
   * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
   *
   * @deprecated It is deprecated and modern browsers return true in all cases.
   *
   * @param {string} feature
   * @param {string} [version]
   * @returns {boolean} always true
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
   * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
   */
  hasFeature: function hasFeature(feature, version) {
    return true;
  },
  /**
   * Creates an XML Document object of the specified type with its document element.
   *
   * __It behaves slightly different from the description in the living standard__:
   * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
   * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
   * - this implementation is not validating names or qualified names
   *   (when parsing XML strings, the SAX parser takes care of that)
   *
   * @param {string|null} namespaceURI
   * @param {string} qualifiedName
   * @param {DocumentType=null} doctype
   * @returns {Document}
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
   * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
   *
   * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
   * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
   * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
   */
  createDocument: function createDocument(namespaceURI, qualifiedName, doctype) {
    var doc = new Document();
    doc.implementation = this;
    doc.childNodes = new NodeList();
    doc.doctype = doctype || null;
    if (doctype) {
      doc.appendChild(doctype);
    }
    if (qualifiedName) {
      var root = doc.createElementNS(namespaceURI, qualifiedName);
      doc.appendChild(root);
    }
    return doc;
  },
  /**
   * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
   *
   * __This behavior is slightly different from the in the specs__:
   * - this implementation is not validating names or qualified names
   *   (when parsing XML strings, the SAX parser takes care of that)
   *
   * @param {string} qualifiedName
   * @param {string} [publicId]
   * @param {string} [systemId]
   * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
   * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
   * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
   *
   * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
   * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
   * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
   */
  createDocumentType: function createDocumentType(qualifiedName, publicId, systemId) {
    var node = new DocumentType();
    node.name = qualifiedName;
    node.nodeName = qualifiedName;
    node.publicId = publicId || '';
    node.systemId = systemId || '';
    return node;
  }
};

/**
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247
 */

function Node() {}
;
Node.prototype = {
  firstChild: null,
  lastChild: null,
  previousSibling: null,
  nextSibling: null,
  attributes: null,
  parentNode: null,
  childNodes: null,
  ownerDocument: null,
  nodeValue: null,
  namespaceURI: null,
  prefix: null,
  localName: null,
  // Modified in DOM Level 2:
  insertBefore: function insertBefore(newChild, refChild) {
    //raises
    return _insertBefore(this, newChild, refChild);
  },
  replaceChild: function replaceChild(newChild, oldChild) {
    //raises
    _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
    if (oldChild) {
      this.removeChild(oldChild);
    }
  },
  removeChild: function removeChild(oldChild) {
    return _removeChild(this, oldChild);
  },
  appendChild: function appendChild(newChild) {
    return this.insertBefore(newChild, null);
  },
  hasChildNodes: function hasChildNodes() {
    return this.firstChild != null;
  },
  cloneNode: function cloneNode(deep) {
    return _cloneNode(this.ownerDocument || this, this, deep);
  },
  // Modified in DOM Level 2:
  normalize: function normalize() {
    var child = this.firstChild;
    while (child) {
      var next = child.nextSibling;
      if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
        this.removeChild(next);
        child.appendData(next.data);
      } else {
        child.normalize();
        child = next;
      }
    }
  },
  // Introduced in DOM Level 2:
  isSupported: function isSupported(feature, version) {
    return this.ownerDocument.implementation.hasFeature(feature, version);
  },
  // Introduced in DOM Level 2:
  hasAttributes: function hasAttributes() {
    return this.attributes.length > 0;
  },
  /**
   * Look up the prefix associated to the given namespace URI, starting from this node.
   * **The default namespace declarations are ignored by this method.**
   * See Namespace Prefix Lookup for details on the algorithm used by this method.
   *
   * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
   *
   * @param {string | null} namespaceURI
   * @returns {string | null}
   * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
   * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
   * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
   * @see https://github.com/xmldom/xmldom/issues/322
   */
  lookupPrefix: function lookupPrefix(namespaceURI) {
    var el = this;
    while (el) {
      var map = el._nsMap;
      //console.dir(map)
      if (map) {
        for (var n in map) {
          if (Object.prototype.hasOwnProperty.call(map, n) && map[n] === namespaceURI) {
            return n;
          }
        }
      }
      el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
    }
    return null;
  },
  // Introduced in DOM Level 3:
  lookupNamespaceURI: function lookupNamespaceURI(prefix) {
    var el = this;
    while (el) {
      var map = el._nsMap;
      //console.dir(map)
      if (map) {
        if (Object.prototype.hasOwnProperty.call(map, prefix)) {
          return map[prefix];
        }
      }
      el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
    }
    return null;
  },
  // Introduced in DOM Level 3:
  isDefaultNamespace: function isDefaultNamespace(namespaceURI) {
    var prefix = this.lookupPrefix(namespaceURI);
    return prefix == null;
  }
};
function _xmlEncoder(c) {
  return c == '<' && '&lt;' || c == '>' && '&gt;' || c == '&' && '&amp;' || c == '"' && '&quot;' || '&#' + c.charCodeAt() + ';';
}
copy(NodeType, Node);
copy(NodeType, Node.prototype);

/**
 * @param callback return true for continue,false for break
 * @return boolean true: break visit;
 */
function _visitNode(node, callback) {
  if (callback(node)) {
    return true;
  }
  if (node = node.firstChild) {
    do {
      if (_visitNode(node, callback)) {
        return true;
      }
    } while (node = node.nextSibling);
  }
}
function Document() {
  this.ownerDocument = this;
}
function _onAddAttribute(doc, el, newAttr) {
  doc && doc._inc++;
  var ns = newAttr.namespaceURI;
  if (ns === NAMESPACE.XMLNS) {
    //update namespace
    el._nsMap[newAttr.prefix ? newAttr.localName : ''] = newAttr.value;
  }
}
function _onRemoveAttribute(doc, el, newAttr, remove) {
  doc && doc._inc++;
  var ns = newAttr.namespaceURI;
  if (ns === NAMESPACE.XMLNS) {
    //update namespace
    delete el._nsMap[newAttr.prefix ? newAttr.localName : ''];
  }
}

/**
 * Updates `el.childNodes`, updating the indexed items and it's `length`.
 * Passing `newChild` means it will be appended.
 * Otherwise it's assumed that an item has been removed,
 * and `el.firstNode` and it's `.nextSibling` are used
 * to walk the current list of child nodes.
 *
 * @param {Document} doc
 * @param {Node} el
 * @param {Node} [newChild]
 * @private
 */
function _onUpdateChild(doc, el, newChild) {
  if (doc && doc._inc) {
    doc._inc++;
    //update childNodes
    var cs = el.childNodes;
    if (newChild) {
      cs[cs.length++] = newChild;
    } else {
      var child = el.firstChild;
      var i = 0;
      while (child) {
        cs[i++] = child;
        child = child.nextSibling;
      }
      cs.length = i;
      delete cs[cs.length];
    }
  }
}

/**
 * Removes the connections between `parentNode` and `child`
 * and any existing `child.previousSibling` or `child.nextSibling`.
 *
 * @see https://github.com/xmldom/xmldom/issues/135
 * @see https://github.com/xmldom/xmldom/issues/145
 *
 * @param {Node} parentNode
 * @param {Node} child
 * @returns {Node} the child that was removed.
 * @private
 */
function _removeChild(parentNode, child) {
  var previous = child.previousSibling;
  var next = child.nextSibling;
  if (previous) {
    previous.nextSibling = next;
  } else {
    parentNode.firstChild = next;
  }
  if (next) {
    next.previousSibling = previous;
  } else {
    parentNode.lastChild = previous;
  }
  child.parentNode = null;
  child.previousSibling = null;
  child.nextSibling = null;
  _onUpdateChild(parentNode.ownerDocument, parentNode);
  return child;
}

/**
 * Returns `true` if `node` can be a parent for insertion.
 * @param {Node} node
 * @returns {boolean}
 */
function hasValidParentNodeType(node) {
  return node && (node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE);
}

/**
 * Returns `true` if `node` can be inserted according to it's `nodeType`.
 * @param {Node} node
 * @returns {boolean}
 */
function hasInsertableNodeType(node) {
  return node && (isElementNode(node) || isTextNode(node) || isDocTypeNode(node) || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.COMMENT_NODE || node.nodeType === Node.PROCESSING_INSTRUCTION_NODE);
}

/**
 * Returns true if `node` is a DOCTYPE node
 * @param {Node} node
 * @returns {boolean}
 */
function isDocTypeNode(node) {
  return node && node.nodeType === Node.DOCUMENT_TYPE_NODE;
}

/**
 * Returns true if the node is an element
 * @param {Node} node
 * @returns {boolean}
 */
function isElementNode(node) {
  return node && node.nodeType === Node.ELEMENT_NODE;
}
/**
 * Returns true if `node` is a text node
 * @param {Node} node
 * @returns {boolean}
 */
function isTextNode(node) {
  return node && node.nodeType === Node.TEXT_NODE;
}

/**
 * Check if en element node can be inserted before `child`, or at the end if child is falsy,
 * according to the presence and position of a doctype node on the same level.
 *
 * @param {Document} doc The document node
 * @param {Node} child the node that would become the nextSibling if the element would be inserted
 * @returns {boolean} `true` if an element can be inserted before child
 * @private
 * https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
 */
function isElementInsertionPossible(doc, child) {
  var parentChildNodes = doc.childNodes || [];
  if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
    return false;
  }
  var docTypeNode = find(parentChildNodes, isDocTypeNode);
  return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
}

/**
 * Check if en element node can be inserted before `child`, or at the end if child is falsy,
 * according to the presence and position of a doctype node on the same level.
 *
 * @param {Node} doc The document node
 * @param {Node} child the node that would become the nextSibling if the element would be inserted
 * @returns {boolean} `true` if an element can be inserted before child
 * @private
 * https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
 */
function isElementReplacementPossible(doc, child) {
  var parentChildNodes = doc.childNodes || [];
  function hasElementChildThatIsNotChild(node) {
    return isElementNode(node) && node !== child;
  }
  if (find(parentChildNodes, hasElementChildThatIsNotChild)) {
    return false;
  }
  var docTypeNode = find(parentChildNodes, isDocTypeNode);
  return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
}

/**
 * @private
 * Steps 1-5 of the checks before inserting and before replacing a child are the same.
 *
 * @param {Node} parent the parent node to insert `node` into
 * @param {Node} node the node to insert
 * @param {Node=} child the node that should become the `nextSibling` of `node`
 * @returns {Node}
 * @throws DOMException for several node combinations that would create a DOM that is not well-formed.
 * @throws DOMException if `child` is provided but is not a child of `parent`.
 * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
 * @see https://dom.spec.whatwg.org/#concept-node-replace
 */
function assertPreInsertionValidity1to5(parent, node, child) {
  // 1. If `parent` is not a Document, DocumentFragment, or Element node, then throw a "HierarchyRequestError" DOMException.
  if (!hasValidParentNodeType(parent)) {
    throw new DOMException(HIERARCHY_REQUEST_ERR, 'Unexpected parent node type ' + parent.nodeType);
  }
  // 2. If `node` is a host-including inclusive ancestor of `parent`, then throw a "HierarchyRequestError" DOMException.
  // not implemented!
  // 3. If `child` is non-null and its parent is not `parent`, then throw a "NotFoundError" DOMException.
  if (child && child.parentNode !== parent) {
    throw new DOMException(NOT_FOUND_ERR, 'child not in parent');
  }
  if (
  // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
  !hasInsertableNodeType(node) ||
  // 5. If either `node` is a Text node and `parent` is a document,
  // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
  // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
  // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
  isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE) {
    throw new DOMException(HIERARCHY_REQUEST_ERR, 'Unexpected node type ' + node.nodeType + ' for parent node type ' + parent.nodeType);
  }
}

/**
 * @private
 * Step 6 of the checks before inserting and before replacing a child are different.
 *
 * @param {Document} parent the parent node to insert `node` into
 * @param {Node} node the node to insert
 * @param {Node | undefined} child the node that should become the `nextSibling` of `node`
 * @returns {Node}
 * @throws DOMException for several node combinations that would create a DOM that is not well-formed.
 * @throws DOMException if `child` is provided but is not a child of `parent`.
 * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
 * @see https://dom.spec.whatwg.org/#concept-node-replace
 */
function assertPreInsertionValidityInDocument(parent, node, child) {
  var parentChildNodes = parent.childNodes || [];
  var nodeChildNodes = node.childNodes || [];

  // DocumentFragment
  if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
    var nodeChildElements = nodeChildNodes.filter(isElementNode);
    // If node has more than one element child or has a Text node child.
    if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, 'More than one element or text in fragment');
    }
    // Otherwise, if `node` has one element child and either `parent` has an element child,
    // `child` is a doctype, or `child` is non-null and a doctype is following `child`.
    if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, 'Element in fragment can not be inserted before doctype');
    }
  }
  // Element
  if (isElementNode(node)) {
    // `parent` has an element child, `child` is a doctype,
    // or `child` is non-null and a doctype is following `child`.
    if (!isElementInsertionPossible(parent, child)) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one element can be added and only after doctype');
    }
  }
  // DocumentType
  if (isDocTypeNode(node)) {
    // `parent` has a doctype child,
    if (find(parentChildNodes, isDocTypeNode)) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one doctype is allowed');
    }
    var parentElementChild = find(parentChildNodes, isElementNode);
    // `child` is non-null and an element is preceding `child`,
    if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, 'Doctype can only be inserted before an element');
    }
    // or `child` is null and `parent` has an element child.
    if (!child && parentElementChild) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, 'Doctype can not be appended since element is present');
    }
  }
}

/**
 * @private
 * Step 6 of the checks before inserting and before replacing a child are different.
 *
 * @param {Document} parent the parent node to insert `node` into
 * @param {Node} node the node to insert
 * @param {Node | undefined} child the node that should become the `nextSibling` of `node`
 * @returns {Node}
 * @throws DOMException for several node combinations that would create a DOM that is not well-formed.
 * @throws DOMException if `child` is provided but is not a child of `parent`.
 * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
 * @see https://dom.spec.whatwg.org/#concept-node-replace
 */
function assertPreReplacementValidityInDocument(parent, node, child) {
  var parentChildNodes = parent.childNodes || [];
  var nodeChildNodes = node.childNodes || [];

  // DocumentFragment
  if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
    var nodeChildElements = nodeChildNodes.filter(isElementNode);
    // If `node` has more than one element child or has a Text node child.
    if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, 'More than one element or text in fragment');
    }
    // Otherwise, if `node` has one element child and either `parent` has an element child that is not `child` or a doctype is following `child`.
    if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, 'Element in fragment can not be inserted before doctype');
    }
  }
  // Element
  if (isElementNode(node)) {
    // `parent` has an element child that is not `child` or a doctype is following `child`.
    if (!isElementReplacementPossible(parent, child)) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one element can be added and only after doctype');
    }
  }
  // DocumentType
  if (isDocTypeNode(node)) {
    var hasDoctypeChildThatIsNotChild = function hasDoctypeChildThatIsNotChild(node) {
      return isDocTypeNode(node) && node !== child;
    }; // `parent` has a doctype child that is not `child`,
    if (find(parentChildNodes, hasDoctypeChildThatIsNotChild)) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one doctype is allowed');
    }
    var parentElementChild = find(parentChildNodes, isElementNode);
    // or an element is preceding `child`.
    if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, 'Doctype can only be inserted before an element');
    }
  }
}

/**
 * @private
 * @param {Node} parent the parent node to insert `node` into
 * @param {Node} node the node to insert
 * @param {Node=} child the node that should become the `nextSibling` of `node`
 * @returns {Node}
 * @throws DOMException for several node combinations that would create a DOM that is not well-formed.
 * @throws DOMException if `child` is provided but is not a child of `parent`.
 * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
 */
function _insertBefore(parent, node, child, _inDocumentAssertion) {
  // To ensure pre-insertion validity of a node into a parent before a child, run these steps:
  assertPreInsertionValidity1to5(parent, node, child);

  // If parent is a document, and any of the statements below, switched on the interface node implements,
  // are true, then throw a "HierarchyRequestError" DOMException.
  if (parent.nodeType === Node.DOCUMENT_NODE) {
    (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);
  }
  var cp = node.parentNode;
  if (cp) {
    cp.removeChild(node); //remove and update
  }

  if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
    var newFirst = node.firstChild;
    if (newFirst == null) {
      return node;
    }
    var newLast = node.lastChild;
  } else {
    newFirst = newLast = node;
  }
  var pre = child ? child.previousSibling : parent.lastChild;
  newFirst.previousSibling = pre;
  newLast.nextSibling = child;
  if (pre) {
    pre.nextSibling = newFirst;
  } else {
    parent.firstChild = newFirst;
  }
  if (child == null) {
    parent.lastChild = newLast;
  } else {
    child.previousSibling = newLast;
  }
  do {
    newFirst.parentNode = parent;
  } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
  _onUpdateChild(parent.ownerDocument || parent, parent);
  //console.log(parent.lastChild.nextSibling == null)
  if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {
    node.firstChild = node.lastChild = null;
  }
  return node;
}

/**
 * Appends `newChild` to `parentNode`.
 * If `newChild` is already connected to a `parentNode` it is first removed from it.
 *
 * @see https://github.com/xmldom/xmldom/issues/135
 * @see https://github.com/xmldom/xmldom/issues/145
 * @param {Node} parentNode
 * @param {Node} newChild
 * @returns {Node}
 * @private
 */
function _appendSingleChild(parentNode, newChild) {
  if (newChild.parentNode) {
    newChild.parentNode.removeChild(newChild);
  }
  newChild.parentNode = parentNode;
  newChild.previousSibling = parentNode.lastChild;
  newChild.nextSibling = null;
  if (newChild.previousSibling) {
    newChild.previousSibling.nextSibling = newChild;
  } else {
    parentNode.firstChild = newChild;
  }
  parentNode.lastChild = newChild;
  _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
  return newChild;
}
Document.prototype = {
  //implementation : null,
  nodeName: '#document',
  nodeType: DOCUMENT_NODE,
  /**
   * The DocumentType node of the document.
   *
   * @readonly
   * @type DocumentType
   */
  doctype: null,
  documentElement: null,
  _inc: 1,
  insertBefore: function insertBefore(newChild, refChild) {
    //raises
    if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
      var child = newChild.firstChild;
      while (child) {
        var next = child.nextSibling;
        this.insertBefore(child, refChild);
        child = next;
      }
      return newChild;
    }
    _insertBefore(this, newChild, refChild);
    newChild.ownerDocument = this;
    if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {
      this.documentElement = newChild;
    }
    return newChild;
  },
  removeChild: function removeChild(oldChild) {
    if (this.documentElement == oldChild) {
      this.documentElement = null;
    }
    return _removeChild(this, oldChild);
  },
  replaceChild: function replaceChild(newChild, oldChild) {
    //raises
    _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
    newChild.ownerDocument = this;
    if (oldChild) {
      this.removeChild(oldChild);
    }
    if (isElementNode(newChild)) {
      this.documentElement = newChild;
    }
  },
  // Introduced in DOM Level 2:
  importNode: function importNode(importedNode, deep) {
    return _importNode(this, importedNode, deep);
  },
  // Introduced in DOM Level 2:
  getElementById: function getElementById(id) {
    var rtv = null;
    _visitNode(this.documentElement, function (node) {
      if (node.nodeType == ELEMENT_NODE) {
        if (node.getAttribute('id') == id) {
          rtv = node;
          return true;
        }
      }
    });
    return rtv;
  },
  /**
   * The `getElementsByClassName` method of `Document` interface returns an array-like object
   * of all child elements which have **all** of the given class name(s).
   *
   * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
   *
   *
   * Warning: This is a live LiveNodeList.
   * Changes in the DOM will reflect in the array as the changes occur.
   * If an element selected by this array no longer qualifies for the selector,
   * it will automatically be removed. Be aware of this for iteration purposes.
   *
   * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
   * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
   */
  getElementsByClassName: function getElementsByClassName(classNames) {
    var classNamesSet = toOrderedSet(classNames);
    return new LiveNodeList(this, function (base) {
      var ls = [];
      if (classNamesSet.length > 0) {
        _visitNode(base.documentElement, function (node) {
          if (node !== base && node.nodeType === ELEMENT_NODE) {
            var nodeClassNames = node.getAttribute('class');
            // can be null if the attribute does not exist
            if (nodeClassNames) {
              // before splitting and iterating just compare them for the most common case
              var matches = classNames === nodeClassNames;
              if (!matches) {
                var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
              }
              if (matches) {
                ls.push(node);
              }
            }
          }
        });
      }
      return ls;
    });
  },
  //document factory method:
  createElement: function createElement(tagName) {
    var node = new Element();
    node.ownerDocument = this;
    node.nodeName = tagName;
    node.tagName = tagName;
    node.localName = tagName;
    node.childNodes = new NodeList();
    var attrs = node.attributes = new NamedNodeMap();
    attrs._ownerElement = node;
    return node;
  },
  createDocumentFragment: function createDocumentFragment() {
    var node = new DocumentFragment();
    node.ownerDocument = this;
    node.childNodes = new NodeList();
    return node;
  },
  createTextNode: function createTextNode(data) {
    var node = new Text();
    node.ownerDocument = this;
    node.appendData(data);
    return node;
  },
  createComment: function createComment(data) {
    var node = new Comment();
    node.ownerDocument = this;
    node.appendData(data);
    return node;
  },
  createCDATASection: function createCDATASection(data) {
    var node = new CDATASection();
    node.ownerDocument = this;
    node.appendData(data);
    return node;
  },
  createProcessingInstruction: function createProcessingInstruction(target, data) {
    var node = new ProcessingInstruction();
    node.ownerDocument = this;
    node.tagName = node.nodeName = node.target = target;
    node.nodeValue = node.data = data;
    return node;
  },
  createAttribute: function createAttribute(name) {
    var node = new Attr();
    node.ownerDocument = this;
    node.name = name;
    node.nodeName = name;
    node.localName = name;
    node.specified = true;
    return node;
  },
  createEntityReference: function createEntityReference(name) {
    var node = new EntityReference();
    node.ownerDocument = this;
    node.nodeName = name;
    return node;
  },
  // Introduced in DOM Level 2:
  createElementNS: function createElementNS(namespaceURI, qualifiedName) {
    var node = new Element();
    var pl = qualifiedName.split(':');
    var attrs = node.attributes = new NamedNodeMap();
    node.childNodes = new NodeList();
    node.ownerDocument = this;
    node.nodeName = qualifiedName;
    node.tagName = qualifiedName;
    node.namespaceURI = namespaceURI;
    if (pl.length == 2) {
      node.prefix = pl[0];
      node.localName = pl[1];
    } else {
      //el.prefix = null;
      node.localName = qualifiedName;
    }
    attrs._ownerElement = node;
    return node;
  },
  // Introduced in DOM Level 2:
  createAttributeNS: function createAttributeNS(namespaceURI, qualifiedName) {
    var node = new Attr();
    var pl = qualifiedName.split(':');
    node.ownerDocument = this;
    node.nodeName = qualifiedName;
    node.name = qualifiedName;
    node.namespaceURI = namespaceURI;
    node.specified = true;
    if (pl.length == 2) {
      node.prefix = pl[0];
      node.localName = pl[1];
    } else {
      //el.prefix = null;
      node.localName = qualifiedName;
    }
    return node;
  }
};
_extends(Document, Node);
function Element() {
  this._nsMap = {};
}
;
Element.prototype = {
  nodeType: ELEMENT_NODE,
  hasAttribute: function hasAttribute(name) {
    return this.getAttributeNode(name) != null;
  },
  getAttribute: function getAttribute(name) {
    var attr = this.getAttributeNode(name);
    return attr && attr.value || '';
  },
  getAttributeNode: function getAttributeNode(name) {
    return this.attributes.getNamedItem(name);
  },
  setAttribute: function setAttribute(name, value) {
    var attr = this.ownerDocument.createAttribute(name);
    attr.value = attr.nodeValue = "" + value;
    this.setAttributeNode(attr);
  },
  removeAttribute: function removeAttribute(name) {
    var attr = this.getAttributeNode(name);
    attr && this.removeAttributeNode(attr);
  },
  //four real opeartion method
  appendChild: function appendChild(newChild) {
    if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
      return this.insertBefore(newChild, null);
    } else {
      return _appendSingleChild(this, newChild);
    }
  },
  setAttributeNode: function setAttributeNode(newAttr) {
    return this.attributes.setNamedItem(newAttr);
  },
  setAttributeNodeNS: function setAttributeNodeNS(newAttr) {
    return this.attributes.setNamedItemNS(newAttr);
  },
  removeAttributeNode: function removeAttributeNode(oldAttr) {
    //console.log(this == oldAttr.ownerElement)
    return this.attributes.removeNamedItem(oldAttr.nodeName);
  },
  //get real attribute name,and remove it by removeAttributeNode
  removeAttributeNS: function removeAttributeNS(namespaceURI, localName) {
    var old = this.getAttributeNodeNS(namespaceURI, localName);
    old && this.removeAttributeNode(old);
  },
  hasAttributeNS: function hasAttributeNS(namespaceURI, localName) {
    return this.getAttributeNodeNS(namespaceURI, localName) != null;
  },
  getAttributeNS: function getAttributeNS(namespaceURI, localName) {
    var attr = this.getAttributeNodeNS(namespaceURI, localName);
    return attr && attr.value || '';
  },
  setAttributeNS: function setAttributeNS(namespaceURI, qualifiedName, value) {
    var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
    attr.value = attr.nodeValue = "" + value;
    this.setAttributeNode(attr);
  },
  getAttributeNodeNS: function getAttributeNodeNS(namespaceURI, localName) {
    return this.attributes.getNamedItemNS(namespaceURI, localName);
  },
  getElementsByTagName: function getElementsByTagName(tagName) {
    return new LiveNodeList(this, function (base) {
      var ls = [];
      _visitNode(base, function (node) {
        if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)) {
          ls.push(node);
        }
      });
      return ls;
    });
  },
  getElementsByTagNameNS: function getElementsByTagNameNS(namespaceURI, localName) {
    return new LiveNodeList(this, function (base) {
      var ls = [];
      _visitNode(base, function (node) {
        if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === '*' || node.namespaceURI === namespaceURI) && (localName === '*' || node.localName == localName)) {
          ls.push(node);
        }
      });
      return ls;
    });
  }
};
Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;
_extends(Element, Node);
function Attr() {}
;
Attr.prototype.nodeType = ATTRIBUTE_NODE;
_extends(Attr, Node);
function CharacterData() {}
;
CharacterData.prototype = {
  data: '',
  substringData: function substringData(offset, count) {
    return this.data.substring(offset, offset + count);
  },
  appendData: function appendData(text) {
    text = this.data + text;
    this.nodeValue = this.data = text;
    this.length = text.length;
  },
  insertData: function insertData(offset, text) {
    this.replaceData(offset, 0, text);
  },
  appendChild: function appendChild(newChild) {
    throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
  },
  deleteData: function deleteData(offset, count) {
    this.replaceData(offset, count, "");
  },
  replaceData: function replaceData(offset, count, text) {
    var start = this.data.substring(0, offset);
    var end = this.data.substring(offset + count);
    text = start + text + end;
    this.nodeValue = this.data = text;
    this.length = text.length;
  }
};
_extends(CharacterData, Node);
function Text() {}
;
Text.prototype = {
  nodeName: "#text",
  nodeType: TEXT_NODE,
  splitText: function splitText(offset) {
    var text = this.data;
    var newText = text.substring(offset);
    text = text.substring(0, offset);
    this.data = this.nodeValue = text;
    this.length = text.length;
    var newNode = this.ownerDocument.createTextNode(newText);
    if (this.parentNode) {
      this.parentNode.insertBefore(newNode, this.nextSibling);
    }
    return newNode;
  }
};
_extends(Text, CharacterData);
function Comment() {}
;
Comment.prototype = {
  nodeName: "#comment",
  nodeType: COMMENT_NODE
};
_extends(Comment, CharacterData);
function CDATASection() {}
;
CDATASection.prototype = {
  nodeName: "#cdata-section",
  nodeType: CDATA_SECTION_NODE
};
_extends(CDATASection, CharacterData);
function DocumentType() {}
;
DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
_extends(DocumentType, Node);
function Notation() {}
;
Notation.prototype.nodeType = NOTATION_NODE;
_extends(Notation, Node);
function Entity() {}
;
Entity.prototype.nodeType = ENTITY_NODE;
_extends(Entity, Node);
function EntityReference() {}
;
EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
_extends(EntityReference, Node);
function DocumentFragment() {}
;
DocumentFragment.prototype.nodeName = "#document-fragment";
DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
_extends(DocumentFragment, Node);
function ProcessingInstruction() {}
ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
_extends(ProcessingInstruction, Node);
function XMLSerializer() {}
XMLSerializer.prototype.serializeToString = function (node, isHtml, nodeFilter) {
  return nodeSerializeToString.call(node, isHtml, nodeFilter);
};
Node.prototype.toString = nodeSerializeToString;
function nodeSerializeToString(isHtml, nodeFilter) {
  var buf = [];
  var refNode = this.nodeType == 9 && this.documentElement || this;
  var prefix = refNode.prefix;
  var uri = refNode.namespaceURI;
  if (uri && prefix == null) {
    //console.log(prefix)
    var prefix = refNode.lookupPrefix(uri);
    if (prefix == null) {
      //isHTML = true;
      var visibleNamespaces = [{
        namespace: uri,
        prefix: null
      }
      //{namespace:uri,prefix:''}
      ];
    }
  }

  serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
  //console.log('###',this.nodeType,uri,prefix,buf.join(''))
  return buf.join('');
}
function needNamespaceDefine(node, isHTML, visibleNamespaces) {
  var prefix = node.prefix || '';
  var uri = node.namespaceURI;
  // According to [Namespaces in XML 1.0](https://www.w3.org/TR/REC-xml-names/#ns-using) ,
  // and more specifically https://www.w3.org/TR/REC-xml-names/#nsc-NoPrefixUndecl :
  // > In a namespace declaration for a prefix [...], the attribute value MUST NOT be empty.
  // in a similar manner [Namespaces in XML 1.1](https://www.w3.org/TR/xml-names11/#ns-using)
  // and more specifically https://www.w3.org/TR/xml-names11/#nsc-NSDeclared :
  // > [...] Furthermore, the attribute value [...] must not be an empty string.
  // so serializing empty namespace value like xmlns:ds="" would produce an invalid XML document.
  if (!uri) {
    return false;
  }
  if (prefix === "xml" && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) {
    return false;
  }
  var i = visibleNamespaces.length;
  while (i--) {
    var ns = visibleNamespaces[i];
    // get namespace prefix
    if (ns.prefix === prefix) {
      return ns.namespace !== uri;
    }
  }
  return true;
}
/**
 * Well-formed constraint: No < in Attribute Values
 * > The replacement text of any entity referred to directly or indirectly
 * > in an attribute value must not contain a <.
 * @see https://www.w3.org/TR/xml11/#CleanAttrVals
 * @see https://www.w3.org/TR/xml11/#NT-AttValue
 *
 * Literal whitespace other than space that appear in attribute values
 * are serialized as their entity references, so they will be preserved.
 * (In contrast to whitespace literals in the input which are normalized to spaces)
 * @see https://www.w3.org/TR/xml11/#AVNormalize
 * @see https://w3c.github.io/DOM-Parsing/#serializing-an-element-s-attributes
 */
function addSerializedAttribute(buf, qualifiedName, value) {
  buf.push(' ', qualifiedName, '="', value.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"');
}
function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {
  if (!visibleNamespaces) {
    visibleNamespaces = [];
  }
  if (nodeFilter) {
    node = nodeFilter(node);
    if (node) {
      if (typeof node == 'string') {
        buf.push(node);
        return;
      }
    } else {
      return;
    }
    //buf.sort.apply(attrs, attributeSorter);
  }

  switch (node.nodeType) {
    case ELEMENT_NODE:
      var attrs = node.attributes;
      var len = attrs.length;
      var child = node.firstChild;
      var nodeName = node.tagName;
      isHTML = NAMESPACE.isHTML(node.namespaceURI) || isHTML;
      var prefixedNodeName = nodeName;
      if (!isHTML && !node.prefix && node.namespaceURI) {
        var defaultNS;
        // lookup current default ns from `xmlns` attribute
        for (var ai = 0; ai < attrs.length; ai++) {
          if (attrs.item(ai).name === 'xmlns') {
            defaultNS = attrs.item(ai).value;
            break;
          }
        }
        if (!defaultNS) {
          // lookup current default ns in visibleNamespaces
          for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
            var namespace = visibleNamespaces[nsi];
            if (namespace.prefix === '' && namespace.namespace === node.namespaceURI) {
              defaultNS = namespace.namespace;
              break;
            }
          }
        }
        if (defaultNS !== node.namespaceURI) {
          for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
            var namespace = visibleNamespaces[nsi];
            if (namespace.namespace === node.namespaceURI) {
              if (namespace.prefix) {
                prefixedNodeName = namespace.prefix + ':' + nodeName;
              }
              break;
            }
          }
        }
      }
      buf.push('<', prefixedNodeName);
      for (var i = 0; i < len; i++) {
        // add namespaces for attributes
        var attr = attrs.item(i);
        if (attr.prefix == 'xmlns') {
          visibleNamespaces.push({
            prefix: attr.localName,
            namespace: attr.value
          });
        } else if (attr.nodeName == 'xmlns') {
          visibleNamespaces.push({
            prefix: '',
            namespace: attr.value
          });
        }
      }
      for (var i = 0; i < len; i++) {
        var attr = attrs.item(i);
        if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
          var prefix = attr.prefix || '';
          var uri = attr.namespaceURI;
          addSerializedAttribute(buf, prefix ? 'xmlns:' + prefix : "xmlns", uri);
          visibleNamespaces.push({
            prefix: prefix,
            namespace: uri
          });
        }
        serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
      }

      // add namespace for current node
      if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
        var prefix = node.prefix || '';
        var uri = node.namespaceURI;
        addSerializedAttribute(buf, prefix ? 'xmlns:' + prefix : "xmlns", uri);
        visibleNamespaces.push({
          prefix: prefix,
          namespace: uri
        });
      }
      if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
        buf.push('>');
        //if is cdata child node
        if (isHTML && /^script$/i.test(nodeName)) {
          while (child) {
            if (child.data) {
              buf.push(child.data);
            } else {
              serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
            }
            child = child.nextSibling;
          }
        } else {
          while (child) {
            serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
            child = child.nextSibling;
          }
        }
        buf.push('</', prefixedNodeName, '>');
      } else {
        buf.push('/>');
      }
      // remove added visible namespaces
      //visibleNamespaces.length = startVisibleNamespaces;
      return;
    case DOCUMENT_NODE:
    case DOCUMENT_FRAGMENT_NODE:
      var child = node.firstChild;
      while (child) {
        serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
        child = child.nextSibling;
      }
      return;
    case ATTRIBUTE_NODE:
      return addSerializedAttribute(buf, node.name, node.value);
    case TEXT_NODE:
      /**
       * The ampersand character (&) and the left angle bracket (<) must not appear in their literal form,
       * except when used as markup delimiters, or within a comment, a processing instruction, or a CDATA section.
       * If they are needed elsewhere, they must be escaped using either numeric character references or the strings
       * `&amp;` and `&lt;` respectively.
       * The right angle bracket (>) may be represented using the string " &gt; ", and must, for compatibility,
       * be escaped using either `&gt;` or a character reference when it appears in the string `]]>` in content,
       * when that string is not marking the end of a CDATA section.
       *
       * In the content of elements, character data is any string of characters
       * which does not contain the start-delimiter of any markup
       * and does not include the CDATA-section-close delimiter, `]]>`.
       *
       * @see https://www.w3.org/TR/xml/#NT-CharData
       * @see https://w3c.github.io/DOM-Parsing/#xml-serializing-a-text-node
       */
      return buf.push(node.data.replace(/[<&>]/g, _xmlEncoder));
    case CDATA_SECTION_NODE:
      return buf.push('<![CDATA[', node.data, ']]>');
    case COMMENT_NODE:
      return buf.push("<!--", node.data, "-->");
    case DOCUMENT_TYPE_NODE:
      var pubid = node.publicId;
      var sysid = node.systemId;
      buf.push('<!DOCTYPE ', node.name);
      if (pubid) {
        buf.push(' PUBLIC ', pubid);
        if (sysid && sysid != '.') {
          buf.push(' ', sysid);
        }
        buf.push('>');
      } else if (sysid && sysid != '.') {
        buf.push(' SYSTEM ', sysid, '>');
      } else {
        var sub = node.internalSubset;
        if (sub) {
          buf.push(" [", sub, "]");
        }
        buf.push(">");
      }
      return;
    case PROCESSING_INSTRUCTION_NODE:
      return buf.push("<?", node.target, " ", node.data, "?>");
    case ENTITY_REFERENCE_NODE:
      return buf.push('&', node.nodeName, ';');
    //case ENTITY_NODE:
    //case NOTATION_NODE:
    default:
      buf.push('??', node.nodeName);
  }
}
function _importNode(doc, node, deep) {
  var node2;
  switch (node.nodeType) {
    case ELEMENT_NODE:
      node2 = node.cloneNode(false);
      node2.ownerDocument = doc;
    //var attrs = node2.attributes;
    //var len = attrs.length;
    //for(var i=0;i<len;i++){
    //node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
    //}
    case DOCUMENT_FRAGMENT_NODE:
      break;
    case ATTRIBUTE_NODE:
      deep = true;
      break;
    //case ENTITY_REFERENCE_NODE:
    //case PROCESSING_INSTRUCTION_NODE:
    ////case TEXT_NODE:
    //case CDATA_SECTION_NODE:
    //case COMMENT_NODE:
    //	deep = false;
    //	break;
    //case DOCUMENT_NODE:
    //case DOCUMENT_TYPE_NODE:
    //cannot be imported.
    //case ENTITY_NODE:
    //case NOTATION_NODE
    //can not hit in level3
    //default:throw e;
  }

  if (!node2) {
    node2 = node.cloneNode(false); //false
  }

  node2.ownerDocument = doc;
  node2.parentNode = null;
  if (deep) {
    var child = node.firstChild;
    while (child) {
      node2.appendChild(_importNode(doc, child, deep));
      child = child.nextSibling;
    }
  }
  return node2;
}
//
//var _relationMap = {firstChild:1,lastChild:1,previousSibling:1,nextSibling:1,
//					attributes:1,childNodes:1,parentNode:1,documentElement:1,doctype,};
function _cloneNode(doc, node, deep) {
  var node2 = new node.constructor();
  for (var n in node) {
    if (Object.prototype.hasOwnProperty.call(node, n)) {
      var v = node[n];
      if ((0, _typeof2.default)(v) != "object") {
        if (v != node2[n]) {
          node2[n] = v;
        }
      }
    }
  }
  if (node.childNodes) {
    node2.childNodes = new NodeList();
  }
  node2.ownerDocument = doc;
  switch (node2.nodeType) {
    case ELEMENT_NODE:
      var attrs = node.attributes;
      var attrs2 = node2.attributes = new NamedNodeMap();
      var len = attrs.length;
      attrs2._ownerElement = node2;
      for (var i = 0; i < len; i++) {
        node2.setAttributeNode(_cloneNode(doc, attrs.item(i), true));
      }
      break;
      ;
    case ATTRIBUTE_NODE:
      deep = true;
  }
  if (deep) {
    var child = node.firstChild;
    while (child) {
      node2.appendChild(_cloneNode(doc, child, deep));
      child = child.nextSibling;
    }
  }
  return node2;
}
function __set__(object, key, value) {
  object[key] = value;
}
//do dynamic
try {
  if (Object.defineProperty) {
    var getTextContent = function getTextContent(node) {
      switch (node.nodeType) {
        case ELEMENT_NODE:
        case DOCUMENT_FRAGMENT_NODE:
          var buf = [];
          node = node.firstChild;
          while (node) {
            if (node.nodeType !== 7 && node.nodeType !== 8) {
              buf.push(getTextContent(node));
            }
            node = node.nextSibling;
          }
          return buf.join('');
        default:
          return node.nodeValue;
      }
    };
    Object.defineProperty(LiveNodeList.prototype, 'length', {
      get: function get() {
        _updateLiveList(this);
        return this.$$length;
      }
    });
    Object.defineProperty(Node.prototype, 'textContent', {
      get: function get() {
        return getTextContent(this);
      },
      set: function set(data) {
        switch (this.nodeType) {
          case ELEMENT_NODE:
          case DOCUMENT_FRAGMENT_NODE:
            while (this.firstChild) {
              this.removeChild(this.firstChild);
            }
            if (data || String(data)) {
              this.appendChild(this.ownerDocument.createTextNode(data));
            }
            break;
          default:
            this.data = data;
            this.value = data;
            this.nodeValue = data;
        }
      }
    });
    __set__ = function __set__(object, key, value) {
      //console.log(value)
      object['$$' + key] = value;
    };
  }
} catch (e) {//ie8
}

//if(typeof require == 'function'){
exports.DocumentType = DocumentType;
exports.DOMException = DOMException;
exports.DOMImplementation = DOMImplementation;
exports.Element = Element;
exports.Node = Node;
exports.NodeList = NodeList;
exports.XMLSerializer = XMLSerializer;
//}

},{"./conventions":256,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.filter.js":572,"core-js/modules/es.array.find.js":574,"core-js/modules/es.array.join.js":578,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.keys.js":609,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.replace.js":629,"core-js/modules/es.string.split.js":631}],259:[function(require,module,exports){
'use strict';

var freeze = require('./conventions').freeze;

/**
 * The entities that are predefined in every XML document.
 *
 * @see https://www.w3.org/TR/2006/REC-xml11-20060816/#sec-predefined-ent W3C XML 1.1
 * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-predefined-ent W3C XML 1.0
 * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Predefined_entities_in_XML Wikipedia
 */
exports.XML_ENTITIES = freeze({
  amp: '&',
  apos: "'",
  gt: '>',
  lt: '<',
  quot: '"'
});

/**
 * A map of all entities that are detected in an HTML document.
 * They contain all entries from `XML_ENTITIES`.
 *
 * @see XML_ENTITIES
 * @see DOMParser.parseFromString
 * @see DOMImplementation.prototype.createHTMLDocument
 * @see https://html.spec.whatwg.org/#named-character-references WHATWG HTML(5) Spec
 * @see https://html.spec.whatwg.org/entities.json JSON
 * @see https://www.w3.org/TR/xml-entity-names/ W3C XML Entity Names
 * @see https://www.w3.org/TR/html4/sgml/entities.html W3C HTML4/SGML
 * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Character_entity_references_in_HTML Wikipedia (HTML)
 * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Entities_representing_special_characters_in_XHTML Wikpedia (XHTML)
 */
exports.HTML_ENTITIES = freeze({
  Aacute: "\xC1",
  aacute: "\xE1",
  Abreve: "\u0102",
  abreve: "\u0103",
  ac: "\u223E",
  acd: "\u223F",
  acE: "\u223E\u0333",
  Acirc: "\xC2",
  acirc: "\xE2",
  acute: "\xB4",
  Acy: "\u0410",
  acy: "\u0430",
  AElig: "\xC6",
  aelig: "\xE6",
  af: "\u2061",
  Afr: "\uD835\uDD04",
  afr: "\uD835\uDD1E",
  Agrave: "\xC0",
  agrave: "\xE0",
  alefsym: "\u2135",
  aleph: "\u2135",
  Alpha: "\u0391",
  alpha: "\u03B1",
  Amacr: "\u0100",
  amacr: "\u0101",
  amalg: "\u2A3F",
  AMP: "&",
  amp: "&",
  And: "\u2A53",
  and: "\u2227",
  andand: "\u2A55",
  andd: "\u2A5C",
  andslope: "\u2A58",
  andv: "\u2A5A",
  ang: "\u2220",
  ange: "\u29A4",
  angle: "\u2220",
  angmsd: "\u2221",
  angmsdaa: "\u29A8",
  angmsdab: "\u29A9",
  angmsdac: "\u29AA",
  angmsdad: "\u29AB",
  angmsdae: "\u29AC",
  angmsdaf: "\u29AD",
  angmsdag: "\u29AE",
  angmsdah: "\u29AF",
  angrt: "\u221F",
  angrtvb: "\u22BE",
  angrtvbd: "\u299D",
  angsph: "\u2222",
  angst: "\xC5",
  angzarr: "\u237C",
  Aogon: "\u0104",
  aogon: "\u0105",
  Aopf: "\uD835\uDD38",
  aopf: "\uD835\uDD52",
  ap: "\u2248",
  apacir: "\u2A6F",
  apE: "\u2A70",
  ape: "\u224A",
  apid: "\u224B",
  apos: "'",
  ApplyFunction: "\u2061",
  approx: "\u2248",
  approxeq: "\u224A",
  Aring: "\xC5",
  aring: "\xE5",
  Ascr: "\uD835\uDC9C",
  ascr: "\uD835\uDCB6",
  Assign: "\u2254",
  ast: "*",
  asymp: "\u2248",
  asympeq: "\u224D",
  Atilde: "\xC3",
  atilde: "\xE3",
  Auml: "\xC4",
  auml: "\xE4",
  awconint: "\u2233",
  awint: "\u2A11",
  backcong: "\u224C",
  backepsilon: "\u03F6",
  backprime: "\u2035",
  backsim: "\u223D",
  backsimeq: "\u22CD",
  Backslash: "\u2216",
  Barv: "\u2AE7",
  barvee: "\u22BD",
  Barwed: "\u2306",
  barwed: "\u2305",
  barwedge: "\u2305",
  bbrk: "\u23B5",
  bbrktbrk: "\u23B6",
  bcong: "\u224C",
  Bcy: "\u0411",
  bcy: "\u0431",
  bdquo: "\u201E",
  becaus: "\u2235",
  Because: "\u2235",
  because: "\u2235",
  bemptyv: "\u29B0",
  bepsi: "\u03F6",
  bernou: "\u212C",
  Bernoullis: "\u212C",
  Beta: "\u0392",
  beta: "\u03B2",
  beth: "\u2136",
  between: "\u226C",
  Bfr: "\uD835\uDD05",
  bfr: "\uD835\uDD1F",
  bigcap: "\u22C2",
  bigcirc: "\u25EF",
  bigcup: "\u22C3",
  bigodot: "\u2A00",
  bigoplus: "\u2A01",
  bigotimes: "\u2A02",
  bigsqcup: "\u2A06",
  bigstar: "\u2605",
  bigtriangledown: "\u25BD",
  bigtriangleup: "\u25B3",
  biguplus: "\u2A04",
  bigvee: "\u22C1",
  bigwedge: "\u22C0",
  bkarow: "\u290D",
  blacklozenge: "\u29EB",
  blacksquare: "\u25AA",
  blacktriangle: "\u25B4",
  blacktriangledown: "\u25BE",
  blacktriangleleft: "\u25C2",
  blacktriangleright: "\u25B8",
  blank: "\u2423",
  blk12: "\u2592",
  blk14: "\u2591",
  blk34: "\u2593",
  block: "\u2588",
  bne: "=\u20E5",
  bnequiv: "\u2261\u20E5",
  bNot: "\u2AED",
  bnot: "\u2310",
  Bopf: "\uD835\uDD39",
  bopf: "\uD835\uDD53",
  bot: "\u22A5",
  bottom: "\u22A5",
  bowtie: "\u22C8",
  boxbox: "\u29C9",
  boxDL: "\u2557",
  boxDl: "\u2556",
  boxdL: "\u2555",
  boxdl: "\u2510",
  boxDR: "\u2554",
  boxDr: "\u2553",
  boxdR: "\u2552",
  boxdr: "\u250C",
  boxH: "\u2550",
  boxh: "\u2500",
  boxHD: "\u2566",
  boxHd: "\u2564",
  boxhD: "\u2565",
  boxhd: "\u252C",
  boxHU: "\u2569",
  boxHu: "\u2567",
  boxhU: "\u2568",
  boxhu: "\u2534",
  boxminus: "\u229F",
  boxplus: "\u229E",
  boxtimes: "\u22A0",
  boxUL: "\u255D",
  boxUl: "\u255C",
  boxuL: "\u255B",
  boxul: "\u2518",
  boxUR: "\u255A",
  boxUr: "\u2559",
  boxuR: "\u2558",
  boxur: "\u2514",
  boxV: "\u2551",
  boxv: "\u2502",
  boxVH: "\u256C",
  boxVh: "\u256B",
  boxvH: "\u256A",
  boxvh: "\u253C",
  boxVL: "\u2563",
  boxVl: "\u2562",
  boxvL: "\u2561",
  boxvl: "\u2524",
  boxVR: "\u2560",
  boxVr: "\u255F",
  boxvR: "\u255E",
  boxvr: "\u251C",
  bprime: "\u2035",
  Breve: "\u02D8",
  breve: "\u02D8",
  brvbar: "\xA6",
  Bscr: "\u212C",
  bscr: "\uD835\uDCB7",
  bsemi: "\u204F",
  bsim: "\u223D",
  bsime: "\u22CD",
  bsol: "\\",
  bsolb: "\u29C5",
  bsolhsub: "\u27C8",
  bull: "\u2022",
  bullet: "\u2022",
  bump: "\u224E",
  bumpE: "\u2AAE",
  bumpe: "\u224F",
  Bumpeq: "\u224E",
  bumpeq: "\u224F",
  Cacute: "\u0106",
  cacute: "\u0107",
  Cap: "\u22D2",
  cap: "\u2229",
  capand: "\u2A44",
  capbrcup: "\u2A49",
  capcap: "\u2A4B",
  capcup: "\u2A47",
  capdot: "\u2A40",
  CapitalDifferentialD: "\u2145",
  caps: "\u2229\uFE00",
  caret: "\u2041",
  caron: "\u02C7",
  Cayleys: "\u212D",
  ccaps: "\u2A4D",
  Ccaron: "\u010C",
  ccaron: "\u010D",
  Ccedil: "\xC7",
  ccedil: "\xE7",
  Ccirc: "\u0108",
  ccirc: "\u0109",
  Cconint: "\u2230",
  ccups: "\u2A4C",
  ccupssm: "\u2A50",
  Cdot: "\u010A",
  cdot: "\u010B",
  cedil: "\xB8",
  Cedilla: "\xB8",
  cemptyv: "\u29B2",
  cent: "\xA2",
  CenterDot: "\xB7",
  centerdot: "\xB7",
  Cfr: "\u212D",
  cfr: "\uD835\uDD20",
  CHcy: "\u0427",
  chcy: "\u0447",
  check: "\u2713",
  checkmark: "\u2713",
  Chi: "\u03A7",
  chi: "\u03C7",
  cir: "\u25CB",
  circ: "\u02C6",
  circeq: "\u2257",
  circlearrowleft: "\u21BA",
  circlearrowright: "\u21BB",
  circledast: "\u229B",
  circledcirc: "\u229A",
  circleddash: "\u229D",
  CircleDot: "\u2299",
  circledR: "\xAE",
  circledS: "\u24C8",
  CircleMinus: "\u2296",
  CirclePlus: "\u2295",
  CircleTimes: "\u2297",
  cirE: "\u29C3",
  cire: "\u2257",
  cirfnint: "\u2A10",
  cirmid: "\u2AEF",
  cirscir: "\u29C2",
  ClockwiseContourIntegral: "\u2232",
  CloseCurlyDoubleQuote: "\u201D",
  CloseCurlyQuote: "\u2019",
  clubs: "\u2663",
  clubsuit: "\u2663",
  Colon: "\u2237",
  colon: ":",
  Colone: "\u2A74",
  colone: "\u2254",
  coloneq: "\u2254",
  comma: ",",
  commat: "@",
  comp: "\u2201",
  compfn: "\u2218",
  complement: "\u2201",
  complexes: "\u2102",
  cong: "\u2245",
  congdot: "\u2A6D",
  Congruent: "\u2261",
  Conint: "\u222F",
  conint: "\u222E",
  ContourIntegral: "\u222E",
  Copf: "\u2102",
  copf: "\uD835\uDD54",
  coprod: "\u2210",
  Coproduct: "\u2210",
  COPY: "\xA9",
  copy: "\xA9",
  copysr: "\u2117",
  CounterClockwiseContourIntegral: "\u2233",
  crarr: "\u21B5",
  Cross: "\u2A2F",
  cross: "\u2717",
  Cscr: "\uD835\uDC9E",
  cscr: "\uD835\uDCB8",
  csub: "\u2ACF",
  csube: "\u2AD1",
  csup: "\u2AD0",
  csupe: "\u2AD2",
  ctdot: "\u22EF",
  cudarrl: "\u2938",
  cudarrr: "\u2935",
  cuepr: "\u22DE",
  cuesc: "\u22DF",
  cularr: "\u21B6",
  cularrp: "\u293D",
  Cup: "\u22D3",
  cup: "\u222A",
  cupbrcap: "\u2A48",
  CupCap: "\u224D",
  cupcap: "\u2A46",
  cupcup: "\u2A4A",
  cupdot: "\u228D",
  cupor: "\u2A45",
  cups: "\u222A\uFE00",
  curarr: "\u21B7",
  curarrm: "\u293C",
  curlyeqprec: "\u22DE",
  curlyeqsucc: "\u22DF",
  curlyvee: "\u22CE",
  curlywedge: "\u22CF",
  curren: "\xA4",
  curvearrowleft: "\u21B6",
  curvearrowright: "\u21B7",
  cuvee: "\u22CE",
  cuwed: "\u22CF",
  cwconint: "\u2232",
  cwint: "\u2231",
  cylcty: "\u232D",
  Dagger: "\u2021",
  dagger: "\u2020",
  daleth: "\u2138",
  Darr: "\u21A1",
  dArr: "\u21D3",
  darr: "\u2193",
  dash: "\u2010",
  Dashv: "\u2AE4",
  dashv: "\u22A3",
  dbkarow: "\u290F",
  dblac: "\u02DD",
  Dcaron: "\u010E",
  dcaron: "\u010F",
  Dcy: "\u0414",
  dcy: "\u0434",
  DD: "\u2145",
  dd: "\u2146",
  ddagger: "\u2021",
  ddarr: "\u21CA",
  DDotrahd: "\u2911",
  ddotseq: "\u2A77",
  deg: "\xB0",
  Del: "\u2207",
  Delta: "\u0394",
  delta: "\u03B4",
  demptyv: "\u29B1",
  dfisht: "\u297F",
  Dfr: "\uD835\uDD07",
  dfr: "\uD835\uDD21",
  dHar: "\u2965",
  dharl: "\u21C3",
  dharr: "\u21C2",
  DiacriticalAcute: "\xB4",
  DiacriticalDot: "\u02D9",
  DiacriticalDoubleAcute: "\u02DD",
  DiacriticalGrave: "`",
  DiacriticalTilde: "\u02DC",
  diam: "\u22C4",
  Diamond: "\u22C4",
  diamond: "\u22C4",
  diamondsuit: "\u2666",
  diams: "\u2666",
  die: "\xA8",
  DifferentialD: "\u2146",
  digamma: "\u03DD",
  disin: "\u22F2",
  div: "\xF7",
  divide: "\xF7",
  divideontimes: "\u22C7",
  divonx: "\u22C7",
  DJcy: "\u0402",
  djcy: "\u0452",
  dlcorn: "\u231E",
  dlcrop: "\u230D",
  dollar: "$",
  Dopf: "\uD835\uDD3B",
  dopf: "\uD835\uDD55",
  Dot: "\xA8",
  dot: "\u02D9",
  DotDot: "\u20DC",
  doteq: "\u2250",
  doteqdot: "\u2251",
  DotEqual: "\u2250",
  dotminus: "\u2238",
  dotplus: "\u2214",
  dotsquare: "\u22A1",
  doublebarwedge: "\u2306",
  DoubleContourIntegral: "\u222F",
  DoubleDot: "\xA8",
  DoubleDownArrow: "\u21D3",
  DoubleLeftArrow: "\u21D0",
  DoubleLeftRightArrow: "\u21D4",
  DoubleLeftTee: "\u2AE4",
  DoubleLongLeftArrow: "\u27F8",
  DoubleLongLeftRightArrow: "\u27FA",
  DoubleLongRightArrow: "\u27F9",
  DoubleRightArrow: "\u21D2",
  DoubleRightTee: "\u22A8",
  DoubleUpArrow: "\u21D1",
  DoubleUpDownArrow: "\u21D5",
  DoubleVerticalBar: "\u2225",
  DownArrow: "\u2193",
  Downarrow: "\u21D3",
  downarrow: "\u2193",
  DownArrowBar: "\u2913",
  DownArrowUpArrow: "\u21F5",
  DownBreve: "\u0311",
  downdownarrows: "\u21CA",
  downharpoonleft: "\u21C3",
  downharpoonright: "\u21C2",
  DownLeftRightVector: "\u2950",
  DownLeftTeeVector: "\u295E",
  DownLeftVector: "\u21BD",
  DownLeftVectorBar: "\u2956",
  DownRightTeeVector: "\u295F",
  DownRightVector: "\u21C1",
  DownRightVectorBar: "\u2957",
  DownTee: "\u22A4",
  DownTeeArrow: "\u21A7",
  drbkarow: "\u2910",
  drcorn: "\u231F",
  drcrop: "\u230C",
  Dscr: "\uD835\uDC9F",
  dscr: "\uD835\uDCB9",
  DScy: "\u0405",
  dscy: "\u0455",
  dsol: "\u29F6",
  Dstrok: "\u0110",
  dstrok: "\u0111",
  dtdot: "\u22F1",
  dtri: "\u25BF",
  dtrif: "\u25BE",
  duarr: "\u21F5",
  duhar: "\u296F",
  dwangle: "\u29A6",
  DZcy: "\u040F",
  dzcy: "\u045F",
  dzigrarr: "\u27FF",
  Eacute: "\xC9",
  eacute: "\xE9",
  easter: "\u2A6E",
  Ecaron: "\u011A",
  ecaron: "\u011B",
  ecir: "\u2256",
  Ecirc: "\xCA",
  ecirc: "\xEA",
  ecolon: "\u2255",
  Ecy: "\u042D",
  ecy: "\u044D",
  eDDot: "\u2A77",
  Edot: "\u0116",
  eDot: "\u2251",
  edot: "\u0117",
  ee: "\u2147",
  efDot: "\u2252",
  Efr: "\uD835\uDD08",
  efr: "\uD835\uDD22",
  eg: "\u2A9A",
  Egrave: "\xC8",
  egrave: "\xE8",
  egs: "\u2A96",
  egsdot: "\u2A98",
  el: "\u2A99",
  Element: "\u2208",
  elinters: "\u23E7",
  ell: "\u2113",
  els: "\u2A95",
  elsdot: "\u2A97",
  Emacr: "\u0112",
  emacr: "\u0113",
  empty: "\u2205",
  emptyset: "\u2205",
  EmptySmallSquare: "\u25FB",
  emptyv: "\u2205",
  EmptyVerySmallSquare: "\u25AB",
  emsp: "\u2003",
  emsp13: "\u2004",
  emsp14: "\u2005",
  ENG: "\u014A",
  eng: "\u014B",
  ensp: "\u2002",
  Eogon: "\u0118",
  eogon: "\u0119",
  Eopf: "\uD835\uDD3C",
  eopf: "\uD835\uDD56",
  epar: "\u22D5",
  eparsl: "\u29E3",
  eplus: "\u2A71",
  epsi: "\u03B5",
  Epsilon: "\u0395",
  epsilon: "\u03B5",
  epsiv: "\u03F5",
  eqcirc: "\u2256",
  eqcolon: "\u2255",
  eqsim: "\u2242",
  eqslantgtr: "\u2A96",
  eqslantless: "\u2A95",
  Equal: "\u2A75",
  equals: "=",
  EqualTilde: "\u2242",
  equest: "\u225F",
  Equilibrium: "\u21CC",
  equiv: "\u2261",
  equivDD: "\u2A78",
  eqvparsl: "\u29E5",
  erarr: "\u2971",
  erDot: "\u2253",
  Escr: "\u2130",
  escr: "\u212F",
  esdot: "\u2250",
  Esim: "\u2A73",
  esim: "\u2242",
  Eta: "\u0397",
  eta: "\u03B7",
  ETH: "\xD0",
  eth: "\xF0",
  Euml: "\xCB",
  euml: "\xEB",
  euro: "\u20AC",
  excl: "!",
  exist: "\u2203",
  Exists: "\u2203",
  expectation: "\u2130",
  ExponentialE: "\u2147",
  exponentiale: "\u2147",
  fallingdotseq: "\u2252",
  Fcy: "\u0424",
  fcy: "\u0444",
  female: "\u2640",
  ffilig: "\uFB03",
  fflig: "\uFB00",
  ffllig: "\uFB04",
  Ffr: "\uD835\uDD09",
  ffr: "\uD835\uDD23",
  filig: "\uFB01",
  FilledSmallSquare: "\u25FC",
  FilledVerySmallSquare: "\u25AA",
  fjlig: "fj",
  flat: "\u266D",
  fllig: "\uFB02",
  fltns: "\u25B1",
  fnof: "\u0192",
  Fopf: "\uD835\uDD3D",
  fopf: "\uD835\uDD57",
  ForAll: "\u2200",
  forall: "\u2200",
  fork: "\u22D4",
  forkv: "\u2AD9",
  Fouriertrf: "\u2131",
  fpartint: "\u2A0D",
  frac12: "\xBD",
  frac13: "\u2153",
  frac14: "\xBC",
  frac15: "\u2155",
  frac16: "\u2159",
  frac18: "\u215B",
  frac23: "\u2154",
  frac25: "\u2156",
  frac34: "\xBE",
  frac35: "\u2157",
  frac38: "\u215C",
  frac45: "\u2158",
  frac56: "\u215A",
  frac58: "\u215D",
  frac78: "\u215E",
  frasl: "\u2044",
  frown: "\u2322",
  Fscr: "\u2131",
  fscr: "\uD835\uDCBB",
  gacute: "\u01F5",
  Gamma: "\u0393",
  gamma: "\u03B3",
  Gammad: "\u03DC",
  gammad: "\u03DD",
  gap: "\u2A86",
  Gbreve: "\u011E",
  gbreve: "\u011F",
  Gcedil: "\u0122",
  Gcirc: "\u011C",
  gcirc: "\u011D",
  Gcy: "\u0413",
  gcy: "\u0433",
  Gdot: "\u0120",
  gdot: "\u0121",
  gE: "\u2267",
  ge: "\u2265",
  gEl: "\u2A8C",
  gel: "\u22DB",
  geq: "\u2265",
  geqq: "\u2267",
  geqslant: "\u2A7E",
  ges: "\u2A7E",
  gescc: "\u2AA9",
  gesdot: "\u2A80",
  gesdoto: "\u2A82",
  gesdotol: "\u2A84",
  gesl: "\u22DB\uFE00",
  gesles: "\u2A94",
  Gfr: "\uD835\uDD0A",
  gfr: "\uD835\uDD24",
  Gg: "\u22D9",
  gg: "\u226B",
  ggg: "\u22D9",
  gimel: "\u2137",
  GJcy: "\u0403",
  gjcy: "\u0453",
  gl: "\u2277",
  gla: "\u2AA5",
  glE: "\u2A92",
  glj: "\u2AA4",
  gnap: "\u2A8A",
  gnapprox: "\u2A8A",
  gnE: "\u2269",
  gne: "\u2A88",
  gneq: "\u2A88",
  gneqq: "\u2269",
  gnsim: "\u22E7",
  Gopf: "\uD835\uDD3E",
  gopf: "\uD835\uDD58",
  grave: "`",
  GreaterEqual: "\u2265",
  GreaterEqualLess: "\u22DB",
  GreaterFullEqual: "\u2267",
  GreaterGreater: "\u2AA2",
  GreaterLess: "\u2277",
  GreaterSlantEqual: "\u2A7E",
  GreaterTilde: "\u2273",
  Gscr: "\uD835\uDCA2",
  gscr: "\u210A",
  gsim: "\u2273",
  gsime: "\u2A8E",
  gsiml: "\u2A90",
  Gt: "\u226B",
  GT: ">",
  gt: ">",
  gtcc: "\u2AA7",
  gtcir: "\u2A7A",
  gtdot: "\u22D7",
  gtlPar: "\u2995",
  gtquest: "\u2A7C",
  gtrapprox: "\u2A86",
  gtrarr: "\u2978",
  gtrdot: "\u22D7",
  gtreqless: "\u22DB",
  gtreqqless: "\u2A8C",
  gtrless: "\u2277",
  gtrsim: "\u2273",
  gvertneqq: "\u2269\uFE00",
  gvnE: "\u2269\uFE00",
  Hacek: "\u02C7",
  hairsp: "\u200A",
  half: "\xBD",
  hamilt: "\u210B",
  HARDcy: "\u042A",
  hardcy: "\u044A",
  hArr: "\u21D4",
  harr: "\u2194",
  harrcir: "\u2948",
  harrw: "\u21AD",
  Hat: "^",
  hbar: "\u210F",
  Hcirc: "\u0124",
  hcirc: "\u0125",
  hearts: "\u2665",
  heartsuit: "\u2665",
  hellip: "\u2026",
  hercon: "\u22B9",
  Hfr: "\u210C",
  hfr: "\uD835\uDD25",
  HilbertSpace: "\u210B",
  hksearow: "\u2925",
  hkswarow: "\u2926",
  hoarr: "\u21FF",
  homtht: "\u223B",
  hookleftarrow: "\u21A9",
  hookrightarrow: "\u21AA",
  Hopf: "\u210D",
  hopf: "\uD835\uDD59",
  horbar: "\u2015",
  HorizontalLine: "\u2500",
  Hscr: "\u210B",
  hscr: "\uD835\uDCBD",
  hslash: "\u210F",
  Hstrok: "\u0126",
  hstrok: "\u0127",
  HumpDownHump: "\u224E",
  HumpEqual: "\u224F",
  hybull: "\u2043",
  hyphen: "\u2010",
  Iacute: "\xCD",
  iacute: "\xED",
  ic: "\u2063",
  Icirc: "\xCE",
  icirc: "\xEE",
  Icy: "\u0418",
  icy: "\u0438",
  Idot: "\u0130",
  IEcy: "\u0415",
  iecy: "\u0435",
  iexcl: "\xA1",
  iff: "\u21D4",
  Ifr: "\u2111",
  ifr: "\uD835\uDD26",
  Igrave: "\xCC",
  igrave: "\xEC",
  ii: "\u2148",
  iiiint: "\u2A0C",
  iiint: "\u222D",
  iinfin: "\u29DC",
  iiota: "\u2129",
  IJlig: "\u0132",
  ijlig: "\u0133",
  Im: "\u2111",
  Imacr: "\u012A",
  imacr: "\u012B",
  image: "\u2111",
  ImaginaryI: "\u2148",
  imagline: "\u2110",
  imagpart: "\u2111",
  imath: "\u0131",
  imof: "\u22B7",
  imped: "\u01B5",
  Implies: "\u21D2",
  in: "\u2208",
  incare: "\u2105",
  infin: "\u221E",
  infintie: "\u29DD",
  inodot: "\u0131",
  Int: "\u222C",
  int: "\u222B",
  intcal: "\u22BA",
  integers: "\u2124",
  Integral: "\u222B",
  intercal: "\u22BA",
  Intersection: "\u22C2",
  intlarhk: "\u2A17",
  intprod: "\u2A3C",
  InvisibleComma: "\u2063",
  InvisibleTimes: "\u2062",
  IOcy: "\u0401",
  iocy: "\u0451",
  Iogon: "\u012E",
  iogon: "\u012F",
  Iopf: "\uD835\uDD40",
  iopf: "\uD835\uDD5A",
  Iota: "\u0399",
  iota: "\u03B9",
  iprod: "\u2A3C",
  iquest: "\xBF",
  Iscr: "\u2110",
  iscr: "\uD835\uDCBE",
  isin: "\u2208",
  isindot: "\u22F5",
  isinE: "\u22F9",
  isins: "\u22F4",
  isinsv: "\u22F3",
  isinv: "\u2208",
  it: "\u2062",
  Itilde: "\u0128",
  itilde: "\u0129",
  Iukcy: "\u0406",
  iukcy: "\u0456",
  Iuml: "\xCF",
  iuml: "\xEF",
  Jcirc: "\u0134",
  jcirc: "\u0135",
  Jcy: "\u0419",
  jcy: "\u0439",
  Jfr: "\uD835\uDD0D",
  jfr: "\uD835\uDD27",
  jmath: "\u0237",
  Jopf: "\uD835\uDD41",
  jopf: "\uD835\uDD5B",
  Jscr: "\uD835\uDCA5",
  jscr: "\uD835\uDCBF",
  Jsercy: "\u0408",
  jsercy: "\u0458",
  Jukcy: "\u0404",
  jukcy: "\u0454",
  Kappa: "\u039A",
  kappa: "\u03BA",
  kappav: "\u03F0",
  Kcedil: "\u0136",
  kcedil: "\u0137",
  Kcy: "\u041A",
  kcy: "\u043A",
  Kfr: "\uD835\uDD0E",
  kfr: "\uD835\uDD28",
  kgreen: "\u0138",
  KHcy: "\u0425",
  khcy: "\u0445",
  KJcy: "\u040C",
  kjcy: "\u045C",
  Kopf: "\uD835\uDD42",
  kopf: "\uD835\uDD5C",
  Kscr: "\uD835\uDCA6",
  kscr: "\uD835\uDCC0",
  lAarr: "\u21DA",
  Lacute: "\u0139",
  lacute: "\u013A",
  laemptyv: "\u29B4",
  lagran: "\u2112",
  Lambda: "\u039B",
  lambda: "\u03BB",
  Lang: "\u27EA",
  lang: "\u27E8",
  langd: "\u2991",
  langle: "\u27E8",
  lap: "\u2A85",
  Laplacetrf: "\u2112",
  laquo: "\xAB",
  Larr: "\u219E",
  lArr: "\u21D0",
  larr: "\u2190",
  larrb: "\u21E4",
  larrbfs: "\u291F",
  larrfs: "\u291D",
  larrhk: "\u21A9",
  larrlp: "\u21AB",
  larrpl: "\u2939",
  larrsim: "\u2973",
  larrtl: "\u21A2",
  lat: "\u2AAB",
  lAtail: "\u291B",
  latail: "\u2919",
  late: "\u2AAD",
  lates: "\u2AAD\uFE00",
  lBarr: "\u290E",
  lbarr: "\u290C",
  lbbrk: "\u2772",
  lbrace: "{",
  lbrack: "[",
  lbrke: "\u298B",
  lbrksld: "\u298F",
  lbrkslu: "\u298D",
  Lcaron: "\u013D",
  lcaron: "\u013E",
  Lcedil: "\u013B",
  lcedil: "\u013C",
  lceil: "\u2308",
  lcub: "{",
  Lcy: "\u041B",
  lcy: "\u043B",
  ldca: "\u2936",
  ldquo: "\u201C",
  ldquor: "\u201E",
  ldrdhar: "\u2967",
  ldrushar: "\u294B",
  ldsh: "\u21B2",
  lE: "\u2266",
  le: "\u2264",
  LeftAngleBracket: "\u27E8",
  LeftArrow: "\u2190",
  Leftarrow: "\u21D0",
  leftarrow: "\u2190",
  LeftArrowBar: "\u21E4",
  LeftArrowRightArrow: "\u21C6",
  leftarrowtail: "\u21A2",
  LeftCeiling: "\u2308",
  LeftDoubleBracket: "\u27E6",
  LeftDownTeeVector: "\u2961",
  LeftDownVector: "\u21C3",
  LeftDownVectorBar: "\u2959",
  LeftFloor: "\u230A",
  leftharpoondown: "\u21BD",
  leftharpoonup: "\u21BC",
  leftleftarrows: "\u21C7",
  LeftRightArrow: "\u2194",
  Leftrightarrow: "\u21D4",
  leftrightarrow: "\u2194",
  leftrightarrows: "\u21C6",
  leftrightharpoons: "\u21CB",
  leftrightsquigarrow: "\u21AD",
  LeftRightVector: "\u294E",
  LeftTee: "\u22A3",
  LeftTeeArrow: "\u21A4",
  LeftTeeVector: "\u295A",
  leftthreetimes: "\u22CB",
  LeftTriangle: "\u22B2",
  LeftTriangleBar: "\u29CF",
  LeftTriangleEqual: "\u22B4",
  LeftUpDownVector: "\u2951",
  LeftUpTeeVector: "\u2960",
  LeftUpVector: "\u21BF",
  LeftUpVectorBar: "\u2958",
  LeftVector: "\u21BC",
  LeftVectorBar: "\u2952",
  lEg: "\u2A8B",
  leg: "\u22DA",
  leq: "\u2264",
  leqq: "\u2266",
  leqslant: "\u2A7D",
  les: "\u2A7D",
  lescc: "\u2AA8",
  lesdot: "\u2A7F",
  lesdoto: "\u2A81",
  lesdotor: "\u2A83",
  lesg: "\u22DA\uFE00",
  lesges: "\u2A93",
  lessapprox: "\u2A85",
  lessdot: "\u22D6",
  lesseqgtr: "\u22DA",
  lesseqqgtr: "\u2A8B",
  LessEqualGreater: "\u22DA",
  LessFullEqual: "\u2266",
  LessGreater: "\u2276",
  lessgtr: "\u2276",
  LessLess: "\u2AA1",
  lesssim: "\u2272",
  LessSlantEqual: "\u2A7D",
  LessTilde: "\u2272",
  lfisht: "\u297C",
  lfloor: "\u230A",
  Lfr: "\uD835\uDD0F",
  lfr: "\uD835\uDD29",
  lg: "\u2276",
  lgE: "\u2A91",
  lHar: "\u2962",
  lhard: "\u21BD",
  lharu: "\u21BC",
  lharul: "\u296A",
  lhblk: "\u2584",
  LJcy: "\u0409",
  ljcy: "\u0459",
  Ll: "\u22D8",
  ll: "\u226A",
  llarr: "\u21C7",
  llcorner: "\u231E",
  Lleftarrow: "\u21DA",
  llhard: "\u296B",
  lltri: "\u25FA",
  Lmidot: "\u013F",
  lmidot: "\u0140",
  lmoust: "\u23B0",
  lmoustache: "\u23B0",
  lnap: "\u2A89",
  lnapprox: "\u2A89",
  lnE: "\u2268",
  lne: "\u2A87",
  lneq: "\u2A87",
  lneqq: "\u2268",
  lnsim: "\u22E6",
  loang: "\u27EC",
  loarr: "\u21FD",
  lobrk: "\u27E6",
  LongLeftArrow: "\u27F5",
  Longleftarrow: "\u27F8",
  longleftarrow: "\u27F5",
  LongLeftRightArrow: "\u27F7",
  Longleftrightarrow: "\u27FA",
  longleftrightarrow: "\u27F7",
  longmapsto: "\u27FC",
  LongRightArrow: "\u27F6",
  Longrightarrow: "\u27F9",
  longrightarrow: "\u27F6",
  looparrowleft: "\u21AB",
  looparrowright: "\u21AC",
  lopar: "\u2985",
  Lopf: "\uD835\uDD43",
  lopf: "\uD835\uDD5D",
  loplus: "\u2A2D",
  lotimes: "\u2A34",
  lowast: "\u2217",
  lowbar: "_",
  LowerLeftArrow: "\u2199",
  LowerRightArrow: "\u2198",
  loz: "\u25CA",
  lozenge: "\u25CA",
  lozf: "\u29EB",
  lpar: "(",
  lparlt: "\u2993",
  lrarr: "\u21C6",
  lrcorner: "\u231F",
  lrhar: "\u21CB",
  lrhard: "\u296D",
  lrm: "\u200E",
  lrtri: "\u22BF",
  lsaquo: "\u2039",
  Lscr: "\u2112",
  lscr: "\uD835\uDCC1",
  Lsh: "\u21B0",
  lsh: "\u21B0",
  lsim: "\u2272",
  lsime: "\u2A8D",
  lsimg: "\u2A8F",
  lsqb: "[",
  lsquo: "\u2018",
  lsquor: "\u201A",
  Lstrok: "\u0141",
  lstrok: "\u0142",
  Lt: "\u226A",
  LT: "<",
  lt: "<",
  ltcc: "\u2AA6",
  ltcir: "\u2A79",
  ltdot: "\u22D6",
  lthree: "\u22CB",
  ltimes: "\u22C9",
  ltlarr: "\u2976",
  ltquest: "\u2A7B",
  ltri: "\u25C3",
  ltrie: "\u22B4",
  ltrif: "\u25C2",
  ltrPar: "\u2996",
  lurdshar: "\u294A",
  luruhar: "\u2966",
  lvertneqq: "\u2268\uFE00",
  lvnE: "\u2268\uFE00",
  macr: "\xAF",
  male: "\u2642",
  malt: "\u2720",
  maltese: "\u2720",
  Map: "\u2905",
  map: "\u21A6",
  mapsto: "\u21A6",
  mapstodown: "\u21A7",
  mapstoleft: "\u21A4",
  mapstoup: "\u21A5",
  marker: "\u25AE",
  mcomma: "\u2A29",
  Mcy: "\u041C",
  mcy: "\u043C",
  mdash: "\u2014",
  mDDot: "\u223A",
  measuredangle: "\u2221",
  MediumSpace: "\u205F",
  Mellintrf: "\u2133",
  Mfr: "\uD835\uDD10",
  mfr: "\uD835\uDD2A",
  mho: "\u2127",
  micro: "\xB5",
  mid: "\u2223",
  midast: "*",
  midcir: "\u2AF0",
  middot: "\xB7",
  minus: "\u2212",
  minusb: "\u229F",
  minusd: "\u2238",
  minusdu: "\u2A2A",
  MinusPlus: "\u2213",
  mlcp: "\u2ADB",
  mldr: "\u2026",
  mnplus: "\u2213",
  models: "\u22A7",
  Mopf: "\uD835\uDD44",
  mopf: "\uD835\uDD5E",
  mp: "\u2213",
  Mscr: "\u2133",
  mscr: "\uD835\uDCC2",
  mstpos: "\u223E",
  Mu: "\u039C",
  mu: "\u03BC",
  multimap: "\u22B8",
  mumap: "\u22B8",
  nabla: "\u2207",
  Nacute: "\u0143",
  nacute: "\u0144",
  nang: "\u2220\u20D2",
  nap: "\u2249",
  napE: "\u2A70\u0338",
  napid: "\u224B\u0338",
  napos: "\u0149",
  napprox: "\u2249",
  natur: "\u266E",
  natural: "\u266E",
  naturals: "\u2115",
  nbsp: "\xA0",
  nbump: "\u224E\u0338",
  nbumpe: "\u224F\u0338",
  ncap: "\u2A43",
  Ncaron: "\u0147",
  ncaron: "\u0148",
  Ncedil: "\u0145",
  ncedil: "\u0146",
  ncong: "\u2247",
  ncongdot: "\u2A6D\u0338",
  ncup: "\u2A42",
  Ncy: "\u041D",
  ncy: "\u043D",
  ndash: "\u2013",
  ne: "\u2260",
  nearhk: "\u2924",
  neArr: "\u21D7",
  nearr: "\u2197",
  nearrow: "\u2197",
  nedot: "\u2250\u0338",
  NegativeMediumSpace: "\u200B",
  NegativeThickSpace: "\u200B",
  NegativeThinSpace: "\u200B",
  NegativeVeryThinSpace: "\u200B",
  nequiv: "\u2262",
  nesear: "\u2928",
  nesim: "\u2242\u0338",
  NestedGreaterGreater: "\u226B",
  NestedLessLess: "\u226A",
  NewLine: "\n",
  nexist: "\u2204",
  nexists: "\u2204",
  Nfr: "\uD835\uDD11",
  nfr: "\uD835\uDD2B",
  ngE: "\u2267\u0338",
  nge: "\u2271",
  ngeq: "\u2271",
  ngeqq: "\u2267\u0338",
  ngeqslant: "\u2A7E\u0338",
  nges: "\u2A7E\u0338",
  nGg: "\u22D9\u0338",
  ngsim: "\u2275",
  nGt: "\u226B\u20D2",
  ngt: "\u226F",
  ngtr: "\u226F",
  nGtv: "\u226B\u0338",
  nhArr: "\u21CE",
  nharr: "\u21AE",
  nhpar: "\u2AF2",
  ni: "\u220B",
  nis: "\u22FC",
  nisd: "\u22FA",
  niv: "\u220B",
  NJcy: "\u040A",
  njcy: "\u045A",
  nlArr: "\u21CD",
  nlarr: "\u219A",
  nldr: "\u2025",
  nlE: "\u2266\u0338",
  nle: "\u2270",
  nLeftarrow: "\u21CD",
  nleftarrow: "\u219A",
  nLeftrightarrow: "\u21CE",
  nleftrightarrow: "\u21AE",
  nleq: "\u2270",
  nleqq: "\u2266\u0338",
  nleqslant: "\u2A7D\u0338",
  nles: "\u2A7D\u0338",
  nless: "\u226E",
  nLl: "\u22D8\u0338",
  nlsim: "\u2274",
  nLt: "\u226A\u20D2",
  nlt: "\u226E",
  nltri: "\u22EA",
  nltrie: "\u22EC",
  nLtv: "\u226A\u0338",
  nmid: "\u2224",
  NoBreak: "\u2060",
  NonBreakingSpace: "\xA0",
  Nopf: "\u2115",
  nopf: "\uD835\uDD5F",
  Not: "\u2AEC",
  not: "\xAC",
  NotCongruent: "\u2262",
  NotCupCap: "\u226D",
  NotDoubleVerticalBar: "\u2226",
  NotElement: "\u2209",
  NotEqual: "\u2260",
  NotEqualTilde: "\u2242\u0338",
  NotExists: "\u2204",
  NotGreater: "\u226F",
  NotGreaterEqual: "\u2271",
  NotGreaterFullEqual: "\u2267\u0338",
  NotGreaterGreater: "\u226B\u0338",
  NotGreaterLess: "\u2279",
  NotGreaterSlantEqual: "\u2A7E\u0338",
  NotGreaterTilde: "\u2275",
  NotHumpDownHump: "\u224E\u0338",
  NotHumpEqual: "\u224F\u0338",
  notin: "\u2209",
  notindot: "\u22F5\u0338",
  notinE: "\u22F9\u0338",
  notinva: "\u2209",
  notinvb: "\u22F7",
  notinvc: "\u22F6",
  NotLeftTriangle: "\u22EA",
  NotLeftTriangleBar: "\u29CF\u0338",
  NotLeftTriangleEqual: "\u22EC",
  NotLess: "\u226E",
  NotLessEqual: "\u2270",
  NotLessGreater: "\u2278",
  NotLessLess: "\u226A\u0338",
  NotLessSlantEqual: "\u2A7D\u0338",
  NotLessTilde: "\u2274",
  NotNestedGreaterGreater: "\u2AA2\u0338",
  NotNestedLessLess: "\u2AA1\u0338",
  notni: "\u220C",
  notniva: "\u220C",
  notnivb: "\u22FE",
  notnivc: "\u22FD",
  NotPrecedes: "\u2280",
  NotPrecedesEqual: "\u2AAF\u0338",
  NotPrecedesSlantEqual: "\u22E0",
  NotReverseElement: "\u220C",
  NotRightTriangle: "\u22EB",
  NotRightTriangleBar: "\u29D0\u0338",
  NotRightTriangleEqual: "\u22ED",
  NotSquareSubset: "\u228F\u0338",
  NotSquareSubsetEqual: "\u22E2",
  NotSquareSuperset: "\u2290\u0338",
  NotSquareSupersetEqual: "\u22E3",
  NotSubset: "\u2282\u20D2",
  NotSubsetEqual: "\u2288",
  NotSucceeds: "\u2281",
  NotSucceedsEqual: "\u2AB0\u0338",
  NotSucceedsSlantEqual: "\u22E1",
  NotSucceedsTilde: "\u227F\u0338",
  NotSuperset: "\u2283\u20D2",
  NotSupersetEqual: "\u2289",
  NotTilde: "\u2241",
  NotTildeEqual: "\u2244",
  NotTildeFullEqual: "\u2247",
  NotTildeTilde: "\u2249",
  NotVerticalBar: "\u2224",
  npar: "\u2226",
  nparallel: "\u2226",
  nparsl: "\u2AFD\u20E5",
  npart: "\u2202\u0338",
  npolint: "\u2A14",
  npr: "\u2280",
  nprcue: "\u22E0",
  npre: "\u2AAF\u0338",
  nprec: "\u2280",
  npreceq: "\u2AAF\u0338",
  nrArr: "\u21CF",
  nrarr: "\u219B",
  nrarrc: "\u2933\u0338",
  nrarrw: "\u219D\u0338",
  nRightarrow: "\u21CF",
  nrightarrow: "\u219B",
  nrtri: "\u22EB",
  nrtrie: "\u22ED",
  nsc: "\u2281",
  nsccue: "\u22E1",
  nsce: "\u2AB0\u0338",
  Nscr: "\uD835\uDCA9",
  nscr: "\uD835\uDCC3",
  nshortmid: "\u2224",
  nshortparallel: "\u2226",
  nsim: "\u2241",
  nsime: "\u2244",
  nsimeq: "\u2244",
  nsmid: "\u2224",
  nspar: "\u2226",
  nsqsube: "\u22E2",
  nsqsupe: "\u22E3",
  nsub: "\u2284",
  nsubE: "\u2AC5\u0338",
  nsube: "\u2288",
  nsubset: "\u2282\u20D2",
  nsubseteq: "\u2288",
  nsubseteqq: "\u2AC5\u0338",
  nsucc: "\u2281",
  nsucceq: "\u2AB0\u0338",
  nsup: "\u2285",
  nsupE: "\u2AC6\u0338",
  nsupe: "\u2289",
  nsupset: "\u2283\u20D2",
  nsupseteq: "\u2289",
  nsupseteqq: "\u2AC6\u0338",
  ntgl: "\u2279",
  Ntilde: "\xD1",
  ntilde: "\xF1",
  ntlg: "\u2278",
  ntriangleleft: "\u22EA",
  ntrianglelefteq: "\u22EC",
  ntriangleright: "\u22EB",
  ntrianglerighteq: "\u22ED",
  Nu: "\u039D",
  nu: "\u03BD",
  num: "#",
  numero: "\u2116",
  numsp: "\u2007",
  nvap: "\u224D\u20D2",
  nVDash: "\u22AF",
  nVdash: "\u22AE",
  nvDash: "\u22AD",
  nvdash: "\u22AC",
  nvge: "\u2265\u20D2",
  nvgt: ">\u20D2",
  nvHarr: "\u2904",
  nvinfin: "\u29DE",
  nvlArr: "\u2902",
  nvle: "\u2264\u20D2",
  nvlt: "<\u20D2",
  nvltrie: "\u22B4\u20D2",
  nvrArr: "\u2903",
  nvrtrie: "\u22B5\u20D2",
  nvsim: "\u223C\u20D2",
  nwarhk: "\u2923",
  nwArr: "\u21D6",
  nwarr: "\u2196",
  nwarrow: "\u2196",
  nwnear: "\u2927",
  Oacute: "\xD3",
  oacute: "\xF3",
  oast: "\u229B",
  ocir: "\u229A",
  Ocirc: "\xD4",
  ocirc: "\xF4",
  Ocy: "\u041E",
  ocy: "\u043E",
  odash: "\u229D",
  Odblac: "\u0150",
  odblac: "\u0151",
  odiv: "\u2A38",
  odot: "\u2299",
  odsold: "\u29BC",
  OElig: "\u0152",
  oelig: "\u0153",
  ofcir: "\u29BF",
  Ofr: "\uD835\uDD12",
  ofr: "\uD835\uDD2C",
  ogon: "\u02DB",
  Ograve: "\xD2",
  ograve: "\xF2",
  ogt: "\u29C1",
  ohbar: "\u29B5",
  ohm: "\u03A9",
  oint: "\u222E",
  olarr: "\u21BA",
  olcir: "\u29BE",
  olcross: "\u29BB",
  oline: "\u203E",
  olt: "\u29C0",
  Omacr: "\u014C",
  omacr: "\u014D",
  Omega: "\u03A9",
  omega: "\u03C9",
  Omicron: "\u039F",
  omicron: "\u03BF",
  omid: "\u29B6",
  ominus: "\u2296",
  Oopf: "\uD835\uDD46",
  oopf: "\uD835\uDD60",
  opar: "\u29B7",
  OpenCurlyDoubleQuote: "\u201C",
  OpenCurlyQuote: "\u2018",
  operp: "\u29B9",
  oplus: "\u2295",
  Or: "\u2A54",
  or: "\u2228",
  orarr: "\u21BB",
  ord: "\u2A5D",
  order: "\u2134",
  orderof: "\u2134",
  ordf: "\xAA",
  ordm: "\xBA",
  origof: "\u22B6",
  oror: "\u2A56",
  orslope: "\u2A57",
  orv: "\u2A5B",
  oS: "\u24C8",
  Oscr: "\uD835\uDCAA",
  oscr: "\u2134",
  Oslash: "\xD8",
  oslash: "\xF8",
  osol: "\u2298",
  Otilde: "\xD5",
  otilde: "\xF5",
  Otimes: "\u2A37",
  otimes: "\u2297",
  otimesas: "\u2A36",
  Ouml: "\xD6",
  ouml: "\xF6",
  ovbar: "\u233D",
  OverBar: "\u203E",
  OverBrace: "\u23DE",
  OverBracket: "\u23B4",
  OverParenthesis: "\u23DC",
  par: "\u2225",
  para: "\xB6",
  parallel: "\u2225",
  parsim: "\u2AF3",
  parsl: "\u2AFD",
  part: "\u2202",
  PartialD: "\u2202",
  Pcy: "\u041F",
  pcy: "\u043F",
  percnt: "%",
  period: ".",
  permil: "\u2030",
  perp: "\u22A5",
  pertenk: "\u2031",
  Pfr: "\uD835\uDD13",
  pfr: "\uD835\uDD2D",
  Phi: "\u03A6",
  phi: "\u03C6",
  phiv: "\u03D5",
  phmmat: "\u2133",
  phone: "\u260E",
  Pi: "\u03A0",
  pi: "\u03C0",
  pitchfork: "\u22D4",
  piv: "\u03D6",
  planck: "\u210F",
  planckh: "\u210E",
  plankv: "\u210F",
  plus: "+",
  plusacir: "\u2A23",
  plusb: "\u229E",
  pluscir: "\u2A22",
  plusdo: "\u2214",
  plusdu: "\u2A25",
  pluse: "\u2A72",
  PlusMinus: "\xB1",
  plusmn: "\xB1",
  plussim: "\u2A26",
  plustwo: "\u2A27",
  pm: "\xB1",
  Poincareplane: "\u210C",
  pointint: "\u2A15",
  Popf: "\u2119",
  popf: "\uD835\uDD61",
  pound: "\xA3",
  Pr: "\u2ABB",
  pr: "\u227A",
  prap: "\u2AB7",
  prcue: "\u227C",
  prE: "\u2AB3",
  pre: "\u2AAF",
  prec: "\u227A",
  precapprox: "\u2AB7",
  preccurlyeq: "\u227C",
  Precedes: "\u227A",
  PrecedesEqual: "\u2AAF",
  PrecedesSlantEqual: "\u227C",
  PrecedesTilde: "\u227E",
  preceq: "\u2AAF",
  precnapprox: "\u2AB9",
  precneqq: "\u2AB5",
  precnsim: "\u22E8",
  precsim: "\u227E",
  Prime: "\u2033",
  prime: "\u2032",
  primes: "\u2119",
  prnap: "\u2AB9",
  prnE: "\u2AB5",
  prnsim: "\u22E8",
  prod: "\u220F",
  Product: "\u220F",
  profalar: "\u232E",
  profline: "\u2312",
  profsurf: "\u2313",
  prop: "\u221D",
  Proportion: "\u2237",
  Proportional: "\u221D",
  propto: "\u221D",
  prsim: "\u227E",
  prurel: "\u22B0",
  Pscr: "\uD835\uDCAB",
  pscr: "\uD835\uDCC5",
  Psi: "\u03A8",
  psi: "\u03C8",
  puncsp: "\u2008",
  Qfr: "\uD835\uDD14",
  qfr: "\uD835\uDD2E",
  qint: "\u2A0C",
  Qopf: "\u211A",
  qopf: "\uD835\uDD62",
  qprime: "\u2057",
  Qscr: "\uD835\uDCAC",
  qscr: "\uD835\uDCC6",
  quaternions: "\u210D",
  quatint: "\u2A16",
  quest: "?",
  questeq: "\u225F",
  QUOT: "\"",
  quot: "\"",
  rAarr: "\u21DB",
  race: "\u223D\u0331",
  Racute: "\u0154",
  racute: "\u0155",
  radic: "\u221A",
  raemptyv: "\u29B3",
  Rang: "\u27EB",
  rang: "\u27E9",
  rangd: "\u2992",
  range: "\u29A5",
  rangle: "\u27E9",
  raquo: "\xBB",
  Rarr: "\u21A0",
  rArr: "\u21D2",
  rarr: "\u2192",
  rarrap: "\u2975",
  rarrb: "\u21E5",
  rarrbfs: "\u2920",
  rarrc: "\u2933",
  rarrfs: "\u291E",
  rarrhk: "\u21AA",
  rarrlp: "\u21AC",
  rarrpl: "\u2945",
  rarrsim: "\u2974",
  Rarrtl: "\u2916",
  rarrtl: "\u21A3",
  rarrw: "\u219D",
  rAtail: "\u291C",
  ratail: "\u291A",
  ratio: "\u2236",
  rationals: "\u211A",
  RBarr: "\u2910",
  rBarr: "\u290F",
  rbarr: "\u290D",
  rbbrk: "\u2773",
  rbrace: "}",
  rbrack: "]",
  rbrke: "\u298C",
  rbrksld: "\u298E",
  rbrkslu: "\u2990",
  Rcaron: "\u0158",
  rcaron: "\u0159",
  Rcedil: "\u0156",
  rcedil: "\u0157",
  rceil: "\u2309",
  rcub: "}",
  Rcy: "\u0420",
  rcy: "\u0440",
  rdca: "\u2937",
  rdldhar: "\u2969",
  rdquo: "\u201D",
  rdquor: "\u201D",
  rdsh: "\u21B3",
  Re: "\u211C",
  real: "\u211C",
  realine: "\u211B",
  realpart: "\u211C",
  reals: "\u211D",
  rect: "\u25AD",
  REG: "\xAE",
  reg: "\xAE",
  ReverseElement: "\u220B",
  ReverseEquilibrium: "\u21CB",
  ReverseUpEquilibrium: "\u296F",
  rfisht: "\u297D",
  rfloor: "\u230B",
  Rfr: "\u211C",
  rfr: "\uD835\uDD2F",
  rHar: "\u2964",
  rhard: "\u21C1",
  rharu: "\u21C0",
  rharul: "\u296C",
  Rho: "\u03A1",
  rho: "\u03C1",
  rhov: "\u03F1",
  RightAngleBracket: "\u27E9",
  RightArrow: "\u2192",
  Rightarrow: "\u21D2",
  rightarrow: "\u2192",
  RightArrowBar: "\u21E5",
  RightArrowLeftArrow: "\u21C4",
  rightarrowtail: "\u21A3",
  RightCeiling: "\u2309",
  RightDoubleBracket: "\u27E7",
  RightDownTeeVector: "\u295D",
  RightDownVector: "\u21C2",
  RightDownVectorBar: "\u2955",
  RightFloor: "\u230B",
  rightharpoondown: "\u21C1",
  rightharpoonup: "\u21C0",
  rightleftarrows: "\u21C4",
  rightleftharpoons: "\u21CC",
  rightrightarrows: "\u21C9",
  rightsquigarrow: "\u219D",
  RightTee: "\u22A2",
  RightTeeArrow: "\u21A6",
  RightTeeVector: "\u295B",
  rightthreetimes: "\u22CC",
  RightTriangle: "\u22B3",
  RightTriangleBar: "\u29D0",
  RightTriangleEqual: "\u22B5",
  RightUpDownVector: "\u294F",
  RightUpTeeVector: "\u295C",
  RightUpVector: "\u21BE",
  RightUpVectorBar: "\u2954",
  RightVector: "\u21C0",
  RightVectorBar: "\u2953",
  ring: "\u02DA",
  risingdotseq: "\u2253",
  rlarr: "\u21C4",
  rlhar: "\u21CC",
  rlm: "\u200F",
  rmoust: "\u23B1",
  rmoustache: "\u23B1",
  rnmid: "\u2AEE",
  roang: "\u27ED",
  roarr: "\u21FE",
  robrk: "\u27E7",
  ropar: "\u2986",
  Ropf: "\u211D",
  ropf: "\uD835\uDD63",
  roplus: "\u2A2E",
  rotimes: "\u2A35",
  RoundImplies: "\u2970",
  rpar: ")",
  rpargt: "\u2994",
  rppolint: "\u2A12",
  rrarr: "\u21C9",
  Rrightarrow: "\u21DB",
  rsaquo: "\u203A",
  Rscr: "\u211B",
  rscr: "\uD835\uDCC7",
  Rsh: "\u21B1",
  rsh: "\u21B1",
  rsqb: "]",
  rsquo: "\u2019",
  rsquor: "\u2019",
  rthree: "\u22CC",
  rtimes: "\u22CA",
  rtri: "\u25B9",
  rtrie: "\u22B5",
  rtrif: "\u25B8",
  rtriltri: "\u29CE",
  RuleDelayed: "\u29F4",
  ruluhar: "\u2968",
  rx: "\u211E",
  Sacute: "\u015A",
  sacute: "\u015B",
  sbquo: "\u201A",
  Sc: "\u2ABC",
  sc: "\u227B",
  scap: "\u2AB8",
  Scaron: "\u0160",
  scaron: "\u0161",
  sccue: "\u227D",
  scE: "\u2AB4",
  sce: "\u2AB0",
  Scedil: "\u015E",
  scedil: "\u015F",
  Scirc: "\u015C",
  scirc: "\u015D",
  scnap: "\u2ABA",
  scnE: "\u2AB6",
  scnsim: "\u22E9",
  scpolint: "\u2A13",
  scsim: "\u227F",
  Scy: "\u0421",
  scy: "\u0441",
  sdot: "\u22C5",
  sdotb: "\u22A1",
  sdote: "\u2A66",
  searhk: "\u2925",
  seArr: "\u21D8",
  searr: "\u2198",
  searrow: "\u2198",
  sect: "\xA7",
  semi: ";",
  seswar: "\u2929",
  setminus: "\u2216",
  setmn: "\u2216",
  sext: "\u2736",
  Sfr: "\uD835\uDD16",
  sfr: "\uD835\uDD30",
  sfrown: "\u2322",
  sharp: "\u266F",
  SHCHcy: "\u0429",
  shchcy: "\u0449",
  SHcy: "\u0428",
  shcy: "\u0448",
  ShortDownArrow: "\u2193",
  ShortLeftArrow: "\u2190",
  shortmid: "\u2223",
  shortparallel: "\u2225",
  ShortRightArrow: "\u2192",
  ShortUpArrow: "\u2191",
  shy: "\xAD",
  Sigma: "\u03A3",
  sigma: "\u03C3",
  sigmaf: "\u03C2",
  sigmav: "\u03C2",
  sim: "\u223C",
  simdot: "\u2A6A",
  sime: "\u2243",
  simeq: "\u2243",
  simg: "\u2A9E",
  simgE: "\u2AA0",
  siml: "\u2A9D",
  simlE: "\u2A9F",
  simne: "\u2246",
  simplus: "\u2A24",
  simrarr: "\u2972",
  slarr: "\u2190",
  SmallCircle: "\u2218",
  smallsetminus: "\u2216",
  smashp: "\u2A33",
  smeparsl: "\u29E4",
  smid: "\u2223",
  smile: "\u2323",
  smt: "\u2AAA",
  smte: "\u2AAC",
  smtes: "\u2AAC\uFE00",
  SOFTcy: "\u042C",
  softcy: "\u044C",
  sol: "/",
  solb: "\u29C4",
  solbar: "\u233F",
  Sopf: "\uD835\uDD4A",
  sopf: "\uD835\uDD64",
  spades: "\u2660",
  spadesuit: "\u2660",
  spar: "\u2225",
  sqcap: "\u2293",
  sqcaps: "\u2293\uFE00",
  sqcup: "\u2294",
  sqcups: "\u2294\uFE00",
  Sqrt: "\u221A",
  sqsub: "\u228F",
  sqsube: "\u2291",
  sqsubset: "\u228F",
  sqsubseteq: "\u2291",
  sqsup: "\u2290",
  sqsupe: "\u2292",
  sqsupset: "\u2290",
  sqsupseteq: "\u2292",
  squ: "\u25A1",
  Square: "\u25A1",
  square: "\u25A1",
  SquareIntersection: "\u2293",
  SquareSubset: "\u228F",
  SquareSubsetEqual: "\u2291",
  SquareSuperset: "\u2290",
  SquareSupersetEqual: "\u2292",
  SquareUnion: "\u2294",
  squarf: "\u25AA",
  squf: "\u25AA",
  srarr: "\u2192",
  Sscr: "\uD835\uDCAE",
  sscr: "\uD835\uDCC8",
  ssetmn: "\u2216",
  ssmile: "\u2323",
  sstarf: "\u22C6",
  Star: "\u22C6",
  star: "\u2606",
  starf: "\u2605",
  straightepsilon: "\u03F5",
  straightphi: "\u03D5",
  strns: "\xAF",
  Sub: "\u22D0",
  sub: "\u2282",
  subdot: "\u2ABD",
  subE: "\u2AC5",
  sube: "\u2286",
  subedot: "\u2AC3",
  submult: "\u2AC1",
  subnE: "\u2ACB",
  subne: "\u228A",
  subplus: "\u2ABF",
  subrarr: "\u2979",
  Subset: "\u22D0",
  subset: "\u2282",
  subseteq: "\u2286",
  subseteqq: "\u2AC5",
  SubsetEqual: "\u2286",
  subsetneq: "\u228A",
  subsetneqq: "\u2ACB",
  subsim: "\u2AC7",
  subsub: "\u2AD5",
  subsup: "\u2AD3",
  succ: "\u227B",
  succapprox: "\u2AB8",
  succcurlyeq: "\u227D",
  Succeeds: "\u227B",
  SucceedsEqual: "\u2AB0",
  SucceedsSlantEqual: "\u227D",
  SucceedsTilde: "\u227F",
  succeq: "\u2AB0",
  succnapprox: "\u2ABA",
  succneqq: "\u2AB6",
  succnsim: "\u22E9",
  succsim: "\u227F",
  SuchThat: "\u220B",
  Sum: "\u2211",
  sum: "\u2211",
  sung: "\u266A",
  Sup: "\u22D1",
  sup: "\u2283",
  sup1: "\xB9",
  sup2: "\xB2",
  sup3: "\xB3",
  supdot: "\u2ABE",
  supdsub: "\u2AD8",
  supE: "\u2AC6",
  supe: "\u2287",
  supedot: "\u2AC4",
  Superset: "\u2283",
  SupersetEqual: "\u2287",
  suphsol: "\u27C9",
  suphsub: "\u2AD7",
  suplarr: "\u297B",
  supmult: "\u2AC2",
  supnE: "\u2ACC",
  supne: "\u228B",
  supplus: "\u2AC0",
  Supset: "\u22D1",
  supset: "\u2283",
  supseteq: "\u2287",
  supseteqq: "\u2AC6",
  supsetneq: "\u228B",
  supsetneqq: "\u2ACC",
  supsim: "\u2AC8",
  supsub: "\u2AD4",
  supsup: "\u2AD6",
  swarhk: "\u2926",
  swArr: "\u21D9",
  swarr: "\u2199",
  swarrow: "\u2199",
  swnwar: "\u292A",
  szlig: "\xDF",
  Tab: "\t",
  target: "\u2316",
  Tau: "\u03A4",
  tau: "\u03C4",
  tbrk: "\u23B4",
  Tcaron: "\u0164",
  tcaron: "\u0165",
  Tcedil: "\u0162",
  tcedil: "\u0163",
  Tcy: "\u0422",
  tcy: "\u0442",
  tdot: "\u20DB",
  telrec: "\u2315",
  Tfr: "\uD835\uDD17",
  tfr: "\uD835\uDD31",
  there4: "\u2234",
  Therefore: "\u2234",
  therefore: "\u2234",
  Theta: "\u0398",
  theta: "\u03B8",
  thetasym: "\u03D1",
  thetav: "\u03D1",
  thickapprox: "\u2248",
  thicksim: "\u223C",
  ThickSpace: "\u205F\u200A",
  thinsp: "\u2009",
  ThinSpace: "\u2009",
  thkap: "\u2248",
  thksim: "\u223C",
  THORN: "\xDE",
  thorn: "\xFE",
  Tilde: "\u223C",
  tilde: "\u02DC",
  TildeEqual: "\u2243",
  TildeFullEqual: "\u2245",
  TildeTilde: "\u2248",
  times: "\xD7",
  timesb: "\u22A0",
  timesbar: "\u2A31",
  timesd: "\u2A30",
  tint: "\u222D",
  toea: "\u2928",
  top: "\u22A4",
  topbot: "\u2336",
  topcir: "\u2AF1",
  Topf: "\uD835\uDD4B",
  topf: "\uD835\uDD65",
  topfork: "\u2ADA",
  tosa: "\u2929",
  tprime: "\u2034",
  TRADE: "\u2122",
  trade: "\u2122",
  triangle: "\u25B5",
  triangledown: "\u25BF",
  triangleleft: "\u25C3",
  trianglelefteq: "\u22B4",
  triangleq: "\u225C",
  triangleright: "\u25B9",
  trianglerighteq: "\u22B5",
  tridot: "\u25EC",
  trie: "\u225C",
  triminus: "\u2A3A",
  TripleDot: "\u20DB",
  triplus: "\u2A39",
  trisb: "\u29CD",
  tritime: "\u2A3B",
  trpezium: "\u23E2",
  Tscr: "\uD835\uDCAF",
  tscr: "\uD835\uDCC9",
  TScy: "\u0426",
  tscy: "\u0446",
  TSHcy: "\u040B",
  tshcy: "\u045B",
  Tstrok: "\u0166",
  tstrok: "\u0167",
  twixt: "\u226C",
  twoheadleftarrow: "\u219E",
  twoheadrightarrow: "\u21A0",
  Uacute: "\xDA",
  uacute: "\xFA",
  Uarr: "\u219F",
  uArr: "\u21D1",
  uarr: "\u2191",
  Uarrocir: "\u2949",
  Ubrcy: "\u040E",
  ubrcy: "\u045E",
  Ubreve: "\u016C",
  ubreve: "\u016D",
  Ucirc: "\xDB",
  ucirc: "\xFB",
  Ucy: "\u0423",
  ucy: "\u0443",
  udarr: "\u21C5",
  Udblac: "\u0170",
  udblac: "\u0171",
  udhar: "\u296E",
  ufisht: "\u297E",
  Ufr: "\uD835\uDD18",
  ufr: "\uD835\uDD32",
  Ugrave: "\xD9",
  ugrave: "\xF9",
  uHar: "\u2963",
  uharl: "\u21BF",
  uharr: "\u21BE",
  uhblk: "\u2580",
  ulcorn: "\u231C",
  ulcorner: "\u231C",
  ulcrop: "\u230F",
  ultri: "\u25F8",
  Umacr: "\u016A",
  umacr: "\u016B",
  uml: "\xA8",
  UnderBar: "_",
  UnderBrace: "\u23DF",
  UnderBracket: "\u23B5",
  UnderParenthesis: "\u23DD",
  Union: "\u22C3",
  UnionPlus: "\u228E",
  Uogon: "\u0172",
  uogon: "\u0173",
  Uopf: "\uD835\uDD4C",
  uopf: "\uD835\uDD66",
  UpArrow: "\u2191",
  Uparrow: "\u21D1",
  uparrow: "\u2191",
  UpArrowBar: "\u2912",
  UpArrowDownArrow: "\u21C5",
  UpDownArrow: "\u2195",
  Updownarrow: "\u21D5",
  updownarrow: "\u2195",
  UpEquilibrium: "\u296E",
  upharpoonleft: "\u21BF",
  upharpoonright: "\u21BE",
  uplus: "\u228E",
  UpperLeftArrow: "\u2196",
  UpperRightArrow: "\u2197",
  Upsi: "\u03D2",
  upsi: "\u03C5",
  upsih: "\u03D2",
  Upsilon: "\u03A5",
  upsilon: "\u03C5",
  UpTee: "\u22A5",
  UpTeeArrow: "\u21A5",
  upuparrows: "\u21C8",
  urcorn: "\u231D",
  urcorner: "\u231D",
  urcrop: "\u230E",
  Uring: "\u016E",
  uring: "\u016F",
  urtri: "\u25F9",
  Uscr: "\uD835\uDCB0",
  uscr: "\uD835\uDCCA",
  utdot: "\u22F0",
  Utilde: "\u0168",
  utilde: "\u0169",
  utri: "\u25B5",
  utrif: "\u25B4",
  uuarr: "\u21C8",
  Uuml: "\xDC",
  uuml: "\xFC",
  uwangle: "\u29A7",
  vangrt: "\u299C",
  varepsilon: "\u03F5",
  varkappa: "\u03F0",
  varnothing: "\u2205",
  varphi: "\u03D5",
  varpi: "\u03D6",
  varpropto: "\u221D",
  vArr: "\u21D5",
  varr: "\u2195",
  varrho: "\u03F1",
  varsigma: "\u03C2",
  varsubsetneq: "\u228A\uFE00",
  varsubsetneqq: "\u2ACB\uFE00",
  varsupsetneq: "\u228B\uFE00",
  varsupsetneqq: "\u2ACC\uFE00",
  vartheta: "\u03D1",
  vartriangleleft: "\u22B2",
  vartriangleright: "\u22B3",
  Vbar: "\u2AEB",
  vBar: "\u2AE8",
  vBarv: "\u2AE9",
  Vcy: "\u0412",
  vcy: "\u0432",
  VDash: "\u22AB",
  Vdash: "\u22A9",
  vDash: "\u22A8",
  vdash: "\u22A2",
  Vdashl: "\u2AE6",
  Vee: "\u22C1",
  vee: "\u2228",
  veebar: "\u22BB",
  veeeq: "\u225A",
  vellip: "\u22EE",
  Verbar: "\u2016",
  verbar: "|",
  Vert: "\u2016",
  vert: "|",
  VerticalBar: "\u2223",
  VerticalLine: "|",
  VerticalSeparator: "\u2758",
  VerticalTilde: "\u2240",
  VeryThinSpace: "\u200A",
  Vfr: "\uD835\uDD19",
  vfr: "\uD835\uDD33",
  vltri: "\u22B2",
  vnsub: "\u2282\u20D2",
  vnsup: "\u2283\u20D2",
  Vopf: "\uD835\uDD4D",
  vopf: "\uD835\uDD67",
  vprop: "\u221D",
  vrtri: "\u22B3",
  Vscr: "\uD835\uDCB1",
  vscr: "\uD835\uDCCB",
  vsubnE: "\u2ACB\uFE00",
  vsubne: "\u228A\uFE00",
  vsupnE: "\u2ACC\uFE00",
  vsupne: "\u228B\uFE00",
  Vvdash: "\u22AA",
  vzigzag: "\u299A",
  Wcirc: "\u0174",
  wcirc: "\u0175",
  wedbar: "\u2A5F",
  Wedge: "\u22C0",
  wedge: "\u2227",
  wedgeq: "\u2259",
  weierp: "\u2118",
  Wfr: "\uD835\uDD1A",
  wfr: "\uD835\uDD34",
  Wopf: "\uD835\uDD4E",
  wopf: "\uD835\uDD68",
  wp: "\u2118",
  wr: "\u2240",
  wreath: "\u2240",
  Wscr: "\uD835\uDCB2",
  wscr: "\uD835\uDCCC",
  xcap: "\u22C2",
  xcirc: "\u25EF",
  xcup: "\u22C3",
  xdtri: "\u25BD",
  Xfr: "\uD835\uDD1B",
  xfr: "\uD835\uDD35",
  xhArr: "\u27FA",
  xharr: "\u27F7",
  Xi: "\u039E",
  xi: "\u03BE",
  xlArr: "\u27F8",
  xlarr: "\u27F5",
  xmap: "\u27FC",
  xnis: "\u22FB",
  xodot: "\u2A00",
  Xopf: "\uD835\uDD4F",
  xopf: "\uD835\uDD69",
  xoplus: "\u2A01",
  xotime: "\u2A02",
  xrArr: "\u27F9",
  xrarr: "\u27F6",
  Xscr: "\uD835\uDCB3",
  xscr: "\uD835\uDCCD",
  xsqcup: "\u2A06",
  xuplus: "\u2A04",
  xutri: "\u25B3",
  xvee: "\u22C1",
  xwedge: "\u22C0",
  Yacute: "\xDD",
  yacute: "\xFD",
  YAcy: "\u042F",
  yacy: "\u044F",
  Ycirc: "\u0176",
  ycirc: "\u0177",
  Ycy: "\u042B",
  ycy: "\u044B",
  yen: "\xA5",
  Yfr: "\uD835\uDD1C",
  yfr: "\uD835\uDD36",
  YIcy: "\u0407",
  yicy: "\u0457",
  Yopf: "\uD835\uDD50",
  yopf: "\uD835\uDD6A",
  Yscr: "\uD835\uDCB4",
  yscr: "\uD835\uDCCE",
  YUcy: "\u042E",
  yucy: "\u044E",
  Yuml: "\u0178",
  yuml: "\xFF",
  Zacute: "\u0179",
  zacute: "\u017A",
  Zcaron: "\u017D",
  zcaron: "\u017E",
  Zcy: "\u0417",
  zcy: "\u0437",
  Zdot: "\u017B",
  zdot: "\u017C",
  zeetrf: "\u2128",
  ZeroWidthSpace: "\u200B",
  Zeta: "\u0396",
  zeta: "\u03B6",
  Zfr: "\u2128",
  zfr: "\uD835\uDD37",
  ZHcy: "\u0416",
  zhcy: "\u0436",
  zigrarr: "\u21DD",
  Zopf: "\u2124",
  zopf: "\uD835\uDD6B",
  Zscr: "\uD835\uDCB5",
  zscr: "\uD835\uDCCF",
  zwj: "\u200D",
  zwnj: "\u200C"
});

/**
 * @deprecated use `HTML_ENTITIES` instead
 * @see HTML_ENTITIES
 */
exports.entityMap = exports.HTML_ENTITIES;

},{"./conventions":256}],260:[function(require,module,exports){
"use strict";

var dom = require('./dom');
exports.DOMImplementation = dom.DOMImplementation;
exports.XMLSerializer = dom.XMLSerializer;
exports.DOMParser = require('./dom-parser').DOMParser;

},{"./dom":258,"./dom-parser":257}],261:[function(require,module,exports){
"use strict";

require("core-js/modules/es.regexp.constructor.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.string.match.js");
var NAMESPACE = require("./conventions").NAMESPACE;

//[4]   	NameStartChar	   ::=   	":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
//[4a]   	NameChar	   ::=   	NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
//[5]   	Name	   ::=   	NameStartChar (NameChar)*
var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/; //\u10000-\uEFFFF
var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
var tagNamePattern = new RegExp('^' + nameStartChar.source + nameChar.source + '*(?:\:' + nameStartChar.source + nameChar.source + '*)?$');
//var tagNamePattern = /^[a-zA-Z_][\w\-\.]*(?:\:[a-zA-Z_][\w\-\.]*)?$/
//var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')

//S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
//S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
var S_TAG = 0; //tag name offerring
var S_ATTR = 1; //attr name offerring
var S_ATTR_SPACE = 2; //attr name end and space offer
var S_EQ = 3; //=space?
var S_ATTR_NOQUOT_VALUE = 4; //attr value(no quot value only)
var S_ATTR_END = 5; //attr value end and no space(quot end)
var S_TAG_SPACE = 6; //(attr value end || tag end ) && (space offer)
var S_TAG_CLOSE = 7; //closed el<el />

/**
 * Creates an error that will not be caught by XMLReader aka the SAX parser.
 *
 * @param {string} message
 * @param {any?} locator Optional, can provide details about the location in the source
 * @constructor
 */
function ParseError(message, locator) {
  this.message = message;
  this.locator = locator;
  if (Error.captureStackTrace) Error.captureStackTrace(this, ParseError);
}
ParseError.prototype = new Error();
ParseError.prototype.name = ParseError.name;
function XMLReader() {}
XMLReader.prototype = {
  parse: function parse(source, defaultNSMap, entityMap) {
    var domBuilder = this.domBuilder;
    domBuilder.startDocument();
    _copy(defaultNSMap, defaultNSMap = {});
    _parse(source, defaultNSMap, entityMap, domBuilder, this.errorHandler);
    domBuilder.endDocument();
  }
};
function _parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
  function fixedFromCharCode(code) {
    // String.prototype.fromCharCode does not supports
    // > 2 bytes unicode chars directly
    if (code > 0xffff) {
      code -= 0x10000;
      var surrogate1 = 0xd800 + (code >> 10),
        surrogate2 = 0xdc00 + (code & 0x3ff);
      return String.fromCharCode(surrogate1, surrogate2);
    } else {
      return String.fromCharCode(code);
    }
  }
  function entityReplacer(a) {
    var k = a.slice(1, -1);
    if (Object.hasOwnProperty.call(entityMap, k)) {
      return entityMap[k];
    } else if (k.charAt(0) === '#') {
      return fixedFromCharCode(parseInt(k.substr(1).replace('x', '0x')));
    } else {
      errorHandler.error('entity not found:' + a);
      return a;
    }
  }
  function appendText(end) {
    //has some bugs
    if (end > start) {
      var xt = source.substring(start, end).replace(/&#?\w+;/g, entityReplacer);
      locator && position(start);
      domBuilder.characters(xt, 0, end - start);
      start = end;
    }
  }
  function position(p, m) {
    while (p >= lineEnd && (m = linePattern.exec(source))) {
      lineStart = m.index;
      lineEnd = lineStart + m[0].length;
      locator.lineNumber++;
      //console.log('line++:',locator,startPos,endPos)
    }

    locator.columnNumber = p - lineStart + 1;
  }
  var lineStart = 0;
  var lineEnd = 0;
  var linePattern = /.*(?:\r\n?|\n)|.*$/g;
  var locator = domBuilder.locator;
  var parseStack = [{
    currentNSMap: defaultNSMapCopy
  }];
  var closeMap = {};
  var start = 0;
  while (true) {
    try {
      var tagStart = source.indexOf('<', start);
      if (tagStart < 0) {
        if (!source.substr(start).match(/^\s*$/)) {
          var doc = domBuilder.doc;
          var text = doc.createTextNode(source.substr(start));
          doc.appendChild(text);
          domBuilder.currentElement = text;
        }
        return;
      }
      if (tagStart > start) {
        appendText(tagStart);
      }
      switch (source.charAt(tagStart + 1)) {
        case '/':
          var end = source.indexOf('>', tagStart + 3);
          var tagName = source.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, '');
          var config = parseStack.pop();
          if (end < 0) {
            tagName = source.substring(tagStart + 2).replace(/[\s<].*/, '');
            errorHandler.error("end tag name: " + tagName + ' is not complete:' + config.tagName);
            end = tagStart + 1 + tagName.length;
          } else if (tagName.match(/\s</)) {
            tagName = tagName.replace(/[\s<].*/, '');
            errorHandler.error("end tag name: " + tagName + ' maybe not complete');
            end = tagStart + 1 + tagName.length;
          }
          var localNSMap = config.localNSMap;
          var endMatch = config.tagName == tagName;
          var endIgnoreCaseMach = endMatch || config.tagName && config.tagName.toLowerCase() == tagName.toLowerCase();
          if (endIgnoreCaseMach) {
            domBuilder.endElement(config.uri, config.localName, tagName);
            if (localNSMap) {
              for (var prefix in localNSMap) {
                if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
                  domBuilder.endPrefixMapping(prefix);
                }
              }
            }
            if (!endMatch) {
              errorHandler.fatalError("end tag name: " + tagName + ' is not match the current start tagName:' + config.tagName); // No known test case
            }
          } else {
            parseStack.push(config);
          }
          end++;
          break;
        // end elment
        case '?':
          // <?...?>
          locator && position(tagStart);
          end = parseInstruction(source, tagStart, domBuilder);
          break;
        case '!':
          // <!doctype,<![CDATA,<!--
          locator && position(tagStart);
          end = parseDCC(source, tagStart, domBuilder, errorHandler);
          break;
        default:
          locator && position(tagStart);
          var el = new ElementAttributes();
          var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
          //elStartEnd
          var end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler);
          var len = el.length;
          if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {
            el.closed = true;
            if (!entityMap.nbsp) {
              errorHandler.warning('unclosed xml attribute');
            }
          }
          if (locator && len) {
            var locator2 = copyLocator(locator, {});
            //try{//attribute position fixed
            for (var i = 0; i < len; i++) {
              var a = el[i];
              position(a.offset);
              a.locator = copyLocator(locator, {});
            }
            domBuilder.locator = locator2;
            if (appendElement(el, domBuilder, currentNSMap)) {
              parseStack.push(el);
            }
            domBuilder.locator = locator;
          } else {
            if (appendElement(el, domBuilder, currentNSMap)) {
              parseStack.push(el);
            }
          }
          if (NAMESPACE.isHTML(el.uri) && !el.closed) {
            end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);
          } else {
            end++;
          }
      }
    } catch (e) {
      if (e instanceof ParseError) {
        throw e;
      }
      errorHandler.error('element parse error: ' + e);
      end = -1;
    }
    if (end > start) {
      start = end;
    } else {
      //TODO: sax
      appendText(Math.max(tagStart, start) + 1);
    }
  }
}
function copyLocator(f, t) {
  t.lineNumber = f.lineNumber;
  t.columnNumber = f.columnNumber;
  return t;
}

/**
 * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);
 * @return end of the elementStartPart(end of elementEndPart for selfClosed el)
 */
function parseElementStartPart(source, start, el, currentNSMap, entityReplacer, errorHandler) {
  /**
   * @param {string} qname
   * @param {string} value
   * @param {number} startIndex
   */
  function addAttribute(qname, value, startIndex) {
    if (el.attributeNames.hasOwnProperty(qname)) {
      errorHandler.fatalError('Attribute ' + qname + ' redefined');
    }
    el.addValue(qname,
    // @see https://www.w3.org/TR/xml/#AVNormalize
    // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
    // - recursive replacement of (DTD) entity references
    // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
    value.replace(/[\t\n\r]/g, ' ').replace(/&#?\w+;/g, entityReplacer), startIndex);
  }
  var attrName;
  var value;
  var p = ++start;
  var s = S_TAG; //status
  while (true) {
    var c = source.charAt(p);
    switch (c) {
      case '=':
        if (s === S_ATTR) {
          //attrName
          attrName = source.slice(start, p);
          s = S_EQ;
        } else if (s === S_ATTR_SPACE) {
          s = S_EQ;
        } else {
          //fatalError: equal must after attrName or space after attrName
          throw new Error('attribute equal must after attrName'); // No known test case
        }

        break;
      case '\'':
      case '"':
        if (s === S_EQ || s === S_ATTR //|| s == S_ATTR_SPACE
        ) {
          //equal
          if (s === S_ATTR) {
            errorHandler.warning('attribute value must after "="');
            attrName = source.slice(start, p);
          }
          start = p + 1;
          p = source.indexOf(c, start);
          if (p > 0) {
            value = source.slice(start, p);
            addAttribute(attrName, value, start - 1);
            s = S_ATTR_END;
          } else {
            //fatalError: no end quot match
            throw new Error('attribute value no end \'' + c + '\' match');
          }
        } else if (s == S_ATTR_NOQUOT_VALUE) {
          value = source.slice(start, p);
          addAttribute(attrName, value, start);
          errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c + ')!!');
          start = p + 1;
          s = S_ATTR_END;
        } else {
          //fatalError: no equal before
          throw new Error('attribute value must after "="'); // No known test case
        }

        break;
      case '/':
        switch (s) {
          case S_TAG:
            el.setTagName(source.slice(start, p));
          case S_ATTR_END:
          case S_TAG_SPACE:
          case S_TAG_CLOSE:
            s = S_TAG_CLOSE;
            el.closed = true;
          case S_ATTR_NOQUOT_VALUE:
          case S_ATTR:
            break;
          case S_ATTR_SPACE:
            el.closed = true;
            break;
          //case S_EQ:
          default:
            throw new Error("attribute invalid close char('/')");
          // No known test case
        }

        break;
      case '':
        //end document
        errorHandler.error('unexpected end of input');
        if (s == S_TAG) {
          el.setTagName(source.slice(start, p));
        }
        return p;
      case '>':
        switch (s) {
          case S_TAG:
            el.setTagName(source.slice(start, p));
          case S_ATTR_END:
          case S_TAG_SPACE:
          case S_TAG_CLOSE:
            break;
          //normal
          case S_ATTR_NOQUOT_VALUE: //Compatible state
          case S_ATTR:
            value = source.slice(start, p);
            if (value.slice(-1) === '/') {
              el.closed = true;
              value = value.slice(0, -1);
            }
          case S_ATTR_SPACE:
            if (s === S_ATTR_SPACE) {
              value = attrName;
            }
            if (s == S_ATTR_NOQUOT_VALUE) {
              errorHandler.warning('attribute "' + value + '" missed quot(")!');
              addAttribute(attrName, value, start);
            } else {
              if (!NAMESPACE.isHTML(currentNSMap['']) || !value.match(/^(?:disabled|checked|selected)$/i)) {
                errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
              }
              addAttribute(value, value, start);
            }
            break;
          case S_EQ:
            throw new Error('attribute value missed!!');
        }
        //			console.log(tagName,tagNamePattern,tagNamePattern.test(tagName))
        return p;
      /*xml space '\x20' | #x9 | #xD | #xA; */
      case "\x80":
        c = ' ';
      default:
        if (c <= ' ') {
          //space
          switch (s) {
            case S_TAG:
              el.setTagName(source.slice(start, p)); //tagName
              s = S_TAG_SPACE;
              break;
            case S_ATTR:
              attrName = source.slice(start, p);
              s = S_ATTR_SPACE;
              break;
            case S_ATTR_NOQUOT_VALUE:
              var value = source.slice(start, p);
              errorHandler.warning('attribute "' + value + '" missed quot(")!!');
              addAttribute(attrName, value, start);
            case S_ATTR_END:
              s = S_TAG_SPACE;
              break;
            //case S_TAG_SPACE:
            //case S_EQ:
            //case S_ATTR_SPACE:
            //	void();break;
            //case S_TAG_CLOSE:
            //ignore warning
          }
        } else {
          //not space
          //S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
          //S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
          switch (s) {
            //case S_TAG:void();break;
            //case S_ATTR:void();break;
            //case S_ATTR_NOQUOT_VALUE:void();break;
            case S_ATTR_SPACE:
              var tagName = el.tagName;
              if (!NAMESPACE.isHTML(currentNSMap['']) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
                errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
              }
              addAttribute(attrName, attrName, start);
              start = p;
              s = S_ATTR;
              break;
            case S_ATTR_END:
              errorHandler.warning('attribute space is required"' + attrName + '"!!');
            case S_TAG_SPACE:
              s = S_ATTR;
              start = p;
              break;
            case S_EQ:
              s = S_ATTR_NOQUOT_VALUE;
              start = p;
              break;
            case S_TAG_CLOSE:
              throw new Error("elements closed character '/' and '>' must be connected to");
          }
        }
    } //end outer switch
    //console.log('p++',p)
    p++;
  }
}
/**
 * @return true if has new namespace define
 */
function appendElement(el, domBuilder, currentNSMap) {
  var tagName = el.tagName;
  var localNSMap = null;
  //var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
  var i = el.length;
  while (i--) {
    var a = el[i];
    var qName = a.qName;
    var value = a.value;
    var nsp = qName.indexOf(':');
    if (nsp > 0) {
      var prefix = a.prefix = qName.slice(0, nsp);
      var localName = qName.slice(nsp + 1);
      var nsPrefix = prefix === 'xmlns' && localName;
    } else {
      localName = qName;
      prefix = null;
      nsPrefix = qName === 'xmlns' && '';
    }
    //can not set prefix,because prefix !== ''
    a.localName = localName;
    //prefix == null for no ns prefix attribute
    if (nsPrefix !== false) {
      //hack!!
      if (localNSMap == null) {
        localNSMap = {};
        //console.log(currentNSMap,0)
        _copy(currentNSMap, currentNSMap = {});
        //console.log(currentNSMap,1)
      }

      currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
      a.uri = NAMESPACE.XMLNS;
      domBuilder.startPrefixMapping(nsPrefix, value);
    }
  }
  var i = el.length;
  while (i--) {
    a = el[i];
    var prefix = a.prefix;
    if (prefix) {
      //no prefix attribute has no namespace
      if (prefix === 'xml') {
        a.uri = NAMESPACE.XML;
      }
      if (prefix !== 'xmlns') {
        a.uri = currentNSMap[prefix || ''];

        //{console.log('###'+a.qName,domBuilder.locator.systemId+'',currentNSMap,a.uri)}
      }
    }
  }

  var nsp = tagName.indexOf(':');
  if (nsp > 0) {
    prefix = el.prefix = tagName.slice(0, nsp);
    localName = el.localName = tagName.slice(nsp + 1);
  } else {
    prefix = null; //important!!
    localName = el.localName = tagName;
  }
  //no prefix element has default namespace
  var ns = el.uri = currentNSMap[prefix || ''];
  domBuilder.startElement(ns, localName, tagName, el);
  //endPrefixMapping and startPrefixMapping have not any help for dom builder
  //localNSMap = null
  if (el.closed) {
    domBuilder.endElement(ns, localName, tagName);
    if (localNSMap) {
      for (prefix in localNSMap) {
        if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
          domBuilder.endPrefixMapping(prefix);
        }
      }
    }
  } else {
    el.currentNSMap = currentNSMap;
    el.localNSMap = localNSMap;
    //parseStack.push(el);
    return true;
  }
}
function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
  if (/^(?:script|textarea)$/i.test(tagName)) {
    var elEndStart = source.indexOf('</' + tagName + '>', elStartEnd);
    var text = source.substring(elStartEnd + 1, elEndStart);
    if (/[&<]/.test(text)) {
      if (/^script$/i.test(tagName)) {
        //if(!/\]\]>/.test(text)){
        //lexHandler.startCDATA();
        domBuilder.characters(text, 0, text.length);
        //lexHandler.endCDATA();
        return elEndStart;
        //}
      } //}else{//text area
      text = text.replace(/&#?\w+;/g, entityReplacer);
      domBuilder.characters(text, 0, text.length);
      return elEndStart;
      //}
    }
  }

  return elStartEnd + 1;
}
function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
  //if(tagName in closeMap){
  var pos = closeMap[tagName];
  if (pos == null) {
    //console.log(tagName)
    pos = source.lastIndexOf('</' + tagName + '>');
    if (pos < elStartEnd) {
      //
      pos = source.lastIndexOf('</' + tagName);
    }
    closeMap[tagName] = pos;
  }
  return pos < elStartEnd;
  //}
}

function _copy(source, target) {
  for (var n in source) {
    if (Object.prototype.hasOwnProperty.call(source, n)) {
      target[n] = source[n];
    }
  }
}
function parseDCC(source, start, domBuilder, errorHandler) {
  //sure start with '<!'
  var next = source.charAt(start + 2);
  switch (next) {
    case '-':
      if (source.charAt(start + 3) === '-') {
        var end = source.indexOf('-->', start + 4);
        //append comment source.substring(4,end)//<!--
        if (end > start) {
          domBuilder.comment(source, start + 4, end - start - 4);
          return end + 3;
        } else {
          errorHandler.error("Unclosed comment");
          return -1;
        }
      } else {
        //error
        return -1;
      }
    default:
      if (source.substr(start + 3, 6) == 'CDATA[') {
        var end = source.indexOf(']]>', start + 9);
        domBuilder.startCDATA();
        domBuilder.characters(source, start + 9, end - start - 9);
        domBuilder.endCDATA();
        return end + 3;
      }
      //<!DOCTYPE
      //startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId)
      var matchs = split(source, start);
      var len = matchs.length;
      if (len > 1 && /!doctype/i.test(matchs[0][0])) {
        var name = matchs[1][0];
        var pubid = false;
        var sysid = false;
        if (len > 3) {
          if (/^public$/i.test(matchs[2][0])) {
            pubid = matchs[3][0];
            sysid = len > 4 && matchs[4][0];
          } else if (/^system$/i.test(matchs[2][0])) {
            sysid = matchs[3][0];
          }
        }
        var lastMatch = matchs[len - 1];
        domBuilder.startDTD(name, pubid, sysid);
        domBuilder.endDTD();
        return lastMatch.index + lastMatch[0].length;
      }
  }
  return -1;
}
function parseInstruction(source, start, domBuilder) {
  var end = source.indexOf('?>', start);
  if (end) {
    var match = source.substring(start, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
    if (match) {
      var len = match[0].length;
      domBuilder.processingInstruction(match[1], match[2]);
      return end + 2;
    } else {
      //error
      return -1;
    }
  }
  return -1;
}
function ElementAttributes() {
  this.attributeNames = {};
}
ElementAttributes.prototype = {
  setTagName: function setTagName(tagName) {
    if (!tagNamePattern.test(tagName)) {
      throw new Error('invalid tagName:' + tagName);
    }
    this.tagName = tagName;
  },
  addValue: function addValue(qName, value, offset) {
    if (!tagNamePattern.test(qName)) {
      throw new Error('invalid attribute:' + qName);
    }
    this.attributeNames[qName] = this.length;
    this[this.length++] = {
      qName: qName,
      value: value,
      offset: offset
    };
  },
  length: 0,
  getLocalName: function getLocalName(i) {
    return this[i].localName;
  },
  getLocator: function getLocator(i) {
    return this[i].locator;
  },
  getQName: function getQName(i) {
    return this[i].qName;
  },
  getURI: function getURI(i) {
    return this[i].uri;
  },
  getValue: function getValue(i) {
    return this[i].value;
  }
  //	,getIndex:function(uri, localName)){
  //		if(localName){
  //
  //		}else{
  //			var qName = uri
  //		}
  //	},
  //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
  //	getType:function(uri,localName){}
  //	getType:function(i){},
};

function split(source, start) {
  var match;
  var buf = [];
  var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
  reg.lastIndex = start;
  reg.exec(source); //skip <
  while (match = reg.exec(source)) {
    buf.push(match);
    if (match[1]) return buf;
  }
}
exports.XMLReader = XMLReader;
exports.ParseError = ParseError;

},{"./conventions":256,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.regexp.constructor.js":617,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.match.js":627,"core-js/modules/es.string.replace.js":629}],262:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
// ConvertTo-TS run at 2016-10-04T11:26:49.0828748-07:00
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.function.name.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var assert = require("assert");
var Decorators_1 = require("./Decorators");
var IntStream_1 = require("./IntStream");
var READ_BUFFER_SIZE = 1024;
var INITIAL_BUFFER_SIZE = 1024;
/**
 * Vacuum all input from a {@link Reader}/{@link InputStream} and then treat it
 * like a `char[]` buffer. Can also pass in a {@link String} or
 * `char[]` to use.
 *
 * If you need encoding, pass in stream/reader with correct encoding.
 *
 * @deprecated as of 4.7, please use `CharStreams` interface.
 */
var ANTLRInputStream = /*#__PURE__*/function () {
  /** Copy data in string to a local char array */
  function ANTLRInputStream(input) {
    (0, _classCallCheck2.default)(this, ANTLRInputStream);
    /** 0..n-1 index into string of next char */
    this.p = 0;
    this.data = input;
    this.n = input.length;
  }
  /** Reset the stream so that it's in the same state it was
   *  when the object was created *except* the data array is not
   *  touched.
   */
  (0, _createClass2.default)(ANTLRInputStream, [{
    key: "reset",
    value: function reset() {
      this.p = 0;
    }
  }, {
    key: "consume",
    value: function consume() {
      if (this.p >= this.n) {
        assert(this.LA(1) === IntStream_1.IntStream.EOF);
        throw new Error("cannot consume EOF");
      }
      //System.out.println("prev p="+p+", c="+(char)data[p]);
      if (this.p < this.n) {
        this.p++;
        //System.out.println("p moves to "+p+" (c='"+(char)data[p]+"')");
      }
    }
  }, {
    key: "LA",
    value: function LA(i) {
      if (i === 0) {
        return 0; // undefined
      }

      if (i < 0) {
        i++; // e.g., translate LA(-1) to use offset i=0; then data[p+0-1]
        if (this.p + i - 1 < 0) {
          return IntStream_1.IntStream.EOF; // invalid; no char before first char
        }
      }

      if (this.p + i - 1 >= this.n) {
        //System.out.println("char LA("+i+")=EOF; p="+p);
        return IntStream_1.IntStream.EOF;
      }
      //System.out.println("char LA("+i+")="+(char)data[p+i-1]+"; p="+p);
      //System.out.println("LA("+i+"); p="+p+" n="+n+" data.length="+data.length);
      return this.data.charCodeAt(this.p + i - 1);
    }
  }, {
    key: "LT",
    value: function LT(i) {
      return this.LA(i);
    }
    /** Return the current input symbol index 0..n where n indicates the
     *  last symbol has been read.  The index is the index of char to
     *  be returned from LA(1).
     */
  }, {
    key: "index",
    get: function get() {
      return this.p;
    }
  }, {
    key: "size",
    get: function get() {
      return this.n;
    }
    /** mark/release do nothing; we have entire buffer */
  }, {
    key: "mark",
    value: function mark() {
      return -1;
    }
  }, {
    key: "release",
    value: function release(marker) {
      // No default implementation since this stream buffers the entire input
    }
    /** consume() ahead until p==index; can't just set p=index as we must
     *  update line and charPositionInLine. If we seek backwards, just set p
     */
  }, {
    key: "seek",
    value: function seek(index) {
      if (index <= this.p) {
        this.p = index; // just jump; don't update stream state (line, ...)
        return;
      }
      // seek forward, consume until p hits index or n (whichever comes first)
      index = Math.min(index, this.n);
      while (this.p < index) {
        this.consume();
      }
    }
  }, {
    key: "getText",
    value: function getText(interval) {
      var start = interval.a;
      var stop = interval.b;
      if (stop >= this.n) {
        stop = this.n - 1;
      }
      var count = stop - start + 1;
      if (start >= this.n) {
        return "";
      }
      // System.err.println("data: "+Arrays.toString(data)+", n="+n+
      // 				   ", start="+start+
      // 				   ", stop="+stop);
      return this.data.substr(start, count);
    }
  }, {
    key: "sourceName",
    get: function get() {
      if (!this.name) {
        return IntStream_1.IntStream.UNKNOWN_SOURCE_NAME;
      }
      return this.name;
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.data;
    }
  }]);
  return ANTLRInputStream;
}();
__decorate([Decorators_1.Override], ANTLRInputStream.prototype, "consume", null);
__decorate([Decorators_1.Override], ANTLRInputStream.prototype, "LA", null);
__decorate([Decorators_1.Override], ANTLRInputStream.prototype, "index", null);
__decorate([Decorators_1.Override], ANTLRInputStream.prototype, "size", null);
__decorate([Decorators_1.Override], ANTLRInputStream.prototype, "mark", null);
__decorate([Decorators_1.Override], ANTLRInputStream.prototype, "release", null);
__decorate([Decorators_1.Override], ANTLRInputStream.prototype, "seek", null);
__decorate([Decorators_1.Override], ANTLRInputStream.prototype, "getText", null);
__decorate([Decorators_1.Override], ANTLRInputStream.prototype, "sourceName", null);
__decorate([Decorators_1.Override], ANTLRInputStream.prototype, "toString", null);
exports.ANTLRInputStream = ANTLRInputStream;

},{"./Decorators":272,"./IntStream":278,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"assert":413,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612}],263:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:49.2855056-07:00
var DefaultErrorStrategy_1 = require("./DefaultErrorStrategy");
var InputMismatchException_1 = require("./InputMismatchException");
var Decorators_1 = require("./Decorators");
var ParseCancellationException_1 = require("./misc/ParseCancellationException");
/**
 * This implementation of {@link ANTLRErrorStrategy} responds to syntax errors
 * by immediately canceling the parse operation with a
 * {@link ParseCancellationException}. The implementation ensures that the
 * {@link ParserRuleContext#exception} field is set for all parse tree nodes
 * that were not completed prior to encountering the error.
 *
 * This error strategy is useful in the following scenarios.
 *
 * * **Two-stage parsing:** This error strategy allows the first
 *   stage of two-stage parsing to immediately terminate if an error is
 *   encountered, and immediately fall back to the second stage. In addition to
 *   avoiding wasted work by attempting to recover from errors here, the empty
 *   implementation of {@link BailErrorStrategy#sync} improves the performance of
 *   the first stage.
 * * **Silent validation:** When syntax errors are not being
 *   reported or logged, and the parse result is simply ignored if errors occur,
 *   the {@link BailErrorStrategy} avoids wasting work on recovering from errors
 *   when the result will be ignored either way.
 *
 * ```
 * myparser.errorHandler = new BailErrorStrategy();
 * ```
 *
 * @see Parser.errorHandler
 */
var BailErrorStrategy = /*#__PURE__*/function (_DefaultErrorStrategy) {
  (0, _inherits2.default)(BailErrorStrategy, _DefaultErrorStrategy);
  var _super = _createSuper(BailErrorStrategy);
  function BailErrorStrategy() {
    (0, _classCallCheck2.default)(this, BailErrorStrategy);
    return _super.apply(this, arguments);
  }
  (0, _createClass2.default)(BailErrorStrategy, [{
    key: "recover",
    value:
    /** Instead of recovering from exception `e`, re-throw it wrapped
     *  in a {@link ParseCancellationException} so it is not caught by the
     *  rule function catches.  Use {@link Exception#getCause()} to get the
     *  original {@link RecognitionException}.
     */
    function recover(recognizer, e) {
      for (var context = recognizer.context; context; context = context.parent) {
        context.exception = e;
      }
      throw new ParseCancellationException_1.ParseCancellationException(e);
    }
    /** Make sure we don't attempt to recover inline; if the parser
     *  successfully recovers, it won't throw an exception.
     */
  }, {
    key: "recoverInline",
    value: function recoverInline(recognizer) {
      var e = new InputMismatchException_1.InputMismatchException(recognizer);
      for (var context = recognizer.context; context; context = context.parent) {
        context.exception = e;
      }
      throw new ParseCancellationException_1.ParseCancellationException(e);
    }
    /** Make sure we don't attempt to recover from problems in subrules. */
  }, {
    key: "sync",
    value: function sync(recognizer) {
      // intentionally empty
    }
  }]);
  return BailErrorStrategy;
}(DefaultErrorStrategy_1.DefaultErrorStrategy);
__decorate([Decorators_1.Override], BailErrorStrategy.prototype, "recover", null);
__decorate([Decorators_1.Override], BailErrorStrategy.prototype, "recoverInline", null);
__decorate([Decorators_1.Override], BailErrorStrategy.prototype, "sync", null);
exports.BailErrorStrategy = BailErrorStrategy;

},{"./Decorators":272,"./DefaultErrorStrategy":273,"./InputMismatchException":277,"./misc/ParseCancellationException":383,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],264:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.set.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.array.filter.js");
require("core-js/modules/es.array.fill.js");
require("core-js/modules/es.regexp.to-string.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:49.6074365-07:00
var assert = require("assert");
var CommonToken_1 = require("./CommonToken");
var Interval_1 = require("./misc/Interval");
var Lexer_1 = require("./Lexer");
var Decorators_1 = require("./Decorators");
var Token_1 = require("./Token");
/**
 * This implementation of {@link TokenStream} loads tokens from a
 * {@link TokenSource} on-demand, and places the tokens in a buffer to provide
 * access to any previous token by index.
 *
 * This token stream ignores the value of {@link Token#getChannel}. If your
 * parser requires the token stream filter tokens to only those on a particular
 * channel, such as {@link Token#DEFAULT_CHANNEL} or
 * {@link Token#HIDDEN_CHANNEL}, use a filtering token stream such a
 * {@link CommonTokenStream}.
 */
var BufferedTokenStream = /*#__PURE__*/function () {
  function BufferedTokenStream(tokenSource) {
    (0, _classCallCheck2.default)(this, BufferedTokenStream);
    /**
     * A collection of all tokens fetched from the token source. The list is
     * considered a complete view of the input once {@link #fetchedEOF} is set
     * to `true`.
     */
    this.tokens = [];
    /**
     * The index into {@link #tokens} of the current token (next token to
     * {@link #consume}). {@link #tokens}`[`{@link #p}`]` should be
     * {@link #LT LT(1)}.
     *
     * This field is set to -1 when the stream is first constructed or when
     * {@link #setTokenSource} is called, indicating that the first token has
     * not yet been fetched from the token source. For additional information,
     * see the documentation of {@link IntStream} for a description of
     * Initializing Methods.
     */
    this.p = -1;
    /**
     * Indicates whether the {@link Token#EOF} token has been fetched from
     * {@link #tokenSource} and added to {@link #tokens}. This field improves
     * performance for the following cases:
     *
     * * {@link #consume}: The lookahead check in {@link #consume} to prevent
     *   consuming the EOF symbol is optimized by checking the values of
     *   {@link #fetchedEOF} and {@link #p} instead of calling {@link #LA}.
     * * {@link #fetch}: The check to prevent adding multiple EOF symbols into
     *   {@link #tokens} is trivial with this field.
     */
    this.fetchedEOF = false;
    if (tokenSource == null) {
      throw new Error("tokenSource cannot be null");
    }
    this._tokenSource = tokenSource;
  }
  (0, _createClass2.default)(BufferedTokenStream, [{
    key: "tokenSource",
    get: function get() {
      return this._tokenSource;
    }
    /** Reset this token stream by setting its token source. */,
    set: function set(tokenSource) {
      this._tokenSource = tokenSource;
      this.tokens.length = 0;
      this.p = -1;
      this.fetchedEOF = false;
    }
  }, {
    key: "index",
    get: function get() {
      return this.p;
    }
  }, {
    key: "mark",
    value: function mark() {
      return 0;
    }
  }, {
    key: "release",
    value: function release(marker) {
      // no resources to release
    }
  }, {
    key: "seek",
    value: function seek(index) {
      this.lazyInit();
      this.p = this.adjustSeekIndex(index);
    }
  }, {
    key: "size",
    get: function get() {
      return this.tokens.length;
    }
  }, {
    key: "consume",
    value: function consume() {
      var skipEofCheck;
      if (this.p >= 0) {
        if (this.fetchedEOF) {
          // the last token in tokens is EOF. skip check if p indexes any
          // fetched token except the last.
          skipEofCheck = this.p < this.tokens.length - 1;
        } else {
          // no EOF token in tokens. skip check if p indexes a fetched token.
          skipEofCheck = this.p < this.tokens.length;
        }
      } else {
        // not yet initialized
        skipEofCheck = false;
      }
      if (!skipEofCheck && this.LA(1) === Token_1.Token.EOF) {
        throw new Error("cannot consume EOF");
      }
      if (this.sync(this.p + 1)) {
        this.p = this.adjustSeekIndex(this.p + 1);
      }
    }
    /** Make sure index `i` in tokens has a token.
     *
     * @returns `true` if a token is located at index `i`, otherwise
     *    `false`.
     * @see #get(int i)
     */
  }, {
    key: "sync",
    value: function sync(i) {
      assert(i >= 0);
      var n = i - this.tokens.length + 1; // how many more elements we need?
      //System.out.println("sync("+i+") needs "+n);
      if (n > 0) {
        var fetched = this.fetch(n);
        return fetched >= n;
      }
      return true;
    }
    /** Add `n` elements to buffer.
     *
     * @returns The actual number of elements added to the buffer.
     */
  }, {
    key: "fetch",
    value: function fetch(n) {
      if (this.fetchedEOF) {
        return 0;
      }
      for (var i = 0; i < n; i++) {
        var t = this.tokenSource.nextToken();
        if (this.isWritableToken(t)) {
          t.tokenIndex = this.tokens.length;
        }
        this.tokens.push(t);
        if (t.type === Token_1.Token.EOF) {
          this.fetchedEOF = true;
          return i + 1;
        }
      }
      return n;
    }
  }, {
    key: "get",
    value: function get(i) {
      if (i < 0 || i >= this.tokens.length) {
        throw new RangeError("token index " + i + " out of range 0.." + (this.tokens.length - 1));
      }
      return this.tokens[i];
    }
    /** Get all tokens from start..stop inclusively. */
  }, {
    key: "getRange",
    value: function getRange(start, stop) {
      if (start < 0 || stop < 0) {
        return [];
      }
      this.lazyInit();
      var subset = new Array();
      if (stop >= this.tokens.length) {
        stop = this.tokens.length - 1;
      }
      for (var i = start; i <= stop; i++) {
        var t = this.tokens[i];
        if (t.type === Token_1.Token.EOF) {
          break;
        }
        subset.push(t);
      }
      return subset;
    }
  }, {
    key: "LA",
    value: function LA(i) {
      var token = this.LT(i);
      if (!token) {
        return Token_1.Token.INVALID_TYPE;
      }
      return token.type;
    }
  }, {
    key: "tryLB",
    value: function tryLB(k) {
      if (this.p - k < 0) {
        return undefined;
      }
      return this.tokens[this.p - k];
    }
  }, {
    key: "LT",
    value: function LT(k) {
      var result = this.tryLT(k);
      if (result === undefined) {
        throw new RangeError("requested lookback index out of range");
      }
      return result;
    }
  }, {
    key: "tryLT",
    value: function tryLT(k) {
      this.lazyInit();
      if (k === 0) {
        throw new RangeError("0 is not a valid lookahead index");
      }
      if (k < 0) {
        return this.tryLB(-k);
      }
      var i = this.p + k - 1;
      this.sync(i);
      if (i >= this.tokens.length) {
        // return EOF token
        // EOF must be last token
        return this.tokens[this.tokens.length - 1];
      }
      //		if ( i>range ) range = i;
      return this.tokens[i];
    }
    /**
     * Allowed derived classes to modify the behavior of operations which change
     * the current stream position by adjusting the target token index of a seek
     * operation. The default implementation simply returns `i`. If an
     * exception is thrown in this method, the current stream index should not be
     * changed.
     *
     * For example, {@link CommonTokenStream} overrides this method to ensure that
     * the seek target is always an on-channel token.
     *
     * @param i The target token index.
     * @returns The adjusted target token index.
     */
  }, {
    key: "adjustSeekIndex",
    value: function adjustSeekIndex(i) {
      return i;
    }
  }, {
    key: "lazyInit",
    value: function lazyInit() {
      if (this.p === -1) {
        this.setup();
      }
    }
  }, {
    key: "setup",
    value: function setup() {
      this.sync(0);
      this.p = this.adjustSeekIndex(0);
    }
    /** Given a start and stop index, return a `List` of all tokens in
     *  the token type `BitSet`.  Return an empty array if no tokens were found.  This
     *  method looks at both on and off channel tokens.
     */
  }, {
    key: "getTokens",
    value: function getTokens(start, stop, types) {
      this.lazyInit();
      if (start === undefined) {
        assert(stop === undefined && types === undefined);
        return this.tokens;
      } else if (stop === undefined) {
        stop = this.tokens.length - 1;
      }
      if (start < 0 || stop >= this.tokens.length || stop < 0 || start >= this.tokens.length) {
        throw new RangeError("start " + start + " or stop " + stop + " not in 0.." + (this.tokens.length - 1));
      }
      if (start > stop) {
        return [];
      }
      if (types === undefined) {
        return this.tokens.slice(start, stop + 1);
      } else if (typeof types === "number") {
        types = new Set().add(types);
      }
      var typesSet = types;
      // list = tokens[start:stop]:{T t, t.type in types}
      var filteredTokens = this.tokens.slice(start, stop + 1);
      filteredTokens = filteredTokens.filter(function (value) {
        return typesSet.has(value.type);
      });
      return filteredTokens;
    }
    /**
     * Given a starting index, return the index of the next token on channel.
     * Return `i` if `tokens[i]` is on channel. Return the index of
     * the EOF token if there are no tokens on channel between `i` and
     * EOF.
     */
  }, {
    key: "nextTokenOnChannel",
    value: function nextTokenOnChannel(i, channel) {
      this.sync(i);
      if (i >= this.size) {
        return this.size - 1;
      }
      var token = this.tokens[i];
      while (token.channel !== channel) {
        if (token.type === Token_1.Token.EOF) {
          return i;
        }
        i++;
        this.sync(i);
        token = this.tokens[i];
      }
      return i;
    }
    /**
     * Given a starting index, return the index of the previous token on
     * channel. Return `i` if `tokens[i]` is on channel. Return -1
     * if there are no tokens on channel between `i` and 0.
     *
     * If `i` specifies an index at or after the EOF token, the EOF token
     * index is returned. This is due to the fact that the EOF token is treated
     * as though it were on every channel.
     */
  }, {
    key: "previousTokenOnChannel",
    value: function previousTokenOnChannel(i, channel) {
      this.sync(i);
      if (i >= this.size) {
        // the EOF token is on every channel
        return this.size - 1;
      }
      while (i >= 0) {
        var token = this.tokens[i];
        if (token.type === Token_1.Token.EOF || token.channel === channel) {
          return i;
        }
        i--;
      }
      return i;
    }
    /** Collect all tokens on specified channel to the right of
     *  the current token up until we see a token on {@link Lexer#DEFAULT_TOKEN_CHANNEL} or
     *  EOF. If `channel` is `-1`, find any non default channel token.
     */
  }, {
    key: "getHiddenTokensToRight",
    value: function getHiddenTokensToRight(tokenIndex) {
      var channel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
      this.lazyInit();
      if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
        throw new RangeError(tokenIndex + " not in 0.." + (this.tokens.length - 1));
      }
      var nextOnChannel = this.nextTokenOnChannel(tokenIndex + 1, Lexer_1.Lexer.DEFAULT_TOKEN_CHANNEL);
      var to;
      var from = tokenIndex + 1;
      // if none onchannel to right, nextOnChannel=-1 so set to = last token
      if (nextOnChannel === -1) {
        to = this.size - 1;
      } else {
        to = nextOnChannel;
      }
      return this.filterForChannel(from, to, channel);
    }
    /** Collect all tokens on specified channel to the left of
     *  the current token up until we see a token on {@link Lexer#DEFAULT_TOKEN_CHANNEL}.
     *  If `channel` is `-1`, find any non default channel token.
     */
  }, {
    key: "getHiddenTokensToLeft",
    value: function getHiddenTokensToLeft(tokenIndex) {
      var channel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
      this.lazyInit();
      if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
        throw new RangeError(tokenIndex + " not in 0.." + (this.tokens.length - 1));
      }
      if (tokenIndex === 0) {
        // obviously no tokens can appear before the first token
        return [];
      }
      var prevOnChannel = this.previousTokenOnChannel(tokenIndex - 1, Lexer_1.Lexer.DEFAULT_TOKEN_CHANNEL);
      if (prevOnChannel === tokenIndex - 1) {
        return [];
      }
      // if none onchannel to left, prevOnChannel=-1 then from=0
      var from = prevOnChannel + 1;
      var to = tokenIndex - 1;
      return this.filterForChannel(from, to, channel);
    }
  }, {
    key: "filterForChannel",
    value: function filterForChannel(from, to, channel) {
      var hidden = new Array();
      for (var i = from; i <= to; i++) {
        var t = this.tokens[i];
        if (channel === -1) {
          if (t.channel !== Lexer_1.Lexer.DEFAULT_TOKEN_CHANNEL) {
            hidden.push(t);
          }
        } else {
          if (t.channel === channel) {
            hidden.push(t);
          }
        }
      }
      return hidden;
    }
  }, {
    key: "sourceName",
    get: function get() {
      return this.tokenSource.sourceName;
    }
  }, {
    key: "getText",
    value: function getText(interval) {
      if (interval === undefined) {
        interval = Interval_1.Interval.of(0, this.size - 1);
      } else if (!(interval instanceof Interval_1.Interval)) {
        // Note: the more obvious check for 'instanceof RuleContext' results in a circular dependency problem
        interval = interval.sourceInterval;
      }
      var start = interval.a;
      var stop = interval.b;
      if (start < 0 || stop < 0) {
        return "";
      }
      this.fill();
      if (stop >= this.tokens.length) {
        stop = this.tokens.length - 1;
      }
      var buf = "";
      for (var i = start; i <= stop; i++) {
        var t = this.tokens[i];
        if (t.type === Token_1.Token.EOF) {
          break;
        }
        buf += t.text;
      }
      return buf.toString();
    }
  }, {
    key: "getTextFromRange",
    value: function getTextFromRange(start, stop) {
      if (this.isToken(start) && this.isToken(stop)) {
        return this.getText(Interval_1.Interval.of(start.tokenIndex, stop.tokenIndex));
      }
      return "";
    }
    /** Get all tokens from lexer until EOF. */
  }, {
    key: "fill",
    value: function fill() {
      this.lazyInit();
      var blockSize = 1000;
      while (true) {
        var fetched = this.fetch(blockSize);
        if (fetched < blockSize) {
          return;
        }
      }
    }
    // TODO: Figure out a way to make this more flexible?
  }, {
    key: "isWritableToken",
    value: function isWritableToken(t) {
      return t instanceof CommonToken_1.CommonToken;
    }
    // TODO: Figure out a way to make this more flexible?
  }, {
    key: "isToken",
    value: function isToken(t) {
      return t instanceof CommonToken_1.CommonToken;
    }
  }]);
  return BufferedTokenStream;
}();
__decorate([Decorators_1.NotNull], BufferedTokenStream.prototype, "_tokenSource", void 0);
__decorate([Decorators_1.Override], BufferedTokenStream.prototype, "tokenSource", null);
__decorate([Decorators_1.Override], BufferedTokenStream.prototype, "index", null);
__decorate([Decorators_1.Override], BufferedTokenStream.prototype, "mark", null);
__decorate([Decorators_1.Override], BufferedTokenStream.prototype, "release", null);
__decorate([Decorators_1.Override], BufferedTokenStream.prototype, "seek", null);
__decorate([Decorators_1.Override], BufferedTokenStream.prototype, "size", null);
__decorate([Decorators_1.Override], BufferedTokenStream.prototype, "consume", null);
__decorate([Decorators_1.Override], BufferedTokenStream.prototype, "get", null);
__decorate([Decorators_1.Override], BufferedTokenStream.prototype, "LA", null);
__decorate([Decorators_1.NotNull, Decorators_1.Override], BufferedTokenStream.prototype, "LT", null);
__decorate([Decorators_1.Override], BufferedTokenStream.prototype, "sourceName", null);
__decorate([Decorators_1.NotNull, Decorators_1.Override], BufferedTokenStream.prototype, "getText", null);
__decorate([Decorators_1.NotNull, Decorators_1.Override], BufferedTokenStream.prototype, "getTextFromRange", null);
BufferedTokenStream = __decorate([__param(0, Decorators_1.NotNull)], BufferedTokenStream);
exports.BufferedTokenStream = BufferedTokenStream;

},{"./CommonToken":268,"./Decorators":272,"./Lexer":280,"./Token":296,"./misc/Interval":378,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"assert":413,"core-js/modules/es.array.fill.js":571,"core-js/modules/es.array.filter.js":572,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.set.js":621,"core-js/modules/es.string.iterator.js":626,"core-js/modules/web.dom-collections.iterator.js":677}],265:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array-buffer.slice.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.typed-array.uint16-array.js");
require("core-js/modules/es.typed-array.copy-within.js");
require("core-js/modules/es.typed-array.every.js");
require("core-js/modules/es.typed-array.fill.js");
require("core-js/modules/es.typed-array.filter.js");
require("core-js/modules/es.typed-array.find.js");
require("core-js/modules/es.typed-array.find-index.js");
require("core-js/modules/es.typed-array.for-each.js");
require("core-js/modules/es.typed-array.includes.js");
require("core-js/modules/es.typed-array.index-of.js");
require("core-js/modules/es.typed-array.iterator.js");
require("core-js/modules/es.typed-array.join.js");
require("core-js/modules/es.typed-array.last-index-of.js");
require("core-js/modules/es.typed-array.map.js");
require("core-js/modules/es.typed-array.reduce.js");
require("core-js/modules/es.typed-array.reduce-right.js");
require("core-js/modules/es.typed-array.reverse.js");
require("core-js/modules/es.typed-array.set.js");
require("core-js/modules/es.typed-array.slice.js");
require("core-js/modules/es.typed-array.some.js");
require("core-js/modules/es.typed-array.sort.js");
require("core-js/modules/es.typed-array.subarray.js");
require("core-js/modules/es.typed-array.to-locale-string.js");
require("core-js/modules/es.typed-array.to-string.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
var CodePointBuffer_1 = require("./CodePointBuffer");
var CodePointCharStream_1 = require("./CodePointCharStream");
var IntStream_1 = require("./IntStream");
// const DEFAULT_BUFFER_SIZE: number = 4096;
/** This class represents the primary interface for creating {@link CharStream}s
 *  from a variety of sources as of 4.7.  The motivation was to support
 *  Unicode code points > U+FFFF.  {@link ANTLRInputStream} and
 *  {@link ANTLRFileStream} are now deprecated in favor of the streams created
 *  by this interface.
 *
 *  DEPRECATED: {@code new ANTLRFileStream("myinputfile")}
 *  NEW:        {@code CharStreams.fromFileName("myinputfile")}
 *
 *  WARNING: If you use both the deprecated and the new streams, you will see
 *  a nontrivial performance degradation. This speed hit is because the
 *  {@link Lexer}'s internal code goes from a monomorphic to megamorphic
 *  dynamic dispatch to get characters from the input stream. Java's
 *  on-the-fly compiler (JIT) is unable to perform the same optimizations
 *  so stick with either the old or the new streams, if performance is
 *  a primary concern. See the extreme debugging and spelunking
 *  needed to identify this issue in our timing rig:
 *
 *      https://github.com/antlr/antlr4/pull/1781
 *
 *  The ANTLR character streams still buffer all the input when you create
 *  the stream, as they have done for ~20 years. If you need unbuffered
 *  access, please note that it becomes challenging to create
 *  parse trees. The parse tree has to point to tokens which will either
 *  point into a stale location in an unbuffered stream or you have to copy
 *  the characters out of the buffer into the token. That defeats the purpose
 *  of unbuffered input. Per the ANTLR book, unbuffered streams are primarily
 *  useful for processing infinite streams *during the parse.*
 *
 *  The new streams also use 8-bit buffers when possible so this new
 *  interface supports character streams that use half as much memory
 *  as the old {@link ANTLRFileStream}, which assumed 16-bit characters.
 *
 *  A big shout out to Ben Hamilton (github bhamiltoncx) for his superhuman
 *  efforts across all targets to get true Unicode 3.1 support for U+10FFFF.
 *
 *  @since 4.7
 */
var CharStreams;
(function (CharStreams) {
  // /**
  //  * Creates a {@link CharStream} given a path to a UTF-8
  //  * encoded file on disk.
  //  *
  //  * Reads the entire contents of the file into the result before returning.
  //  */
  // export function fromFile(file: File): CharStream;
  // export function fromFile(file: File, charset: Charset): CharStream;
  // export function fromFile(file: File, charset?: Charset): CharStream {
  // 	if (charset === undefined) {
  // 		charset = Charset.forName("UTF-8");
  // 	}
  function fromString(s, sourceName) {
    if (sourceName === undefined || sourceName.length === 0) {
      sourceName = IntStream_1.IntStream.UNKNOWN_SOURCE_NAME;
    }
    // Initial guess assumes no code points > U+FFFF: one code
    // point for each code unit in the string
    var codePointBufferBuilder = CodePointBuffer_1.CodePointBuffer.builder(s.length);
    // TODO: CharBuffer.wrap(String) rightfully returns a read-only buffer
    // which doesn't expose its array, so we make a copy.
    var cb = new Uint16Array(s.length);
    for (var i = 0; i < s.length; i++) {
      cb[i] = s.charCodeAt(i);
    }
    codePointBufferBuilder.append(cb);
    return CodePointCharStream_1.CodePointCharStream.fromBuffer(codePointBufferBuilder.build(), sourceName);
  }
  CharStreams.fromString = fromString;
  // export function bufferFromChannel(
  // 	channel: ReadableByteChannel,
  // 	charset: Charset,
  // 	bufferSize: number,
  // 	decodingErrorAction: CodingErrorAction,
  // 	inputSize: number): CodePointBuffer {
  // 	try {
  // 		let utf8BytesIn: Uint8Array = new Uint8Array(bufferSize);
  // 		let utf16CodeUnitsOut: Uint16Array = new Uint16Array(bufferSize);
  // 		if (inputSize === -1) {
  // 			inputSize = bufferSize;
  // 		} else if (inputSize > Integer.MAX_VALUE) {
  // 			// ByteBuffer et al don't support long sizes
  // 			throw new RangeError(`inputSize ${inputSize} larger than max ${Integer.MAX_VALUE}`);
  // 		}
  // 		let codePointBufferBuilder: CodePointBuffer.Builder = CodePointBuffer.builder(inputSize);
  // 		let decoder: CharsetDecoder = charset
  // 				.newDecoder()
  // 				.onMalformedInput(decodingErrorAction)
  // 				.onUnmappableCharacter(decodingErrorAction);
  // 		let endOfInput: boolean = false;
  // 		while (!endOfInput) {
  // 			let bytesRead: number = channel.read(utf8BytesIn);
  // 			endOfInput = (bytesRead === -1);
  // 			utf8BytesIn.flip();
  // 			let result: CoderResult = decoder.decode(
  // 				utf8BytesIn,
  // 				utf16CodeUnitsOut,
  // 				endOfInput);
  // 			if (result.isError() && decodingErrorAction === CodingErrorAction.REPORT) {
  // 				result.throwException();
  // 			}
  // 			utf16CodeUnitsOut.flip();
  // 			codePointBufferBuilder.append(utf16CodeUnitsOut);
  // 			utf8BytesIn.compact();
  // 			utf16CodeUnitsOut.compact();
  // 		}
  // 		// Handle any bytes at the end of the file which need to
  // 		// be represented as errors or substitution characters.
  // 		let flushResult: CoderResult = decoder.flush(utf16CodeUnitsOut);
  // 		if (flushResult.isError() && decodingErrorAction === CodingErrorAction.REPORT) {
  // 			flushResult.throwException();
  // 		}
  // 		utf16CodeUnitsOut.flip();
  // 		codePointBufferBuilder.append(utf16CodeUnitsOut);
  // 		return codePointBufferBuilder.build();
  // 	}
  // 	finally {
  // 		channel.close();
  // 	}
  // }
})(CharStreams = exports.CharStreams || (exports.CharStreams = {}));

},{"./CodePointBuffer":266,"./CodePointCharStream":267,"./IntStream":278,"core-js/modules/es.array-buffer.slice.js":568,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.typed-array.copy-within.js":641,"core-js/modules/es.typed-array.every.js":642,"core-js/modules/es.typed-array.fill.js":643,"core-js/modules/es.typed-array.filter.js":644,"core-js/modules/es.typed-array.find-index.js":645,"core-js/modules/es.typed-array.find.js":646,"core-js/modules/es.typed-array.for-each.js":649,"core-js/modules/es.typed-array.includes.js":650,"core-js/modules/es.typed-array.index-of.js":651,"core-js/modules/es.typed-array.iterator.js":655,"core-js/modules/es.typed-array.join.js":656,"core-js/modules/es.typed-array.last-index-of.js":657,"core-js/modules/es.typed-array.map.js":658,"core-js/modules/es.typed-array.reduce-right.js":659,"core-js/modules/es.typed-array.reduce.js":660,"core-js/modules/es.typed-array.reverse.js":661,"core-js/modules/es.typed-array.set.js":662,"core-js/modules/es.typed-array.slice.js":663,"core-js/modules/es.typed-array.some.js":664,"core-js/modules/es.typed-array.sort.js":665,"core-js/modules/es.typed-array.subarray.js":666,"core-js/modules/es.typed-array.to-locale-string.js":667,"core-js/modules/es.typed-array.to-string.js":668,"core-js/modules/es.typed-array.uint16-array.js":669}],266:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array-buffer.slice.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.typed-array.uint8-array.js");
require("core-js/modules/es.typed-array.copy-within.js");
require("core-js/modules/es.typed-array.every.js");
require("core-js/modules/es.typed-array.fill.js");
require("core-js/modules/es.typed-array.filter.js");
require("core-js/modules/es.typed-array.find.js");
require("core-js/modules/es.typed-array.find-index.js");
require("core-js/modules/es.typed-array.for-each.js");
require("core-js/modules/es.typed-array.includes.js");
require("core-js/modules/es.typed-array.index-of.js");
require("core-js/modules/es.typed-array.iterator.js");
require("core-js/modules/es.typed-array.join.js");
require("core-js/modules/es.typed-array.last-index-of.js");
require("core-js/modules/es.typed-array.map.js");
require("core-js/modules/es.typed-array.reduce.js");
require("core-js/modules/es.typed-array.reduce-right.js");
require("core-js/modules/es.typed-array.reverse.js");
require("core-js/modules/es.typed-array.set.js");
require("core-js/modules/es.typed-array.slice.js");
require("core-js/modules/es.typed-array.some.js");
require("core-js/modules/es.typed-array.sort.js");
require("core-js/modules/es.typed-array.subarray.js");
require("core-js/modules/es.typed-array.to-locale-string.js");
require("core-js/modules/es.typed-array.to-string.js");
require("core-js/modules/es.typed-array.uint16-array.js");
require("core-js/modules/es.typed-array.int32-array.js");
require("core-js/modules/es.string.code-point-at.js");
require("core-js/modules/es.math.clz32.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
Object.defineProperty(exports, "__esModule", {
  value: true
});
var assert = require("assert");
var Character = require("./misc/Character");
/**
 * Wrapper for `Uint8Array` / `Uint16Array` / `Int32Array`.
 */
var CodePointBuffer = /*#__PURE__*/function () {
  function CodePointBuffer(buffer, size) {
    (0, _classCallCheck2.default)(this, CodePointBuffer);
    this.buffer = buffer;
    this._position = 0;
    this._size = size;
  }
  (0, _createClass2.default)(CodePointBuffer, [{
    key: "position",
    get: function get() {
      return this._position;
    },
    set: function set(newPosition) {
      if (newPosition < 0 || newPosition > this._size) {
        throw new RangeError();
      }
      this._position = newPosition;
    }
  }, {
    key: "remaining",
    get: function get() {
      return this._size - this.position;
    }
  }, {
    key: "get",
    value: function get(offset) {
      return this.buffer[offset];
    }
  }, {
    key: "array",
    value: function array() {
      return this.buffer.slice(0, this._size);
    }
  }], [{
    key: "withArray",
    value: function withArray(buffer) {
      return new CodePointBuffer(buffer, buffer.length);
    }
  }, {
    key: "builder",
    value: function builder(initialBufferSize) {
      return new CodePointBuffer.Builder(initialBufferSize);
    }
  }]);
  return CodePointBuffer;
}();
exports.CodePointBuffer = CodePointBuffer;
(function (CodePointBuffer) {
  var Type;
  (function (Type) {
    Type[Type["BYTE"] = 0] = "BYTE";
    Type[Type["CHAR"] = 1] = "CHAR";
    Type[Type["INT"] = 2] = "INT";
  })(Type || (Type = {}));
  var Builder = /*#__PURE__*/function () {
    function Builder(initialBufferSize) {
      (0, _classCallCheck2.default)(this, Builder);
      this.type = 0 /* BYTE */;
      this.buffer = new Uint8Array(initialBufferSize);
      this.prevHighSurrogate = -1;
      this.position = 0;
    }
    (0, _createClass2.default)(Builder, [{
      key: "build",
      value: function build() {
        return new CodePointBuffer(this.buffer, this.position);
      }
    }, {
      key: "ensureRemaining",
      value: function ensureRemaining(remainingNeeded) {
        switch (this.type) {
          case 0 /* BYTE */:
            if (this.buffer.length - this.position < remainingNeeded) {
              var newCapacity = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);
              var newBuffer = new Uint8Array(newCapacity);
              newBuffer.set(this.buffer.subarray(0, this.position), 0);
              this.buffer = newBuffer;
            }
            break;
          case 1 /* CHAR */:
            if (this.buffer.length - this.position < remainingNeeded) {
              var _newCapacity = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);
              var _newBuffer = new Uint16Array(_newCapacity);
              _newBuffer.set(this.buffer.subarray(0, this.position), 0);
              this.buffer = _newBuffer;
            }
            break;
          case 2 /* INT */:
            if (this.buffer.length - this.position < remainingNeeded) {
              var _newCapacity2 = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);
              var _newBuffer2 = new Int32Array(_newCapacity2);
              _newBuffer2.set(this.buffer.subarray(0, this.position), 0);
              this.buffer = _newBuffer2;
            }
            break;
        }
      }
    }, {
      key: "append",
      value: function append(utf16In) {
        this.ensureRemaining(utf16In.length);
        this.appendArray(utf16In);
      }
    }, {
      key: "appendArray",
      value: function appendArray(utf16In) {
        switch (this.type) {
          case 0 /* BYTE */:
            this.appendArrayByte(utf16In);
            break;
          case 1 /* CHAR */:
            this.appendArrayChar(utf16In);
            break;
          case 2 /* INT */:
            this.appendArrayInt(utf16In);
            break;
        }
      }
    }, {
      key: "appendArrayByte",
      value: function appendArrayByte(utf16In) {
        assert(this.prevHighSurrogate === -1);
        var input = utf16In;
        var inOffset = 0;
        var inLimit = utf16In.length;
        var outByte = this.buffer;
        var outOffset = this.position;
        while (inOffset < inLimit) {
          var c = input[inOffset];
          if (c <= 0xFF) {
            outByte[outOffset] = c;
          } else {
            utf16In = utf16In.subarray(inOffset, inLimit);
            this.position = outOffset;
            if (!Character.isHighSurrogate(c)) {
              this.byteToCharBuffer(utf16In.length);
              this.appendArrayChar(utf16In);
              return;
            } else {
              this.byteToIntBuffer(utf16In.length);
              this.appendArrayInt(utf16In);
              return;
            }
          }
          inOffset++;
          outOffset++;
        }
        this.position = outOffset;
      }
    }, {
      key: "appendArrayChar",
      value: function appendArrayChar(utf16In) {
        assert(this.prevHighSurrogate === -1);
        var input = utf16In;
        var inOffset = 0;
        var inLimit = utf16In.length;
        var outChar = this.buffer;
        var outOffset = this.position;
        while (inOffset < inLimit) {
          var c = input[inOffset];
          if (!Character.isHighSurrogate(c)) {
            outChar[outOffset] = c;
          } else {
            utf16In = utf16In.subarray(inOffset, inLimit);
            this.position = outOffset;
            this.charToIntBuffer(utf16In.length);
            this.appendArrayInt(utf16In);
            return;
          }
          inOffset++;
          outOffset++;
        }
        this.position = outOffset;
      }
    }, {
      key: "appendArrayInt",
      value: function appendArrayInt(utf16In) {
        var input = utf16In;
        var inOffset = 0;
        var inLimit = utf16In.length;
        var outInt = this.buffer;
        var outOffset = this.position;
        while (inOffset < inLimit) {
          var c = input[inOffset];
          inOffset++;
          if (this.prevHighSurrogate !== -1) {
            if (Character.isLowSurrogate(c)) {
              outInt[outOffset] = String.fromCharCode(this.prevHighSurrogate, c).codePointAt(0);
              outOffset++;
              this.prevHighSurrogate = -1;
            } else {
              // Dangling high surrogate
              outInt[outOffset] = this.prevHighSurrogate;
              outOffset++;
              if (Character.isHighSurrogate(c)) {
                this.prevHighSurrogate = c;
              } else {
                outInt[outOffset] = c;
                outOffset++;
                this.prevHighSurrogate = -1;
              }
            }
          } else if (Character.isHighSurrogate(c)) {
            this.prevHighSurrogate = c;
          } else {
            outInt[outOffset] = c;
            outOffset++;
          }
        }
        if (this.prevHighSurrogate !== -1) {
          // Dangling high surrogate
          outInt[outOffset] = this.prevHighSurrogate;
          outOffset++;
        }
        this.position = outOffset;
      }
    }, {
      key: "byteToCharBuffer",
      value: function byteToCharBuffer(toAppend) {
        // CharBuffers hold twice as much per unit as ByteBuffers, so start with half the capacity.
        var newBuffer = new Uint16Array(Math.max(this.position + toAppend, this.buffer.length >> 1));
        newBuffer.set(this.buffer.subarray(0, this.position), 0);
        this.type = 1 /* CHAR */;
        this.buffer = newBuffer;
      }
    }, {
      key: "byteToIntBuffer",
      value: function byteToIntBuffer(toAppend) {
        // IntBuffers hold four times as much per unit as ByteBuffers, so start with one quarter the capacity.
        var newBuffer = new Int32Array(Math.max(this.position + toAppend, this.buffer.length >> 2));
        newBuffer.set(this.buffer.subarray(0, this.position), 0);
        this.type = 2 /* INT */;
        this.buffer = newBuffer;
      }
    }, {
      key: "charToIntBuffer",
      value: function charToIntBuffer(toAppend) {
        // IntBuffers hold two times as much per unit as ByteBuffers, so start with one half the capacity.
        var newBuffer = new Int32Array(Math.max(this.position + toAppend, this.buffer.length >> 1));
        newBuffer.set(this.buffer.subarray(0, this.position), 0);
        this.type = 2 /* INT */;
        this.buffer = newBuffer;
      }
    }], [{
      key: "roundUpToNextPowerOfTwo",
      value: function roundUpToNextPowerOfTwo(i) {
        var nextPowerOfTwo = 32 - Math.clz32(i - 1);
        return Math.pow(2, nextPowerOfTwo);
      }
    }]);
    return Builder;
  }();
  CodePointBuffer.Builder = Builder;
})(CodePointBuffer = exports.CodePointBuffer || (exports.CodePointBuffer = {}));

},{"./misc/Character":374,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"assert":413,"core-js/modules/es.array-buffer.slice.js":568,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.math.clz32.js":588,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.string.code-point-at.js":622,"core-js/modules/es.typed-array.copy-within.js":641,"core-js/modules/es.typed-array.every.js":642,"core-js/modules/es.typed-array.fill.js":643,"core-js/modules/es.typed-array.filter.js":644,"core-js/modules/es.typed-array.find-index.js":645,"core-js/modules/es.typed-array.find.js":646,"core-js/modules/es.typed-array.for-each.js":649,"core-js/modules/es.typed-array.includes.js":650,"core-js/modules/es.typed-array.index-of.js":651,"core-js/modules/es.typed-array.int32-array.js":653,"core-js/modules/es.typed-array.iterator.js":655,"core-js/modules/es.typed-array.join.js":656,"core-js/modules/es.typed-array.last-index-of.js":657,"core-js/modules/es.typed-array.map.js":658,"core-js/modules/es.typed-array.reduce-right.js":659,"core-js/modules/es.typed-array.reduce.js":660,"core-js/modules/es.typed-array.reverse.js":661,"core-js/modules/es.typed-array.set.js":662,"core-js/modules/es.typed-array.slice.js":663,"core-js/modules/es.typed-array.some.js":664,"core-js/modules/es.typed-array.sort.js":665,"core-js/modules/es.typed-array.subarray.js":666,"core-js/modules/es.typed-array.to-locale-string.js":667,"core-js/modules/es.typed-array.to-string.js":668,"core-js/modules/es.typed-array.uint16-array.js":669,"core-js/modules/es.typed-array.uint8-array.js":671}],267:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.math.sign.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array-buffer.slice.js");
require("core-js/modules/es.typed-array.int32-array.js");
require("core-js/modules/es.typed-array.copy-within.js");
require("core-js/modules/es.typed-array.every.js");
require("core-js/modules/es.typed-array.fill.js");
require("core-js/modules/es.typed-array.filter.js");
require("core-js/modules/es.typed-array.find.js");
require("core-js/modules/es.typed-array.find-index.js");
require("core-js/modules/es.typed-array.for-each.js");
require("core-js/modules/es.typed-array.includes.js");
require("core-js/modules/es.typed-array.index-of.js");
require("core-js/modules/es.typed-array.iterator.js");
require("core-js/modules/es.typed-array.join.js");
require("core-js/modules/es.typed-array.last-index-of.js");
require("core-js/modules/es.typed-array.map.js");
require("core-js/modules/es.typed-array.reduce.js");
require("core-js/modules/es.typed-array.reduce-right.js");
require("core-js/modules/es.typed-array.reverse.js");
require("core-js/modules/es.typed-array.set.js");
require("core-js/modules/es.typed-array.slice.js");
require("core-js/modules/es.typed-array.some.js");
require("core-js/modules/es.typed-array.sort.js");
require("core-js/modules/es.typed-array.subarray.js");
require("core-js/modules/es.typed-array.to-locale-string.js");
require("core-js/modules/es.typed-array.to-string.js");
require("core-js/modules/es.string.from-code-point.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var assert = require("assert");
var IntStream_1 = require("./IntStream");
var Interval_1 = require("./misc/Interval");
var Decorators_1 = require("./Decorators");
/**
 * Alternative to {@link ANTLRInputStream} which treats the input
 * as a series of Unicode code points, instead of a series of UTF-16
 * code units.
 *
 * Use this if you need to parse input which potentially contains
 * Unicode values > U+FFFF.
 */
var CodePointCharStream = /*#__PURE__*/function () {
  // Use the factory method {@link #fromBuffer(CodePointBuffer)} to
  // construct instances of this type.
  function CodePointCharStream(array, position, remaining, name) {
    (0, _classCallCheck2.default)(this, CodePointCharStream);
    // TODO
    assert(position === 0);
    this._array = array;
    this._size = remaining;
    this._name = name;
    this._position = 0;
  }
  (0, _createClass2.default)(CodePointCharStream, [{
    key: "internalStorage",
    get: function get() {
      return this._array;
    }
  }, {
    key: "consume",
    value: function consume() {
      if (this._size - this._position === 0) {
        assert(this.LA(1) === IntStream_1.IntStream.EOF);
        throw new RangeError("cannot consume EOF");
      }
      this._position++;
    }
  }, {
    key: "index",
    get: function get() {
      return this._position;
    }
  }, {
    key: "size",
    get: function get() {
      return this._size;
    }
    /** mark/release do nothing; we have entire buffer */
  }, {
    key: "mark",
    value: function mark() {
      return -1;
    }
  }, {
    key: "release",
    value: function release(marker) {
      // No default implementation since this stream buffers the entire input
    }
  }, {
    key: "seek",
    value: function seek(index) {
      this._position = index;
    }
  }, {
    key: "sourceName",
    get: function get() {
      return this._name;
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.getText(Interval_1.Interval.of(0, this.size - 1));
    }
  }, {
    key: "LA",
    value: function LA(i) {
      var offset;
      switch (Math.sign(i)) {
        case -1:
          offset = this.index + i;
          if (offset < 0) {
            return IntStream_1.IntStream.EOF;
          }
          return this._array[offset];
        case 0:
          // Undefined
          return 0;
        case 1:
          offset = this.index + i - 1;
          if (offset >= this.size) {
            return IntStream_1.IntStream.EOF;
          }
          return this._array[offset];
      }
      throw new RangeError("Not reached");
    }
    /** Return the UTF-16 encoded string for the given interval */
  }, {
    key: "getText",
    value: function getText(interval) {
      var startIdx = Math.min(interval.a, this.size);
      var len = Math.min(interval.b - interval.a + 1, this.size - startIdx);
      if (this._array instanceof Int32Array) {
        return String.fromCodePoint.apply(String, (0, _toConsumableArray2.default)(Array.from(this._array.subarray(startIdx, startIdx + len))));
      } else {
        return String.fromCharCode.apply(String, (0, _toConsumableArray2.default)(Array.from(this._array.subarray(startIdx, startIdx + len))));
      }
    }
  }], [{
    key: "fromBuffer",
    value: function fromBuffer(codePointBuffer, name) {
      if (name === undefined || name.length === 0) {
        name = IntStream_1.IntStream.UNKNOWN_SOURCE_NAME;
      }
      // Java lacks generics on primitive types.
      //
      // To avoid lots of calls to virtual methods in the
      // very hot codepath of LA() below, we construct one
      // of three concrete subclasses.
      //
      // The concrete subclasses directly access the code
      // points stored in the underlying array (byte[],
      // char[], or int[]), so we can avoid lots of virtual
      // method calls to ByteBuffer.get(offset).
      return new CodePointCharStream(codePointBuffer.array(), codePointBuffer.position, codePointBuffer.remaining, name);
    }
  }]);
  return CodePointCharStream;
}();
__decorate([Decorators_1.Override], CodePointCharStream.prototype, "consume", null);
__decorate([Decorators_1.Override], CodePointCharStream.prototype, "index", null);
__decorate([Decorators_1.Override], CodePointCharStream.prototype, "size", null);
__decorate([Decorators_1.Override], CodePointCharStream.prototype, "mark", null);
__decorate([Decorators_1.Override], CodePointCharStream.prototype, "release", null);
__decorate([Decorators_1.Override], CodePointCharStream.prototype, "seek", null);
__decorate([Decorators_1.Override], CodePointCharStream.prototype, "sourceName", null);
__decorate([Decorators_1.Override], CodePointCharStream.prototype, "toString", null);
__decorate([Decorators_1.Override], CodePointCharStream.prototype, "LA", null);
__decorate([Decorators_1.Override], CodePointCharStream.prototype, "getText", null);
exports.CodePointCharStream = CodePointCharStream;

},{"./Decorators":272,"./IntStream":278,"./misc/Interval":378,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/toConsumableArray":249,"@babel/runtime/helpers/typeof":252,"assert":413,"core-js/modules/es.array-buffer.slice.js":568,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.math.sign.js":590,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.string.from-code-point.js":624,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.typed-array.copy-within.js":641,"core-js/modules/es.typed-array.every.js":642,"core-js/modules/es.typed-array.fill.js":643,"core-js/modules/es.typed-array.filter.js":644,"core-js/modules/es.typed-array.find-index.js":645,"core-js/modules/es.typed-array.find.js":646,"core-js/modules/es.typed-array.for-each.js":649,"core-js/modules/es.typed-array.includes.js":650,"core-js/modules/es.typed-array.index-of.js":651,"core-js/modules/es.typed-array.int32-array.js":653,"core-js/modules/es.typed-array.iterator.js":655,"core-js/modules/es.typed-array.join.js":656,"core-js/modules/es.typed-array.last-index-of.js":657,"core-js/modules/es.typed-array.map.js":658,"core-js/modules/es.typed-array.reduce-right.js":659,"core-js/modules/es.typed-array.reduce.js":660,"core-js/modules/es.typed-array.reverse.js":661,"core-js/modules/es.typed-array.set.js":662,"core-js/modules/es.typed-array.slice.js":663,"core-js/modules/es.typed-array.some.js":664,"core-js/modules/es.typed-array.sort.js":665,"core-js/modules/es.typed-array.subarray.js":666,"core-js/modules/es.typed-array.to-locale-string.js":667,"core-js/modules/es.typed-array.to-string.js":668}],268:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var Interval_1 = require("./misc/Interval");
var Decorators_1 = require("./Decorators");
var Token_1 = require("./Token");
var CommonToken = /*#__PURE__*/function () {
  function CommonToken(type, text) {
    var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : CommonToken.EMPTY_SOURCE;
    var channel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Token_1.Token.DEFAULT_CHANNEL;
    var start = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var stop = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
    (0, _classCallCheck2.default)(this, CommonToken);
    /**
     * This is the backing field for {@link #getLine} and {@link #setLine}.
     */
    this._line = 0;
    /**
     * This is the backing field for {@link #getCharPositionInLine} and
     * {@link #setCharPositionInLine}.
     */
    this._charPositionInLine = -1; // set to invalid position
    /**
     * This is the backing field for {@link #getChannel} and
     * {@link #setChannel}.
     */
    this._channel = Token_1.Token.DEFAULT_CHANNEL;
    /**
     * This is the backing field for `tokenIndex`.
     */
    this.index = -1;
    this._text = text;
    this._type = type;
    this.source = source;
    this._channel = channel;
    this.start = start;
    this.stop = stop;
    if (source.source != null) {
      this._line = source.source.line;
      this._charPositionInLine = source.source.charPositionInLine;
    }
  }
  /**
   * Constructs a new {@link CommonToken} as a copy of another {@link Token}.
   *
   * If `oldToken` is also a {@link CommonToken} instance, the newly
   * constructed token will share a reference to the {@link #text} field and
   * the {@link Tuple2} stored in {@link #source}. Otherwise, {@link #text} will
   * be assigned the result of calling {@link #getText}, and {@link #source}
   * will be constructed from the result of {@link Token#getTokenSource} and
   * {@link Token#getInputStream}.
   *
   * @param oldToken The token to copy.
   */
  (0, _createClass2.default)(CommonToken, [{
    key: "type",
    get: function get() {
      return this._type;
    }
    // @Override
    ,
    set: function set(type) {
      this._type = type;
    }
  }, {
    key: "line",
    get: function get() {
      return this._line;
    }
    // @Override
    ,
    set: function set(line) {
      this._line = line;
    }
  }, {
    key: "text",
    get: function get() {
      if (this._text != null) {
        return this._text;
      }
      var input = this.inputStream;
      if (input == null) {
        return undefined;
      }
      var n = input.size;
      if (this.start < n && this.stop < n) {
        return input.getText(Interval_1.Interval.of(this.start, this.stop));
      } else {
        return "<EOF>";
      }
    }
    /**
     * Explicitly set the text for this token. If {code text} is not
     * `undefined`, then {@link #getText} will return this value rather than
     * extracting the text from the input.
     *
     * @param text The explicit text of the token, or `undefined` if the text
     * should be obtained from the input along with the start and stop indexes
     * of the token.
     */
    // @Override
    ,
    set: function set(text) {
      this._text = text;
    }
  }, {
    key: "charPositionInLine",
    get: function get() {
      return this._charPositionInLine;
    }
    // @Override
    ,
    set: function set(charPositionInLine) {
      this._charPositionInLine = charPositionInLine;
    }
  }, {
    key: "channel",
    get: function get() {
      return this._channel;
    }
    // @Override
    ,
    set: function set(channel) {
      this._channel = channel;
    }
  }, {
    key: "startIndex",
    get: function get() {
      return this.start;
    },
    set: function set(start) {
      this.start = start;
    }
  }, {
    key: "stopIndex",
    get: function get() {
      return this.stop;
    },
    set: function set(stop) {
      this.stop = stop;
    }
  }, {
    key: "tokenIndex",
    get: function get() {
      return this.index;
    }
    // @Override
    ,
    set: function set(index) {
      this.index = index;
    }
  }, {
    key: "tokenSource",
    get: function get() {
      return this.source.source;
    }
  }, {
    key: "inputStream",
    get: function get() {
      return this.source.stream;
    }
  }, {
    key: "toString",
    value: function toString(recognizer) {
      var channelStr = "";
      if (this._channel > 0) {
        channelStr = ",channel=" + this._channel;
      }
      var txt = this.text;
      if (txt != null) {
        txt = txt.replace(/\n/g, "\\n");
        txt = txt.replace(/\r/g, "\\r");
        txt = txt.replace(/\t/g, "\\t");
      } else {
        txt = "<no text>";
      }
      var typeString = String(this._type);
      if (recognizer) {
        typeString = recognizer.vocabulary.getDisplayName(this._type);
      }
      return "[@" + this.tokenIndex + "," + this.start + ":" + this.stop + "='" + txt + "',<" + typeString + ">" + channelStr + "," + this._line + ":" + this.charPositionInLine + "]";
    }
  }], [{
    key: "fromToken",
    value: function fromToken(oldToken) {
      var result = new CommonToken(oldToken.type, undefined, CommonToken.EMPTY_SOURCE, oldToken.channel, oldToken.startIndex, oldToken.stopIndex);
      result._line = oldToken.line;
      result.index = oldToken.tokenIndex;
      result._charPositionInLine = oldToken.charPositionInLine;
      if (oldToken instanceof CommonToken) {
        result._text = oldToken.text;
        result.source = oldToken.source;
      } else {
        result._text = oldToken.text;
        result.source = {
          source: oldToken.tokenSource,
          stream: oldToken.inputStream
        };
      }
      return result;
    }
  }]);
  return CommonToken;
}();
/**
 * An empty {@link Tuple2} which is used as the default value of
 * {@link #source} for tokens that do not have a source.
 */
CommonToken.EMPTY_SOURCE = {
  source: undefined,
  stream: undefined
};
__decorate([Decorators_1.NotNull], CommonToken.prototype, "source", void 0);
__decorate([Decorators_1.Override], CommonToken.prototype, "type", null);
__decorate([Decorators_1.Override], CommonToken.prototype, "line", null);
__decorate([Decorators_1.Override], CommonToken.prototype, "text", null);
__decorate([Decorators_1.Override], CommonToken.prototype, "charPositionInLine", null);
__decorate([Decorators_1.Override], CommonToken.prototype, "channel", null);
__decorate([Decorators_1.Override], CommonToken.prototype, "startIndex", null);
__decorate([Decorators_1.Override], CommonToken.prototype, "stopIndex", null);
__decorate([Decorators_1.Override], CommonToken.prototype, "tokenIndex", null);
__decorate([Decorators_1.Override], CommonToken.prototype, "tokenSource", null);
__decorate([Decorators_1.Override], CommonToken.prototype, "inputStream", null);
__decorate([Decorators_1.Override], CommonToken.prototype, "toString", null);
__decorate([__param(0, Decorators_1.NotNull)], CommonToken, "fromToken", null);
CommonToken = __decorate([__param(2, Decorators_1.NotNull)], CommonToken);
exports.CommonToken = CommonToken;

},{"./Decorators":272,"./Token":296,"./misc/Interval":378,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.string.replace.js":629}],269:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var CommonToken_1 = require("./CommonToken");
var Interval_1 = require("./misc/Interval");
var Decorators_1 = require("./Decorators");
/**
 * This default implementation of {@link TokenFactory} creates
 * {@link CommonToken} objects.
 */
var CommonTokenFactory = /*#__PURE__*/function () {
  /**
   * Constructs a {@link CommonTokenFactory} with the specified value for
   * {@link #copyText}.
   *
   * When `copyText` is `false`, the {@link #DEFAULT} instance
   * should be used instead of constructing a new instance.
   *
   * @param copyText The value for {@link #copyText}.
   */
  function CommonTokenFactory() {
    var copyText = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    (0, _classCallCheck2.default)(this, CommonTokenFactory);
    this.copyText = copyText;
  }
  (0, _createClass2.default)(CommonTokenFactory, [{
    key: "create",
    value: function create(source, type, text, channel, start, stop, line, charPositionInLine) {
      var t = new CommonToken_1.CommonToken(type, text, source, channel, start, stop);
      t.line = line;
      t.charPositionInLine = charPositionInLine;
      if (text == null && this.copyText && source.stream != null) {
        t.text = source.stream.getText(Interval_1.Interval.of(start, stop));
      }
      return t;
    }
  }, {
    key: "createSimple",
    value: function createSimple(type, text) {
      return new CommonToken_1.CommonToken(type, text);
    }
  }]);
  return CommonTokenFactory;
}();
__decorate([Decorators_1.Override], CommonTokenFactory.prototype, "create", null);
__decorate([Decorators_1.Override], CommonTokenFactory.prototype, "createSimple", null);
exports.CommonTokenFactory = CommonTokenFactory;
(function (CommonTokenFactory) {
  /**
   * The default {@link CommonTokenFactory} instance.
   *
   * This token factory does not explicitly copy token text when constructing
   * tokens.
   */
  CommonTokenFactory.DEFAULT = new CommonTokenFactory();
})(CommonTokenFactory = exports.CommonTokenFactory || (exports.CommonTokenFactory = {}));

},{"./CommonToken":268,"./Decorators":272,"./misc/Interval":378,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612}],270:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.array.fill.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:50.3953157-07:00
var BufferedTokenStream_1 = require("./BufferedTokenStream");
var Decorators_1 = require("./Decorators");
var Token_1 = require("./Token");
/**
 * This class extends {@link BufferedTokenStream} with functionality to filter
 * token streams to tokens on a particular channel (tokens where
 * {@link Token#getChannel} returns a particular value).
 *
 * This token stream provides access to all tokens by index or when calling
 * methods like {@link #getText}. The channel filtering is only used for code
 * accessing tokens via the lookahead methods {@link #LA}, {@link #LT}, and
 * {@link #LB}.
 *
 * By default, tokens are placed on the default channel
 * ({@link Token#DEFAULT_CHANNEL}), but may be reassigned by using the
 * `->channel(HIDDEN)` lexer command, or by using an embedded action to
 * call {@link Lexer#setChannel}.
 *
 * Note: lexer rules which use the `->skip` lexer command or call
 * {@link Lexer#skip} do not produce tokens at all, so input text matched by
 * such a rule will not be available as part of the token stream, regardless of
 * channel.
 */
var CommonTokenStream = /*#__PURE__*/function (_BufferedTokenStream_) {
  (0, _inherits2.default)(CommonTokenStream, _BufferedTokenStream_);
  var _super = _createSuper(CommonTokenStream);
  /**
   * Constructs a new {@link CommonTokenStream} using the specified token
   * source and filtering tokens to the specified channel. Only tokens whose
   * {@link Token#getChannel} matches `channel` or have the
   * `Token.type` equal to {@link Token#EOF} will be returned by the
   * token stream lookahead methods.
   *
   * @param tokenSource The token source.
   * @param channel The channel to use for filtering tokens.
   */
  function CommonTokenStream(tokenSource) {
    var _this;
    var channel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Token_1.Token.DEFAULT_CHANNEL;
    (0, _classCallCheck2.default)(this, CommonTokenStream);
    _this = _super.call(this, tokenSource);
    _this.channel = channel;
    return _this;
  }
  (0, _createClass2.default)(CommonTokenStream, [{
    key: "adjustSeekIndex",
    value: function adjustSeekIndex(i) {
      return this.nextTokenOnChannel(i, this.channel);
    }
  }, {
    key: "tryLB",
    value: function tryLB(k) {
      if (this.p - k < 0) {
        return undefined;
      }
      var i = this.p;
      var n = 1;
      // find k good tokens looking backwards
      while (n <= k && i > 0) {
        // skip off-channel tokens
        i = this.previousTokenOnChannel(i - 1, this.channel);
        n++;
      }
      if (i < 0) {
        return undefined;
      }
      return this.tokens[i];
    }
  }, {
    key: "tryLT",
    value: function tryLT(k) {
      //System.out.println("enter LT("+k+")");
      this.lazyInit();
      if (k === 0) {
        throw new RangeError("0 is not a valid lookahead index");
      }
      if (k < 0) {
        return this.tryLB(-k);
      }
      var i = this.p;
      var n = 1; // we know tokens[p] is a good one
      // find k good tokens
      while (n < k) {
        // skip off-channel tokens, but make sure to not look past EOF
        if (this.sync(i + 1)) {
          i = this.nextTokenOnChannel(i + 1, this.channel);
        }
        n++;
      }
      //		if ( i>range ) range = i;
      return this.tokens[i];
    }
    /** Count EOF just once. */
  }, {
    key: "getNumberOfOnChannelTokens",
    value: function getNumberOfOnChannelTokens() {
      var n = 0;
      this.fill();
      var _iterator = _createForOfIteratorHelper(this.tokens),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var t = _step.value;
          if (t.channel === this.channel) {
            n++;
          }
          if (t.type === Token_1.Token.EOF) {
            break;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return n;
    }
  }]);
  return CommonTokenStream;
}(BufferedTokenStream_1.BufferedTokenStream);
__decorate([Decorators_1.Override], CommonTokenStream.prototype, "adjustSeekIndex", null);
__decorate([Decorators_1.Override], CommonTokenStream.prototype, "tryLB", null);
__decorate([Decorators_1.Override], CommonTokenStream.prototype, "tryLT", null);
CommonTokenStream = __decorate([__param(0, Decorators_1.NotNull)], CommonTokenStream);
exports.CommonTokenStream = CommonTokenStream;

},{"./BufferedTokenStream":264,"./Decorators":272,"./Token":296,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.fill.js":571,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],271:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.concat.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 *
 * @author Sam Harwell
 */
var ConsoleErrorListener = /*#__PURE__*/function () {
  function ConsoleErrorListener() {
    (0, _classCallCheck2.default)(this, ConsoleErrorListener);
  }
  (0, _createClass2.default)(ConsoleErrorListener, [{
    key: "syntaxError",
    value:
    /**
     * {@inheritDoc}
     *
     * This implementation prints messages to {@link System#err} containing the
     * values of `line`, `charPositionInLine`, and `msg` using
     * the following format.
     *
     * <pre>
     * line *line*:*charPositionInLine* *msg*
     * </pre>
     */
    function syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
      console.error("line ".concat(line, ":").concat(charPositionInLine, " ").concat(msg));
    }
  }]);
  return ConsoleErrorListener;
}();
/**
 * Provides a default instance of {@link ConsoleErrorListener}.
 */
ConsoleErrorListener.INSTANCE = new ConsoleErrorListener();
exports.ConsoleErrorListener = ConsoleErrorListener;

},{"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"core-js/modules/es.array.concat.js":569}],272:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
function NotNull(target, propertyKey, propertyDescriptor) {
  // intentionally empty
}
exports.NotNull = NotNull;
function Nullable(target, propertyKey, propertyDescriptor) {
  // intentionally empty
}
exports.Nullable = Nullable;
function Override(target, propertyKey, propertyDescriptor) {
  // do something with 'target' ...
}
exports.Override = Override;
function SuppressWarnings(options) {
  return function (target, propertyKey, descriptor) {
    // intentionally empty
  };
}
exports.SuppressWarnings = SuppressWarnings;

},{}],273:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var ATNState_1 = require("./atn/ATNState");
var ATNStateType_1 = require("./atn/ATNStateType");
var FailedPredicateException_1 = require("./FailedPredicateException");
var InputMismatchException_1 = require("./InputMismatchException");
var IntervalSet_1 = require("./misc/IntervalSet");
var NoViableAltException_1 = require("./NoViableAltException");
var PredictionContext_1 = require("./atn/PredictionContext");
var Token_1 = require("./Token");
var Decorators_1 = require("./Decorators");
/**
 * This is the default implementation of {@link ANTLRErrorStrategy} used for
 * error reporting and recovery in ANTLR parsers.
 */
var DefaultErrorStrategy = /*#__PURE__*/function () {
  function DefaultErrorStrategy() {
    (0, _classCallCheck2.default)(this, DefaultErrorStrategy);
    /**
     * Indicates whether the error strategy is currently "recovering from an
     * error". This is used to suppress reporting multiple error messages while
     * attempting to recover from a detected syntax error.
     *
     * @see #inErrorRecoveryMode
     */
    this.errorRecoveryMode = false;
    /** The index into the input stream where the last error occurred.
     * 	This is used to prevent infinite loops where an error is found
     *  but no token is consumed during recovery...another error is found,
     *  ad nauseum.  This is a failsafe mechanism to guarantee that at least
     *  one token/tree node is consumed for two errors.
     */
    this.lastErrorIndex = -1;
    /**
     * @see #nextTokensContext
     */
    this.nextTokensState = ATNState_1.ATNState.INVALID_STATE_NUMBER;
  }
  /**
   * {@inheritDoc}
   *
   * The default implementation simply calls {@link #endErrorCondition} to
   * ensure that the handler is not in error recovery mode.
   */
  (0, _createClass2.default)(DefaultErrorStrategy, [{
    key: "reset",
    value: function reset(recognizer) {
      this.endErrorCondition(recognizer);
    }
    /**
     * This method is called to enter error recovery mode when a recognition
     * exception is reported.
     *
     * @param recognizer the parser instance
     */
  }, {
    key: "beginErrorCondition",
    value: function beginErrorCondition(recognizer) {
      this.errorRecoveryMode = true;
    }
    /**
     * {@inheritDoc}
     */
  }, {
    key: "inErrorRecoveryMode",
    value: function inErrorRecoveryMode(recognizer) {
      return this.errorRecoveryMode;
    }
    /**
     * This method is called to leave error recovery mode after recovering from
     * a recognition exception.
     *
     * @param recognizer
     */
  }, {
    key: "endErrorCondition",
    value: function endErrorCondition(recognizer) {
      this.errorRecoveryMode = false;
      this.lastErrorStates = undefined;
      this.lastErrorIndex = -1;
    }
    /**
     * {@inheritDoc}
     *
     * The default implementation simply calls {@link #endErrorCondition}.
     */
  }, {
    key: "reportMatch",
    value: function reportMatch(recognizer) {
      this.endErrorCondition(recognizer);
    }
    /**
     * {@inheritDoc}
     *
     * The default implementation returns immediately if the handler is already
     * in error recovery mode. Otherwise, it calls {@link #beginErrorCondition}
     * and dispatches the reporting task based on the runtime type of `e`
     * according to the following table.
     *
     * * {@link NoViableAltException}: Dispatches the call to
     *   {@link #reportNoViableAlternative}
     * * {@link InputMismatchException}: Dispatches the call to
     *   {@link #reportInputMismatch}
     * * {@link FailedPredicateException}: Dispatches the call to
     *   {@link #reportFailedPredicate}
     * * All other types: calls {@link Parser#notifyErrorListeners} to report
     *   the exception
     */
  }, {
    key: "reportError",
    value: function reportError(recognizer, e) {
      // if we've already reported an error and have not matched a token
      // yet successfully, don't report any errors.
      if (this.inErrorRecoveryMode(recognizer)) {
        //			System.err.print("[SPURIOUS] ");
        return; // don't report spurious errors
      }

      this.beginErrorCondition(recognizer);
      if (e instanceof NoViableAltException_1.NoViableAltException) {
        this.reportNoViableAlternative(recognizer, e);
      } else if (e instanceof InputMismatchException_1.InputMismatchException) {
        this.reportInputMismatch(recognizer, e);
      } else if (e instanceof FailedPredicateException_1.FailedPredicateException) {
        this.reportFailedPredicate(recognizer, e);
      } else {
        console.error("unknown recognition error type: ".concat(e));
        this.notifyErrorListeners(recognizer, e.toString(), e);
      }
    }
  }, {
    key: "notifyErrorListeners",
    value: function notifyErrorListeners(recognizer, message, e) {
      var offendingToken = e.getOffendingToken(recognizer);
      if (offendingToken === undefined) {
        // Pass null to notifyErrorListeners so it in turn calls the error listeners with undefined as the offending
        // token. If we passed undefined, it would instead call the listeners with currentToken from the parser.
        offendingToken = null;
      }
      recognizer.notifyErrorListeners(message, offendingToken, e);
    }
    /**
     * {@inheritDoc}
     *
     * The default implementation resynchronizes the parser by consuming tokens
     * until we find one in the resynchronization set--loosely the set of tokens
     * that can follow the current rule.
     */
  }, {
    key: "recover",
    value: function recover(recognizer, e) {
      //		System.out.println("recover in "+recognizer.getRuleInvocationStack()+
      //						   " index="+recognizer.inputStream.index+
      //						   ", lastErrorIndex="+
      //						   lastErrorIndex+
      //						   ", states="+lastErrorStates);
      if (this.lastErrorIndex === recognizer.inputStream.index && this.lastErrorStates && this.lastErrorStates.contains(recognizer.state)) {
        // uh oh, another error at same token index and previously-visited
        // state in ATN; must be a case where LT(1) is in the recovery
        // token set so nothing got consumed. Consume a single token
        // at least to prevent an infinite loop; this is a failsafe.
        //			System.err.println("seen error condition before index="+
        //							   lastErrorIndex+", states="+lastErrorStates);
        //			System.err.println("FAILSAFE consumes "+recognizer.getTokenNames()[recognizer.inputStream.LA(1)]);
        recognizer.consume();
      }
      this.lastErrorIndex = recognizer.inputStream.index;
      if (!this.lastErrorStates) {
        this.lastErrorStates = new IntervalSet_1.IntervalSet();
      }
      this.lastErrorStates.add(recognizer.state);
      var followSet = this.getErrorRecoverySet(recognizer);
      this.consumeUntil(recognizer, followSet);
    }
    /**
     * The default implementation of {@link ANTLRErrorStrategy#sync} makes sure
     * that the current lookahead symbol is consistent with what were expecting
     * at this point in the ATN. You can call this anytime but ANTLR only
     * generates code to check before subrules/loops and each iteration.
     *
     * Implements Jim Idle's magic sync mechanism in closures and optional
     * subrules. E.g.,
     *
     * ```antlr
     * a : sync ( stuff sync )* ;
     * sync : {consume to what can follow sync} ;
     * ```
     *
     * At the start of a sub rule upon error, {@link #sync} performs single
     * token deletion, if possible. If it can't do that, it bails on the current
     * rule and uses the default error recovery, which consumes until the
     * resynchronization set of the current rule.
     *
     * If the sub rule is optional (`(...)?`, `(...)*`, or block
     * with an empty alternative), then the expected set includes what follows
     * the subrule.
     *
     * During loop iteration, it consumes until it sees a token that can start a
     * sub rule or what follows loop. Yes, that is pretty aggressive. We opt to
     * stay in the loop as long as possible.
     *
     * **ORIGINS**
     *
     * Previous versions of ANTLR did a poor job of their recovery within loops.
     * A single mismatch token or missing token would force the parser to bail
     * out of the entire rules surrounding the loop. So, for rule
     *
     * ```antlr
     * classDef : 'class' ID '{' member* '}'
     * ```
     *
     * input with an extra token between members would force the parser to
     * consume until it found the next class definition rather than the next
     * member definition of the current class.
     *
     * This functionality cost a little bit of effort because the parser has to
     * compare token set at the start of the loop and at each iteration. If for
     * some reason speed is suffering for you, you can turn off this
     * functionality by simply overriding this method as a blank { }.
     */
  }, {
    key: "sync",
    value: function sync(recognizer) {
      var s = recognizer.interpreter.atn.states[recognizer.state];
      //		System.err.println("sync @ "+s.stateNumber+"="+s.getClass().getSimpleName());
      // If already recovering, don't try to sync
      if (this.inErrorRecoveryMode(recognizer)) {
        return;
      }
      var tokens = recognizer.inputStream;
      var la = tokens.LA(1);
      // try cheaper subset first; might get lucky. seems to shave a wee bit off
      var nextTokens = recognizer.atn.nextTokens(s);
      if (nextTokens.contains(la)) {
        // We are sure the token matches
        this.nextTokensContext = undefined;
        this.nextTokensState = ATNState_1.ATNState.INVALID_STATE_NUMBER;
        return;
      }
      if (nextTokens.contains(Token_1.Token.EPSILON)) {
        if (this.nextTokensContext === undefined) {
          // It's possible the next token won't match; information tracked
          // by sync is restricted for performance.
          this.nextTokensContext = recognizer.context;
          this.nextTokensState = recognizer.state;
        }
        return;
      }
      switch (s.stateType) {
        case ATNStateType_1.ATNStateType.BLOCK_START:
        case ATNStateType_1.ATNStateType.STAR_BLOCK_START:
        case ATNStateType_1.ATNStateType.PLUS_BLOCK_START:
        case ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY:
          // report error and recover if possible
          if (this.singleTokenDeletion(recognizer)) {
            return;
          }
          throw new InputMismatchException_1.InputMismatchException(recognizer);
        case ATNStateType_1.ATNStateType.PLUS_LOOP_BACK:
        case ATNStateType_1.ATNStateType.STAR_LOOP_BACK:
          //			System.err.println("at loop back: "+s.getClass().getSimpleName());
          this.reportUnwantedToken(recognizer);
          var expecting = recognizer.getExpectedTokens();
          var whatFollowsLoopIterationOrRule = expecting.or(this.getErrorRecoverySet(recognizer));
          this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);
          break;
        default:
          // do nothing if we can't identify the exact kind of ATN state
          break;
      }
    }
    /**
     * This is called by {@link #reportError} when the exception is a
     * {@link NoViableAltException}.
     *
     * @see #reportError
     *
     * @param recognizer the parser instance
     * @param e the recognition exception
     */
  }, {
    key: "reportNoViableAlternative",
    value: function reportNoViableAlternative(recognizer, e) {
      var tokens = recognizer.inputStream;
      var input;
      if (tokens) {
        if (e.startToken.type === Token_1.Token.EOF) {
          input = "<EOF>";
        } else {
          input = tokens.getTextFromRange(e.startToken, e.getOffendingToken());
        }
      } else {
        input = "<unknown input>";
      }
      var msg = "no viable alternative at input " + this.escapeWSAndQuote(input);
      this.notifyErrorListeners(recognizer, msg, e);
    }
    /**
     * This is called by {@link #reportError} when the exception is an
     * {@link InputMismatchException}.
     *
     * @see #reportError
     *
     * @param recognizer the parser instance
     * @param e the recognition exception
     */
  }, {
    key: "reportInputMismatch",
    value: function reportInputMismatch(recognizer, e) {
      var expected = e.expectedTokens;
      var expectedString = expected ? expected.toStringVocabulary(recognizer.vocabulary) : "";
      var msg = "mismatched input " + this.getTokenErrorDisplay(e.getOffendingToken(recognizer)) + " expecting " + expectedString;
      this.notifyErrorListeners(recognizer, msg, e);
    }
    /**
     * This is called by {@link #reportError} when the exception is a
     * {@link FailedPredicateException}.
     *
     * @see #reportError
     *
     * @param recognizer the parser instance
     * @param e the recognition exception
     */
  }, {
    key: "reportFailedPredicate",
    value: function reportFailedPredicate(recognizer, e) {
      var ruleName = recognizer.ruleNames[recognizer.context.ruleIndex];
      var msg = "rule " + ruleName + " " + e.message;
      this.notifyErrorListeners(recognizer, msg, e);
    }
    /**
     * This method is called to report a syntax error which requires the removal
     * of a token from the input stream. At the time this method is called, the
     * erroneous symbol is current `LT(1)` symbol and has not yet been
     * removed from the input stream. When this method returns,
     * `recognizer` is in error recovery mode.
     *
     * This method is called when {@link #singleTokenDeletion} identifies
     * single-token deletion as a viable recovery strategy for a mismatched
     * input error.
     *
     * The default implementation simply returns if the handler is already in
     * error recovery mode. Otherwise, it calls {@link #beginErrorCondition} to
     * enter error recovery mode, followed by calling
     * {@link Parser#notifyErrorListeners}.
     *
     * @param recognizer the parser instance
     */
  }, {
    key: "reportUnwantedToken",
    value: function reportUnwantedToken(recognizer) {
      if (this.inErrorRecoveryMode(recognizer)) {
        return;
      }
      this.beginErrorCondition(recognizer);
      var t = recognizer.currentToken;
      var tokenName = this.getTokenErrorDisplay(t);
      var expecting = this.getExpectedTokens(recognizer);
      var msg = "extraneous input " + tokenName + " expecting " + expecting.toStringVocabulary(recognizer.vocabulary);
      recognizer.notifyErrorListeners(msg, t, undefined);
    }
    /**
     * This method is called to report a syntax error which requires the
     * insertion of a missing token into the input stream. At the time this
     * method is called, the missing token has not yet been inserted. When this
     * method returns, `recognizer` is in error recovery mode.
     *
     * This method is called when {@link #singleTokenInsertion} identifies
     * single-token insertion as a viable recovery strategy for a mismatched
     * input error.
     *
     * The default implementation simply returns if the handler is already in
     * error recovery mode. Otherwise, it calls {@link #beginErrorCondition} to
     * enter error recovery mode, followed by calling
     * {@link Parser#notifyErrorListeners}.
     *
     * @param recognizer the parser instance
     */
  }, {
    key: "reportMissingToken",
    value: function reportMissingToken(recognizer) {
      if (this.inErrorRecoveryMode(recognizer)) {
        return;
      }
      this.beginErrorCondition(recognizer);
      var t = recognizer.currentToken;
      var expecting = this.getExpectedTokens(recognizer);
      var msg = "missing " + expecting.toStringVocabulary(recognizer.vocabulary) + " at " + this.getTokenErrorDisplay(t);
      recognizer.notifyErrorListeners(msg, t, undefined);
    }
    /**
     * {@inheritDoc}
     *
     * The default implementation attempts to recover from the mismatched input
     * by using single token insertion and deletion as described below. If the
     * recovery attempt fails, this method
     * {@link InputMismatchException}.
     *
     * **EXTRA TOKEN** (single token deletion)
     *
     * `LA(1)` is not what we are looking for. If `LA(2)` has the
     * right token, however, then assume `LA(1)` is some extra spurious
     * token and delete it. Then consume and return the next token (which was
     * the `LA(2)` token) as the successful result of the match operation.
     *
     * This recovery strategy is implemented by {@link #singleTokenDeletion}.
     *
     * **MISSING TOKEN** (single token insertion)
     *
     * If current token (at `LA(1)`) is consistent with what could come
     * after the expected `LA(1)` token, then assume the token is missing
     * and use the parser's {@link TokenFactory} to create it on the fly. The
     * "insertion" is performed by returning the created token as the successful
     * result of the match operation.
     *
     * This recovery strategy is implemented by {@link #singleTokenInsertion}.
     *
     * **EXAMPLE**
     *
     * For example, Input `i=(3;` is clearly missing the `')'`. When
     * the parser returns from the nested call to `expr`, it will have
     * call chain:
     *
     * ```
     * stat  expr  atom
     * ```
     *
     * and it will be trying to match the `')'` at this point in the
     * derivation:
     *
     * ```
     * => ID '=' '(' INT ')' ('+' atom)* ';'
     *                    ^
     * ```
     *
     * The attempt to match `')'` will fail when it sees `';'` and
     * call {@link #recoverInline}. To recover, it sees that `LA(1)==';'`
     * is in the set of tokens that can follow the `')'` token reference
     * in rule `atom`. It can assume that you forgot the `')'`.
     */
  }, {
    key: "recoverInline",
    value: function recoverInline(recognizer) {
      // SINGLE TOKEN DELETION
      var matchedSymbol = this.singleTokenDeletion(recognizer);
      if (matchedSymbol) {
        // we have deleted the extra token.
        // now, move past ttype token as if all were ok
        recognizer.consume();
        return matchedSymbol;
      }
      // SINGLE TOKEN INSERTION
      if (this.singleTokenInsertion(recognizer)) {
        return this.getMissingSymbol(recognizer);
      }
      // even that didn't work; must throw the exception
      if (this.nextTokensContext === undefined) {
        throw new InputMismatchException_1.InputMismatchException(recognizer);
      } else {
        throw new InputMismatchException_1.InputMismatchException(recognizer, this.nextTokensState, this.nextTokensContext);
      }
    }
    /**
     * This method implements the single-token insertion inline error recovery
     * strategy. It is called by {@link #recoverInline} if the single-token
     * deletion strategy fails to recover from the mismatched input. If this
     * method returns `true`, `recognizer` will be in error recovery
     * mode.
     *
     * This method determines whether or not single-token insertion is viable by
     * checking if the `LA(1)` input symbol could be successfully matched
     * if it were instead the `LA(2)` symbol. If this method returns
     * `true`, the caller is responsible for creating and inserting a
     * token with the correct type to produce this behavior.
     *
     * @param recognizer the parser instance
     * @returns `true` if single-token insertion is a viable recovery
     * strategy for the current mismatched input, otherwise `false`
     */
  }, {
    key: "singleTokenInsertion",
    value: function singleTokenInsertion(recognizer) {
      var currentSymbolType = recognizer.inputStream.LA(1);
      // if current token is consistent with what could come after current
      // ATN state, then we know we're missing a token; error recovery
      // is free to conjure up and insert the missing token
      var currentState = recognizer.interpreter.atn.states[recognizer.state];
      var next = currentState.transition(0).target;
      var atn = recognizer.interpreter.atn;
      var expectingAtLL2 = atn.nextTokens(next, PredictionContext_1.PredictionContext.fromRuleContext(atn, recognizer.context));
      //		console.warn("LT(2) set="+expectingAtLL2.toString(recognizer.getTokenNames()));
      if (expectingAtLL2.contains(currentSymbolType)) {
        this.reportMissingToken(recognizer);
        return true;
      }
      return false;
    }
    /**
     * This method implements the single-token deletion inline error recovery
     * strategy. It is called by {@link #recoverInline} to attempt to recover
     * from mismatched input. If this method returns `undefined`, the parser and error
     * handler state will not have changed. If this method returns non-`undefined`,
     * `recognizer` will *not* be in error recovery mode since the
     * returned token was a successful match.
     *
     * If the single-token deletion is successful, this method calls
     * {@link #reportUnwantedToken} to report the error, followed by
     * {@link Parser#consume} to actually "delete" the extraneous token. Then,
     * before returning {@link #reportMatch} is called to signal a successful
     * match.
     *
     * @param recognizer the parser instance
     * @returns the successfully matched {@link Token} instance if single-token
     * deletion successfully recovers from the mismatched input, otherwise
     * `undefined`
     */
  }, {
    key: "singleTokenDeletion",
    value: function singleTokenDeletion(recognizer) {
      var nextTokenType = recognizer.inputStream.LA(2);
      var expecting = this.getExpectedTokens(recognizer);
      if (expecting.contains(nextTokenType)) {
        this.reportUnwantedToken(recognizer);
        /*
        System.err.println("recoverFromMismatchedToken deleting "+
                           ((TokenStream)recognizer.inputStream).LT(1)+
                           " since "+((TokenStream)recognizer.inputStream).LT(2)+
                           " is what we want");
        */
        recognizer.consume(); // simply delete extra token
        // we want to return the token we're actually matching
        var matchedSymbol = recognizer.currentToken;
        this.reportMatch(recognizer); // we know current token is correct
        return matchedSymbol;
      }
      return undefined;
    }
    /** Conjure up a missing token during error recovery.
     *
     *  The recognizer attempts to recover from single missing
     *  symbols. But, actions might refer to that missing symbol.
     *  For example, x=ID {f($x);}. The action clearly assumes
     *  that there has been an identifier matched previously and that
     *  $x points at that token. If that token is missing, but
     *  the next token in the stream is what we want we assume that
     *  this token is missing and we keep going. Because we
     *  have to return some token to replace the missing token,
     *  we have to conjure one up. This method gives the user control
     *  over the tokens returned for missing tokens. Mostly,
     *  you will want to create something special for identifier
     *  tokens. For literals such as '{' and ',', the default
     *  action in the parser or tree parser works. It simply creates
     *  a CommonToken of the appropriate type. The text will be the token.
     *  If you change what tokens must be created by the lexer,
     *  override this method to create the appropriate tokens.
     */
  }, {
    key: "getMissingSymbol",
    value: function getMissingSymbol(recognizer) {
      var currentSymbol = recognizer.currentToken;
      var expecting = this.getExpectedTokens(recognizer);
      var expectedTokenType = Token_1.Token.INVALID_TYPE;
      if (!expecting.isNil) {
        // get any element
        expectedTokenType = expecting.minElement;
      }
      var tokenText;
      if (expectedTokenType === Token_1.Token.EOF) {
        tokenText = "<missing EOF>";
      } else {
        tokenText = "<missing " + recognizer.vocabulary.getDisplayName(expectedTokenType) + ">";
      }
      var current = currentSymbol;
      var lookback = recognizer.inputStream.tryLT(-1);
      if (current.type === Token_1.Token.EOF && lookback != null) {
        current = lookback;
      }
      return this.constructToken(recognizer.inputStream.tokenSource, expectedTokenType, tokenText, current);
    }
  }, {
    key: "constructToken",
    value: function constructToken(tokenSource, expectedTokenType, tokenText, current) {
      var factory = tokenSource.tokenFactory;
      var x = current.tokenSource;
      var stream = x ? x.inputStream : undefined;
      return factory.create({
        source: tokenSource,
        stream: stream
      }, expectedTokenType, tokenText, Token_1.Token.DEFAULT_CHANNEL, -1, -1, current.line, current.charPositionInLine);
    }
  }, {
    key: "getExpectedTokens",
    value: function getExpectedTokens(recognizer) {
      return recognizer.getExpectedTokens();
    }
    /** How should a token be displayed in an error message? The default
     *  is to display just the text, but during development you might
     *  want to have a lot of information spit out.  Override in that case
     *  to use t.toString() (which, for CommonToken, dumps everything about
     *  the token). This is better than forcing you to override a method in
     *  your token objects because you don't have to go modify your lexer
     *  so that it creates a new Java type.
     */
  }, {
    key: "getTokenErrorDisplay",
    value: function getTokenErrorDisplay(t) {
      if (!t) {
        return "<no token>";
      }
      var s = this.getSymbolText(t);
      if (!s) {
        if (this.getSymbolType(t) === Token_1.Token.EOF) {
          s = "<EOF>";
        } else {
          s = "<".concat(this.getSymbolType(t), ">");
        }
      }
      return this.escapeWSAndQuote(s);
    }
  }, {
    key: "getSymbolText",
    value: function getSymbolText(symbol) {
      return symbol.text;
    }
  }, {
    key: "getSymbolType",
    value: function getSymbolType(symbol) {
      return symbol.type;
    }
  }, {
    key: "escapeWSAndQuote",
    value: function escapeWSAndQuote(s) {
      //		if ( s==null ) return s;
      s = s.replace("\n", "\\n");
      s = s.replace("\r", "\\r");
      s = s.replace("\t", "\\t");
      return "'" + s + "'";
    }
    /*  Compute the error recovery set for the current rule.  During
     *  rule invocation, the parser pushes the set of tokens that can
     *  follow that rule reference on the stack; this amounts to
     *  computing FIRST of what follows the rule reference in the
     *  enclosing rule. See LinearApproximator.FIRST().
     *  This local follow set only includes tokens
     *  from within the rule; i.e., the FIRST computation done by
     *  ANTLR stops at the end of a rule.
     *
     *  EXAMPLE
     *
     *  When you find a "no viable alt exception", the input is not
     *  consistent with any of the alternatives for rule r.  The best
     *  thing to do is to consume tokens until you see something that
     *  can legally follow a call to r *or* any rule that called r.
     *  You don't want the exact set of viable next tokens because the
     *  input might just be missing a token--you might consume the
     *  rest of the input looking for one of the missing tokens.
     *
     *  Consider grammar:
     *
     *  a : '[' b ']'
     *    | '(' b ')'
     *    ;
     *  b : c '^' INT ;
     *  c : ID
     *    | INT
     *    ;
     *
     *  At each rule invocation, the set of tokens that could follow
     *  that rule is pushed on a stack.  Here are the various
     *  context-sensitive follow sets:
     *
     *  FOLLOW(b1_in_a) = FIRST(']') = ']'
     *  FOLLOW(b2_in_a) = FIRST(')') = ')'
     *  FOLLOW(c_in_b) = FIRST('^') = '^'
     *
     *  Upon erroneous input "[]", the call chain is
     *
     *  a -> b -> c
     *
     *  and, hence, the follow context stack is:
     *
     *  depth     follow set       start of rule execution
     *    0         <EOF>                    a (from main())
     *    1          ']'                     b
     *    2          '^'                     c
     *
     *  Notice that ')' is not included, because b would have to have
     *  been called from a different context in rule a for ')' to be
     *  included.
     *
     *  For error recovery, we cannot consider FOLLOW(c)
     *  (context-sensitive or otherwise).  We need the combined set of
     *  all context-sensitive FOLLOW sets--the set of all tokens that
     *  could follow any reference in the call chain.  We need to
     *  resync to one of those tokens.  Note that FOLLOW(c)='^' and if
     *  we resync'd to that token, we'd consume until EOF.  We need to
     *  sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.
     *  In this case, for input "[]", LA(1) is ']' and in the set, so we would
     *  not consume anything. After printing an error, rule c would
     *  return normally.  Rule b would not find the required '^' though.
     *  At this point, it gets a mismatched token error and
     *  exception (since LA(1) is not in the viable following token
     *  set).  The rule exception handler tries to recover, but finds
     *  the same recovery set and doesn't consume anything.  Rule b
     *  exits normally returning to rule a.  Now it finds the ']' (and
     *  with the successful match exits errorRecovery mode).
     *
     *  So, you can see that the parser walks up the call chain looking
     *  for the token that was a member of the recovery set.
     *
     *  Errors are not generated in errorRecovery mode.
     *
     *  ANTLR's error recovery mechanism is based upon original ideas:
     *
     *  "Algorithms + Data Structures = Programs" by Niklaus Wirth
     *
     *  and
     *
     *  "A note on error recovery in recursive descent parsers":
     *  http://portal.acm.org/citation.cfm?id=947902.947905
     *
     *  Later, Josef Grosch had some good ideas:
     *
     *  "Efficient and Comfortable Error Recovery in Recursive Descent
     *  Parsers":
     *  ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip
     *
     *  Like Grosch I implement context-sensitive FOLLOW sets that are combined
     *  at run-time upon error to avoid overhead during parsing.
     */
  }, {
    key: "getErrorRecoverySet",
    value: function getErrorRecoverySet(recognizer) {
      var atn = recognizer.interpreter.atn;
      var ctx = recognizer.context;
      var recoverSet = new IntervalSet_1.IntervalSet();
      while (ctx && ctx.invokingState >= 0) {
        // compute what follows who invoked us
        var invokingState = atn.states[ctx.invokingState];
        var rt = invokingState.transition(0);
        var follow = atn.nextTokens(rt.followState);
        recoverSet.addAll(follow);
        ctx = ctx._parent;
      }
      recoverSet.remove(Token_1.Token.EPSILON);
      //		System.out.println("recover set "+recoverSet.toString(recognizer.getTokenNames()));
      return recoverSet;
    }
    /** Consume tokens until one matches the given token set. */
  }, {
    key: "consumeUntil",
    value: function consumeUntil(recognizer, set) {
      //		System.err.println("consumeUntil("+set.toString(recognizer.getTokenNames())+")");
      var ttype = recognizer.inputStream.LA(1);
      while (ttype !== Token_1.Token.EOF && !set.contains(ttype)) {
        //System.out.println("consume during recover LA(1)="+getTokenNames()[input.LA(1)]);
        //			recognizer.inputStream.consume();
        recognizer.consume();
        ttype = recognizer.inputStream.LA(1);
      }
    }
  }]);
  return DefaultErrorStrategy;
}();
__decorate([Decorators_1.Override], DefaultErrorStrategy.prototype, "reset", null);
__decorate([__param(0, Decorators_1.NotNull)], DefaultErrorStrategy.prototype, "beginErrorCondition", null);
__decorate([Decorators_1.Override], DefaultErrorStrategy.prototype, "inErrorRecoveryMode", null);
__decorate([__param(0, Decorators_1.NotNull)], DefaultErrorStrategy.prototype, "endErrorCondition", null);
__decorate([Decorators_1.Override], DefaultErrorStrategy.prototype, "reportMatch", null);
__decorate([Decorators_1.Override], DefaultErrorStrategy.prototype, "reportError", null);
__decorate([__param(0, Decorators_1.NotNull)], DefaultErrorStrategy.prototype, "notifyErrorListeners", null);
__decorate([Decorators_1.Override], DefaultErrorStrategy.prototype, "recover", null);
__decorate([Decorators_1.Override], DefaultErrorStrategy.prototype, "sync", null);
__decorate([__param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)], DefaultErrorStrategy.prototype, "reportNoViableAlternative", null);
__decorate([__param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)], DefaultErrorStrategy.prototype, "reportInputMismatch", null);
__decorate([__param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)], DefaultErrorStrategy.prototype, "reportFailedPredicate", null);
__decorate([__param(0, Decorators_1.NotNull)], DefaultErrorStrategy.prototype, "reportUnwantedToken", null);
__decorate([__param(0, Decorators_1.NotNull)], DefaultErrorStrategy.prototype, "reportMissingToken", null);
__decorate([Decorators_1.Override], DefaultErrorStrategy.prototype, "recoverInline", null);
__decorate([__param(0, Decorators_1.NotNull)], DefaultErrorStrategy.prototype, "singleTokenInsertion", null);
__decorate([__param(0, Decorators_1.NotNull)], DefaultErrorStrategy.prototype, "singleTokenDeletion", null);
__decorate([Decorators_1.NotNull, __param(0, Decorators_1.NotNull)], DefaultErrorStrategy.prototype, "getMissingSymbol", null);
__decorate([Decorators_1.NotNull, __param(0, Decorators_1.NotNull)], DefaultErrorStrategy.prototype, "getExpectedTokens", null);
__decorate([__param(0, Decorators_1.NotNull)], DefaultErrorStrategy.prototype, "getSymbolText", null);
__decorate([__param(0, Decorators_1.NotNull)], DefaultErrorStrategy.prototype, "getSymbolType", null);
__decorate([Decorators_1.NotNull, __param(0, Decorators_1.NotNull)], DefaultErrorStrategy.prototype, "escapeWSAndQuote", null);
__decorate([Decorators_1.NotNull, __param(0, Decorators_1.NotNull)], DefaultErrorStrategy.prototype, "getErrorRecoverySet", null);
__decorate([__param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)], DefaultErrorStrategy.prototype, "consumeUntil", null);
exports.DefaultErrorStrategy = DefaultErrorStrategy;

},{"./Decorators":272,"./FailedPredicateException":276,"./InputMismatchException":277,"./NoViableAltException":284,"./Token":296,"./atn/ATNState":305,"./atn/ATNStateType":306,"./atn/PredictionContext":346,"./misc/IntervalSet":379,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.replace.js":629}],274:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:51.1349829-07:00
/**
 *
 * @author Sam Harwell
 */
var Dependents;
(function (Dependents) {
  /**
   * The element is dependent upon the specified rule.
   */
  Dependents[Dependents["SELF"] = 0] = "SELF";
  /**
   * The element is dependent upon the set of the specified rule's parents
   * (rules which directly reference it).
   */
  Dependents[Dependents["PARENTS"] = 1] = "PARENTS";
  /**
   * The element is dependent upon the set of the specified rule's children
   * (rules which it directly references).
   */
  Dependents[Dependents["CHILDREN"] = 2] = "CHILDREN";
  /**
   * The element is dependent upon the set of the specified rule's ancestors
   * (the transitive closure of `PARENTS` rules).
   */
  Dependents[Dependents["ANCESTORS"] = 3] = "ANCESTORS";
  /**
   * The element is dependent upon the set of the specified rule's descendants
   * (the transitive closure of `CHILDREN` rules).
   */
  Dependents[Dependents["DESCENDANTS"] = 4] = "DESCENDANTS";
  /**
   * The element is dependent upon the set of the specified rule's siblings
   * (the union of `CHILDREN` of its `PARENTS`).
   */
  Dependents[Dependents["SIBLINGS"] = 5] = "SIBLINGS";
  /**
   * The element is dependent upon the set of the specified rule's preceeding
   * siblings (the union of `CHILDREN` of its `PARENTS` which
   * appear before a reference to the rule).
   */
  Dependents[Dependents["PRECEEDING_SIBLINGS"] = 6] = "PRECEEDING_SIBLINGS";
  /**
   * The element is dependent upon the set of the specified rule's following
   * siblings (the union of `CHILDREN` of its `PARENTS` which
   * appear after a reference to the rule).
   */
  Dependents[Dependents["FOLLOWING_SIBLINGS"] = 7] = "FOLLOWING_SIBLINGS";
  /**
   * The element is dependent upon the set of the specified rule's preceeding
   * elements (rules which might end before the start of the specified rule
   * while parsing). This is calculated by taking the
   * `PRECEEDING_SIBLINGS` of the rule and each of its
   * `ANCESTORS`, along with the `DESCENDANTS` of those
   * elements.
   */
  Dependents[Dependents["PRECEEDING"] = 8] = "PRECEEDING";
  /**
   * The element is dependent upon the set of the specified rule's following
   * elements (rules which might start after the end of the specified rule
   * while parsing). This is calculated by taking the
   * `FOLLOWING_SIBLINGS` of the rule and each of its
   * `ANCESTORS`, along with the `DESCENDANTS` of those
   * elements.
   */
  Dependents[Dependents["FOLLOWING"] = 9] = "FOLLOWING";
})(Dependents = exports.Dependents || (exports.Dependents = {}));

},{}],275:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.array.concat.js");
require("core-js/modules/es.regexp.to-string.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var BitSet_1 = require("./misc/BitSet");
var Decorators_1 = require("./Decorators");
var Interval_1 = require("./misc/Interval");
/**
 * This implementation of {@link ANTLRErrorListener} can be used to identify
 * certain potential correctness and performance problems in grammars. "Reports"
 * are made by calling {@link Parser#notifyErrorListeners} with the appropriate
 * message.
 *
 * * **Ambiguities**: These are cases where more than one path through the
 *   grammar can match the input.
 * * **Weak context sensitivity**: These are cases where full-context
 *   prediction resolved an SLL conflict to a unique alternative which equaled the
 *   minimum alternative of the SLL conflict.
 * * **Strong (forced) context sensitivity**: These are cases where the
 *   full-context prediction resolved an SLL conflict to a unique alternative,
 *   *and* the minimum alternative of the SLL conflict was found to not be
 *   a truly viable alternative. Two-stage parsing cannot be used for inputs where
 *   this situation occurs.
 *
 * @author Sam Harwell
 */
var DiagnosticErrorListener = /*#__PURE__*/function () {
  /**
   * Initializes a new instance of {@link DiagnosticErrorListener}, specifying
   * whether all ambiguities or only exact ambiguities are reported.
   *
   * @param exactOnly `true` to report only exact ambiguities, otherwise
   * `false` to report all ambiguities.  Defaults to true.
   */
  function DiagnosticErrorListener() {
    var exactOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    (0, _classCallCheck2.default)(this, DiagnosticErrorListener);
    this.exactOnly = exactOnly;
    this.exactOnly = exactOnly;
  }
  (0, _createClass2.default)(DiagnosticErrorListener, [{
    key: "syntaxError",
    value: function syntaxError( /*@NotNull*/
    recognizer, offendingSymbol, line, charPositionInLine, /*@NotNull*/
    msg, e) {
      // intentionally empty
    }
  }, {
    key: "reportAmbiguity",
    value: function reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
      if (this.exactOnly && !exact) {
        return;
      }
      var decision = this.getDecisionDescription(recognizer, dfa);
      var conflictingAlts = this.getConflictingAlts(ambigAlts, configs);
      var text = recognizer.inputStream.getText(Interval_1.Interval.of(startIndex, stopIndex));
      var message = "reportAmbiguity d=".concat(decision, ": ambigAlts=").concat(conflictingAlts, ", input='").concat(text, "'");
      recognizer.notifyErrorListeners(message);
    }
  }, {
    key: "reportAttemptingFullContext",
    value: function reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, conflictState) {
      var format = "reportAttemptingFullContext d=%s, input='%s'";
      var decision = this.getDecisionDescription(recognizer, dfa);
      var text = recognizer.inputStream.getText(Interval_1.Interval.of(startIndex, stopIndex));
      var message = "reportAttemptingFullContext d=".concat(decision, ", input='").concat(text, "'");
      recognizer.notifyErrorListeners(message);
    }
  }, {
    key: "reportContextSensitivity",
    value: function reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, acceptState) {
      var format = "reportContextSensitivity d=%s, input='%s'";
      var decision = this.getDecisionDescription(recognizer, dfa);
      var text = recognizer.inputStream.getText(Interval_1.Interval.of(startIndex, stopIndex));
      var message = "reportContextSensitivity d=".concat(decision, ", input='").concat(text, "'");
      recognizer.notifyErrorListeners(message);
    }
  }, {
    key: "getDecisionDescription",
    value: function getDecisionDescription(recognizer, dfa) {
      var decision = dfa.decision;
      var ruleIndex = dfa.atnStartState.ruleIndex;
      var ruleNames = recognizer.ruleNames;
      if (ruleIndex < 0 || ruleIndex >= ruleNames.length) {
        return decision.toString();
      }
      var ruleName = ruleNames[ruleIndex];
      if (!ruleName) {
        return decision.toString();
      }
      return "".concat(decision, " (").concat(ruleName, ")");
    }
    /**
     * Computes the set of conflicting or ambiguous alternatives from a
     * configuration set, if that information was not already provided by the
     * parser.
     *
     * @param reportedAlts The set of conflicting or ambiguous alternatives, as
     * reported by the parser.
     * @param configs The conflicting or ambiguous configuration set.
     * @returns Returns `reportedAlts` if it is not `undefined`, otherwise
     * returns the set of alternatives represented in `configs`.
     */
  }, {
    key: "getConflictingAlts",
    value: function getConflictingAlts(reportedAlts, configs) {
      if (reportedAlts != null) {
        return reportedAlts;
      }
      var result = new BitSet_1.BitSet();
      var _iterator = _createForOfIteratorHelper(configs),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var config = _step.value;
          result.set(config.alt);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return result;
    }
  }]);
  return DiagnosticErrorListener;
}();
__decorate([Decorators_1.Override], DiagnosticErrorListener.prototype, "syntaxError", null);
__decorate([Decorators_1.Override, __param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull), __param(6, Decorators_1.NotNull)], DiagnosticErrorListener.prototype, "reportAmbiguity", null);
__decorate([Decorators_1.Override, __param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull), __param(5, Decorators_1.NotNull)], DiagnosticErrorListener.prototype, "reportAttemptingFullContext", null);
__decorate([Decorators_1.Override, __param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull), __param(5, Decorators_1.NotNull)], DiagnosticErrorListener.prototype, "reportContextSensitivity", null);
__decorate([__param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)], DiagnosticErrorListener.prototype, "getDecisionDescription", null);
__decorate([Decorators_1.NotNull, __param(1, Decorators_1.NotNull)], DiagnosticErrorListener.prototype, "getConflictingAlts", null);
exports.DiagnosticErrorListener = DiagnosticErrorListener;

},{"./Decorators":272,"./misc/BitSet":373,"./misc/Interval":378,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],276:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var RecognitionException_1 = require("./RecognitionException");
var Decorators_1 = require("./Decorators");
var PredicateTransition_1 = require("./atn/PredicateTransition");
/** A semantic predicate failed during validation.  Validation of predicates
 *  occurs when normally parsing the alternative just like matching a token.
 *  Disambiguating predicate evaluation occurs when we test a predicate during
 *  prediction.
 */
var FailedPredicateException = /*#__PURE__*/function (_RecognitionException) {
  (0, _inherits2.default)(FailedPredicateException, _RecognitionException);
  var _super = _createSuper(FailedPredicateException);
  function FailedPredicateException(recognizer, predicate, message) {
    var _thisSuper, _this;
    (0, _classCallCheck2.default)(this, FailedPredicateException);
    _this = _super.call(this, recognizer, recognizer.inputStream, recognizer.context, FailedPredicateException.formatMessage(predicate, message));
    var s = recognizer.interpreter.atn.states[recognizer.state];
    var trans = s.transition(0);
    if (trans instanceof PredicateTransition_1.PredicateTransition) {
      _this._ruleIndex = trans.ruleIndex;
      _this._predicateIndex = trans.predIndex;
    } else {
      _this._ruleIndex = 0;
      _this._predicateIndex = 0;
    }
    _this._predicate = predicate;
    (0, _get2.default)((_thisSuper = (0, _assertThisInitialized2.default)(_this), (0, _getPrototypeOf2.default)(FailedPredicateException.prototype)), "setOffendingToken", _thisSuper).call(_thisSuper, recognizer, recognizer.currentToken);
    return _this;
  }
  (0, _createClass2.default)(FailedPredicateException, [{
    key: "ruleIndex",
    get: function get() {
      return this._ruleIndex;
    }
  }, {
    key: "predicateIndex",
    get: function get() {
      return this._predicateIndex;
    }
  }, {
    key: "predicate",
    get: function get() {
      return this._predicate;
    }
  }], [{
    key: "formatMessage",
    value: function formatMessage(predicate, message) {
      if (message) {
        return message;
      }
      return "failed predicate: {".concat(predicate, "}?");
    }
  }]);
  return FailedPredicateException;
}(RecognitionException_1.RecognitionException);
__decorate([Decorators_1.NotNull], FailedPredicateException, "formatMessage", null);
FailedPredicateException = __decorate([__param(0, Decorators_1.NotNull)], FailedPredicateException);
exports.FailedPredicateException = FailedPredicateException;

},{"./Decorators":272,"./RecognitionException":290,"./atn/PredicateTransition":345,"@babel/runtime/helpers/assertThisInitialized":229,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/get":234,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],277:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:51.5187682-07:00
var RecognitionException_1 = require("./RecognitionException");
var Decorators_1 = require("./Decorators");
/** This signifies any kind of mismatched input exceptions such as
 *  when the current input does not match the expected token.
 */
var InputMismatchException = /*#__PURE__*/function (_RecognitionException) {
  (0, _inherits2.default)(InputMismatchException, _RecognitionException);
  var _super = _createSuper(InputMismatchException);
  function InputMismatchException(recognizer, state, context) {
    var _this;
    (0, _classCallCheck2.default)(this, InputMismatchException);
    if (context === undefined) {
      context = recognizer.context;
    }
    _this = _super.call(this, recognizer, recognizer.inputStream, context);
    if (state !== undefined) {
      _this.setOffendingState(state);
    }
    _this.setOffendingToken(recognizer, recognizer.currentToken);
    return _this;
  }
  return (0, _createClass2.default)(InputMismatchException);
}(RecognitionException_1.RecognitionException);
InputMismatchException = __decorate([__param(0, Decorators_1.NotNull)], InputMismatchException);
exports.InputMismatchException = InputMismatchException;

},{"./Decorators":272,"./RecognitionException":290,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],278:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:51.6934376-07:00
var IntStream;
(function (IntStream) {
  /**
   * The value returned by {@link #LA LA()} when the end of the stream is
   * reached.
   */
  IntStream.EOF = -1;
  /**
   * The value returned by {@link #getSourceName} when the actual name of the
   * underlying source is not known.
   */
  IntStream.UNKNOWN_SOURCE_NAME = "<unknown>";
})(IntStream = exports.IntStream || (exports.IntStream = {}));

},{}],279:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:51.5898546-07:00
var Decorators_1 = require("./Decorators");
var ParserRuleContext_1 = require("./ParserRuleContext");
/**
 * This class extends {@link ParserRuleContext} by allowing the value of
 * {@link #getRuleIndex} to be explicitly set for the context.
 *
 * {@link ParserRuleContext} does not include field storage for the rule index
 * since the context classes created by the code generator override the
 * {@link #getRuleIndex} method to return the correct value for that context.
 * Since the parser interpreter does not use the context classes generated for a
 * parser, this class (with slightly more memory overhead per node) is used to
 * provide equivalent functionality.
 */
var InterpreterRuleContext = /*#__PURE__*/function (_ParserRuleContext_1$) {
  (0, _inherits2.default)(InterpreterRuleContext, _ParserRuleContext_1$);
  var _super = _createSuper(InterpreterRuleContext);
  function InterpreterRuleContext(ruleIndex, parent, invokingStateNumber) {
    var _this;
    (0, _classCallCheck2.default)(this, InterpreterRuleContext);
    if (invokingStateNumber !== undefined) {
      _this = _super.call(this, parent, invokingStateNumber);
    } else {
      _this = _super.call(this);
    }
    _this._ruleIndex = ruleIndex;
    return (0, _possibleConstructorReturn2.default)(_this);
  }
  (0, _createClass2.default)(InterpreterRuleContext, [{
    key: "ruleIndex",
    get: function get() {
      return this._ruleIndex;
    }
  }]);
  return InterpreterRuleContext;
}(ParserRuleContext_1.ParserRuleContext);
__decorate([Decorators_1.Override], InterpreterRuleContext.prototype, "ruleIndex", null);
exports.InterpreterRuleContext = InterpreterRuleContext;

},{"./Decorators":272,"./ParserRuleContext":287,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],280:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.match.js");
require("core-js/modules/es.string.replace.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var CommonTokenFactory_1 = require("./CommonTokenFactory");
var IntegerStack_1 = require("./misc/IntegerStack");
var Interval_1 = require("./misc/Interval");
var IntStream_1 = require("./IntStream");
var LexerATNSimulator_1 = require("./atn/LexerATNSimulator");
var LexerNoViableAltException_1 = require("./LexerNoViableAltException");
var Decorators_1 = require("./Decorators");
var Recognizer_1 = require("./Recognizer");
var Token_1 = require("./Token");
/** A lexer is recognizer that draws input symbols from a character stream.
 *  lexer grammars result in a subclass of this object. A Lexer object
 *  uses simplified match() and error recovery mechanisms in the interest
 *  of speed.
 */
var Lexer = /*#__PURE__*/function (_Recognizer_1$Recogni) {
  (0, _inherits2.default)(Lexer, _Recognizer_1$Recogni);
  var _super = _createSuper(Lexer);
  function Lexer(input) {
    var _this;
    (0, _classCallCheck2.default)(this, Lexer);
    _this = _super.call(this);
    /** How to create token objects */
    _this._factory = CommonTokenFactory_1.CommonTokenFactory.DEFAULT;
    /** What character index in the stream did the current token start at?
     *  Needed, for example, to get the text for current token.  Set at
     *  the start of nextToken.
     */
    _this._tokenStartCharIndex = -1;
    /** The line on which the first character of the token resides */
    _this._tokenStartLine = 0;
    /** The character position of first character within the line */
    _this._tokenStartCharPositionInLine = 0;
    /** Once we see EOF on char stream, next token will be EOF.
     *  If you have DONE : EOF ; then you see DONE EOF.
     */
    _this._hitEOF = false;
    /** The channel number for the current token */
    _this._channel = 0;
    /** The token type for the current token */
    _this._type = 0;
    _this._modeStack = new IntegerStack_1.IntegerStack();
    _this._mode = Lexer.DEFAULT_MODE;
    _this._input = input;
    _this._tokenFactorySourcePair = {
      source: (0, _assertThisInitialized2.default)(_this),
      stream: input
    };
    return _this;
  }
  (0, _createClass2.default)(Lexer, [{
    key: "reset",
    value: function reset(resetInput) {
      // wack Lexer state variables
      if (resetInput === undefined || resetInput) {
        this._input.seek(0); // rewind the input
      }

      this._token = undefined;
      this._type = Token_1.Token.INVALID_TYPE;
      this._channel = Token_1.Token.DEFAULT_CHANNEL;
      this._tokenStartCharIndex = -1;
      this._tokenStartCharPositionInLine = -1;
      this._tokenStartLine = -1;
      this._text = undefined;
      this._hitEOF = false;
      this._mode = Lexer.DEFAULT_MODE;
      this._modeStack.clear();
      this.interpreter.reset();
    }
    /** Return a token from this source; i.e., match a token on the char
     *  stream.
     */
  }, {
    key: "nextToken",
    value: function nextToken() {
      if (this._input == null) {
        throw new Error("nextToken requires a non-null input stream.");
      }
      // Mark start location in char stream so unbuffered streams are
      // guaranteed at least have text of current token
      var tokenStartMarker = this._input.mark();
      try {
        outer: while (true) {
          if (this._hitEOF) {
            return this.emitEOF();
          }
          this._token = undefined;
          this._channel = Token_1.Token.DEFAULT_CHANNEL;
          this._tokenStartCharIndex = this._input.index;
          this._tokenStartCharPositionInLine = this.interpreter.charPositionInLine;
          this._tokenStartLine = this.interpreter.line;
          this._text = undefined;
          do {
            this._type = Token_1.Token.INVALID_TYPE;
            //				System.out.println("nextToken line "+tokenStartLine+" at "+((char)input.LA(1))+
            //								   " in mode "+mode+
            //								   " at index "+input.index);
            var ttype = void 0;
            try {
              ttype = this.interpreter.match(this._input, this._mode);
            } catch (e) {
              if (e instanceof LexerNoViableAltException_1.LexerNoViableAltException) {
                this.notifyListeners(e); // report error
                this.recover(e);
                ttype = Lexer.SKIP;
              } else {
                throw e;
              }
            }
            if (this._input.LA(1) === IntStream_1.IntStream.EOF) {
              this._hitEOF = true;
            }
            if (this._type === Token_1.Token.INVALID_TYPE) {
              this._type = ttype;
            }
            if (this._type === Lexer.SKIP) {
              continue outer;
            }
          } while (this._type === Lexer.MORE);
          if (this._token == null) {
            return this.emit();
          }
          return this._token;
        }
      } finally {
        // make sure we release marker after match or
        // unbuffered char stream will keep buffering
        this._input.release(tokenStartMarker);
      }
    }
    /** Instruct the lexer to skip creating a token for current lexer rule
     *  and look for another token.  nextToken() knows to keep looking when
     *  a lexer rule finishes with token set to SKIP_TOKEN.  Recall that
     *  if token==undefined at end of any token rule, it creates one for you
     *  and emits it.
     */
  }, {
    key: "skip",
    value: function skip() {
      this._type = Lexer.SKIP;
    }
  }, {
    key: "more",
    value: function more() {
      this._type = Lexer.MORE;
    }
  }, {
    key: "mode",
    value: function mode(m) {
      this._mode = m;
    }
  }, {
    key: "pushMode",
    value: function pushMode(m) {
      if (LexerATNSimulator_1.LexerATNSimulator.debug) {
        console.log("pushMode " + m);
      }
      this._modeStack.push(this._mode);
      this.mode(m);
    }
  }, {
    key: "popMode",
    value: function popMode() {
      if (this._modeStack.isEmpty) {
        throw new Error("EmptyStackException");
      }
      if (LexerATNSimulator_1.LexerATNSimulator.debug) {
        console.log("popMode back to " + this._modeStack.peek());
      }
      this.mode(this._modeStack.pop());
      return this._mode;
    }
  }, {
    key: "tokenFactory",
    get: function get() {
      return this._factory;
    }
    // @Override
    ,
    set: function set(factory) {
      this._factory = factory;
    }
  }, {
    key: "inputStream",
    get: function get() {
      return this._input;
    }
    /** Set the char stream and reset the lexer */,
    set: function set(input) {
      this.reset(false);
      this._input = input;
      this._tokenFactorySourcePair = {
        source: this,
        stream: this._input
      };
    }
  }, {
    key: "sourceName",
    get: function get() {
      return this._input.sourceName;
    }
  }, {
    key: "emit",
    value: function emit(token) {
      if (!token) {
        token = this._factory.create(this._tokenFactorySourcePair, this._type, this._text, this._channel, this._tokenStartCharIndex, this.charIndex - 1, this._tokenStartLine, this._tokenStartCharPositionInLine);
      }
      this._token = token;
      return token;
    }
  }, {
    key: "emitEOF",
    value: function emitEOF() {
      var cpos = this.charPositionInLine;
      var line = this.line;
      var eof = this._factory.create(this._tokenFactorySourcePair, Token_1.Token.EOF, undefined, Token_1.Token.DEFAULT_CHANNEL, this._input.index, this._input.index - 1, line, cpos);
      this.emit(eof);
      return eof;
    }
  }, {
    key: "line",
    get: function get() {
      return this.interpreter.line;
    },
    set: function set(line) {
      this.interpreter.line = line;
    }
  }, {
    key: "charPositionInLine",
    get: function get() {
      return this.interpreter.charPositionInLine;
    },
    set: function set(charPositionInLine) {
      this.interpreter.charPositionInLine = charPositionInLine;
    }
    /** What is the index of the current character of lookahead? */
  }, {
    key: "charIndex",
    get: function get() {
      return this._input.index;
    }
    /** Return the text matched so far for the current token or any
     *  text override.
     */
  }, {
    key: "text",
    get: function get() {
      if (this._text != null) {
        return this._text;
      }
      return this.interpreter.getText(this._input);
    }
    /** Set the complete text of this token; it wipes any previous
     *  changes to the text.
     */,
    set: function set(text) {
      this._text = text;
    }
    /** Override if emitting multiple tokens. */
  }, {
    key: "token",
    get: function get() {
      return this._token;
    },
    set: function set(_token) {
      this._token = _token;
    }
  }, {
    key: "type",
    get: function get() {
      return this._type;
    },
    set: function set(ttype) {
      this._type = ttype;
    }
  }, {
    key: "channel",
    get: function get() {
      return this._channel;
    }
    /** Return a list of all Token objects in input char stream.
     *  Forces load of all tokens. Does not include EOF token.
     */,
    set: function set(channel) {
      this._channel = channel;
    }
  }, {
    key: "getAllTokens",
    value: function getAllTokens() {
      var tokens = [];
      var t = this.nextToken();
      while (t.type !== Token_1.Token.EOF) {
        tokens.push(t);
        t = this.nextToken();
      }
      return tokens;
    }
  }, {
    key: "notifyListeners",
    value: function notifyListeners(e) {
      var text = this._input.getText(Interval_1.Interval.of(this._tokenStartCharIndex, this._input.index));
      var msg = "token recognition error at: '" + this.getErrorDisplay(text) + "'";
      var listener = this.getErrorListenerDispatch();
      if (listener.syntaxError) {
        listener.syntaxError(this, undefined, this._tokenStartLine, this._tokenStartCharPositionInLine, msg, e);
      }
    }
  }, {
    key: "getErrorDisplay",
    value: function getErrorDisplay(s) {
      if (typeof s === "number") {
        switch (s) {
          case Token_1.Token.EOF:
            return "<EOF>";
          case 0x0a:
            return "\\n";
          case 0x09:
            return "\\t";
          case 0x0d:
            return "\\r";
        }
        return String.fromCharCode(s);
      }
      return s.replace(/\n/g, "\\n").replace(/\t/g, "\\t").replace(/\r/g, "\\r");
    }
  }, {
    key: "getCharErrorDisplay",
    value: function getCharErrorDisplay(c) {
      var s = this.getErrorDisplay(c);
      return "'" + s + "'";
    }
  }, {
    key: "recover",
    value: function recover(re) {
      if (re instanceof LexerNoViableAltException_1.LexerNoViableAltException) {
        if (this._input.LA(1) !== IntStream_1.IntStream.EOF) {
          // skip a char and try again
          this.interpreter.consume(this._input);
        }
      } else {
        //System.out.println("consuming char "+(char)input.LA(1)+" during recovery");
        //re.printStackTrace();
        // TODO: Do we lose character or line position information?
        this._input.consume();
      }
    }
  }], [{
    key: "DEFAULT_TOKEN_CHANNEL",
    get: function get() {
      return Token_1.Token.DEFAULT_CHANNEL;
    }
  }, {
    key: "HIDDEN",
    get: function get() {
      return Token_1.Token.HIDDEN_CHANNEL;
    }
  }]);
  return Lexer;
}(Recognizer_1.Recognizer);
Lexer.DEFAULT_MODE = 0;
Lexer.MORE = -2;
Lexer.SKIP = -3;
Lexer.MIN_CHAR_VALUE = 0x0000;
Lexer.MAX_CHAR_VALUE = 0x10FFFF;
__decorate([Decorators_1.Override], Lexer.prototype, "nextToken", null);
__decorate([Decorators_1.Override], Lexer.prototype, "tokenFactory", null);
__decorate([Decorators_1.Override], Lexer.prototype, "inputStream", null);
__decorate([Decorators_1.Override], Lexer.prototype, "sourceName", null);
__decorate([Decorators_1.Override], Lexer.prototype, "line", null);
__decorate([Decorators_1.Override], Lexer.prototype, "charPositionInLine", null);
exports.Lexer = Lexer;

},{"./CommonTokenFactory":269,"./Decorators":272,"./IntStream":278,"./LexerNoViableAltException":282,"./Recognizer":291,"./Token":296,"./atn/LexerATNSimulator":324,"./misc/IntegerStack":377,"./misc/Interval":378,"@babel/runtime/helpers/assertThisInitialized":229,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.string.match.js":627,"core-js/modules/es.string.replace.js":629}],281:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.array.slice.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var Lexer_1 = require("./Lexer");
var LexerATNSimulator_1 = require("./atn/LexerATNSimulator");
var Decorators_1 = require("./Decorators");
var Decorators_2 = require("./Decorators");
var LexerInterpreter = /*#__PURE__*/function (_Lexer_1$Lexer) {
  (0, _inherits2.default)(LexerInterpreter, _Lexer_1$Lexer);
  var _super = _createSuper(LexerInterpreter);
  function LexerInterpreter(grammarFileName, vocabulary, ruleNames, channelNames, modeNames, atn, input) {
    var _this;
    (0, _classCallCheck2.default)(this, LexerInterpreter);
    _this = _super.call(this, input);
    if (atn.grammarType !== 0 /* LEXER */) {
      throw new Error("IllegalArgumentException: The ATN must be a lexer ATN.");
    }
    _this._grammarFileName = grammarFileName;
    _this._atn = atn;
    _this._ruleNames = ruleNames.slice(0);
    _this._channelNames = channelNames.slice(0);
    _this._modeNames = modeNames.slice(0);
    _this._vocabulary = vocabulary;
    _this._interp = new LexerATNSimulator_1.LexerATNSimulator(atn, (0, _assertThisInitialized2.default)(_this));
    return _this;
  }
  (0, _createClass2.default)(LexerInterpreter, [{
    key: "atn",
    get: function get() {
      return this._atn;
    }
  }, {
    key: "grammarFileName",
    get: function get() {
      return this._grammarFileName;
    }
  }, {
    key: "ruleNames",
    get: function get() {
      return this._ruleNames;
    }
  }, {
    key: "channelNames",
    get: function get() {
      return this._channelNames;
    }
  }, {
    key: "modeNames",
    get: function get() {
      return this._modeNames;
    }
  }, {
    key: "vocabulary",
    get: function get() {
      return this._vocabulary;
    }
  }]);
  return LexerInterpreter;
}(Lexer_1.Lexer);
__decorate([Decorators_1.NotNull], LexerInterpreter.prototype, "_vocabulary", void 0);
__decorate([Decorators_2.Override], LexerInterpreter.prototype, "atn", null);
__decorate([Decorators_2.Override], LexerInterpreter.prototype, "grammarFileName", null);
__decorate([Decorators_2.Override], LexerInterpreter.prototype, "ruleNames", null);
__decorate([Decorators_2.Override], LexerInterpreter.prototype, "channelNames", null);
__decorate([Decorators_2.Override], LexerInterpreter.prototype, "modeNames", null);
__decorate([Decorators_2.Override], LexerInterpreter.prototype, "vocabulary", null);
LexerInterpreter = __decorate([__param(1, Decorators_1.NotNull)], LexerInterpreter);
exports.LexerInterpreter = LexerInterpreter;

},{"./Decorators":272,"./Lexer":280,"./atn/LexerATNSimulator":324,"@babel/runtime/helpers/assertThisInitialized":229,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],282:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var RecognitionException_1 = require("./RecognitionException");
var Decorators_1 = require("./Decorators");
var Interval_1 = require("./misc/Interval");
var Utils = require("./misc/Utils");
var LexerNoViableAltException = /*#__PURE__*/function (_RecognitionException) {
  (0, _inherits2.default)(LexerNoViableAltException, _RecognitionException);
  var _super = _createSuper(LexerNoViableAltException);
  function LexerNoViableAltException(lexer, input, startIndex, deadEndConfigs) {
    var _this;
    (0, _classCallCheck2.default)(this, LexerNoViableAltException);
    _this = _super.call(this, lexer, input);
    _this._startIndex = startIndex;
    _this._deadEndConfigs = deadEndConfigs;
    return _this;
  }
  (0, _createClass2.default)(LexerNoViableAltException, [{
    key: "startIndex",
    get: function get() {
      return this._startIndex;
    }
  }, {
    key: "deadEndConfigs",
    get: function get() {
      return this._deadEndConfigs;
    }
  }, {
    key: "inputStream",
    get: function get() {
      return (0, _get2.default)((0, _getPrototypeOf2.default)(LexerNoViableAltException.prototype), "inputStream", this);
    }
  }, {
    key: "toString",
    value: function toString() {
      var symbol = "";
      if (this._startIndex >= 0 && this._startIndex < this.inputStream.size) {
        symbol = this.inputStream.getText(Interval_1.Interval.of(this._startIndex, this._startIndex));
        symbol = Utils.escapeWhitespace(symbol, false);
      }
      // return String.format(Locale.getDefault(), "%s('%s')", LexerNoViableAltException.class.getSimpleName(), symbol);
      return "LexerNoViableAltException('".concat(symbol, "')");
    }
  }]);
  return LexerNoViableAltException;
}(RecognitionException_1.RecognitionException);
__decorate([Decorators_1.Override], LexerNoViableAltException.prototype, "inputStream", null);
__decorate([Decorators_1.Override], LexerNoViableAltException.prototype, "toString", null);
LexerNoViableAltException = __decorate([__param(1, Decorators_1.NotNull)], LexerNoViableAltException);
exports.LexerNoViableAltException = LexerNoViableAltException;

},{"./Decorators":272,"./RecognitionException":290,"./misc/Interval":378,"./misc/Utils":385,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/get":234,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],283:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var CommonTokenFactory_1 = require("./CommonTokenFactory");
var Decorators_1 = require("./Decorators");
var Token_1 = require("./Token");
/**
 * Provides an implementation of {@link TokenSource} as a wrapper around a list
 * of {@link Token} objects.
 *
 * If the final token in the list is an {@link Token#EOF} token, it will be used
 * as the EOF token for every call to {@link #nextToken} after the end of the
 * list is reached. Otherwise, an EOF token will be created.
 */
var ListTokenSource = /*#__PURE__*/function () {
  /**
   * Constructs a new {@link ListTokenSource} instance from the specified
   * collection of {@link Token} objects and source name.
   *
   * @param tokens The collection of {@link Token} objects to provide as a
   * {@link TokenSource}.
   * @param sourceName The name of the {@link TokenSource}. If this value is
   * `undefined`, {@link #getSourceName} will attempt to infer the name from
   * the next {@link Token} (or the previous token if the end of the input has
   * been reached).
   *
   * @exception NullPointerException if `tokens` is `undefined`
   */
  function ListTokenSource(tokens, sourceName) {
    (0, _classCallCheck2.default)(this, ListTokenSource);
    /**
     * The index into {@link #tokens} of token to return by the next call to
     * {@link #nextToken}. The end of the input is indicated by this value
     * being greater than or equal to the number of items in {@link #tokens}.
     */
    this.i = 0;
    /**
     * This is the backing field for {@link #getTokenFactory} and
     * {@link setTokenFactory}.
     */
    this._factory = CommonTokenFactory_1.CommonTokenFactory.DEFAULT;
    if (tokens == null) {
      throw new Error("tokens cannot be null");
    }
    this.tokens = tokens;
    this._sourceName = sourceName;
  }
  /**
   * {@inheritDoc}
   */
  (0, _createClass2.default)(ListTokenSource, [{
    key: "charPositionInLine",
    get: function get() {
      if (this.i < this.tokens.length) {
        return this.tokens[this.i].charPositionInLine;
      } else if (this.eofToken != null) {
        return this.eofToken.charPositionInLine;
      } else if (this.tokens.length > 0) {
        // have to calculate the result from the line/column of the previous
        // token, along with the text of the token.
        var lastToken = this.tokens[this.tokens.length - 1];
        var tokenText = lastToken.text;
        if (tokenText != null) {
          var lastNewLine = tokenText.lastIndexOf("\n");
          if (lastNewLine >= 0) {
            return tokenText.length - lastNewLine - 1;
          }
        }
        return lastToken.charPositionInLine + lastToken.stopIndex - lastToken.startIndex + 1;
      }
      // only reach this if tokens is empty, meaning EOF occurs at the first
      // position in the input
      return 0;
    }
    /**
     * {@inheritDoc}
     */
  }, {
    key: "nextToken",
    value: function nextToken() {
      if (this.i >= this.tokens.length) {
        if (this.eofToken == null) {
          var start = -1;
          if (this.tokens.length > 0) {
            var previousStop = this.tokens[this.tokens.length - 1].stopIndex;
            if (previousStop !== -1) {
              start = previousStop + 1;
            }
          }
          var stop = Math.max(-1, start - 1);
          this.eofToken = this._factory.create({
            source: this,
            stream: this.inputStream
          }, Token_1.Token.EOF, "EOF", Token_1.Token.DEFAULT_CHANNEL, start, stop, this.line, this.charPositionInLine);
        }
        return this.eofToken;
      }
      var t = this.tokens[this.i];
      if (this.i === this.tokens.length - 1 && t.type === Token_1.Token.EOF) {
        this.eofToken = t;
      }
      this.i++;
      return t;
    }
    /**
     * {@inheritDoc}
     */
  }, {
    key: "line",
    get: function get() {
      if (this.i < this.tokens.length) {
        return this.tokens[this.i].line;
      } else if (this.eofToken != null) {
        return this.eofToken.line;
      } else if (this.tokens.length > 0) {
        // have to calculate the result from the line/column of the previous
        // token, along with the text of the token.
        var lastToken = this.tokens[this.tokens.length - 1];
        var line = lastToken.line;
        var tokenText = lastToken.text;
        if (tokenText != null) {
          for (var i = 0; i < tokenText.length; i++) {
            if (tokenText.charAt(i) === "\n") {
              line++;
            }
          }
        }
        // if no text is available, assume the token did not contain any newline characters.
        return line;
      }
      // only reach this if tokens is empty, meaning EOF occurs at the first
      // position in the input
      return 1;
    }
    /**
     * {@inheritDoc}
     */
  }, {
    key: "inputStream",
    get: function get() {
      if (this.i < this.tokens.length) {
        return this.tokens[this.i].inputStream;
      } else if (this.eofToken != null) {
        return this.eofToken.inputStream;
      } else if (this.tokens.length > 0) {
        return this.tokens[this.tokens.length - 1].inputStream;
      }
      // no input stream information is available
      return undefined;
    }
    /**
     * {@inheritDoc}
     */
  }, {
    key: "sourceName",
    get: function get() {
      if (this._sourceName) {
        return this._sourceName;
      }
      var inputStream = this.inputStream;
      if (inputStream != null) {
        return inputStream.sourceName;
      }
      return "List";
    }
    /**
     * {@inheritDoc}
     */
    // @Override
  }, {
    key: "tokenFactory",
    get:
    /**
     * {@inheritDoc}
     */
    function get() {
      return this._factory;
    },
    set: function set(factory) {
      this._factory = factory;
    }
  }]);
  return ListTokenSource;
}();
__decorate([Decorators_1.Override], ListTokenSource.prototype, "charPositionInLine", null);
__decorate([Decorators_1.Override], ListTokenSource.prototype, "nextToken", null);
__decorate([Decorators_1.Override], ListTokenSource.prototype, "line", null);
__decorate([Decorators_1.Override], ListTokenSource.prototype, "inputStream", null);
__decorate([Decorators_1.Override], ListTokenSource.prototype, "sourceName", null);
__decorate([Decorators_1.Override, Decorators_1.NotNull, __param(0, Decorators_1.NotNull)], ListTokenSource.prototype, "tokenFactory", null);
ListTokenSource = __decorate([__param(0, Decorators_1.NotNull)], ListTokenSource);
exports.ListTokenSource = ListTokenSource;

},{"./CommonTokenFactory":269,"./Decorators":272,"./Token":296,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612}],284:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var Parser_1 = require("./Parser");
var RecognitionException_1 = require("./RecognitionException");
var Decorators_1 = require("./Decorators");
/** Indicates that the parser could not decide which of two or more paths
 *  to take based upon the remaining input. It tracks the starting token
 *  of the offending input and also knows where the parser was
 *  in the various paths when the error. Reported by reportNoViableAlternative()
 */
var NoViableAltException = /*#__PURE__*/function (_RecognitionException) {
  (0, _inherits2.default)(NoViableAltException, _RecognitionException);
  var _super = _createSuper(NoViableAltException);
  function NoViableAltException(recognizer, input, startToken, offendingToken, deadEndConfigs, ctx) {
    var _this;
    (0, _classCallCheck2.default)(this, NoViableAltException);
    if (recognizer instanceof Parser_1.Parser) {
      if (input === undefined) {
        input = recognizer.inputStream;
      }
      if (startToken === undefined) {
        startToken = recognizer.currentToken;
      }
      if (offendingToken === undefined) {
        offendingToken = recognizer.currentToken;
      }
      if (ctx === undefined) {
        ctx = recognizer.context;
      }
    }
    _this = _super.call(this, recognizer, input, ctx);
    _this._deadEndConfigs = deadEndConfigs;
    _this._startToken = startToken;
    _this.setOffendingToken(recognizer, offendingToken);
    return _this;
  }
  (0, _createClass2.default)(NoViableAltException, [{
    key: "startToken",
    get: function get() {
      return this._startToken;
    }
  }, {
    key: "deadEndConfigs",
    get: function get() {
      return this._deadEndConfigs;
    }
  }]);
  return NoViableAltException;
}(RecognitionException_1.RecognitionException);
__decorate([Decorators_1.NotNull], NoViableAltException.prototype, "_startToken", void 0);
exports.NoViableAltException = NoViableAltException;

},{"./Decorators":272,"./Parser":285,"./RecognitionException":290,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],285:[function(require,module,exports){
(function (process){(function (){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.array.find-index.js");
require("core-js/modules/es.array.splice.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.map.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var Utils = require("./misc/Utils");
var ATNDeserializationOptions_1 = require("./atn/ATNDeserializationOptions");
var ATNDeserializer_1 = require("./atn/ATNDeserializer");
var DefaultErrorStrategy_1 = require("./DefaultErrorStrategy");
var ErrorNode_1 = require("./tree/ErrorNode");
var IntegerStack_1 = require("./misc/IntegerStack");
var Lexer_1 = require("./Lexer");
var Decorators_1 = require("./Decorators");
var ParseInfo_1 = require("./atn/ParseInfo");
var ParserATNSimulator_1 = require("./atn/ParserATNSimulator");
var ProxyParserErrorListener_1 = require("./ProxyParserErrorListener");
var Recognizer_1 = require("./Recognizer");
var TerminalNode_1 = require("./tree/TerminalNode");
var Token_1 = require("./Token");
var TraceListener = /*#__PURE__*/function () {
  function TraceListener(ruleNames, tokenStream) {
    (0, _classCallCheck2.default)(this, TraceListener);
    this.ruleNames = ruleNames;
    this.tokenStream = tokenStream;
  }
  (0, _createClass2.default)(TraceListener, [{
    key: "enterEveryRule",
    value: function enterEveryRule(ctx) {
      console.log("enter   " + this.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.tokenStream.LT(1).text);
    }
  }, {
    key: "exitEveryRule",
    value: function exitEveryRule(ctx) {
      console.log("exit    " + this.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.tokenStream.LT(1).text);
    }
  }, {
    key: "visitErrorNode",
    value: function visitErrorNode(node) {
      // intentionally empty
    }
  }, {
    key: "visitTerminal",
    value: function visitTerminal(node) {
      var parent = node.parent.ruleContext;
      var token = node.symbol;
      console.log("consume " + token + " rule " + this.ruleNames[parent.ruleIndex]);
    }
  }]);
  return TraceListener;
}();
__decorate([Decorators_1.Override], TraceListener.prototype, "enterEveryRule", null);
__decorate([Decorators_1.Override], TraceListener.prototype, "exitEveryRule", null);
__decorate([Decorators_1.Override], TraceListener.prototype, "visitErrorNode", null);
__decorate([Decorators_1.Override], TraceListener.prototype, "visitTerminal", null);
/** This is all the parsing support code essentially; most of it is error recovery stuff. */
var Parser = /*#__PURE__*/function (_Recognizer_1$Recogni) {
  (0, _inherits2.default)(Parser, _Recognizer_1$Recogni);
  var _super = _createSuper(Parser);
  function Parser(input) {
    var _this;
    (0, _classCallCheck2.default)(this, Parser);
    _this = _super.call(this);
    /**
     * The error handling strategy for the parser. The default value is a new
     * instance of {@link DefaultErrorStrategy}.
     *
     * @see #getErrorHandler
     * @see #setErrorHandler
     */
    _this._errHandler = new DefaultErrorStrategy_1.DefaultErrorStrategy();
    _this._precedenceStack = new IntegerStack_1.IntegerStack();
    /**
     * Specifies whether or not the parser should construct a parse tree during
     * the parsing process. The default value is `true`.
     *
     * @see `buildParseTree`
     */
    _this._buildParseTrees = true;
    /**
     * The list of {@link ParseTreeListener} listeners registered to receive
     * events during the parse.
     *
     * @see #addParseListener
     */
    _this._parseListeners = [];
    /**
     * The number of syntax errors reported during parsing. This value is
     * incremented each time {@link #notifyErrorListeners} is called.
     */
    _this._syntaxErrors = 0;
    /** Indicates parser has match()ed EOF token. See {@link #exitRule()}. */
    _this.matchedEOF = false;
    _this._precedenceStack.push(0);
    _this.inputStream = input;
    return _this;
  }
  (0, _createClass2.default)(Parser, [{
    key: "reset",
    value: function reset(resetInput) {
      // Note: this method executes when not parsing, so _ctx can be undefined
      if (resetInput === undefined || resetInput) {
        this.inputStream.seek(0);
      }
      this._errHandler.reset(this);
      this._ctx = undefined;
      this._syntaxErrors = 0;
      this.matchedEOF = false;
      this.isTrace = false;
      this._precedenceStack.clear();
      this._precedenceStack.push(0);
      var interpreter = this.interpreter;
      if (interpreter != null) {
        interpreter.reset();
      }
    }
    /**
     * Match current input symbol against `ttype`. If the symbol type
     * matches, {@link ANTLRErrorStrategy#reportMatch} and {@link #consume} are
     * called to complete the match process.
     *
     * If the symbol type does not match,
     * {@link ANTLRErrorStrategy#recoverInline} is called on the current error
     * strategy to attempt recovery. If {@link #getBuildParseTree} is
     * `true` and the token index of the symbol returned by
     * {@link ANTLRErrorStrategy#recoverInline} is -1, the symbol is added to
     * the parse tree by calling {@link #createErrorNode(ParserRuleContext, Token)} then
     * {@link ParserRuleContext#addErrorNode(ErrorNode)}.
     *
     * @param ttype the token type to match
     * @returns the matched symbol
     * @ if the current input symbol did not match
     * `ttype` and the error strategy could not recover from the
     * mismatched symbol
     */
  }, {
    key: "match",
    value: function match(ttype) {
      var t = this.currentToken;
      if (t.type === ttype) {
        if (ttype === Token_1.Token.EOF) {
          this.matchedEOF = true;
        }
        this._errHandler.reportMatch(this);
        this.consume();
      } else {
        t = this._errHandler.recoverInline(this);
        if (this._buildParseTrees && t.tokenIndex === -1) {
          // we must have conjured up a new token during single token insertion
          // if it's not the current symbol
          this._ctx.addErrorNode(this.createErrorNode(this._ctx, t));
        }
      }
      return t;
    }
    /**
     * Match current input symbol as a wildcard. If the symbol type matches
     * (i.e. has a value greater than 0), {@link ANTLRErrorStrategy#reportMatch}
     * and {@link #consume} are called to complete the match process.
     *
     * If the symbol type does not match,
     * {@link ANTLRErrorStrategy#recoverInline} is called on the current error
     * strategy to attempt recovery. If {@link #getBuildParseTree} is
     * `true` and the token index of the symbol returned by
     * {@link ANTLRErrorStrategy#recoverInline} is -1, the symbol is added to
     * the parse tree by calling {@link Parser#createErrorNode(ParserRuleContext, Token)} then
     * {@link ParserRuleContext#addErrorNode(ErrorNode)}.
     *
     * @returns the matched symbol
     * @ if the current input symbol did not match
     * a wildcard and the error strategy could not recover from the mismatched
     * symbol
     */
  }, {
    key: "matchWildcard",
    value: function matchWildcard() {
      var t = this.currentToken;
      if (t.type > 0) {
        this._errHandler.reportMatch(this);
        this.consume();
      } else {
        t = this._errHandler.recoverInline(this);
        if (this._buildParseTrees && t.tokenIndex === -1) {
          // we must have conjured up a new token during single token insertion
          // if it's not the current symbol
          this._ctx.addErrorNode(this.createErrorNode(this._ctx, t));
        }
      }
      return t;
    }
    /**
     * Track the {@link ParserRuleContext} objects during the parse and hook
     * them up using the {@link ParserRuleContext#children} list so that it
     * forms a parse tree. The {@link ParserRuleContext} returned from the start
     * rule represents the root of the parse tree.
     *
     * Note that if we are not building parse trees, rule contexts only point
     * upwards. When a rule exits, it returns the context but that gets garbage
     * collected if nobody holds a reference. It points upwards but nobody
     * points at it.
     *
     * When we build parse trees, we are adding all of these contexts to
     * {@link ParserRuleContext#children} list. Contexts are then not candidates
     * for garbage collection.
     */
  }, {
    key: "buildParseTree",
    get:
    /**
     * Gets whether or not a complete parse tree will be constructed while
     * parsing. This property is `true` for a newly constructed parser.
     *
     * @returns `true` if a complete parse tree will be constructed while
     * parsing, otherwise `false`
     */
    function get() {
      return this._buildParseTrees;
    },
    set: function set(buildParseTrees) {
      this._buildParseTrees = buildParseTrees;
    }
  }, {
    key: "getParseListeners",
    value: function getParseListeners() {
      return this._parseListeners;
    }
    /**
     * Registers `listener` to receive events during the parsing process.
     *
     * To support output-preserving grammar transformations (including but not
     * limited to left-recursion removal, automated left-factoring, and
     * optimized code generation), calls to listener methods during the parse
     * may differ substantially from calls made by
     * {@link ParseTreeWalker#DEFAULT} used after the parse is complete. In
     * particular, rule entry and exit events may occur in a different order
     * during the parse than after the parser. In addition, calls to certain
     * rule entry methods may be omitted.
     *
     * With the following specific exceptions, calls to listener events are
     * *deterministic*, i.e. for identical input the calls to listener
     * methods will be the same.
     *
     * * Alterations to the grammar used to generate code may change the
     *   behavior of the listener calls.
     * * Alterations to the command line options passed to ANTLR 4 when
     *   generating the parser may change the behavior of the listener calls.
     * * Changing the version of the ANTLR Tool used to generate the parser
     *   may change the behavior of the listener calls.
     *
     * @param listener the listener to add
     *
     * @throws {@link TypeError} if `listener` is `undefined`
     */
  }, {
    key: "addParseListener",
    value: function addParseListener(listener) {
      if (listener == null) {
        throw new TypeError("listener cannot be null");
      }
      this._parseListeners.push(listener);
    }
    /**
     * Remove `listener` from the list of parse listeners.
     *
     * If `listener` is `undefined` or has not been added as a parse
     * listener, this method does nothing.
     *
     * @see #addParseListener
     *
     * @param listener the listener to remove
     */
  }, {
    key: "removeParseListener",
    value: function removeParseListener(listener) {
      var index = this._parseListeners.findIndex(function (l) {
        return l === listener;
      });
      if (index !== -1) {
        this._parseListeners.splice(index, 1);
      }
    }
    /**
     * Remove all parse listeners.
     *
     * @see #addParseListener
     */
  }, {
    key: "removeParseListeners",
    value: function removeParseListeners() {
      this._parseListeners.length = 0;
    }
    /**
     * Notify any parse listeners of an enter rule event.
     *
     * @see #addParseListener
     */
  }, {
    key: "triggerEnterRuleEvent",
    value: function triggerEnterRuleEvent() {
      var _iterator = _createForOfIteratorHelper(this._parseListeners),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var listener = _step.value;
          if (listener.enterEveryRule) {
            listener.enterEveryRule(this._ctx);
          }
          this._ctx.enterRule(listener);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * Notify any parse listeners of an exit rule event.
     *
     * @see #addParseListener
     */
  }, {
    key: "triggerExitRuleEvent",
    value: function triggerExitRuleEvent() {
      // reverse order walk of listeners
      for (var i = this._parseListeners.length - 1; i >= 0; i--) {
        var listener = this._parseListeners[i];
        this._ctx.exitRule(listener);
        if (listener.exitEveryRule) {
          listener.exitEveryRule(this._ctx);
        }
      }
    }
    /**
     * Gets the number of syntax errors reported during parsing. This value is
     * incremented each time {@link #notifyErrorListeners} is called.
     *
     * @see #notifyErrorListeners
     */
  }, {
    key: "numberOfSyntaxErrors",
    get: function get() {
      return this._syntaxErrors;
    }
  }, {
    key: "tokenFactory",
    get: function get() {
      return this._input.tokenSource.tokenFactory;
    }
    /**
     * The ATN with bypass alternatives is expensive to create so we create it
     * lazily.
     *
     * @ if the current parser does not
     * implement the `serializedATN` property.
     */
  }, {
    key: "getATNWithBypassAlts",
    value: function getATNWithBypassAlts() {
      var serializedAtn = this.serializedATN;
      if (serializedAtn == null) {
        throw new Error("The current parser does not support an ATN with bypass alternatives.");
      }
      var result = Parser.bypassAltsAtnCache.get(serializedAtn);
      if (result == null) {
        var deserializationOptions = new ATNDeserializationOptions_1.ATNDeserializationOptions();
        deserializationOptions.isGenerateRuleBypassTransitions = true;
        result = new ATNDeserializer_1.ATNDeserializer(deserializationOptions).deserialize(Utils.toCharArray(serializedAtn));
        Parser.bypassAltsAtnCache.set(serializedAtn, result);
      }
      return result;
    }
  }, {
    key: "compileParseTreePattern",
    value: function compileParseTreePattern(pattern, patternRuleIndex, lexer) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator.default.mark(function _callee() {
        var tokenSource, currentLexer, m, matcher;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (lexer) {
                _context.next = 4;
                break;
              }
              if (this.inputStream) {
                tokenSource = this.inputStream.tokenSource;
                if (tokenSource instanceof Lexer_1.Lexer) {
                  lexer = tokenSource;
                }
              }
              if (lexer) {
                _context.next = 4;
                break;
              }
              throw new Error("Parser can't discover a lexer to use");
            case 4:
              currentLexer = lexer;
              _context.next = 7;
              return Promise.resolve().then(function () {
                return require("./tree/pattern/ParseTreePatternMatcher");
              });
            case 7:
              m = _context.sent;
              matcher = new m.ParseTreePatternMatcher(currentLexer, this);
              return _context.abrupt("return", matcher.compile(pattern, patternRuleIndex));
            case 10:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
    }
  }, {
    key: "errorHandler",
    get: function get() {
      return this._errHandler;
    },
    set: function set(handler) {
      this._errHandler = handler;
    }
  }, {
    key: "inputStream",
    get: function get() {
      return this._input;
    }
    /** Set the token stream and reset the parser. */,
    set: function set(input) {
      this.reset(false);
      this._input = input;
    }
    /** Match needs to return the current input symbol, which gets put
     *  into the label for the associated token ref; e.g., x=ID.
     */
  }, {
    key: "currentToken",
    get: function get() {
      return this._input.LT(1);
    }
  }, {
    key: "notifyErrorListeners",
    value: function notifyErrorListeners(msg, offendingToken, e) {
      if (offendingToken === undefined) {
        offendingToken = this.currentToken;
      } else if (offendingToken === null) {
        offendingToken = undefined;
      }
      this._syntaxErrors++;
      var line = -1;
      var charPositionInLine = -1;
      if (offendingToken != null) {
        line = offendingToken.line;
        charPositionInLine = offendingToken.charPositionInLine;
      }
      var listener = this.getErrorListenerDispatch();
      if (listener.syntaxError) {
        listener.syntaxError(this, offendingToken, line, charPositionInLine, msg, e);
      }
    }
    /**
     * Consume and return the [current symbol](`currentToken`).
     *
     * E.g., given the following input with `A` being the current
     * lookahead symbol, this function moves the cursor to `B` and returns
     * `A`.
     *
     * ```
     * A B
     * ^
     * ```
     *
     * If the parser is not in error recovery mode, the consumed symbol is added
     * to the parse tree using {@link ParserRuleContext#addChild(TerminalNode)}, and
     * {@link ParseTreeListener#visitTerminal} is called on any parse listeners.
     * If the parser *is* in error recovery mode, the consumed symbol is
     * added to the parse tree using {@link #createErrorNode(ParserRuleContext, Token)} then
     * {@link ParserRuleContext#addErrorNode(ErrorNode)} and
     * {@link ParseTreeListener#visitErrorNode} is called on any parse
     * listeners.
     */
  }, {
    key: "consume",
    value: function consume() {
      var o = this.currentToken;
      if (o.type !== Parser.EOF) {
        this.inputStream.consume();
      }
      var hasListener = this._parseListeners.length !== 0;
      if (this._buildParseTrees || hasListener) {
        if (this._errHandler.inErrorRecoveryMode(this)) {
          var node = this._ctx.addErrorNode(this.createErrorNode(this._ctx, o));
          if (hasListener) {
            var _iterator2 = _createForOfIteratorHelper(this._parseListeners),
              _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var listener = _step2.value;
                if (listener.visitErrorNode) {
                  listener.visitErrorNode(node);
                }
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }
        } else {
          var _node = this.createTerminalNode(this._ctx, o);
          this._ctx.addChild(_node);
          if (hasListener) {
            var _iterator3 = _createForOfIteratorHelper(this._parseListeners),
              _step3;
            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var _listener = _step3.value;
                if (_listener.visitTerminal) {
                  _listener.visitTerminal(_node);
                }
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          }
        }
      }
      return o;
    }
    /**
     * How to create a token leaf node associated with a parent.
     * Typically, the terminal node to create is not a function of the parent.
     *
     * @since 4.7
     */
  }, {
    key: "createTerminalNode",
    value: function createTerminalNode(parent, t) {
      return new TerminalNode_1.TerminalNode(t);
    }
    /**
     * How to create an error node, given a token, associated with a parent.
     * Typically, the error node to create is not a function of the parent.
     *
     * @since 4.7
     */
  }, {
    key: "createErrorNode",
    value: function createErrorNode(parent, t) {
      return new ErrorNode_1.ErrorNode(t);
    }
  }, {
    key: "addContextToParseTree",
    value: function addContextToParseTree() {
      var parent = this._ctx._parent;
      // add current context to parent if we have a parent
      if (parent != null) {
        parent.addChild(this._ctx);
      }
    }
    /**
     * Always called by generated parsers upon entry to a rule. Access field
     * {@link #_ctx} get the current context.
     */
  }, {
    key: "enterRule",
    value: function enterRule(localctx, state, ruleIndex) {
      this.state = state;
      this._ctx = localctx;
      this._ctx._start = this._input.LT(1);
      if (this._buildParseTrees) {
        this.addContextToParseTree();
      }
      this.triggerEnterRuleEvent();
    }
  }, {
    key: "enterLeftFactoredRule",
    value: function enterLeftFactoredRule(localctx, state, ruleIndex) {
      this.state = state;
      if (this._buildParseTrees) {
        var factoredContext = this._ctx.getChild(this._ctx.childCount - 1);
        this._ctx.removeLastChild();
        factoredContext._parent = localctx;
        localctx.addChild(factoredContext);
      }
      this._ctx = localctx;
      this._ctx._start = this._input.LT(1);
      if (this._buildParseTrees) {
        this.addContextToParseTree();
      }
      this.triggerEnterRuleEvent();
    }
  }, {
    key: "exitRule",
    value: function exitRule() {
      if (this.matchedEOF) {
        // if we have matched EOF, it cannot consume past EOF so we use LT(1) here
        this._ctx._stop = this._input.LT(1); // LT(1) will be end of file
      } else {
        this._ctx._stop = this._input.tryLT(-1); // stop node is what we just matched
      }
      // trigger event on _ctx, before it reverts to parent
      this.triggerExitRuleEvent();
      this.state = this._ctx.invokingState;
      this._ctx = this._ctx._parent;
    }
  }, {
    key: "enterOuterAlt",
    value: function enterOuterAlt(localctx, altNum) {
      localctx.altNumber = altNum;
      // if we have new localctx, make sure we replace existing ctx
      // that is previous child of parse tree
      if (this._buildParseTrees && this._ctx !== localctx) {
        var parent = this._ctx._parent;
        if (parent != null) {
          parent.removeLastChild();
          parent.addChild(localctx);
        }
      }
      this._ctx = localctx;
    }
    /**
     * Get the precedence level for the top-most precedence rule.
     *
     * @returns The precedence level for the top-most precedence rule, or -1 if
     * the parser context is not nested within a precedence rule.
     */
  }, {
    key: "precedence",
    get: function get() {
      if (this._precedenceStack.isEmpty) {
        return -1;
      }
      return this._precedenceStack.peek();
    }
  }, {
    key: "enterRecursionRule",
    value: function enterRecursionRule(localctx, state, ruleIndex, precedence) {
      this.state = state;
      this._precedenceStack.push(precedence);
      this._ctx = localctx;
      this._ctx._start = this._input.LT(1);
      this.triggerEnterRuleEvent(); // simulates rule entry for left-recursive rules
    }
    /** Like {@link #enterRule} but for recursive rules.
     *  Make the current context the child of the incoming localctx.
     */
  }, {
    key: "pushNewRecursionContext",
    value: function pushNewRecursionContext(localctx, state, ruleIndex) {
      var previous = this._ctx;
      previous._parent = localctx;
      previous.invokingState = state;
      previous._stop = this._input.tryLT(-1);
      this._ctx = localctx;
      this._ctx._start = previous._start;
      if (this._buildParseTrees) {
        this._ctx.addChild(previous);
      }
      this.triggerEnterRuleEvent(); // simulates rule entry for left-recursive rules
    }
  }, {
    key: "unrollRecursionContexts",
    value: function unrollRecursionContexts(_parentctx) {
      this._precedenceStack.pop();
      this._ctx._stop = this._input.tryLT(-1);
      var retctx = this._ctx; // save current ctx (return value)
      // unroll so _ctx is as it was before call to recursive method
      if (this._parseListeners.length > 0) {
        while (this._ctx !== _parentctx) {
          this.triggerExitRuleEvent();
          this._ctx = this._ctx._parent;
        }
      } else {
        this._ctx = _parentctx;
      }
      // hook into tree
      retctx._parent = _parentctx;
      if (this._buildParseTrees && _parentctx != null) {
        // add return ctx into invoking rule's tree
        _parentctx.addChild(retctx);
      }
    }
  }, {
    key: "getInvokingContext",
    value: function getInvokingContext(ruleIndex) {
      var p = this._ctx;
      while (p && p.ruleIndex !== ruleIndex) {
        p = p._parent;
      }
      return p;
    }
  }, {
    key: "context",
    get: function get() {
      return this._ctx;
    },
    set: function set(ctx) {
      this._ctx = ctx;
    }
  }, {
    key: "precpred",
    value: function precpred(localctx, precedence) {
      return precedence >= this._precedenceStack.peek();
    }
  }, {
    key: "getErrorListenerDispatch",
    value: function getErrorListenerDispatch() {
      return new ProxyParserErrorListener_1.ProxyParserErrorListener(this.getErrorListeners());
    }
  }, {
    key: "inContext",
    value: function inContext(context) {
      // TODO: useful in parser?
      return false;
    }
    /**
     * Checks whether or not `symbol` can follow the current state in the
     * ATN. The behavior of this method is equivalent to the following, but is
     * implemented such that the complete context-sensitive follow set does not
     * need to be explicitly constructed.
     *
     * ```
     * return getExpectedTokens().contains(symbol);
     * ```
     *
     * @param symbol the symbol type to check
     * @returns `true` if `symbol` can follow the current state in
     * the ATN, otherwise `false`.
     */
  }, {
    key: "isExpectedToken",
    value: function isExpectedToken(symbol) {
      //   		return interpreter.atn.nextTokens(_ctx);
      var atn = this.interpreter.atn;
      var ctx = this._ctx;
      var s = atn.states[this.state];
      var following = atn.nextTokens(s);
      if (following.contains(symbol)) {
        return true;
      }
      //        System.out.println("following "+s+"="+following);
      if (!following.contains(Token_1.Token.EPSILON)) {
        return false;
      }
      while (ctx != null && ctx.invokingState >= 0 && following.contains(Token_1.Token.EPSILON)) {
        var invokingState = atn.states[ctx.invokingState];
        var rt = invokingState.transition(0);
        following = atn.nextTokens(rt.followState);
        if (following.contains(symbol)) {
          return true;
        }
        ctx = ctx._parent;
      }
      if (following.contains(Token_1.Token.EPSILON) && symbol === Token_1.Token.EOF) {
        return true;
      }
      return false;
    }
  }, {
    key: "isMatchedEOF",
    get: function get() {
      return this.matchedEOF;
    }
    /**
     * Computes the set of input symbols which could follow the current parser
     * state and context, as given by {@link #getState} and {@link #getContext},
     * respectively.
     *
     * @see ATN#getExpectedTokens(int, RuleContext)
     */
  }, {
    key: "getExpectedTokens",
    value: function getExpectedTokens() {
      return this.atn.getExpectedTokens(this.state, this.context);
    }
  }, {
    key: "getExpectedTokensWithinCurrentRule",
    value: function getExpectedTokensWithinCurrentRule() {
      var atn = this.interpreter.atn;
      var s = atn.states[this.state];
      return atn.nextTokens(s);
    }
    /** Get a rule's index (i.e., `RULE_ruleName` field) or -1 if not found. */
  }, {
    key: "getRuleIndex",
    value: function getRuleIndex(ruleName) {
      var ruleIndex = this.getRuleIndexMap().get(ruleName);
      if (ruleIndex != null) {
        return ruleIndex;
      }
      return -1;
    }
  }, {
    key: "ruleContext",
    get: function get() {
      return this._ctx;
    }
    /** Return List&lt;String&gt; of the rule names in your parser instance
     *  leading up to a call to the current rule.  You could override if
     *  you want more details such as the file/line info of where
     *  in the ATN a rule is invoked.
     *
     *  This is very useful for error messages.
     */
  }, {
    key: "getRuleInvocationStack",
    value: function getRuleInvocationStack() {
      var ctx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._ctx;
      var p = ctx; // Workaround for Microsoft/TypeScript#14487
      var ruleNames = this.ruleNames;
      var stack = [];
      while (p != null) {
        // compute what follows who invoked us
        var ruleIndex = p.ruleIndex;
        if (ruleIndex < 0) {
          stack.push("n/a");
        } else {
          stack.push(ruleNames[ruleIndex]);
        }
        p = p._parent;
      }
      return stack;
    }
    /** For debugging and other purposes. */
  }, {
    key: "getDFAStrings",
    value: function getDFAStrings() {
      var s = [];
      var _iterator4 = _createForOfIteratorHelper(this._interp.atn.decisionToDFA),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var dfa = _step4.value;
          s.push(dfa.toString(this.vocabulary, this.ruleNames));
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      return s;
    }
    /** For debugging and other purposes. */
  }, {
    key: "dumpDFA",
    value: function dumpDFA() {
      var seenOne = false;
      var _iterator5 = _createForOfIteratorHelper(this._interp.atn.decisionToDFA),
        _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var dfa = _step5.value;
          if (!dfa.isEmpty) {
            if (seenOne) {
              console.log();
            }
            console.log("Decision " + dfa.decision + ":");
            process.stdout.write(dfa.toString(this.vocabulary, this.ruleNames));
            seenOne = true;
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
    }
  }, {
    key: "sourceName",
    get: function get() {
      return this._input.sourceName;
    }
  }, {
    key: "parseInfo",
    get: function get() {
      var _this2 = this;
      return Promise.resolve().then(function () {
        return require("./atn/ProfilingATNSimulator");
      }).then(function (m) {
        var interp = _this2.interpreter;
        if (interp instanceof m.ProfilingATNSimulator) {
          return new ParseInfo_1.ParseInfo(interp);
        }
        return undefined;
      });
    }
    /**
     * @since 4.3
     */
  }, {
    key: "setProfile",
    value: function setProfile(profile) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator.default.mark(function _callee2() {
        var m, interp;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return Promise.resolve().then(function () {
                return require("./atn/ProfilingATNSimulator");
              });
            case 2:
              m = _context2.sent;
              interp = this.interpreter;
              if (profile) {
                if (!(interp instanceof m.ProfilingATNSimulator)) {
                  this.interpreter = new m.ProfilingATNSimulator(this);
                }
              } else if (interp instanceof m.ProfilingATNSimulator) {
                this.interpreter = new ParserATNSimulator_1.ParserATNSimulator(this.atn, this);
              }
              this.interpreter.setPredictionMode(interp.getPredictionMode());
            case 6:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
    }
    /** During a parse is sometimes useful to listen in on the rule entry and exit
     *  events as well as token matches. This is for quick and dirty debugging.
     */
  }, {
    key: "isTrace",
    get:
    /**
     * Gets whether a {@link TraceListener} is registered as a parse listener
     * for the parser.
     */
    function get() {
      return this._tracer != null;
    },
    set: function set(trace) {
      if (!trace) {
        if (this._tracer) {
          this.removeParseListener(this._tracer);
          this._tracer = undefined;
        }
      } else {
        if (this._tracer) {
          this.removeParseListener(this._tracer);
        } else {
          this._tracer = new TraceListener(this.ruleNames, this._input);
        }
        this.addParseListener(this._tracer);
      }
    }
  }]);
  return Parser;
}(Recognizer_1.Recognizer);
/**
 * This field maps from the serialized ATN string to the deserialized {@link ATN} with
 * bypass alternatives.
 *
 * @see ATNDeserializationOptions.isGenerateRuleBypassTransitions
 */
Parser.bypassAltsAtnCache = new Map();
__decorate([Decorators_1.NotNull], Parser.prototype, "_errHandler", void 0);
__decorate([Decorators_1.NotNull], Parser.prototype, "match", null);
__decorate([Decorators_1.NotNull], Parser.prototype, "matchWildcard", null);
__decorate([Decorators_1.NotNull], Parser.prototype, "getParseListeners", null);
__decorate([__param(0, Decorators_1.NotNull)], Parser.prototype, "addParseListener", null);
__decorate([Decorators_1.NotNull], Parser.prototype, "getATNWithBypassAlts", null);
__decorate([Decorators_1.NotNull, __param(0, Decorators_1.NotNull)], Parser.prototype, "errorHandler", null);
__decorate([Decorators_1.Override], Parser.prototype, "inputStream", null);
__decorate([Decorators_1.NotNull], Parser.prototype, "currentToken", null);
__decorate([__param(0, Decorators_1.NotNull)], Parser.prototype, "enterRule", null);
__decorate([Decorators_1.Override, __param(0, Decorators_1.Nullable)], Parser.prototype, "precpred", null);
__decorate([Decorators_1.Override], Parser.prototype, "getErrorListenerDispatch", null);
__decorate([Decorators_1.NotNull], Parser.prototype, "getExpectedTokens", null);
__decorate([Decorators_1.NotNull], Parser.prototype, "getExpectedTokensWithinCurrentRule", null);
__decorate([Decorators_1.Override], Parser.prototype, "parseInfo", null);
exports.Parser = Parser;

}).call(this)}).call(this,require('_process'))

},{"./Decorators":272,"./DefaultErrorStrategy":273,"./Lexer":280,"./ProxyParserErrorListener":289,"./Recognizer":291,"./Token":296,"./atn/ATNDeserializationOptions":302,"./atn/ATNDeserializer":303,"./atn/ParseInfo":339,"./atn/ParserATNSimulator":340,"./atn/ProfilingATNSimulator":349,"./misc/IntegerStack":377,"./misc/Utils":385,"./tree/ErrorNode":387,"./tree/TerminalNode":391,"./tree/pattern/ParseTreePatternMatcher":397,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"@babel/runtime/regenerator":255,"_process":732,"core-js/modules/es.array.find-index.js":573,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.array.splice.js":582,"core-js/modules/es.function.name.js":584,"core-js/modules/es.map.js":587,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.promise.js":614,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],286:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.match.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var ATNState_1 = require("./atn/ATNState");
var ATNStateType_1 = require("./atn/ATNStateType");
var BitSet_1 = require("./misc/BitSet");
var FailedPredicateException_1 = require("./FailedPredicateException");
var InputMismatchException_1 = require("./InputMismatchException");
var InterpreterRuleContext_1 = require("./InterpreterRuleContext");
var LoopEndState_1 = require("./atn/LoopEndState");
var Decorators_1 = require("./Decorators");
var Decorators_2 = require("./Decorators");
var Parser_1 = require("./Parser");
var ParserATNSimulator_1 = require("./atn/ParserATNSimulator");
var RecognitionException_1 = require("./RecognitionException");
var StarLoopEntryState_1 = require("./atn/StarLoopEntryState");
var Token_1 = require("./Token");
/** A parser simulator that mimics what ANTLR's generated
 *  parser code does. A ParserATNSimulator is used to make
 *  predictions via adaptivePredict but this class moves a pointer through the
 *  ATN to simulate parsing. ParserATNSimulator just
 *  makes us efficient rather than having to backtrack, for example.
 *
 *  This properly creates parse trees even for left recursive rules.
 *
 *  We rely on the left recursive rule invocation and special predicate
 *  transitions to make left recursive rules work.
 *
 *  See TestParserInterpreter for examples.
 */
var ParserInterpreter = /*#__PURE__*/function (_Parser_1$Parser) {
  (0, _inherits2.default)(ParserInterpreter, _Parser_1$Parser);
  var _super = _createSuper(ParserInterpreter);
  function ParserInterpreter(grammarFileName, vocabulary, ruleNames, atn, input) {
    var _this;
    (0, _classCallCheck2.default)(this, ParserInterpreter);
    _this = _super.call(this, grammarFileName instanceof ParserInterpreter ? grammarFileName.inputStream : input);
    /** This stack corresponds to the _parentctx, _parentState pair of locals
     *  that would exist on call stack frames with a recursive descent parser;
     *  in the generated function for a left-recursive rule you'd see:
     *
     *  private EContext e(int _p) {
     *      ParserRuleContext _parentctx = _ctx;    // Pair.a
     *      int _parentState = state;          // Pair.b
     *      ...
     *  }
     *
     *  Those values are used to create new recursive rule invocation contexts
     *  associated with left operand of an alt like "expr '*' expr".
     */
    _this._parentContextStack = [];
    /** We need a map from (decision,inputIndex)->forced alt for computing ambiguous
     *  parse trees. For now, we allow exactly one override.
     */
    _this.overrideDecision = -1;
    _this.overrideDecisionInputIndex = -1;
    _this.overrideDecisionAlt = -1;
    _this.overrideDecisionReached = false; // latch and only override once; error might trigger infinite loop
    /** What is the current context when we override a decisions?  This tells
     *  us what the root of the parse tree is when using override
     *  for an ambiguity/lookahead check.
     */
    _this._overrideDecisionRoot = undefined;
    if (grammarFileName instanceof ParserInterpreter) {
      var old = grammarFileName;
      _this._grammarFileName = old._grammarFileName;
      _this._atn = old._atn;
      _this.pushRecursionContextStates = old.pushRecursionContextStates;
      _this._ruleNames = old._ruleNames;
      _this._vocabulary = old._vocabulary;
      _this.interpreter = new ParserATNSimulator_1.ParserATNSimulator(_this._atn, (0, _assertThisInitialized2.default)(_this));
    } else {
      // The second constructor requires non-null arguments
      vocabulary = vocabulary;
      ruleNames = ruleNames;
      atn = atn;
      _this._grammarFileName = grammarFileName;
      _this._atn = atn;
      _this._ruleNames = ruleNames.slice(0);
      _this._vocabulary = vocabulary;
      // identify the ATN states where pushNewRecursionContext() must be called
      _this.pushRecursionContextStates = new BitSet_1.BitSet(atn.states.length);
      var _iterator = _createForOfIteratorHelper(atn.states),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var state = _step.value;
          if (!(state instanceof StarLoopEntryState_1.StarLoopEntryState)) {
            continue;
          }
          if (state.precedenceRuleDecision) {
            _this.pushRecursionContextStates.set(state.stateNumber);
          }
        }
        // get atn simulator that knows how to do predictions
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      _this.interpreter = new ParserATNSimulator_1.ParserATNSimulator(atn, (0, _assertThisInitialized2.default)(_this));
    }
    return _this;
  }
  (0, _createClass2.default)(ParserInterpreter, [{
    key: "reset",
    value: function reset(resetInput) {
      if (resetInput === undefined) {
        (0, _get2.default)((0, _getPrototypeOf2.default)(ParserInterpreter.prototype), "reset", this).call(this);
      } else {
        (0, _get2.default)((0, _getPrototypeOf2.default)(ParserInterpreter.prototype), "reset", this).call(this, resetInput);
      }
      this.overrideDecisionReached = false;
      this._overrideDecisionRoot = undefined;
    }
  }, {
    key: "atn",
    get: function get() {
      return this._atn;
    }
  }, {
    key: "vocabulary",
    get: function get() {
      return this._vocabulary;
    }
  }, {
    key: "ruleNames",
    get: function get() {
      return this._ruleNames;
    }
  }, {
    key: "grammarFileName",
    get: function get() {
      return this._grammarFileName;
    }
    /** Begin parsing at startRuleIndex */
  }, {
    key: "parse",
    value: function parse(startRuleIndex) {
      var startRuleStartState = this._atn.ruleToStartState[startRuleIndex];
      this._rootContext = this.createInterpreterRuleContext(undefined, ATNState_1.ATNState.INVALID_STATE_NUMBER, startRuleIndex);
      if (startRuleStartState.isPrecedenceRule) {
        this.enterRecursionRule(this._rootContext, startRuleStartState.stateNumber, startRuleIndex, 0);
      } else {
        this.enterRule(this._rootContext, startRuleStartState.stateNumber, startRuleIndex);
      }
      while (true) {
        var p = this.atnState;
        switch (p.stateType) {
          case ATNStateType_1.ATNStateType.RULE_STOP:
            // pop; return from rule
            if (this._ctx.isEmpty) {
              if (startRuleStartState.isPrecedenceRule) {
                var result = this._ctx;
                var parentContext = this._parentContextStack.pop();
                this.unrollRecursionContexts(parentContext[0]);
                return result;
              } else {
                this.exitRule();
                return this._rootContext;
              }
            }
            this.visitRuleStopState(p);
            break;
          default:
            try {
              this.visitState(p);
            } catch (e) {
              if (e instanceof RecognitionException_1.RecognitionException) {
                this.state = this._atn.ruleToStopState[p.ruleIndex].stateNumber;
                this.context.exception = e;
                this.errorHandler.reportError(this, e);
                this.recover(e);
              } else {
                throw e;
              }
            }
            break;
        }
      }
    }
  }, {
    key: "enterRecursionRule",
    value: function enterRecursionRule(localctx, state, ruleIndex, precedence) {
      this._parentContextStack.push([this._ctx, localctx.invokingState]);
      (0, _get2.default)((0, _getPrototypeOf2.default)(ParserInterpreter.prototype), "enterRecursionRule", this).call(this, localctx, state, ruleIndex, precedence);
    }
  }, {
    key: "atnState",
    get: function get() {
      return this._atn.states[this.state];
    }
  }, {
    key: "visitState",
    value: function visitState(p) {
      var predictedAlt = 1;
      if (p.numberOfTransitions > 1) {
        predictedAlt = this.visitDecisionState(p);
      }
      var transition = p.transition(predictedAlt - 1);
      switch (transition.serializationType) {
        case 1 /* EPSILON */:
          if (this.pushRecursionContextStates.get(p.stateNumber) && !(transition.target instanceof LoopEndState_1.LoopEndState)) {
            // We are at the start of a left recursive rule's (...)* loop
            // and we're not taking the exit branch of loop.
            var parentContext = this._parentContextStack[this._parentContextStack.length - 1];
            var localctx = this.createInterpreterRuleContext(parentContext[0], parentContext[1], this._ctx.ruleIndex);
            this.pushNewRecursionContext(localctx, this._atn.ruleToStartState[p.ruleIndex].stateNumber, this._ctx.ruleIndex);
          }
          break;
        case 5 /* ATOM */:
          this.match(transition._label);
          break;
        case 2 /* RANGE */:
        case 7 /* SET */:
        case 8 /* NOT_SET */:
          if (!transition.matches(this._input.LA(1), Token_1.Token.MIN_USER_TOKEN_TYPE, 65535)) {
            this.recoverInline();
          }
          this.matchWildcard();
          break;
        case 9 /* WILDCARD */:
          this.matchWildcard();
          break;
        case 3 /* RULE */:
          var ruleStartState = transition.target;
          var ruleIndex = ruleStartState.ruleIndex;
          var newctx = this.createInterpreterRuleContext(this._ctx, p.stateNumber, ruleIndex);
          if (ruleStartState.isPrecedenceRule) {
            this.enterRecursionRule(newctx, ruleStartState.stateNumber, ruleIndex, transition.precedence);
          } else {
            this.enterRule(newctx, transition.target.stateNumber, ruleIndex);
          }
          break;
        case 4 /* PREDICATE */:
          var predicateTransition = transition;
          if (!this.sempred(this._ctx, predicateTransition.ruleIndex, predicateTransition.predIndex)) {
            throw new FailedPredicateException_1.FailedPredicateException(this);
          }
          break;
        case 6 /* ACTION */:
          var actionTransition = transition;
          this.action(this._ctx, actionTransition.ruleIndex, actionTransition.actionIndex);
          break;
        case 10 /* PRECEDENCE */:
          if (!this.precpred(this._ctx, transition.precedence)) {
            var precedence = transition.precedence;
            throw new FailedPredicateException_1.FailedPredicateException(this, "precpred(_ctx, ".concat(precedence, ")"));
          }
          break;
        default:
          throw new Error("UnsupportedOperationException: Unrecognized ATN transition type.");
      }
      this.state = transition.target.stateNumber;
    }
    /** Method visitDecisionState() is called when the interpreter reaches
     *  a decision state (instance of DecisionState). It gives an opportunity
     *  for subclasses to track interesting things.
     */
  }, {
    key: "visitDecisionState",
    value: function visitDecisionState(p) {
      var predictedAlt;
      this.errorHandler.sync(this);
      var decision = p.decision;
      if (decision === this.overrideDecision && this._input.index === this.overrideDecisionInputIndex && !this.overrideDecisionReached) {
        predictedAlt = this.overrideDecisionAlt;
        this.overrideDecisionReached = true;
      } else {
        predictedAlt = this.interpreter.adaptivePredict(this._input, decision, this._ctx);
      }
      return predictedAlt;
    }
    /** Provide simple "factory" for InterpreterRuleContext's.
     *  @since 4.5.1
     */
  }, {
    key: "createInterpreterRuleContext",
    value: function createInterpreterRuleContext(parent, invokingStateNumber, ruleIndex) {
      return new InterpreterRuleContext_1.InterpreterRuleContext(ruleIndex, parent, invokingStateNumber);
    }
  }, {
    key: "visitRuleStopState",
    value: function visitRuleStopState(p) {
      var ruleStartState = this._atn.ruleToStartState[p.ruleIndex];
      if (ruleStartState.isPrecedenceRule) {
        var parentContext = this._parentContextStack.pop();
        this.unrollRecursionContexts(parentContext[0]);
        this.state = parentContext[1];
      } else {
        this.exitRule();
      }
      var ruleTransition = this._atn.states[this.state].transition(0);
      this.state = ruleTransition.followState.stateNumber;
    }
    /** Override this parser interpreters normal decision-making process
     *  at a particular decision and input token index. Instead of
     *  allowing the adaptive prediction mechanism to choose the
     *  first alternative within a block that leads to a successful parse,
     *  force it to take the alternative, 1..n for n alternatives.
     *
     *  As an implementation limitation right now, you can only specify one
     *  override. This is sufficient to allow construction of different
     *  parse trees for ambiguous input. It means re-parsing the entire input
     *  in general because you're never sure where an ambiguous sequence would
     *  live in the various parse trees. For example, in one interpretation,
     *  an ambiguous input sequence would be matched completely in expression
     *  but in another it could match all the way back to the root.
     *
     *  s : e '!'? ;
     *  e : ID
     *    | ID '!'
     *    ;
     *
     *  Here, x! can be matched as (s (e ID) !) or (s (e ID !)). In the first
     *  case, the ambiguous sequence is fully contained only by the root.
     *  In the second case, the ambiguous sequences fully contained within just
     *  e, as in: (e ID !).
     *
     *  Rather than trying to optimize this and make
     *  some intelligent decisions for optimization purposes, I settled on
     *  just re-parsing the whole input and then using
     *  {link Trees#getRootOfSubtreeEnclosingRegion} to find the minimal
     *  subtree that contains the ambiguous sequence. I originally tried to
     *  record the call stack at the point the parser detected and ambiguity but
     *  left recursive rules create a parse tree stack that does not reflect
     *  the actual call stack. That impedance mismatch was enough to make
     *  it it challenging to restart the parser at a deeply nested rule
     *  invocation.
     *
     *  Only parser interpreters can override decisions so as to avoid inserting
     *  override checking code in the critical ALL(*) prediction execution path.
     *
     *  @since 4.5
     */
  }, {
    key: "addDecisionOverride",
    value: function addDecisionOverride(decision, tokenIndex, forcedAlt) {
      this.overrideDecision = decision;
      this.overrideDecisionInputIndex = tokenIndex;
      this.overrideDecisionAlt = forcedAlt;
    }
  }, {
    key: "overrideDecisionRoot",
    get: function get() {
      return this._overrideDecisionRoot;
    }
    /** Rely on the error handler for this parser but, if no tokens are consumed
     *  to recover, add an error node. Otherwise, nothing is seen in the parse
     *  tree.
     */
  }, {
    key: "recover",
    value: function recover(e) {
      var i = this._input.index;
      this.errorHandler.recover(this, e);
      if (this._input.index === i) {
        // no input consumed, better add an error node
        var tok = e.getOffendingToken();
        if (!tok) {
          throw new Error("Expected exception to have an offending token");
        }
        var source = tok.tokenSource;
        var stream = source !== undefined ? source.inputStream : undefined;
        var sourcePair = {
          source: source,
          stream: stream
        };
        if (e instanceof InputMismatchException_1.InputMismatchException) {
          var expectedTokens = e.expectedTokens;
          if (expectedTokens === undefined) {
            throw new Error("Expected the exception to provide expected tokens");
          }
          var expectedTokenType = Token_1.Token.INVALID_TYPE;
          if (!expectedTokens.isNil) {
            // get any element
            expectedTokenType = expectedTokens.minElement;
          }
          var errToken = this.tokenFactory.create(sourcePair, expectedTokenType, tok.text, Token_1.Token.DEFAULT_CHANNEL, -1, -1,
          // invalid start/stop
          tok.line, tok.charPositionInLine);
          this._ctx.addErrorNode(this.createErrorNode(this._ctx, errToken));
        } else {
          // NoViableAlt
          var _source = tok.tokenSource;
          var _errToken = this.tokenFactory.create(sourcePair, Token_1.Token.INVALID_TYPE, tok.text, Token_1.Token.DEFAULT_CHANNEL, -1, -1,
          // invalid start/stop
          tok.line, tok.charPositionInLine);
          this._ctx.addErrorNode(this.createErrorNode(this._ctx, _errToken));
        }
      }
    }
  }, {
    key: "recoverInline",
    value: function recoverInline() {
      return this._errHandler.recoverInline(this);
    }
    /** Return the root of the parse, which can be useful if the parser
     *  bails out. You still can access the top node. Note that,
     *  because of the way left recursive rules add children, it's possible
     *  that the root will not have any children if the start rule immediately
     *  called and left recursive rule that fails.
     *
     * @since 4.5.1
     */
  }, {
    key: "rootContext",
    get: function get() {
      return this._rootContext;
    }
  }]);
  return ParserInterpreter;
}(Parser_1.Parser);
__decorate([Decorators_1.NotNull], ParserInterpreter.prototype, "_vocabulary", void 0);
__decorate([Decorators_2.Override], ParserInterpreter.prototype, "reset", null);
__decorate([Decorators_2.Override], ParserInterpreter.prototype, "atn", null);
__decorate([Decorators_2.Override], ParserInterpreter.prototype, "vocabulary", null);
__decorate([Decorators_2.Override], ParserInterpreter.prototype, "ruleNames", null);
__decorate([Decorators_2.Override], ParserInterpreter.prototype, "grammarFileName", null);
__decorate([Decorators_2.Override], ParserInterpreter.prototype, "enterRecursionRule", null);
ParserInterpreter = __decorate([__param(1, Decorators_1.NotNull)], ParserInterpreter);
exports.ParserInterpreter = ParserInterpreter;

},{"./Decorators":272,"./FailedPredicateException":276,"./InputMismatchException":277,"./InterpreterRuleContext":279,"./Parser":285,"./RecognitionException":290,"./Token":296,"./atn/ATNState":305,"./atn/ATNStateType":306,"./atn/LoopEndState":336,"./atn/ParserATNSimulator":340,"./atn/StarLoopEntryState":358,"./misc/BitSet":373,"@babel/runtime/helpers/assertThisInitialized":229,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/get":234,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.string.match.js":627,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],287:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:56.6285494-07:00
var ErrorNode_1 = require("./tree/ErrorNode");
var Interval_1 = require("./misc/Interval");
var Decorators_1 = require("./Decorators");
var RuleContext_1 = require("./RuleContext");
var TerminalNode_1 = require("./tree/TerminalNode");
/** A rule invocation record for parsing.
 *
 *  Contains all of the information about the current rule not stored in the
 *  RuleContext. It handles parse tree children list, Any ATN state
 *  tracing, and the default values available for rule invocations:
 *  start, stop, rule index, current alt number.
 *
 *  Subclasses made for each rule and grammar track the parameters,
 *  return values, locals, and labels specific to that rule. These
 *  are the objects that are returned from rules.
 *
 *  Note text is not an actual field of a rule return value; it is computed
 *  from start and stop using the input stream's toString() method.  I
 *  could add a ctor to this so that we can pass in and store the input
 *  stream, but I'm not sure we want to do that.  It would seem to be undefined
 *  to get the .text property anyway if the rule matches tokens from multiple
 *  input streams.
 *
 *  I do not use getters for fields of objects that are used simply to
 *  group values such as this aggregate.  The getters/setters are there to
 *  satisfy the superclass interface.
 */
var ParserRuleContext = /*#__PURE__*/function (_RuleContext_1$RuleCo) {
  (0, _inherits2.default)(ParserRuleContext, _RuleContext_1$RuleCo);
  var _super = _createSuper(ParserRuleContext);
  function ParserRuleContext(parent, invokingStateNumber) {
    var _this;
    (0, _classCallCheck2.default)(this, ParserRuleContext);
    if (invokingStateNumber == null) {
      _this = _super.call(this);
    } else {
      _this = _super.call(this, parent, invokingStateNumber);
    }
    return (0, _possibleConstructorReturn2.default)(_this);
  }
  (0, _createClass2.default)(ParserRuleContext, [{
    key: "copyFrom",
    value:
    /**
     * COPY a ctx (I'm deliberately not using copy constructor) to avoid
     * confusion with creating node with parent. Does not copy children
     * (except error leaves).
     *
     * This is used in the generated parser code to flip a generic XContext
     * node for rule X to a YContext for alt label Y. In that sense, it is not
     * really a generic copy function.
     *
     * If we do an error sync() at start of a rule, we might add error nodes
     * to the generic XContext so this function must copy those nodes to the
     * YContext as well else they are lost!
     */
    function copyFrom(ctx) {
      this._parent = ctx._parent;
      this.invokingState = ctx.invokingState;
      this._start = ctx._start;
      this._stop = ctx._stop;
      // copy any error nodes to alt label node
      if (ctx.children) {
        this.children = [];
        // reset parent pointer for any error nodes
        var _iterator = _createForOfIteratorHelper(ctx.children),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var child = _step.value;
            if (child instanceof ErrorNode_1.ErrorNode) {
              this.addChild(child);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }
    // Double dispatch methods for listeners
  }, {
    key: "enterRule",
    value: function enterRule(listener) {
      // intentionally empty
    }
  }, {
    key: "exitRule",
    value: function exitRule(listener) {
      // intentionally empty
    }
    /** Add a parse tree node to this as a child.  Works for
     *  internal and leaf nodes. Does not set parent link;
     *  other add methods must do that. Other addChild methods
     *  call this.
     *
     *  We cannot set the parent pointer of the incoming node
     *  because the existing interfaces do not have a setParent()
     *  method and I don't want to break backward compatibility for this.
     *
     *  @since 4.7
     */
  }, {
    key: "addAnyChild",
    value: function addAnyChild(t) {
      if (!this.children) {
        this.children = [t];
      } else {
        this.children.push(t);
      }
      return t;
    }
  }, {
    key: "addChild",
    value: function addChild(t) {
      var result;
      if (t instanceof TerminalNode_1.TerminalNode) {
        t.setParent(this);
        this.addAnyChild(t);
        return;
      } else if (t instanceof RuleContext_1.RuleContext) {
        // Does not set parent link
        this.addAnyChild(t);
        return;
      } else {
        // Deprecated code path
        t = new TerminalNode_1.TerminalNode(t);
        this.addAnyChild(t);
        t.setParent(this);
        return t;
      }
    }
  }, {
    key: "addErrorNode",
    value: function addErrorNode(node) {
      if (node instanceof ErrorNode_1.ErrorNode) {
        var errorNode = node;
        errorNode.setParent(this);
        return this.addAnyChild(errorNode);
      } else {
        // deprecated path
        var badToken = node;
        var t = new ErrorNode_1.ErrorNode(badToken);
        this.addAnyChild(t);
        t.setParent(this);
        return t;
      }
    }
    //	public void trace(int s) {
    //		if ( states==null ) states = new ArrayList<Integer>();
    //		states.add(s);
    //	}
    /** Used by enterOuterAlt to toss out a RuleContext previously added as
     *  we entered a rule. If we have # label, we will need to remove
     *  generic ruleContext object.
     */
  }, {
    key: "removeLastChild",
    value: function removeLastChild() {
      if (this.children) {
        this.children.pop();
      }
    }
  }, {
    key: "parent",
    get: function get() {
      var parent = (0, _get2.default)((0, _getPrototypeOf2.default)(ParserRuleContext.prototype), "parent", this);
      if (parent === undefined || parent instanceof ParserRuleContext) {
        return parent;
      }
      throw new TypeError("Invalid parent type for ParserRuleContext");
    }
    // Note: in TypeScript, order or arguments reversed
  }, {
    key: "getChild",
    value: function getChild(i, ctxType) {
      if (!this.children || i < 0 || i >= this.children.length) {
        throw new RangeError("index parameter must be between >= 0 and <= number of children.");
      }
      if (ctxType == null) {
        return this.children[i];
      }
      var result = this.tryGetChild(i, ctxType);
      if (result === undefined) {
        throw new Error("The specified node does not exist");
      }
      return result;
    }
  }, {
    key: "tryGetChild",
    value: function tryGetChild(i, ctxType) {
      if (!this.children || i < 0 || i >= this.children.length) {
        return undefined;
      }
      var j = -1; // what node with ctxType have we found?
      var _iterator2 = _createForOfIteratorHelper(this.children),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var o = _step2.value;
          if (o instanceof ctxType) {
            j++;
            if (j === i) {
              return o;
            }
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return undefined;
    }
  }, {
    key: "getToken",
    value: function getToken(ttype, i) {
      var result = this.tryGetToken(ttype, i);
      if (result === undefined) {
        throw new Error("The specified token does not exist");
      }
      return result;
    }
  }, {
    key: "tryGetToken",
    value: function tryGetToken(ttype, i) {
      if (!this.children || i < 0 || i >= this.children.length) {
        return undefined;
      }
      var j = -1; // what token with ttype have we found?
      var _iterator3 = _createForOfIteratorHelper(this.children),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var o = _step3.value;
          if (o instanceof TerminalNode_1.TerminalNode) {
            var symbol = o.symbol;
            if (symbol.type === ttype) {
              j++;
              if (j === i) {
                return o;
              }
            }
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      return undefined;
    }
  }, {
    key: "getTokens",
    value: function getTokens(ttype) {
      var tokens = [];
      if (!this.children) {
        return tokens;
      }
      var _iterator4 = _createForOfIteratorHelper(this.children),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var o = _step4.value;
          if (o instanceof TerminalNode_1.TerminalNode) {
            var symbol = o.symbol;
            if (symbol.type === ttype) {
              tokens.push(o);
            }
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      return tokens;
    }
  }, {
    key: "ruleContext",
    get: function get() {
      return this;
    }
    // NOTE: argument order change from Java version
  }, {
    key: "getRuleContext",
    value: function getRuleContext(i, ctxType) {
      return this.getChild(i, ctxType);
    }
  }, {
    key: "tryGetRuleContext",
    value: function tryGetRuleContext(i, ctxType) {
      return this.tryGetChild(i, ctxType);
    }
  }, {
    key: "getRuleContexts",
    value: function getRuleContexts(ctxType) {
      var contexts = [];
      if (!this.children) {
        return contexts;
      }
      var _iterator5 = _createForOfIteratorHelper(this.children),
        _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var o = _step5.value;
          if (o instanceof ctxType) {
            contexts.push(o);
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
      return contexts;
    }
  }, {
    key: "childCount",
    get: function get() {
      return this.children ? this.children.length : 0;
    }
  }, {
    key: "sourceInterval",
    get: function get() {
      if (!this._start) {
        return Interval_1.Interval.INVALID;
      }
      if (!this._stop || this._stop.tokenIndex < this._start.tokenIndex) {
        return Interval_1.Interval.of(this._start.tokenIndex, this._start.tokenIndex - 1); // empty
      }

      return Interval_1.Interval.of(this._start.tokenIndex, this._stop.tokenIndex);
    }
    /**
     * Get the initial token in this context.
     * Note that the range from start to stop is inclusive, so for rules that do not consume anything
     * (for example, zero length or error productions) this token may exceed stop.
     */
  }, {
    key: "start",
    get: function get() {
      return this._start;
    }
    /**
     * Get the final token in this context.
     * Note that the range from start to stop is inclusive, so for rules that do not consume anything
     * (for example, zero length or error productions) this token may precede start.
     */
  }, {
    key: "stop",
    get: function get() {
      return this._stop;
    }
    /** Used for rule context info debugging during parse-time, not so much for ATN debugging */
  }, {
    key: "toInfoString",
    value: function toInfoString(recognizer) {
      var rules = recognizer.getRuleInvocationStack(this).reverse();
      return "ParserRuleContext" + rules + "{" + "start=" + this._start + ", stop=" + this._stop + "}";
    }
  }], [{
    key: "emptyContext",
    value: function emptyContext() {
      return ParserRuleContext.EMPTY;
    }
  }]);
  return ParserRuleContext;
}(RuleContext_1.RuleContext);
ParserRuleContext.EMPTY = new ParserRuleContext();
__decorate([Decorators_1.Override
/** Override to make type more specific */], ParserRuleContext.prototype, "parent", null);
__decorate([Decorators_1.Override], ParserRuleContext.prototype, "childCount", null);
__decorate([Decorators_1.Override], ParserRuleContext.prototype, "sourceInterval", null);
exports.ParserRuleContext = ParserRuleContext;

},{"./Decorators":272,"./RuleContext":292,"./misc/Interval":378,"./tree/ErrorNode":387,"./tree/TerminalNode":391,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/get":234,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],288:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/web.dom-collections.for-each.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var Decorators_1 = require("./Decorators");
/**
 * This implementation of {@link ANTLRErrorListener} dispatches all calls to a
 * collection of delegate listeners. This reduces the effort required to support multiple
 * listeners.
 *
 * @author Sam Harwell
 */
var ProxyErrorListener = /*#__PURE__*/function () {
  function ProxyErrorListener(delegates) {
    (0, _classCallCheck2.default)(this, ProxyErrorListener);
    this.delegates = delegates;
    if (!delegates) {
      throw new Error("Invalid delegates");
    }
  }
  (0, _createClass2.default)(ProxyErrorListener, [{
    key: "getDelegates",
    value: function getDelegates() {
      return this.delegates;
    }
  }, {
    key: "syntaxError",
    value: function syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
      this.delegates.forEach(function (listener) {
        if (listener.syntaxError) {
          listener.syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e);
        }
      });
    }
  }]);
  return ProxyErrorListener;
}();
__decorate([Decorators_1.Override, __param(0, Decorators_1.NotNull), __param(4, Decorators_1.NotNull)], ProxyErrorListener.prototype, "syntaxError", null);
exports.ProxyErrorListener = ProxyErrorListener;

},{"./Decorators":272,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/web.dom-collections.for-each.js":676}],289:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/web.dom-collections.for-each.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var ProxyErrorListener_1 = require("./ProxyErrorListener");
var Decorators_1 = require("./Decorators");
/**
 * @author Sam Harwell
 */
var ProxyParserErrorListener = /*#__PURE__*/function (_ProxyErrorListener_) {
  (0, _inherits2.default)(ProxyParserErrorListener, _ProxyErrorListener_);
  var _super = _createSuper(ProxyParserErrorListener);
  function ProxyParserErrorListener(delegates) {
    (0, _classCallCheck2.default)(this, ProxyParserErrorListener);
    return _super.call(this, delegates);
  }
  (0, _createClass2.default)(ProxyParserErrorListener, [{
    key: "reportAmbiguity",
    value: function reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
      this.getDelegates().forEach(function (listener) {
        if (listener.reportAmbiguity) {
          listener.reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs);
        }
      });
    }
  }, {
    key: "reportAttemptingFullContext",
    value: function reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, conflictState) {
      this.getDelegates().forEach(function (listener) {
        if (listener.reportAttemptingFullContext) {
          listener.reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, conflictState);
        }
      });
    }
  }, {
    key: "reportContextSensitivity",
    value: function reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, acceptState) {
      this.getDelegates().forEach(function (listener) {
        if (listener.reportContextSensitivity) {
          listener.reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, acceptState);
        }
      });
    }
  }]);
  return ProxyParserErrorListener;
}(ProxyErrorListener_1.ProxyErrorListener);
__decorate([Decorators_1.Override], ProxyParserErrorListener.prototype, "reportAmbiguity", null);
__decorate([Decorators_1.Override], ProxyParserErrorListener.prototype, "reportAttemptingFullContext", null);
__decorate([Decorators_1.Override], ProxyParserErrorListener.prototype, "reportContextSensitivity", null);
exports.ProxyParserErrorListener = ProxyParserErrorListener;

},{"./Decorators":272,"./ProxyErrorListener":288,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/web.dom-collections.for-each.js":676}],290:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapNativeSuper"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
/** The root of the ANTLR exception hierarchy. In general, ANTLR tracks just
 *  3 kinds of errors: prediction errors, failed predicate errors, and
 *  mismatched input errors. In each case, the parser knows where it is
 *  in the input, where it is in the ATN, the rule invocation stack,
 *  and what kind of problem occurred.
 */
var RecognitionException = /*#__PURE__*/function (_Error) {
  (0, _inherits2.default)(RecognitionException, _Error);
  var _super = _createSuper(RecognitionException);
  function RecognitionException(recognizer, input, ctx, message) {
    var _this;
    (0, _classCallCheck2.default)(this, RecognitionException);
    _this = _super.call(this, message);
    _this._offendingState = -1;
    _this._recognizer = recognizer;
    _this.input = input;
    _this.ctx = ctx;
    if (recognizer) {
      _this._offendingState = recognizer.state;
    }
    return _this;
  }
  /**
   * Get the ATN state number the parser was in at the time the error
   * occurred. For {@link NoViableAltException} and
   * {@link LexerNoViableAltException} exceptions, this is the
   * {@link DecisionState} number. For others, it is the state whose outgoing
   * edge we couldn't match.
   *
   * If the state number is not known, this method returns -1.
   */
  (0, _createClass2.default)(RecognitionException, [{
    key: "offendingState",
    get: function get() {
      return this._offendingState;
    }
  }, {
    key: "setOffendingState",
    value: function setOffendingState(offendingState) {
      this._offendingState = offendingState;
    }
    /**
     * Gets the set of input symbols which could potentially follow the
     * previously matched symbol at the time this exception was thrown.
     *
     * If the set of expected tokens is not known and could not be computed,
     * this method returns `undefined`.
     *
     * @returns The set of token types that could potentially follow the current
     * state in the ATN, or `undefined` if the information is not available.
     */
  }, {
    key: "expectedTokens",
    get: function get() {
      if (this._recognizer) {
        return this._recognizer.atn.getExpectedTokens(this._offendingState, this.ctx);
      }
      return undefined;
    }
    /**
     * Gets the {@link RuleContext} at the time this exception was thrown.
     *
     * If the context is not available, this method returns `undefined`.
     *
     * @returns The {@link RuleContext} at the time this exception was thrown.
     * If the context is not available, this method returns `undefined`.
     */
  }, {
    key: "context",
    get: function get() {
      return this.ctx;
    }
    /**
     * Gets the input stream which is the symbol source for the recognizer where
     * this exception was thrown.
     *
     * If the input stream is not available, this method returns `undefined`.
     *
     * @returns The input stream which is the symbol source for the recognizer
     * where this exception was thrown, or `undefined` if the stream is not
     * available.
     */
  }, {
    key: "inputStream",
    get: function get() {
      return this.input;
    }
  }, {
    key: "getOffendingToken",
    value: function getOffendingToken(recognizer) {
      if (recognizer && recognizer !== this._recognizer) {
        return undefined;
      }
      return this.offendingToken;
    }
  }, {
    key: "setOffendingToken",
    value: function setOffendingToken(recognizer, offendingToken) {
      if (recognizer === this._recognizer) {
        this.offendingToken = offendingToken;
      }
    }
    /**
     * Gets the {@link Recognizer} where this exception occurred.
     *
     * If the recognizer is not available, this method returns `undefined`.
     *
     * @returns The recognizer where this exception occurred, or `undefined` if
     * the recognizer is not available.
     */
  }, {
    key: "recognizer",
    get: function get() {
      return this._recognizer;
    }
  }]);
  return RecognitionException;
}( /*#__PURE__*/(0, _wrapNativeSuper2.default)(Error));
exports.RecognitionException = RecognitionException;

},{"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/wrapNativeSuper":254,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],291:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.map.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.array.splice.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.weak-map.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var ConsoleErrorListener_1 = require("./ConsoleErrorListener");
var ProxyErrorListener_1 = require("./ProxyErrorListener");
var Decorators_1 = require("./Decorators");
var Token_1 = require("./Token");
var Utils = require("./misc/Utils");
var Recognizer = /*#__PURE__*/function () {
  function Recognizer() {
    (0, _classCallCheck2.default)(this, Recognizer);
    this._listeners = [ConsoleErrorListener_1.ConsoleErrorListener.INSTANCE];
    this._stateNumber = -1;
  }
  /**
   * Get a map from token names to token types.
   *
   * Used for XPath and tree pattern compilation.
   */
  (0, _createClass2.default)(Recognizer, [{
    key: "getTokenTypeMap",
    value: function getTokenTypeMap() {
      var vocabulary = this.vocabulary;
      var result = Recognizer.tokenTypeMapCache.get(vocabulary);
      if (result == null) {
        var intermediateResult = new Map();
        for (var i = 0; i <= this.atn.maxTokenType; i++) {
          var literalName = vocabulary.getLiteralName(i);
          if (literalName != null) {
            intermediateResult.set(literalName, i);
          }
          var symbolicName = vocabulary.getSymbolicName(i);
          if (symbolicName != null) {
            intermediateResult.set(symbolicName, i);
          }
        }
        intermediateResult.set("EOF", Token_1.Token.EOF);
        result = intermediateResult;
        Recognizer.tokenTypeMapCache.set(vocabulary, result);
      }
      return result;
    }
    /**
     * Get a map from rule names to rule indexes.
     *
     * Used for XPath and tree pattern compilation.
     */
  }, {
    key: "getRuleIndexMap",
    value: function getRuleIndexMap() {
      var ruleNames = this.ruleNames;
      if (ruleNames == null) {
        throw new Error("The current recognizer does not provide a list of rule names.");
      }
      var result = Recognizer.ruleIndexMapCache.get(ruleNames);
      if (result == null) {
        result = Utils.toMap(ruleNames);
        Recognizer.ruleIndexMapCache.set(ruleNames, result);
      }
      return result;
    }
  }, {
    key: "getTokenType",
    value: function getTokenType(tokenName) {
      var ttype = this.getTokenTypeMap().get(tokenName);
      if (ttype != null) {
        return ttype;
      }
      return Token_1.Token.INVALID_TYPE;
    }
    /**
     * If this recognizer was generated, it will have a serialized ATN
     * representation of the grammar.
     *
     * For interpreters, we don't know their serialized ATN despite having
     * created the interpreter from it.
     */
  }, {
    key: "serializedATN",
    get: function get() {
      throw new Error("there is no serialized ATN");
    }
    /**
     * Get the {@link ATN} used by the recognizer for prediction.
     *
     * @returns The {@link ATN} used by the recognizer for prediction.
     */
  }, {
    key: "atn",
    get: function get() {
      return this._interp.atn;
    }
    /**
     * Get the ATN interpreter used by the recognizer for prediction.
     *
     * @returns The ATN interpreter used by the recognizer for prediction.
     */
  }, {
    key: "interpreter",
    get: function get() {
      return this._interp;
    }
    /**
     * Set the ATN interpreter used by the recognizer for prediction.
     *
     * @param interpreter The ATN interpreter used by the recognizer for
     * prediction.
     */,
    set: function set(interpreter) {
      this._interp = interpreter;
    }
    /** If profiling during the parse/lex, this will return DecisionInfo records
     *  for each decision in recognizer in a ParseInfo object.
     *
     * @since 4.3
     */
  }, {
    key: "parseInfo",
    get: function get() {
      return Promise.resolve(undefined);
    }
    /** What is the error header, normally line/character position information? */
  }, {
    key: "getErrorHeader",
    value: function getErrorHeader(e) {
      var token = e.getOffendingToken();
      if (!token) {
        return "";
      }
      var line = token.line;
      var charPositionInLine = token.charPositionInLine;
      return "line " + line + ":" + charPositionInLine;
    }
    /**
     * @exception NullPointerException if `listener` is `undefined`.
     */
  }, {
    key: "addErrorListener",
    value: function addErrorListener(listener) {
      if (!listener) {
        throw new TypeError("listener must not be null");
      }
      this._listeners.push(listener);
    }
  }, {
    key: "removeErrorListener",
    value: function removeErrorListener(listener) {
      var position = this._listeners.indexOf(listener);
      if (position !== -1) {
        this._listeners.splice(position, 1);
      }
    }
  }, {
    key: "removeErrorListeners",
    value: function removeErrorListeners() {
      this._listeners.length = 0;
    }
  }, {
    key: "getErrorListeners",
    value: function getErrorListeners() {
      return this._listeners.slice(0);
    }
  }, {
    key: "getErrorListenerDispatch",
    value: function getErrorListenerDispatch() {
      return new ProxyErrorListener_1.ProxyErrorListener(this.getErrorListeners());
    }
    // subclass needs to override these if there are sempreds or actions
    // that the ATN interp needs to execute
  }, {
    key: "sempred",
    value: function sempred(_localctx, ruleIndex, actionIndex) {
      return true;
    }
  }, {
    key: "precpred",
    value: function precpred(localctx, precedence) {
      return true;
    }
  }, {
    key: "action",
    value: function action(_localctx, ruleIndex, actionIndex) {
      // intentionally empty
    }
  }, {
    key: "state",
    get: function get() {
      return this._stateNumber;
    }
    /** Indicate that the recognizer has changed internal state that is
     *  consistent with the ATN state passed in.  This way we always know
     *  where we are in the ATN as the parser goes along. The rule
     *  context objects form a stack that lets us see the stack of
     *  invoking rules. Combine this and we have complete ATN
     *  configuration information.
     */,
    set: function set(atnState) {
      //		System.err.println("setState "+atnState);
      this._stateNumber = atnState;
      //		if ( traceATNStates ) _ctx.trace(atnState);
    }
  }]);
  return Recognizer;
}();
Recognizer.EOF = -1;
Recognizer.tokenTypeMapCache = new WeakMap();
Recognizer.ruleIndexMapCache = new WeakMap();
__decorate([Decorators_1.SuppressWarnings("serial"), Decorators_1.NotNull], Recognizer.prototype, "_listeners", void 0);
__decorate([Decorators_1.NotNull], Recognizer.prototype, "getTokenTypeMap", null);
__decorate([Decorators_1.NotNull], Recognizer.prototype, "getRuleIndexMap", null);
__decorate([Decorators_1.NotNull], Recognizer.prototype, "serializedATN", null);
__decorate([Decorators_1.NotNull], Recognizer.prototype, "atn", null);
__decorate([Decorators_1.NotNull, __param(0, Decorators_1.NotNull)], Recognizer.prototype, "interpreter", null);
__decorate([Decorators_1.NotNull, __param(0, Decorators_1.NotNull)], Recognizer.prototype, "getErrorHeader", null);
__decorate([__param(0, Decorators_1.NotNull)], Recognizer.prototype, "addErrorListener", null);
__decorate([__param(0, Decorators_1.NotNull)], Recognizer.prototype, "removeErrorListener", null);
__decorate([Decorators_1.NotNull], Recognizer.prototype, "getErrorListeners", null);
exports.Recognizer = Recognizer;

},{"./ConsoleErrorListener":271,"./Decorators":272,"./ProxyErrorListener":288,"./Token":296,"./misc/Utils":385,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.array.splice.js":582,"core-js/modules/es.map.js":587,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.promise.js":614,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.weak-map.js":673,"core-js/modules/web.dom-collections.iterator.js":677}],292:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:57.3490837-07:00
var ATN_1 = require("./atn/ATN");
var Recognizer_1 = require("./Recognizer");
var RuleNode_1 = require("./tree/RuleNode");
var Interval_1 = require("./misc/Interval");
var Decorators_1 = require("./Decorators");
var Trees_1 = require("./tree/Trees");
var ParserRuleContext_1 = require("./ParserRuleContext");
/** A rule context is a record of a single rule invocation.
 *
 *  We form a stack of these context objects using the parent
 *  pointer. A parent pointer of `undefined` indicates that the current
 *  context is the bottom of the stack. The ParserRuleContext subclass
 *  as a children list so that we can turn this data structure into a
 *  tree.
 *
 *  The root node always has a `undefined` pointer and invokingState of -1.
 *
 *  Upon entry to parsing, the first invoked rule function creates a
 *  context object (a subclass specialized for that rule such as
 *  SContext) and makes it the root of a parse tree, recorded by field
 *  Parser._ctx.
 *
 *  public final SContext s() throws RecognitionException {
 *      SContext _localctx = new SContext(_ctx, state); <-- create new node
 *      enterRule(_localctx, 0, RULE_s);                     <-- push it
 *      ...
 *      exitRule();                                          <-- pop back to _localctx
 *      return _localctx;
 *  }
 *
 *  A subsequent rule invocation of r from the start rule s pushes a
 *  new context object for r whose parent points at s and use invoking
 *  state is the state with r emanating as edge label.
 *
 *  The invokingState fields from a context object to the root
 *  together form a stack of rule indication states where the root
 *  (bottom of the stack) has a -1 sentinel value. If we invoke start
 *  symbol s then call r1, which calls r2, the  would look like
 *  this:
 *
 *     SContext[-1]   <- root node (bottom of the stack)
 *     R1Context[p]   <- p in rule s called r1
 *     R2Context[q]   <- q in rule r1 called r2
 *
 *  So the top of the stack, _ctx, represents a call to the current
 *  rule and it holds the return address from another rule that invoke
 *  to this rule. To invoke a rule, we must always have a current context.
 *
 *  The parent contexts are useful for computing lookahead sets and
 *  getting error information.
 *
 *  These objects are used during parsing and prediction.
 *  For the special case of parsers, we use the subclass
 *  ParserRuleContext.
 *
 *  @see ParserRuleContext
 */
var RuleContext = /*#__PURE__*/function (_RuleNode_1$RuleNode) {
  (0, _inherits2.default)(RuleContext, _RuleNode_1$RuleNode);
  var _super = _createSuper(RuleContext);
  function RuleContext(parent, invokingState) {
    var _this;
    (0, _classCallCheck2.default)(this, RuleContext);
    _this = _super.call(this);
    _this._parent = parent;
    _this.invokingState = invokingState != null ? invokingState : -1;
    return _this;
  }
  (0, _createClass2.default)(RuleContext, [{
    key: "depth",
    value: function depth() {
      var n = 0;
      var p = this;
      while (p) {
        p = p._parent;
        n++;
      }
      return n;
    }
    /** A context is empty if there is no invoking state; meaning nobody called
     *  current context.
     */
  }, {
    key: "isEmpty",
    get: function get() {
      return this.invokingState === -1;
    }
    // satisfy the ParseTree / SyntaxTree interface
  }, {
    key: "sourceInterval",
    get: function get() {
      return Interval_1.Interval.INVALID;
    }
  }, {
    key: "ruleContext",
    get: function get() {
      return this;
    }
  }, {
    key: "parent",
    get: function get() {
      return this._parent;
    }
    /** @since 4.7. {@see ParseTree#setParent} comment */
  }, {
    key: "setParent",
    value: function setParent(parent) {
      this._parent = parent;
    }
  }, {
    key: "payload",
    get: function get() {
      return this;
    }
    /** Return the combined text of all child nodes. This method only considers
     *  tokens which have been added to the parse tree.
     *
     *  Since tokens on hidden channels (e.g. whitespace or comments) are not
     *  added to the parse trees, they will not appear in the output of this
     *  method.
     */
  }, {
    key: "text",
    get: function get() {
      if (this.childCount === 0) {
        return "";
      }
      var builder = "";
      for (var i = 0; i < this.childCount; i++) {
        builder += this.getChild(i).text;
      }
      return builder.toString();
    }
  }, {
    key: "ruleIndex",
    get: function get() {
      return -1;
    }
    /** For rule associated with this parse tree internal node, return
     *  the outer alternative number used to match the input. Default
     *  implementation does not compute nor store this alt num. Create
     *  a subclass of ParserRuleContext with backing field and set
     *  option contextSuperClass.
     *  to set it.
     *
     *  @since 4.5.3
     */
  }, {
    key: "altNumber",
    get: function get() {
      return ATN_1.ATN.INVALID_ALT_NUMBER;
    }
    /** Set the outer alternative number for this context node. Default
     *  implementation does nothing to avoid backing field overhead for
     *  trees that don't need it.  Create
     *  a subclass of ParserRuleContext with backing field and set
     *  option contextSuperClass.
     *
     *  @since 4.5.3
     */,
    set: function set(altNumber) {
      // intentionally ignored by the base implementation
    }
  }, {
    key: "getChild",
    value: function getChild(i) {
      throw new RangeError("i must be greater than or equal to 0 and less than childCount");
    }
  }, {
    key: "childCount",
    get: function get() {
      return 0;
    }
  }, {
    key: "accept",
    value: function accept(visitor) {
      return visitor.visitChildren(this);
    }
  }, {
    key: "toStringTree",
    value: function toStringTree(recog) {
      return Trees_1.Trees.toStringTree(this, recog);
    }
  }, {
    key: "toString",
    value: function toString(arg1, stop) {
      var ruleNames = arg1 instanceof Recognizer_1.Recognizer ? arg1.ruleNames : arg1;
      stop = stop || ParserRuleContext_1.ParserRuleContext.emptyContext();
      var buf = "";
      var p = this;
      buf += "[";
      while (p && p !== stop) {
        if (!ruleNames) {
          if (!p.isEmpty) {
            buf += p.invokingState;
          }
        } else {
          var ruleIndex = p.ruleIndex;
          var ruleName = ruleIndex >= 0 && ruleIndex < ruleNames.length ? ruleNames[ruleIndex] : ruleIndex.toString();
          buf += ruleName;
        }
        if (p._parent && (ruleNames || !p._parent.isEmpty)) {
          buf += " ";
        }
        p = p._parent;
      }
      buf += "]";
      return buf.toString();
    }
  }], [{
    key: "getChildContext",
    value: function getChildContext(parent, invokingState) {
      return new RuleContext(parent, invokingState);
    }
  }]);
  return RuleContext;
}(RuleNode_1.RuleNode);
__decorate([Decorators_1.Override], RuleContext.prototype, "sourceInterval", null);
__decorate([Decorators_1.Override], RuleContext.prototype, "ruleContext", null);
__decorate([Decorators_1.Override], RuleContext.prototype, "parent", null);
__decorate([Decorators_1.Override], RuleContext.prototype, "setParent", null);
__decorate([Decorators_1.Override], RuleContext.prototype, "payload", null);
__decorate([Decorators_1.Override], RuleContext.prototype, "text", null);
__decorate([Decorators_1.Override], RuleContext.prototype, "getChild", null);
__decorate([Decorators_1.Override], RuleContext.prototype, "childCount", null);
__decorate([Decorators_1.Override], RuleContext.prototype, "accept", null);
__decorate([Decorators_1.Override], RuleContext.prototype, "toStringTree", null);
exports.RuleContext = RuleContext;

},{"./Decorators":272,"./ParserRuleContext":287,"./Recognizer":291,"./atn/ATN":299,"./misc/Interval":378,"./tree/RuleNode":390,"./tree/Trees":392,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.to-string.js":620}],293:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:57.4741196-07:00
var ATN_1 = require("./atn/ATN");
var Decorators_1 = require("./Decorators");
var ParserRuleContext_1 = require("./ParserRuleContext");
/** A handy class for use with
 *
 *  options {contextSuperClass=org.antlr.v4.runtime.RuleContextWithAltNum;}
 *
 *  that provides a backing field / impl for the outer alternative number
 *  matched for an internal parse tree node.
 *
 *  I'm only putting into Java runtime as I'm certain I'm the only one that
 *  will really every use this.
 */
var RuleContextWithAltNum = /*#__PURE__*/function (_ParserRuleContext_1$) {
  (0, _inherits2.default)(RuleContextWithAltNum, _ParserRuleContext_1$);
  var _super = _createSuper(RuleContextWithAltNum);
  function RuleContextWithAltNum(parent, invokingStateNumber) {
    var _this;
    (0, _classCallCheck2.default)(this, RuleContextWithAltNum);
    if (invokingStateNumber !== undefined) {
      _this = _super.call(this, parent, invokingStateNumber);
    } else {
      _this = _super.call(this);
    }
    _this._altNumber = ATN_1.ATN.INVALID_ALT_NUMBER;
    return (0, _possibleConstructorReturn2.default)(_this);
  }
  (0, _createClass2.default)(RuleContextWithAltNum, [{
    key: "altNumber",
    get: function get() {
      return this._altNumber;
    }
    // @Override
    ,
    set: function set(altNum) {
      this._altNumber = altNum;
    }
  }]);
  return RuleContextWithAltNum;
}(ParserRuleContext_1.ParserRuleContext);
__decorate([Decorators_1.Override], RuleContextWithAltNum.prototype, "altNumber", null);
exports.RuleContextWithAltNum = RuleContextWithAltNum;

},{"./Decorators":272,"./ParserRuleContext":287,"./atn/ATN":299,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],294:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Declares a dependency upon a grammar rule, along with a set of zero or more dependent rules.
 *
 * Version numbers within a grammar should be assigned on a monotonically increasing basis to allow for accurate
 * tracking of dependent rules.
 *
 * @author Sam Harwell
 */
function RuleDependency(dependency) {
  return function (target, propertyKey, propertyDescriptor) {
    // intentionally empty
  };
}
exports.RuleDependency = RuleDependency;

},{}],295:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 *
 * @author Sam Harwell
 */
function RuleVersion(version) {
  return function (target, propertyKey, propertyDescriptor) {
    // intentionally empty
  };
}
exports.RuleVersion = RuleVersion;

},{}],296:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
var IntStream_1 = require("./IntStream");
var Token;
(function (Token) {
  Token.INVALID_TYPE = 0;
  /** During lookahead operations, this "token" signifies we hit rule end ATN state
   *  and did not follow it despite needing to.
   */
  Token.EPSILON = -2;
  Token.MIN_USER_TOKEN_TYPE = 1;
  Token.EOF = IntStream_1.IntStream.EOF;
  /** All tokens go to the parser (unless skip() is called in that rule)
   *  on a particular "channel".  The parser tunes to a particular channel
   *  so that whitespace etc... can go to the parser on a "hidden" channel.
   */
  Token.DEFAULT_CHANNEL = 0;
  /** Anything on different channel than DEFAULT_CHANNEL is not parsed
   *  by parser.
   */
  Token.HIDDEN_CHANNEL = 1;
  /**
   * This is the minimum constant value which can be assigned to a
   * user-defined token channel.
   *
   * The non-negative numbers less than {@link #MIN_USER_CHANNEL_VALUE} are
   * assigned to the predefined channels {@link #DEFAULT_CHANNEL} and
   * {@link #HIDDEN_CHANNEL}.
   *
   * @see `Token.channel`
   */
  Token.MIN_USER_CHANNEL_VALUE = 2;
})(Token = exports.Token || (exports.Token = {}));

},{"./IntStream":278}],297:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.map.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.array.concat.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.array.join.js");
require("core-js/modules/es.function.name.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:58.1768850-07:00
var Interval_1 = require("./misc/Interval");
var Decorators_1 = require("./Decorators");
var Token_1 = require("./Token");
/**
 * Useful for rewriting out a buffered input token stream after doing some
 * augmentation or other manipulations on it.
 *
 * You can insert stuff, replace, and delete chunks. Note that the operations
 * are done lazily--only if you convert the buffer to a {@link String} with
 * {@link TokenStream#getText()}. This is very efficient because you are not
 * moving data around all the time. As the buffer of tokens is converted to
 * strings, the {@link #getText()} method(s) scan the input token stream and
 * check to see if there is an operation at the current index. If so, the
 * operation is done and then normal {@link String} rendering continues on the
 * buffer. This is like having multiple Turing machine instruction streams
 * (programs) operating on a single input tape. :)
 *
 * This rewriter makes no modifications to the token stream. It does not ask the
 * stream to fill itself up nor does it advance the input cursor. The token
 * stream `TokenStream.index` will return the same value before and
 * after any {@link #getText()} call.
 *
 * The rewriter only works on tokens that you have in the buffer and ignores the
 * current input cursor. If you are buffering tokens on-demand, calling
 * {@link #getText()} halfway through the input will only do rewrites for those
 * tokens in the first half of the file.
 *
 * Since the operations are done lazily at {@link #getText}-time, operations do
 * not screw up the token index values. That is, an insert operation at token
 * index `i` does not change the index values for tokens
 * `i`+1..n-1.
 *
 * Because operations never actually alter the buffer, you may always get the
 * original token stream back without undoing anything. Since the instructions
 * are queued up, you can easily simulate transactions and roll back any changes
 * if there is an error just by removing instructions. For example,
 *
 * ```
 * CharStream input = new ANTLRFileStream("input");
 * TLexer lex = new TLexer(input);
 * CommonTokenStream tokens = new CommonTokenStream(lex);
 * T parser = new T(tokens);
 * TokenStreamRewriter rewriter = new TokenStreamRewriter(tokens);
 * parser.startRule();
 * ```
 *
 * Then in the rules, you can execute (assuming rewriter is visible):
 *
 * ```
 * Token t,u;
 * ...
 * rewriter.insertAfter(t, "text to put after t");}
 * rewriter.insertAfter(u, "text after u");}
 * System.out.println(rewriter.getText());
 * ```
 *
 * You can also have multiple "instruction streams" and get multiple rewrites
 * from a single pass over the input. Just name the instruction streams and use
 * that name again when printing the buffer. This could be useful for generating
 * a C file and also its header file--all from the same buffer:
 *
 * ```
 * rewriter.insertAfter("pass1", t, "text to put after t");}
 * rewriter.insertAfter("pass2", u, "text after u");}
 * System.out.println(rewriter.getText("pass1"));
 * System.out.println(rewriter.getText("pass2"));
 * ```
 *
 * If you don't use named rewrite streams, a "default" stream is used as the
 * first example shows.
 */
var TokenStreamRewriter = /*#__PURE__*/function () {
  function TokenStreamRewriter(tokens) {
    (0, _classCallCheck2.default)(this, TokenStreamRewriter);
    this.tokens = tokens;
    this.programs = new Map();
    this.programs.set(TokenStreamRewriter.DEFAULT_PROGRAM_NAME, []);
    this.lastRewriteTokenIndexes = new Map();
  }
  (0, _createClass2.default)(TokenStreamRewriter, [{
    key: "getTokenStream",
    value: function getTokenStream() {
      return this.tokens;
    }
  }, {
    key: "rollback",
    value: function rollback(instructionIndex) {
      var programName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TokenStreamRewriter.DEFAULT_PROGRAM_NAME;
      var is = this.programs.get(programName);
      if (is != null) {
        this.programs.set(programName, is.slice(TokenStreamRewriter.MIN_TOKEN_INDEX, instructionIndex));
      }
    }
  }, {
    key: "deleteProgram",
    value: function deleteProgram() {
      var programName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TokenStreamRewriter.DEFAULT_PROGRAM_NAME;
      this.rollback(TokenStreamRewriter.MIN_TOKEN_INDEX, programName);
    }
  }, {
    key: "insertAfter",
    value: function insertAfter(tokenOrIndex, text) {
      var programName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TokenStreamRewriter.DEFAULT_PROGRAM_NAME;
      var index;
      if (typeof tokenOrIndex === "number") {
        index = tokenOrIndex;
      } else {
        index = tokenOrIndex.tokenIndex;
      }
      // to insert after, just insert before next index (even if past end)
      var op = new InsertAfterOp(this.tokens, index, text);
      var rewrites = this.getProgram(programName);
      op.instructionIndex = rewrites.length;
      rewrites.push(op);
    }
  }, {
    key: "insertBefore",
    value: function insertBefore(tokenOrIndex, text) {
      var programName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TokenStreamRewriter.DEFAULT_PROGRAM_NAME;
      var index;
      if (typeof tokenOrIndex === "number") {
        index = tokenOrIndex;
      } else {
        index = tokenOrIndex.tokenIndex;
      }
      var op = new InsertBeforeOp(this.tokens, index, text);
      var rewrites = this.getProgram(programName);
      op.instructionIndex = rewrites.length;
      rewrites.push(op);
    }
  }, {
    key: "replaceSingle",
    value: function replaceSingle(index, text) {
      if (typeof index === "number") {
        this.replace(index, index, text);
      } else {
        this.replace(index, index, text);
      }
    }
  }, {
    key: "replace",
    value: function replace(from, to, text) {
      var programName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : TokenStreamRewriter.DEFAULT_PROGRAM_NAME;
      if (typeof from !== "number") {
        from = from.tokenIndex;
      }
      if (typeof to !== "number") {
        to = to.tokenIndex;
      }
      if (from > to || from < 0 || to < 0 || to >= this.tokens.size) {
        throw new RangeError("replace: range invalid: ".concat(from, "..").concat(to, "(size=").concat(this.tokens.size, ")"));
      }
      var op = new ReplaceOp(this.tokens, from, to, text);
      var rewrites = this.getProgram(programName);
      op.instructionIndex = rewrites.length;
      rewrites.push(op);
    }
  }, {
    key: "delete",
    value: function _delete(from, to) {
      var programName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TokenStreamRewriter.DEFAULT_PROGRAM_NAME;
      if (to === undefined) {
        to = from;
      }
      if (typeof from === "number") {
        this.replace(from, to, "", programName);
      } else {
        this.replace(from, to, "", programName);
      }
    }
  }, {
    key: "getLastRewriteTokenIndex",
    value: function getLastRewriteTokenIndex() {
      var programName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TokenStreamRewriter.DEFAULT_PROGRAM_NAME;
      var I = this.lastRewriteTokenIndexes.get(programName);
      if (I == null) {
        return -1;
      }
      return I;
    }
  }, {
    key: "setLastRewriteTokenIndex",
    value: function setLastRewriteTokenIndex(programName, i) {
      this.lastRewriteTokenIndexes.set(programName, i);
    }
  }, {
    key: "getProgram",
    value: function getProgram(name) {
      var is = this.programs.get(name);
      if (is == null) {
        is = this.initializeProgram(name);
      }
      return is;
    }
  }, {
    key: "initializeProgram",
    value: function initializeProgram(name) {
      var is = [];
      this.programs.set(name, is);
      return is;
    }
  }, {
    key: "getText",
    value: function getText(intervalOrProgram) {
      var programName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TokenStreamRewriter.DEFAULT_PROGRAM_NAME;
      var interval;
      if (intervalOrProgram instanceof Interval_1.Interval) {
        interval = intervalOrProgram;
      } else {
        interval = Interval_1.Interval.of(0, this.tokens.size - 1);
      }
      if (typeof intervalOrProgram === "string") {
        programName = intervalOrProgram;
      }
      var rewrites = this.programs.get(programName);
      var start = interval.a;
      var stop = interval.b;
      // ensure start/end are in range
      if (stop > this.tokens.size - 1) {
        stop = this.tokens.size - 1;
      }
      if (start < 0) {
        start = 0;
      }
      if (rewrites == null || rewrites.length === 0) {
        return this.tokens.getText(interval); // no instructions to execute
      }

      var buf = [];
      // First, optimize instruction stream
      var indexToOp = this.reduceToSingleOperationPerIndex(rewrites);
      // Walk buffer, executing instructions and emitting tokens
      var i = start;
      while (i <= stop && i < this.tokens.size) {
        var op = indexToOp.get(i);
        indexToOp.delete(i); // remove so any left have index size-1
        var t = this.tokens.get(i);
        if (op == null) {
          // no operation at that index, just dump token
          if (t.type !== Token_1.Token.EOF) {
            buf.push(String(t.text));
          }
          i++; // move to next token
        } else {
          i = op.execute(buf); // execute operation and skip
        }
      }
      // include stuff after end if it's last index in buffer
      // So, if they did an insertAfter(lastValidIndex, "foo"), include
      // foo if end==lastValidIndex.
      if (stop === this.tokens.size - 1) {
        // Scan any remaining operations after last token
        // should be included (they will be inserts).
        var _iterator = _createForOfIteratorHelper(indexToOp.values()),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _op = _step.value;
            if (_op.index >= this.tokens.size - 1) {
              buf.push(_op.text.toString());
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
      return buf.join("");
    }
    /** We need to combine operations and report invalid operations (like
     *  overlapping replaces that are not completed nested). Inserts to
     *  same index need to be combined etc...  Here are the cases:
     *
     *  I.i.u I.j.v								leave alone, nonoverlapping
     *  I.i.u I.i.v								combine: Iivu
     *
     *  R.i-j.u R.x-y.v	| i-j in x-y			delete first R
     *  R.i-j.u R.i-j.v							delete first R
     *  R.i-j.u R.x-y.v	| x-y in i-j			ERROR
     *  R.i-j.u R.x-y.v	| boundaries overlap	ERROR
     *
     *  Delete special case of replace (text==undefined):
     *  D.i-j.u D.x-y.v	| boundaries overlap	combine to max(min)..max(right)
     *
     *  I.i.u R.x-y.v | i in (x+1)-y			delete I (since insert before
     * 											we're not deleting i)
     *  I.i.u R.x-y.v | i not in (x+1)-y		leave alone, nonoverlapping
     *  R.x-y.v I.i.u | i in x-y				ERROR
     *  R.x-y.v I.x.u 							R.x-y.uv (combine, delete I)
     *  R.x-y.v I.i.u | i not in x-y			leave alone, nonoverlapping
     *
     *  I.i.u = insert u before op @ index i
     *  R.x-y.u = replace x-y indexed tokens with u
     *
     *  First we need to examine replaces. For any replace op:
     *
     * 		1. wipe out any insertions before op within that range.
     * 		2. Drop any replace op before that is contained completely within
     * 	 that range.
     * 		3. Throw exception upon boundary overlap with any previous replace.
     *
     *  Then we can deal with inserts:
     *
     * 		1. for any inserts to same index, combine even if not adjacent.
     * 		2. for any prior replace with same left boundary, combine this
     * 	 insert with replace and delete this replace.
     * 		3. throw exception if index in same range as previous replace
     *
     *  Don't actually delete; make op undefined in list. Easier to walk list.
     *  Later we can throw as we add to index &rarr; op map.
     *
     *  Note that I.2 R.2-2 will wipe out I.2 even though, technically, the
     *  inserted stuff would be before the replace range. But, if you
     *  add tokens in front of a method body '{' and then delete the method
     *  body, I think the stuff before the '{' you added should disappear too.
     *
     *  Return a map from token index to operation.
     */
  }, {
    key: "reduceToSingleOperationPerIndex",
    value: function reduceToSingleOperationPerIndex(rewrites) {
      // console.log(`rewrites=[${Utils.join(rewrites, ", ")}]`);
      // WALK REPLACES
      for (var i = 0; i < rewrites.length; i++) {
        var op = rewrites[i];
        if (op == null) {
          continue;
        }
        if (!(op instanceof ReplaceOp)) {
          continue;
        }
        var rop = op;
        // Wipe prior inserts within range
        var inserts = this.getKindOfOps(rewrites, InsertBeforeOp, i);
        var _iterator2 = _createForOfIteratorHelper(inserts),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var iop = _step2.value;
            if (iop.index === rop.index) {
              // E.g., insert before 2, delete 2..2; update replace
              // text to include insert before, kill insert
              rewrites[iop.instructionIndex] = undefined;
              rop.text = iop.text.toString() + (rop.text != null ? rop.text.toString() : "");
            } else if (iop.index > rop.index && iop.index <= rop.lastIndex) {
              // delete insert as it's a no-op.
              rewrites[iop.instructionIndex] = undefined;
            }
          }
          // Drop any prior replaces contained within
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        var prevReplaces = this.getKindOfOps(rewrites, ReplaceOp, i);
        var _iterator3 = _createForOfIteratorHelper(prevReplaces),
          _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var prevRop = _step3.value;
            if (prevRop.index >= rop.index && prevRop.lastIndex <= rop.lastIndex) {
              // delete replace as it's a no-op.
              rewrites[prevRop.instructionIndex] = undefined;
              continue;
            }
            // throw exception unless disjoint or identical
            var disjoint = prevRop.lastIndex < rop.index || prevRop.index > rop.lastIndex;
            // Delete special case of replace (text==null):
            // D.i-j.u D.x-y.v	| boundaries overlap	combine to max(min)..max(right)
            if (prevRop.text == null && rop.text == null && !disjoint) {
              // console.log(`overlapping deletes: ${prevRop}, ${rop}`);
              rewrites[prevRop.instructionIndex] = undefined; // kill first delete
              rop.index = Math.min(prevRop.index, rop.index);
              rop.lastIndex = Math.max(prevRop.lastIndex, rop.lastIndex);
              // console.log(`new rop ${rop}`);
            } else if (!disjoint) {
              throw new Error("replace op boundaries of ".concat(rop, " overlap with previous ").concat(prevRop));
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }
      // WALK INSERTS
      for (var _i = 0; _i < rewrites.length; _i++) {
        var _op2 = rewrites[_i];
        if (_op2 == null) {
          continue;
        }
        if (!(_op2 instanceof InsertBeforeOp)) {
          continue;
        }
        var _iop = _op2;
        // combine current insert with prior if any at same index
        var prevInserts = this.getKindOfOps(rewrites, InsertBeforeOp, _i);
        var _iterator4 = _createForOfIteratorHelper(prevInserts),
          _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var prevIop = _step4.value;
            if (prevIop.index === _iop.index) {
              if (prevIop instanceof InsertAfterOp) {
                _iop.text = this.catOpText(prevIop.text, _iop.text);
                rewrites[prevIop.instructionIndex] = undefined;
              } else if (prevIop instanceof InsertBeforeOp) {
                // combine objects
                // convert to strings...we're in process of toString'ing
                // whole token buffer so no lazy eval issue with any templates
                _iop.text = this.catOpText(_iop.text, prevIop.text);
                // delete redundant prior insert
                rewrites[prevIop.instructionIndex] = undefined;
              }
            }
          }
          // look for replaces where iop.index is in range; error
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
        var _prevReplaces = this.getKindOfOps(rewrites, ReplaceOp, _i);
        var _iterator5 = _createForOfIteratorHelper(_prevReplaces),
          _step5;
        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var _rop = _step5.value;
            if (_iop.index === _rop.index) {
              _rop.text = this.catOpText(_iop.text, _rop.text);
              rewrites[_i] = undefined; // delete current insert
              continue;
            }
            if (_iop.index >= _rop.index && _iop.index <= _rop.lastIndex) {
              throw new Error("insert op ".concat(_iop, " within boundaries of previous ").concat(_rop));
            }
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
      }
      // console.log(`rewrites after=[${Utils.join(rewrites, ", ")}]`);
      var m = new Map();
      var _iterator6 = _createForOfIteratorHelper(rewrites),
        _step6;
      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var _op3 = _step6.value;
          if (_op3 == null) {
            // ignore deleted ops
            continue;
          }
          if (m.get(_op3.index) != null) {
            throw new Error("should only be one op per index");
          }
          m.set(_op3.index, _op3);
        }
        // console.log(`index to op: ${m}`);
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
      return m;
    }
  }, {
    key: "catOpText",
    value: function catOpText(a, b) {
      var x = "";
      var y = "";
      if (a != null) {
        x = a.toString();
      }
      if (b != null) {
        y = b.toString();
      }
      return x + y;
    }
    /** Get all operations before an index of a particular kind */
  }, {
    key: "getKindOfOps",
    value: function getKindOfOps(rewrites, kind, before) {
      var ops = [];
      for (var i = 0; i < before && i < rewrites.length; i++) {
        var op = rewrites[i];
        if (op == null) {
          // ignore deleted
          continue;
        }
        if (op instanceof kind) {
          ops.push(op);
        }
      }
      return ops;
    }
  }]);
  return TokenStreamRewriter;
}();
TokenStreamRewriter.DEFAULT_PROGRAM_NAME = "default";
TokenStreamRewriter.PROGRAM_INIT_SIZE = 100;
TokenStreamRewriter.MIN_TOKEN_INDEX = 0;
exports.TokenStreamRewriter = TokenStreamRewriter;
// Define the rewrite operation hierarchy
var RewriteOperation = /*#__PURE__*/function () {
  function RewriteOperation(tokens, index, text) {
    (0, _classCallCheck2.default)(this, RewriteOperation);
    this.tokens = tokens;
    this.index = index;
    this.text = text === undefined ? "" : text;
  }
  /** Execute the rewrite operation by possibly adding to the buffer.
   *  Return the index of the next token to operate on.
   */
  (0, _createClass2.default)(RewriteOperation, [{
    key: "execute",
    value: function execute(buf) {
      return this.index;
    }
  }, {
    key: "toString",
    value: function toString() {
      var opName = this.constructor.name;
      var $index = opName.indexOf("$");
      opName = opName.substring($index + 1, opName.length);
      return "<" + opName + "@" + this.tokens.get(this.index) + ":\"" + this.text + "\">";
    }
  }]);
  return RewriteOperation;
}();
__decorate([Decorators_1.Override], RewriteOperation.prototype, "toString", null);
exports.RewriteOperation = RewriteOperation;
var InsertBeforeOp = /*#__PURE__*/function (_RewriteOperation) {
  (0, _inherits2.default)(InsertBeforeOp, _RewriteOperation);
  var _super = _createSuper(InsertBeforeOp);
  function InsertBeforeOp(tokens, index, text) {
    (0, _classCallCheck2.default)(this, InsertBeforeOp);
    return _super.call(this, tokens, index, text);
  }
  (0, _createClass2.default)(InsertBeforeOp, [{
    key: "execute",
    value: function execute(buf) {
      buf.push(this.text.toString());
      if (this.tokens.get(this.index).type !== Token_1.Token.EOF) {
        buf.push(String(this.tokens.get(this.index).text));
      }
      return this.index + 1;
    }
  }]);
  return InsertBeforeOp;
}(RewriteOperation);
__decorate([Decorators_1.Override], InsertBeforeOp.prototype, "execute", null);
/** Distinguish between insert after/before to do the "insert afters"
 *  first and then the "insert befores" at same index. Implementation
 *  of "insert after" is "insert before index+1".
 */
var InsertAfterOp = /*#__PURE__*/function (_InsertBeforeOp) {
  (0, _inherits2.default)(InsertAfterOp, _InsertBeforeOp);
  var _super2 = _createSuper(InsertAfterOp);
  function InsertAfterOp(tokens, index, text) {
    (0, _classCallCheck2.default)(this, InsertAfterOp);
    return _super2.call(this, tokens, index + 1, text); // insert after is insert before index+1
  }
  return (0, _createClass2.default)(InsertAfterOp);
}(InsertBeforeOp);
/** I'm going to try replacing range from x..y with (y-x)+1 ReplaceOp
 *  instructions.
 */
var ReplaceOp = /*#__PURE__*/function (_RewriteOperation2) {
  (0, _inherits2.default)(ReplaceOp, _RewriteOperation2);
  var _super3 = _createSuper(ReplaceOp);
  function ReplaceOp(tokens, from, to, text) {
    var _this;
    (0, _classCallCheck2.default)(this, ReplaceOp);
    _this = _super3.call(this, tokens, from, text);
    _this.lastIndex = to;
    return _this;
  }
  (0, _createClass2.default)(ReplaceOp, [{
    key: "execute",
    value: function execute(buf) {
      if (this.text != null) {
        buf.push(this.text.toString());
      }
      return this.lastIndex + 1;
    }
  }, {
    key: "toString",
    value: function toString() {
      if (this.text == null) {
        return "<DeleteOp@" + this.tokens.get(this.index) + ".." + this.tokens.get(this.lastIndex) + ">";
      }
      return "<ReplaceOp@" + this.tokens.get(this.index) + ".." + this.tokens.get(this.lastIndex) + ":\"" + this.text + "\">";
    }
  }]);
  return ReplaceOp;
}(RewriteOperation);
__decorate([Decorators_1.Override], ReplaceOp.prototype, "execute", null);
__decorate([Decorators_1.Override], ReplaceOp.prototype, "toString", null);

},{"./Decorators":272,"./Token":296,"./misc/Interval":378,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.join.js":578,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.map.js":587,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.string.replace.js":629,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],298:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:59.5829654-07:00
var Decorators_1 = require("./Decorators");
var Token_1 = require("./Token");
/**
 * This class provides a default implementation of the {@link Vocabulary}
 * interface.
 *
 * @author Sam Harwell
 */
var VocabularyImpl = /*#__PURE__*/function () {
  /**
   * Constructs a new instance of {@link VocabularyImpl} from the specified
   * literal, symbolic, and display token names.
   *
   * @param literalNames The literal names assigned to tokens, or an empty array
   * if no literal names are assigned.
   * @param symbolicNames The symbolic names assigned to tokens, or
   * an empty array if no symbolic names are assigned.
   * @param displayNames The display names assigned to tokens, or an empty array
   * to use the values in `literalNames` and `symbolicNames` as
   * the source of display names, as described in
   * {@link #getDisplayName(int)}.
   *
   * @see #getLiteralName(int)
   * @see #getSymbolicName(int)
   * @see #getDisplayName(int)
   */
  function VocabularyImpl(literalNames, symbolicNames, displayNames) {
    (0, _classCallCheck2.default)(this, VocabularyImpl);
    this.literalNames = literalNames;
    this.symbolicNames = symbolicNames;
    this.displayNames = displayNames;
    // See note here on -1 part: https://github.com/antlr/antlr4/pull/1146
    this._maxTokenType = Math.max(this.displayNames.length, Math.max(this.literalNames.length, this.symbolicNames.length)) - 1;
  }
  (0, _createClass2.default)(VocabularyImpl, [{
    key: "maxTokenType",
    get: function get() {
      return this._maxTokenType;
    }
  }, {
    key: "getLiteralName",
    value: function getLiteralName(tokenType) {
      if (tokenType >= 0 && tokenType < this.literalNames.length) {
        return this.literalNames[tokenType];
      }
      return undefined;
    }
  }, {
    key: "getSymbolicName",
    value: function getSymbolicName(tokenType) {
      if (tokenType >= 0 && tokenType < this.symbolicNames.length) {
        return this.symbolicNames[tokenType];
      }
      if (tokenType === Token_1.Token.EOF) {
        return "EOF";
      }
      return undefined;
    }
  }, {
    key: "getDisplayName",
    value: function getDisplayName(tokenType) {
      if (tokenType >= 0 && tokenType < this.displayNames.length) {
        var displayName = this.displayNames[tokenType];
        if (displayName) {
          return displayName;
        }
      }
      var literalName = this.getLiteralName(tokenType);
      if (literalName) {
        return literalName;
      }
      var symbolicName = this.getSymbolicName(tokenType);
      if (symbolicName) {
        return symbolicName;
      }
      return String(tokenType);
    }
  }]);
  return VocabularyImpl;
}();
/**
 * Gets an empty {@link Vocabulary} instance.
 *
 * No literal or symbol names are assigned to token types, so
 * {@link #getDisplayName(int)} returns the numeric value for all tokens
 * except {@link Token#EOF}.
 */
VocabularyImpl.EMPTY_VOCABULARY = new VocabularyImpl([], [], []);
__decorate([Decorators_1.NotNull], VocabularyImpl.prototype, "literalNames", void 0);
__decorate([Decorators_1.NotNull], VocabularyImpl.prototype, "symbolicNames", void 0);
__decorate([Decorators_1.NotNull], VocabularyImpl.prototype, "displayNames", void 0);
__decorate([Decorators_1.Override], VocabularyImpl.prototype, "maxTokenType", null);
__decorate([Decorators_1.Override], VocabularyImpl.prototype, "getLiteralName", null);
__decorate([Decorators_1.Override], VocabularyImpl.prototype, "getSymbolicName", null);
__decorate([Decorators_1.Override, Decorators_1.NotNull], VocabularyImpl.prototype, "getDisplayName", null);
__decorate([Decorators_1.NotNull], VocabularyImpl, "EMPTY_VOCABULARY", void 0);
exports.VocabularyImpl = VocabularyImpl;

},{"./Decorators":272,"./Token":296,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612}],299:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.map.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:25.1063510-07:00
var Array2DHashMap_1 = require("../misc/Array2DHashMap");
var DFA_1 = require("../dfa/DFA");
var IntervalSet_1 = require("../misc/IntervalSet");
var InvalidState_1 = require("./InvalidState");
var LL1Analyzer_1 = require("./LL1Analyzer");
var Decorators_1 = require("../Decorators");
var ObjectEqualityComparator_1 = require("../misc/ObjectEqualityComparator");
var PredictionContext_1 = require("./PredictionContext");
var Token_1 = require("../Token");
var assert = require("assert");
/** */
var ATN = /*#__PURE__*/function () {
  /** Used for runtime deserialization of ATNs from strings */
  function ATN(grammarType, maxTokenType) {
    (0, _classCallCheck2.default)(this, ATN);
    this.states = [];
    /** Each subrule/rule is a decision point and we must track them so we
     *  can go back later and build DFA predictors for them.  This includes
     *  all the rules, subrules, optional blocks, ()+, ()* etc...
     */
    this.decisionToState = [];
    this.modeNameToStartState = new Map();
    this.modeToStartState = [];
    this.contextCache = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
    this.decisionToDFA = [];
    this.modeToDFA = [];
    this.LL1Table = new Map();
    this.grammarType = grammarType;
    this.maxTokenType = maxTokenType;
  }
  (0, _createClass2.default)(ATN, [{
    key: "clearDFA",
    value: function clearDFA() {
      this.decisionToDFA = new Array(this.decisionToState.length);
      for (var i = 0; i < this.decisionToDFA.length; i++) {
        this.decisionToDFA[i] = new DFA_1.DFA(this.decisionToState[i], i);
      }
      this.modeToDFA = new Array(this.modeToStartState.length);
      for (var _i = 0; _i < this.modeToDFA.length; _i++) {
        this.modeToDFA[_i] = new DFA_1.DFA(this.modeToStartState[_i]);
      }
      this.contextCache.clear();
      this.LL1Table.clear();
    }
  }, {
    key: "contextCacheSize",
    get: function get() {
      return this.contextCache.size;
    }
  }, {
    key: "getCachedContext",
    value: function getCachedContext(context) {
      return PredictionContext_1.PredictionContext.getCachedContext(context, this.contextCache, new PredictionContext_1.PredictionContext.IdentityHashMap());
    }
  }, {
    key: "getDecisionToDFA",
    value: function getDecisionToDFA() {
      assert(this.decisionToDFA != null && this.decisionToDFA.length === this.decisionToState.length);
      return this.decisionToDFA;
    }
  }, {
    key: "nextTokens",
    value: function nextTokens(s, ctx) {
      if (ctx) {
        var anal = new LL1Analyzer_1.LL1Analyzer(this);
        var next = anal.LOOK(s, ctx);
        return next;
      } else {
        if (s.nextTokenWithinRule) {
          return s.nextTokenWithinRule;
        }
        s.nextTokenWithinRule = this.nextTokens(s, PredictionContext_1.PredictionContext.EMPTY_LOCAL);
        s.nextTokenWithinRule.setReadonly(true);
        return s.nextTokenWithinRule;
      }
    }
  }, {
    key: "addState",
    value: function addState(state) {
      state.atn = this;
      state.stateNumber = this.states.length;
      this.states.push(state);
    }
  }, {
    key: "removeState",
    value: function removeState(state) {
      // just replace the state, don't shift states in list
      var invalidState = new InvalidState_1.InvalidState();
      invalidState.atn = this;
      invalidState.stateNumber = state.stateNumber;
      this.states[state.stateNumber] = invalidState;
    }
  }, {
    key: "defineMode",
    value: function defineMode(name, s) {
      this.modeNameToStartState.set(name, s);
      this.modeToStartState.push(s);
      this.modeToDFA.push(new DFA_1.DFA(s));
      this.defineDecisionState(s);
    }
  }, {
    key: "defineDecisionState",
    value: function defineDecisionState(s) {
      this.decisionToState.push(s);
      s.decision = this.decisionToState.length - 1;
      this.decisionToDFA.push(new DFA_1.DFA(s, s.decision));
      return s.decision;
    }
  }, {
    key: "getDecisionState",
    value: function getDecisionState(decision) {
      if (this.decisionToState.length > 0) {
        return this.decisionToState[decision];
      }
      return undefined;
    }
  }, {
    key: "numberOfDecisions",
    get: function get() {
      return this.decisionToState.length;
    }
    /**
     * Computes the set of input symbols which could follow ATN state number
     * `stateNumber` in the specified full `context`. This method
     * considers the complete parser context, but does not evaluate semantic
     * predicates (i.e. all predicates encountered during the calculation are
     * assumed true). If a path in the ATN exists from the starting state to the
     * {@link RuleStopState} of the outermost context without matching any
     * symbols, {@link Token#EOF} is added to the returned set.
     *
     * If `context` is `undefined`, it is treated as
     * {@link ParserRuleContext#EMPTY}.
     *
     * Note that this does NOT give you the set of all tokens that could
     * appear at a given token position in the input phrase.  In other words, it
     * does not answer:
     *
     * > Given a specific partial input phrase, return the set of all
     * > tokens that can follow the last token in the input phrase.
     *
     * The big difference is that with just the input, the parser could land
     * right in the middle of a lookahead decision. Getting all
     * *possible* tokens given a partial input stream is a separate
     * computation. See https://github.com/antlr/antlr4/issues/1428
     *
     * For this function, we are specifying an ATN state and call stack to
     * compute what token(s) can come next and specifically: outside of a
     * lookahead decision. That is what you want for error reporting and
     * recovery upon parse error.
     *
     * @param stateNumber the ATN state number
     * @param context the full parse context
     * @returns The set of potentially valid input symbols which could follow the
     * specified state in the specified context.
     * @ if the ATN does not contain a state with
     * number `stateNumber`
     */
  }, {
    key: "getExpectedTokens",
    value: function getExpectedTokens(stateNumber, context) {
      if (stateNumber < 0 || stateNumber >= this.states.length) {
        throw new RangeError("Invalid state number.");
      }
      var ctx = context;
      var s = this.states[stateNumber];
      var following = this.nextTokens(s);
      if (!following.contains(Token_1.Token.EPSILON)) {
        return following;
      }
      var expected = new IntervalSet_1.IntervalSet();
      expected.addAll(following);
      expected.remove(Token_1.Token.EPSILON);
      while (ctx != null && ctx.invokingState >= 0 && following.contains(Token_1.Token.EPSILON)) {
        var invokingState = this.states[ctx.invokingState];
        var rt = invokingState.transition(0);
        following = this.nextTokens(rt.followState);
        expected.addAll(following);
        expected.remove(Token_1.Token.EPSILON);
        ctx = ctx._parent;
      }
      if (following.contains(Token_1.Token.EPSILON)) {
        expected.add(Token_1.Token.EOF);
      }
      return expected;
    }
  }]);
  return ATN;
}();
__decorate([Decorators_1.NotNull], ATN.prototype, "states", void 0);
__decorate([Decorators_1.NotNull], ATN.prototype, "decisionToState", void 0);
__decorate([Decorators_1.NotNull], ATN.prototype, "modeNameToStartState", void 0);
__decorate([Decorators_1.NotNull], ATN.prototype, "modeToStartState", void 0);
__decorate([Decorators_1.NotNull], ATN.prototype, "decisionToDFA", void 0);
__decorate([Decorators_1.NotNull], ATN.prototype, "modeToDFA", void 0);
__decorate([Decorators_1.NotNull], ATN.prototype, "nextTokens", null);
__decorate([__param(0, Decorators_1.NotNull)], ATN.prototype, "removeState", null);
__decorate([__param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)], ATN.prototype, "defineMode", null);
__decorate([__param(0, Decorators_1.NotNull)], ATN.prototype, "defineDecisionState", null);
__decorate([Decorators_1.NotNull], ATN.prototype, "getExpectedTokens", null);
ATN = __decorate([__param(0, Decorators_1.NotNull)], ATN);
exports.ATN = ATN;
(function (ATN) {
  ATN.INVALID_ALT_NUMBER = 0;
})(ATN = exports.ATN || (exports.ATN = {}));
exports.ATN = ATN;

},{"../Decorators":272,"../Token":296,"../dfa/DFA":364,"../misc/Array2DHashMap":369,"../misc/IntervalSet":379,"../misc/ObjectEqualityComparator":382,"./InvalidState":322,"./LL1Analyzer":323,"./PredictionContext":346,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"assert":413,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.map.js":587,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.string.iterator.js":626,"core-js/modules/web.dom-collections.iterator.js":677}],300:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:25.2796692-07:00
var Array2DHashMap_1 = require("../misc/Array2DHashMap");
var DecisionState_1 = require("./DecisionState");
var MurmurHash_1 = require("../misc/MurmurHash");
var Decorators_1 = require("../Decorators");
var ObjectEqualityComparator_1 = require("../misc/ObjectEqualityComparator");
var PredictionContext_1 = require("./PredictionContext");
var SemanticContext_1 = require("./SemanticContext");
var assert = require("assert");
/**
 * This field stores the bit mask for implementing the
 * {@link #isPrecedenceFilterSuppressed} property as a bit within the
 * existing {@link #altAndOuterContextDepth} field.
 */
var SUPPRESS_PRECEDENCE_FILTER = 0x80000000;
/**
 * Represents a location with context in an ATN. The location is identified by the following values:
 *
 * * The current ATN state
 * * The predicted alternative
 * * The semantic context which must be true for this configuration to be enabled
 * * The syntactic context, which is represented as a graph-structured stack whose path(s) lead to the root of the rule
 *   invocations leading to this state
 *
 * In addition to these values, `ATNConfig` stores several properties about paths taken to get to the location which
 * were added over time to help with performance, correctness, and/or debugging.
 *
 * * `reachesIntoOuterContext`:: Used to ensure semantic predicates are not evaluated in the wrong context.
 * * `hasPassedThroughNonGreedyDecision`: Used for enabling first-match-wins instead of longest-match-wins after
 *   crossing a non-greedy decision.
 * * `lexerActionExecutor`: Used for tracking the lexer action(s) to execute should this instance be selected during
 *   lexing.
 * * `isPrecedenceFilterSuppressed`: A state variable for one of the dynamic disambiguation strategies employed by
 *   `ParserATNSimulator.applyPrecedenceFilter`.
 *
 * Due to the use of a graph-structured stack, a single `ATNConfig` is capable of representing many individual ATN
 * configurations which reached the same location in an ATN by following different paths.
 *
 * PERF: To conserve memory, `ATNConfig` is split into several different concrete types. `ATNConfig` itself stores the
 * minimum amount of information typically used to define an `ATNConfig` instance. Various derived types provide
 * additional storage space for cases where a non-default value is used for some of the object properties. The
 * `ATNConfig.create` and `ATNConfig.transform` methods automatically select the smallest concrete type capable of
 * representing the unique information for any given `ATNConfig`.
 */
var ATNConfig = /*#__PURE__*/function () {
  function ATNConfig(state, altOrConfig, context) {
    (0, _classCallCheck2.default)(this, ATNConfig);
    if (typeof altOrConfig === "number") {
      assert((altOrConfig & 0xFFFFFF) === altOrConfig);
      this._state = state;
      this.altAndOuterContextDepth = altOrConfig;
      this._context = context;
    } else {
      this._state = state;
      this.altAndOuterContextDepth = altOrConfig.altAndOuterContextDepth;
      this._context = context;
    }
  }
  (0, _createClass2.default)(ATNConfig, [{
    key: "state",
    get: /** Gets the ATN state associated with this configuration */
    function get() {
      return this._state;
    }
    /** What alt (or lexer rule) is predicted by this configuration */
  }, {
    key: "alt",
    get: function get() {
      return this.altAndOuterContextDepth & 0x00FFFFFF;
    }
  }, {
    key: "context",
    get: function get() {
      return this._context;
    },
    set: function set(context) {
      this._context = context;
    }
  }, {
    key: "reachesIntoOuterContext",
    get: function get() {
      return this.outerContextDepth !== 0;
    }
    /**
     * We cannot execute predicates dependent upon local context unless
     * we know for sure we are in the correct context. Because there is
     * no way to do this efficiently, we simply cannot evaluate
     * dependent predicates unless we are in the rule that initially
     * invokes the ATN simulator.
     *
     * closure() tracks the depth of how far we dip into the outer context:
     * depth &gt; 0.  Note that it may not be totally accurate depth since I
     * don't ever decrement. TODO: make it a boolean then
     */
  }, {
    key: "outerContextDepth",
    get: function get() {
      return this.altAndOuterContextDepth >>> 24 & 0x7F;
    },
    set: function set(outerContextDepth) {
      assert(outerContextDepth >= 0);
      // saturate at 0x7F - everything but zero/positive is only used for debug information anyway
      outerContextDepth = Math.min(outerContextDepth, 0x7F);
      this.altAndOuterContextDepth = outerContextDepth << 24 | (this.altAndOuterContextDepth & ~0x7F000000) >>> 0;
    }
  }, {
    key: "lexerActionExecutor",
    get: function get() {
      return undefined;
    }
  }, {
    key: "semanticContext",
    get: function get() {
      return SemanticContext_1.SemanticContext.NONE;
    }
  }, {
    key: "hasPassedThroughNonGreedyDecision",
    get: function get() {
      return false;
    }
  }, {
    key: "clone",
    value: function clone() {
      return this.transform(this.state, false);
    }
  }, {
    key: "transform",
    value: function transform( /*@NotNull*/state, checkNonGreedy, arg2) {
      if (arg2 == null) {
        return this.transformImpl(state, this._context, this.semanticContext, checkNonGreedy, this.lexerActionExecutor);
      } else if (arg2 instanceof PredictionContext_1.PredictionContext) {
        return this.transformImpl(state, arg2, this.semanticContext, checkNonGreedy, this.lexerActionExecutor);
      } else if (arg2 instanceof SemanticContext_1.SemanticContext) {
        return this.transformImpl(state, this._context, arg2, checkNonGreedy, this.lexerActionExecutor);
      } else {
        return this.transformImpl(state, this._context, this.semanticContext, checkNonGreedy, arg2);
      }
    }
  }, {
    key: "transformImpl",
    value: function transformImpl(state, context, semanticContext, checkNonGreedy, lexerActionExecutor) {
      var passedThroughNonGreedy = checkNonGreedy && ATNConfig.checkNonGreedyDecision(this, state);
      if (semanticContext !== SemanticContext_1.SemanticContext.NONE) {
        if (lexerActionExecutor != null || passedThroughNonGreedy) {
          return new ActionSemanticContextATNConfig(lexerActionExecutor, semanticContext, state, this, context, passedThroughNonGreedy);
        } else {
          return new SemanticContextATNConfig(semanticContext, state, this, context);
        }
      } else if (lexerActionExecutor != null || passedThroughNonGreedy) {
        return new ActionATNConfig(lexerActionExecutor, state, this, context, passedThroughNonGreedy);
      } else {
        return new ATNConfig(state, this, context);
      }
    }
  }, {
    key: "appendContext",
    value: function appendContext(context, contextCache) {
      if (typeof context === "number") {
        var appendedContext = this.context.appendSingleContext(context, contextCache);
        var result = this.transform(this.state, false, appendedContext);
        return result;
      } else {
        var _appendedContext = this.context.appendContext(context, contextCache);
        var _result = this.transform(this.state, false, _appendedContext);
        return _result;
      }
    }
    /**
     * Determines if this `ATNConfig` fully contains another `ATNConfig`.
     *
     * An ATN configuration represents a position (including context) in an ATN during parsing. Since `ATNConfig` stores
     * the context as a graph, a single `ATNConfig` instance is capable of representing many ATN configurations which
     * are all in the same "location" but have different contexts. These `ATNConfig` instances are again merged when
     * they are added to an `ATNConfigSet`. This method supports `ATNConfigSet.contains` by evaluating whether a
     * particular `ATNConfig` contains all of the ATN configurations represented by another `ATNConfig`.
     *
     * An `ATNConfig` _a_ contains another `ATNConfig` _b_ if all of the following conditions are met:
     *
     * * The configurations are in the same state (`state`)
     * * The configurations predict the same alternative (`alt`)
     * * The semantic context of _a_ implies the semantic context of _b_ (this method performs a weaker equality check)
     * * Joining the prediction contexts of _a_ and _b_ results in the prediction context of _a_
     *
     * This method implements a conservative approximation of containment. As a result, when this method returns `true`
     * it is known that parsing from `subconfig` can only recognize a subset of the inputs which can be recognized
     * starting at the current `ATNConfig`. However, due to the imprecise evaluation of implication for the semantic
     * contexts, no assumptions can be made about the relationship between the configurations when this method returns
     * `false`.
     *
     * @param subconfig The sub configuration.
     * @returns `true` if this configuration contains `subconfig`; otherwise, `false`.
     */
  }, {
    key: "contains",
    value: function contains(subconfig) {
      if (this.state.stateNumber !== subconfig.state.stateNumber || this.alt !== subconfig.alt || !this.semanticContext.equals(subconfig.semanticContext)) {
        return false;
      }
      var leftWorkList = [];
      var rightWorkList = [];
      leftWorkList.push(this.context);
      rightWorkList.push(subconfig.context);
      while (true) {
        var left = leftWorkList.pop();
        var right = rightWorkList.pop();
        if (!left || !right) {
          break;
        }
        if (left === right) {
          return true;
        }
        if (left.size < right.size) {
          return false;
        }
        if (right.isEmpty) {
          return left.hasEmpty;
        } else {
          for (var i = 0; i < right.size; i++) {
            var index = left.findReturnState(right.getReturnState(i));
            if (index < 0) {
              // assumes invokingStates has no duplicate entries
              return false;
            }
            leftWorkList.push(left.getParent(index));
            rightWorkList.push(right.getParent(i));
          }
        }
      }
      return false;
    }
  }, {
    key: "isPrecedenceFilterSuppressed",
    get: function get() {
      return (this.altAndOuterContextDepth & SUPPRESS_PRECEDENCE_FILTER) !== 0;
    },
    set: function set(value) {
      if (value) {
        this.altAndOuterContextDepth |= SUPPRESS_PRECEDENCE_FILTER;
      } else {
        this.altAndOuterContextDepth &= ~SUPPRESS_PRECEDENCE_FILTER;
      }
    }
    /** An ATN configuration is equal to another if both have
     *  the same state, they predict the same alternative, and
     *  syntactic/semantic contexts are the same.
     */
  }, {
    key: "equals",
    value: function equals(o) {
      if (this === o) {
        return true;
      } else if (!(o instanceof ATNConfig)) {
        return false;
      }
      return this.state.stateNumber === o.state.stateNumber && this.alt === o.alt && this.reachesIntoOuterContext === o.reachesIntoOuterContext && this.context.equals(o.context) && this.semanticContext.equals(o.semanticContext) && this.isPrecedenceFilterSuppressed === o.isPrecedenceFilterSuppressed && this.hasPassedThroughNonGreedyDecision === o.hasPassedThroughNonGreedyDecision && ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.equals(this.lexerActionExecutor, o.lexerActionExecutor);
    }
  }, {
    key: "hashCode",
    value: function hashCode() {
      var hashCode = MurmurHash_1.MurmurHash.initialize(7);
      hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.state.stateNumber);
      hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.alt);
      hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.reachesIntoOuterContext ? 1 : 0);
      hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.context);
      hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.semanticContext);
      hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.hasPassedThroughNonGreedyDecision ? 1 : 0);
      hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.lexerActionExecutor);
      hashCode = MurmurHash_1.MurmurHash.finish(hashCode, 7);
      return hashCode;
    }
    /**
     * Returns a graphical representation of the current `ATNConfig` in Graphviz format. The graph can be stored to a
     * **.dot** file and then rendered to an image using Graphviz.
     *
     * @returns A Graphviz graph representing the current `ATNConfig`.
     *
     * @see http://www.graphviz.org/
     */
  }, {
    key: "toDotString",
    value: function toDotString() {
      var builder = "";
      builder += "digraph G {\n";
      builder += "rankdir=LR;\n";
      var visited = new Array2DHashMap_1.Array2DHashMap(PredictionContext_1.PredictionContext.IdentityEqualityComparator.INSTANCE);
      var workList = [];
      function getOrAddContext(context) {
        var newNumber = visited.size;
        var result = visited.putIfAbsent(context, newNumber);
        if (result != null) {
          // Already saw this context
          return result;
        }
        workList.push(context);
        return newNumber;
      }
      workList.push(this.context);
      visited.put(this.context, 0);
      while (true) {
        var current = workList.pop();
        if (!current) {
          break;
        }
        for (var i = 0; i < current.size; i++) {
          builder += "  s" + getOrAddContext(current);
          builder += "->";
          builder += "s" + getOrAddContext(current.getParent(i));
          builder += "[label=\"" + current.getReturnState(i) + "\"];\n";
        }
      }
      builder += "}\n";
      return builder.toString();
    }
  }, {
    key: "toString",
    value: function toString(recog, showAlt, showContext) {
      // Must check showContext before showAlt to preserve original overload behavior
      if (showContext == null) {
        showContext = showAlt != null;
      }
      if (showAlt == null) {
        showAlt = true;
      }
      var buf = "";
      // if (this.state.ruleIndex >= 0) {
      // 	if (recog != null) {
      // 		buf += (recog.ruleNames[this.state.ruleIndex] + ":");
      // 	} else {
      // 		buf += (this.state.ruleIndex + ":");
      // 	}
      // }
      var contexts;
      if (showContext) {
        contexts = this.context.toStrings(recog, this.state.stateNumber);
      } else {
        contexts = ["?"];
      }
      var first = true;
      var _iterator = _createForOfIteratorHelper(contexts),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var contextDesc = _step.value;
          if (first) {
            first = false;
          } else {
            buf += ", ";
          }
          buf += "(";
          buf += this.state;
          if (showAlt) {
            buf += ",";
            buf += this.alt;
          }
          if (this.context) {
            buf += ",";
            buf += contextDesc;
          }
          if (this.semanticContext !== SemanticContext_1.SemanticContext.NONE) {
            buf += ",";
            buf += this.semanticContext;
          }
          if (this.reachesIntoOuterContext) {
            buf += ",up=" + this.outerContextDepth;
          }
          buf += ")";
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return buf.toString();
    }
  }], [{
    key: "create",
    value: function create(state, alt, context) {
      var semanticContext = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : SemanticContext_1.SemanticContext.NONE;
      var lexerActionExecutor = arguments.length > 4 ? arguments[4] : undefined;
      if (semanticContext !== SemanticContext_1.SemanticContext.NONE) {
        if (lexerActionExecutor != null) {
          return new ActionSemanticContextATNConfig(lexerActionExecutor, semanticContext, state, alt, context, false);
        } else {
          return new SemanticContextATNConfig(semanticContext, state, alt, context);
        }
      } else if (lexerActionExecutor != null) {
        return new ActionATNConfig(lexerActionExecutor, state, alt, context, false);
      } else {
        return new ATNConfig(state, alt, context);
      }
    }
  }, {
    key: "checkNonGreedyDecision",
    value: function checkNonGreedyDecision(source, target) {
      return source.hasPassedThroughNonGreedyDecision || target instanceof DecisionState_1.DecisionState && target.nonGreedy;
    }
  }]);
  return ATNConfig;
}();
__decorate([Decorators_1.NotNull], ATNConfig.prototype, "_state", void 0);
__decorate([Decorators_1.NotNull], ATNConfig.prototype, "_context", void 0);
__decorate([Decorators_1.NotNull], ATNConfig.prototype, "state", null);
__decorate([Decorators_1.NotNull, __param(0, Decorators_1.NotNull)], ATNConfig.prototype, "context", null);
__decorate([Decorators_1.NotNull], ATNConfig.prototype, "semanticContext", null);
__decorate([Decorators_1.Override], ATNConfig.prototype, "clone", null);
__decorate([__param(0, Decorators_1.NotNull), __param(2, Decorators_1.NotNull)], ATNConfig.prototype, "transformImpl", null);
__decorate([Decorators_1.Override], ATNConfig.prototype, "equals", null);
__decorate([Decorators_1.Override], ATNConfig.prototype, "hashCode", null);
__decorate([__param(0, Decorators_1.NotNull), __param(3, Decorators_1.NotNull)], ATNConfig, "create", null);
ATNConfig = __decorate([__param(0, Decorators_1.NotNull), __param(2, Decorators_1.NotNull)], ATNConfig);
exports.ATNConfig = ATNConfig;
/**
 * This class was derived from `ATNConfig` purely as a memory optimization. It allows for the creation of an `ATNConfig`
 * with a non-default semantic context.
 *
 * See the `ATNConfig` documentation for more information about conserving memory through the use of several concrete
 * types.
 */
var SemanticContextATNConfig = /*#__PURE__*/function (_ATNConfig) {
  (0, _inherits2.default)(SemanticContextATNConfig, _ATNConfig);
  var _super = _createSuper(SemanticContextATNConfig);
  function SemanticContextATNConfig(semanticContext, state, altOrConfig, context) {
    var _this;
    (0, _classCallCheck2.default)(this, SemanticContextATNConfig);
    if (typeof altOrConfig === "number") {
      _this = _super.call(this, state, altOrConfig, context);
    } else {
      _this = _super.call(this, state, altOrConfig, context);
    }
    _this._semanticContext = semanticContext;
    return (0, _possibleConstructorReturn2.default)(_this);
  }
  (0, _createClass2.default)(SemanticContextATNConfig, [{
    key: "semanticContext",
    get: function get() {
      return this._semanticContext;
    }
  }]);
  return SemanticContextATNConfig;
}(ATNConfig);
__decorate([Decorators_1.NotNull], SemanticContextATNConfig.prototype, "_semanticContext", void 0);
__decorate([Decorators_1.Override], SemanticContextATNConfig.prototype, "semanticContext", null);
SemanticContextATNConfig = __decorate([__param(1, Decorators_1.NotNull), __param(2, Decorators_1.NotNull)], SemanticContextATNConfig);
/**
 * This class was derived from `ATNConfig` purely as a memory optimization. It allows for the creation of an `ATNConfig`
 * with a lexer action.
 *
 * See the `ATNConfig` documentation for more information about conserving memory through the use of several concrete
 * types.
 */
var ActionATNConfig = /*#__PURE__*/function (_ATNConfig2) {
  (0, _inherits2.default)(ActionATNConfig, _ATNConfig2);
  var _super2 = _createSuper(ActionATNConfig);
  function ActionATNConfig(lexerActionExecutor, state, altOrConfig, context, passedThroughNonGreedyDecision) {
    var _this2;
    (0, _classCallCheck2.default)(this, ActionATNConfig);
    if (typeof altOrConfig === "number") {
      _this2 = _super2.call(this, state, altOrConfig, context);
    } else {
      _this2 = _super2.call(this, state, altOrConfig, context);
      if (altOrConfig.semanticContext !== SemanticContext_1.SemanticContext.NONE) {
        throw new Error("Not supported");
      }
    }
    _this2._lexerActionExecutor = lexerActionExecutor;
    _this2.passedThroughNonGreedyDecision = passedThroughNonGreedyDecision;
    return (0, _possibleConstructorReturn2.default)(_this2);
  }
  (0, _createClass2.default)(ActionATNConfig, [{
    key: "lexerActionExecutor",
    get: function get() {
      return this._lexerActionExecutor;
    }
  }, {
    key: "hasPassedThroughNonGreedyDecision",
    get: function get() {
      return this.passedThroughNonGreedyDecision;
    }
  }]);
  return ActionATNConfig;
}(ATNConfig);
__decorate([Decorators_1.Override], ActionATNConfig.prototype, "lexerActionExecutor", null);
__decorate([Decorators_1.Override], ActionATNConfig.prototype, "hasPassedThroughNonGreedyDecision", null);
ActionATNConfig = __decorate([__param(1, Decorators_1.NotNull), __param(2, Decorators_1.NotNull)], ActionATNConfig);
/**
 * This class was derived from `SemanticContextATNConfig` purely as a memory optimization. It allows for the creation of
 * an `ATNConfig` with both a lexer action and a non-default semantic context.
 *
 * See the `ATNConfig` documentation for more information about conserving memory through the use of several concrete
 * types.
 */
var ActionSemanticContextATNConfig = /*#__PURE__*/function (_SemanticContextATNCo) {
  (0, _inherits2.default)(ActionSemanticContextATNConfig, _SemanticContextATNCo);
  var _super3 = _createSuper(ActionSemanticContextATNConfig);
  function ActionSemanticContextATNConfig(lexerActionExecutor, semanticContext, state, altOrConfig, context, passedThroughNonGreedyDecision) {
    var _this3;
    (0, _classCallCheck2.default)(this, ActionSemanticContextATNConfig);
    if (typeof altOrConfig === "number") {
      _this3 = _super3.call(this, semanticContext, state, altOrConfig, context);
    } else {
      _this3 = _super3.call(this, semanticContext, state, altOrConfig, context);
    }
    _this3._lexerActionExecutor = lexerActionExecutor;
    _this3.passedThroughNonGreedyDecision = passedThroughNonGreedyDecision;
    return (0, _possibleConstructorReturn2.default)(_this3);
  }
  (0, _createClass2.default)(ActionSemanticContextATNConfig, [{
    key: "lexerActionExecutor",
    get: function get() {
      return this._lexerActionExecutor;
    }
  }, {
    key: "hasPassedThroughNonGreedyDecision",
    get: function get() {
      return this.passedThroughNonGreedyDecision;
    }
  }]);
  return ActionSemanticContextATNConfig;
}(SemanticContextATNConfig);
__decorate([Decorators_1.Override], ActionSemanticContextATNConfig.prototype, "lexerActionExecutor", null);
__decorate([Decorators_1.Override], ActionSemanticContextATNConfig.prototype, "hasPassedThroughNonGreedyDecision", null);
ActionSemanticContextATNConfig = __decorate([__param(1, Decorators_1.NotNull), __param(2, Decorators_1.NotNull)], ActionSemanticContextATNConfig);

},{"../Decorators":272,"../misc/Array2DHashMap":369,"../misc/MurmurHash":381,"../misc/ObjectEqualityComparator":382,"./DecisionState":319,"./PredictionContext":346,"./SemanticContext":354,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"assert":413,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],301:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.regexp.exec.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.array.join.js");
require("core-js/modules/es.array.splice.js");
require("core-js/modules/es.array.sort.js");
require("core-js/modules/es.regexp.to-string.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:25.5488013-07:00
var Array2DHashMap_1 = require("../misc/Array2DHashMap");
var Array2DHashSet_1 = require("../misc/Array2DHashSet");
var ArrayEqualityComparator_1 = require("../misc/ArrayEqualityComparator");
var ATN_1 = require("./ATN");
var ATNConfig_1 = require("./ATNConfig");
var BitSet_1 = require("../misc/BitSet");
var Decorators_1 = require("../Decorators");
var ObjectEqualityComparator_1 = require("../misc/ObjectEqualityComparator");
var PredictionContext_1 = require("./PredictionContext");
var PredictionContextCache_1 = require("./PredictionContextCache");
var SemanticContext_1 = require("./SemanticContext");
var assert = require("assert");
var Utils = require("../misc/Utils");
var KeyTypeEqualityComparer = /*#__PURE__*/function () {
  function KeyTypeEqualityComparer() {
    (0, _classCallCheck2.default)(this, KeyTypeEqualityComparer);
  }
  (0, _createClass2.default)(KeyTypeEqualityComparer, [{
    key: "hashCode",
    value: function hashCode(key) {
      return key.state ^ key.alt;
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return a.state === b.state && a.alt === b.alt;
    }
  }]);
  return KeyTypeEqualityComparer;
}();
KeyTypeEqualityComparer.INSTANCE = new KeyTypeEqualityComparer();
function NewKeyedConfigMap(map) {
  if (map) {
    return new Array2DHashMap_1.Array2DHashMap(map);
  } else {
    return new Array2DHashMap_1.Array2DHashMap(KeyTypeEqualityComparer.INSTANCE);
  }
}
/**
 * Represents a set of ATN configurations (see `ATNConfig`). As configurations are added to the set, they are merged
 * with other `ATNConfig` instances already in the set when possible using the graph-structured stack.
 *
 * An instance of this class represents the complete set of positions (with context) in an ATN which would be associated
 * with a single DFA state. Its internal representation is more complex than traditional state used for NFA to DFA
 * conversion due to performance requirements (both improving speed and reducing memory overhead) as well as supporting
 * features such as semantic predicates and non-greedy operators in a form to support ANTLR's prediction algorithm.
 *
 * @author Sam Harwell
 */
var ATNConfigSet = /*#__PURE__*/function () {
  function ATNConfigSet(set, readonly) {
    (0, _classCallCheck2.default)(this, ATNConfigSet);
    this._uniqueAlt = 0;
    // Used in parser and lexer. In lexer, it indicates we hit a pred
    // while computing a closure operation.  Don't make a DFA state from this.
    this._hasSemanticContext = false;
    this._dipsIntoOuterContext = false;
    /**
     * When `true`, this config set represents configurations where the entire
     * outer context has been consumed by the ATN interpreter. This prevents the
     * {@link ParserATNSimulator#closure} from pursuing the global FOLLOW when a
     * rule stop state is reached with an empty prediction context.
     *
     * Note: `outermostConfigSet` and {@link #dipsIntoOuterContext} should never
     * be true at the same time.
     */
    this.outermostConfigSet = false;
    this.cachedHashCode = -1;
    if (!set) {
      this.mergedConfigs = NewKeyedConfigMap();
      this.unmerged = [];
      this.configs = [];
      this._uniqueAlt = ATN_1.ATN.INVALID_ALT_NUMBER;
    } else {
      if (readonly) {
        this.mergedConfigs = undefined;
        this.unmerged = undefined;
      } else if (!set.isReadOnly) {
        this.mergedConfigs = NewKeyedConfigMap(set.mergedConfigs);
        this.unmerged = set.unmerged.slice(0);
      } else {
        this.mergedConfigs = NewKeyedConfigMap();
        this.unmerged = [];
      }
      this.configs = set.configs.slice(0);
      this._dipsIntoOuterContext = set._dipsIntoOuterContext;
      this._hasSemanticContext = set._hasSemanticContext;
      this.outermostConfigSet = set.outermostConfigSet;
      if (readonly || !set.isReadOnly) {
        this._uniqueAlt = set._uniqueAlt;
        this._conflictInfo = set._conflictInfo;
      }
      // if (!readonly && set.isReadOnly) -> addAll is called from clone()
    }
  }
  /**
   * Get the set of all alternatives represented by configurations in this
   * set.
   */
  (0, _createClass2.default)(ATNConfigSet, [{
    key: "getRepresentedAlternatives",
    value: function getRepresentedAlternatives() {
      if (this._conflictInfo != null) {
        return this._conflictInfo.conflictedAlts.clone();
      }
      var alts = new BitSet_1.BitSet();
      var _iterator = _createForOfIteratorHelper(this),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var config = _step.value;
          alts.set(config.alt);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return alts;
    }
  }, {
    key: "isReadOnly",
    get: function get() {
      return this.mergedConfigs == null;
    }
  }, {
    key: "isOutermostConfigSet",
    get: function get() {
      return this.outermostConfigSet;
    },
    set: function set(outermostConfigSet) {
      if (this.outermostConfigSet && !outermostConfigSet) {
        throw new Error("IllegalStateException");
      }
      assert(!outermostConfigSet || !this._dipsIntoOuterContext);
      this.outermostConfigSet = outermostConfigSet;
    }
  }, {
    key: "getStates",
    value: function getStates() {
      var states = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
      var _iterator2 = _createForOfIteratorHelper(this.configs),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var c = _step2.value;
          states.add(c.state);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return states;
    }
  }, {
    key: "optimizeConfigs",
    value: function optimizeConfigs(interpreter) {
      if (this.configs.length === 0) {
        return;
      }
      var _iterator3 = _createForOfIteratorHelper(this.configs),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var config = _step3.value;
          config.context = interpreter.atn.getCachedContext(config.context);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
  }, {
    key: "clone",
    value: function clone(readonly) {
      var copy = new ATNConfigSet(this, readonly);
      if (!readonly && this.isReadOnly) {
        copy.addAll(this.configs);
      }
      return copy;
    }
  }, {
    key: "size",
    get: function get() {
      return this.configs.length;
    }
  }, {
    key: "isEmpty",
    get: function get() {
      return this.configs.length === 0;
    }
  }, {
    key: "contains",
    value: function contains(o) {
      if (!(o instanceof ATNConfig_1.ATNConfig)) {
        return false;
      }
      if (this.mergedConfigs && this.unmerged) {
        var config = o;
        var configKey = this.getKey(config);
        var mergedConfig = this.mergedConfigs.get(configKey);
        if (mergedConfig != null && this.canMerge(config, configKey, mergedConfig)) {
          return mergedConfig.contains(config);
        }
        var _iterator4 = _createForOfIteratorHelper(this.unmerged),
          _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var c = _step4.value;
            if (c.contains(o)) {
              return true;
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
      } else {
        var _iterator5 = _createForOfIteratorHelper(this.configs),
          _step5;
        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var _c = _step5.value;
            if (_c.contains(o)) {
              return true;
            }
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
      }
      return false;
    }
  }, {
    key: Symbol.iterator,
    value: /*#__PURE__*/_regenerator.default.mark(function value() {
      return _regenerator.default.wrap(function value$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            return _context.delegateYield(this.configs, "t0", 1);
          case 1:
          case "end":
            return _context.stop();
        }
      }, value, this);
    })
  }, {
    key: "toArray",
    value: function toArray() {
      return this.configs;
    }
  }, {
    key: "add",
    value: function add(e, contextCache) {
      this.ensureWritable();
      if (!this.mergedConfigs || !this.unmerged) {
        throw new Error("Covered by ensureWritable but duplicated here for strict null check limitation");
      }
      assert(!this.outermostConfigSet || !e.reachesIntoOuterContext);
      if (contextCache == null) {
        contextCache = PredictionContextCache_1.PredictionContextCache.UNCACHED;
      }
      var addKey;
      var key = this.getKey(e);
      var mergedConfig = this.mergedConfigs.get(key);
      addKey = mergedConfig == null;
      if (mergedConfig != null && this.canMerge(e, key, mergedConfig)) {
        mergedConfig.outerContextDepth = Math.max(mergedConfig.outerContextDepth, e.outerContextDepth);
        if (e.isPrecedenceFilterSuppressed) {
          mergedConfig.isPrecedenceFilterSuppressed = true;
        }
        var joined = PredictionContext_1.PredictionContext.join(mergedConfig.context, e.context, contextCache);
        this.updatePropertiesForMergedConfig(e);
        if (mergedConfig.context === joined) {
          return false;
        }
        mergedConfig.context = joined;
        return true;
      }
      for (var i = 0; i < this.unmerged.length; i++) {
        var unmergedConfig = this.unmerged[i];
        if (this.canMerge(e, key, unmergedConfig)) {
          unmergedConfig.outerContextDepth = Math.max(unmergedConfig.outerContextDepth, e.outerContextDepth);
          if (e.isPrecedenceFilterSuppressed) {
            unmergedConfig.isPrecedenceFilterSuppressed = true;
          }
          var _joined = PredictionContext_1.PredictionContext.join(unmergedConfig.context, e.context, contextCache);
          this.updatePropertiesForMergedConfig(e);
          if (unmergedConfig.context === _joined) {
            return false;
          }
          unmergedConfig.context = _joined;
          if (addKey) {
            this.mergedConfigs.put(key, unmergedConfig);
            this.unmerged.splice(i, 1);
          }
          return true;
        }
      }
      this.configs.push(e);
      if (addKey) {
        this.mergedConfigs.put(key, e);
      } else {
        this.unmerged.push(e);
      }
      this.updatePropertiesForAddedConfig(e);
      return true;
    }
  }, {
    key: "updatePropertiesForMergedConfig",
    value: function updatePropertiesForMergedConfig(config) {
      // merged configs can't change the alt or semantic context
      this._dipsIntoOuterContext = this._dipsIntoOuterContext || config.reachesIntoOuterContext;
      assert(!this.outermostConfigSet || !this._dipsIntoOuterContext);
    }
  }, {
    key: "updatePropertiesForAddedConfig",
    value: function updatePropertiesForAddedConfig(config) {
      if (this.configs.length === 1) {
        this._uniqueAlt = config.alt;
      } else if (this._uniqueAlt !== config.alt) {
        this._uniqueAlt = ATN_1.ATN.INVALID_ALT_NUMBER;
      }
      this._hasSemanticContext = this._hasSemanticContext || !SemanticContext_1.SemanticContext.NONE.equals(config.semanticContext);
      this._dipsIntoOuterContext = this._dipsIntoOuterContext || config.reachesIntoOuterContext;
      assert(!this.outermostConfigSet || !this._dipsIntoOuterContext);
    }
  }, {
    key: "canMerge",
    value: function canMerge(left, leftKey, right) {
      if (left.state.stateNumber !== right.state.stateNumber) {
        return false;
      }
      if (leftKey.alt !== right.alt) {
        return false;
      }
      return left.semanticContext.equals(right.semanticContext);
    }
  }, {
    key: "getKey",
    value: function getKey(e) {
      return {
        state: e.state.stateNumber,
        alt: e.alt
      };
    }
  }, {
    key: "containsAll",
    value: function containsAll(c) {
      var _iterator6 = _createForOfIteratorHelper(c),
        _step6;
      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var o = _step6.value;
          if (!(o instanceof ATNConfig_1.ATNConfig)) {
            return false;
          }
          if (!this.contains(o)) {
            return false;
          }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
      return true;
    }
  }, {
    key: "addAll",
    value: function addAll(c, contextCache) {
      this.ensureWritable();
      var changed = false;
      var _iterator7 = _createForOfIteratorHelper(c),
        _step7;
      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var group = _step7.value;
          if (this.add(group, contextCache)) {
            changed = true;
          }
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }
      return changed;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.ensureWritable();
      if (!this.mergedConfigs || !this.unmerged) {
        throw new Error("Covered by ensureWritable but duplicated here for strict null check limitation");
      }
      this.mergedConfigs.clear();
      this.unmerged.length = 0;
      this.configs.length = 0;
      this._dipsIntoOuterContext = false;
      this._hasSemanticContext = false;
      this._uniqueAlt = ATN_1.ATN.INVALID_ALT_NUMBER;
      this._conflictInfo = undefined;
    }
  }, {
    key: "equals",
    value: function equals(obj) {
      if (this === obj) {
        return true;
      }
      if (!(obj instanceof ATNConfigSet)) {
        return false;
      }
      return this.outermostConfigSet === obj.outermostConfigSet && Utils.equals(this._conflictInfo, obj._conflictInfo) && ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this.configs, obj.configs);
    }
  }, {
    key: "hashCode",
    value: function hashCode() {
      if (this.isReadOnly && this.cachedHashCode !== -1) {
        return this.cachedHashCode;
      }
      var hashCode = 1;
      hashCode = 5 * hashCode ^ (this.outermostConfigSet ? 1 : 0);
      hashCode = 5 * hashCode ^ ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.hashCode(this.configs);
      if (this.isReadOnly) {
        this.cachedHashCode = hashCode;
      }
      return hashCode;
    }
  }, {
    key: "toString",
    value: function toString(showContext) {
      if (showContext == null) {
        showContext = false;
      }
      var buf = "";
      var sortedConfigs = this.configs.slice(0);
      sortedConfigs.sort(function (o1, o2) {
        if (o1.alt !== o2.alt) {
          return o1.alt - o2.alt;
        } else if (o1.state.stateNumber !== o2.state.stateNumber) {
          return o1.state.stateNumber - o2.state.stateNumber;
        } else {
          return o1.semanticContext.toString().localeCompare(o2.semanticContext.toString());
        }
      });
      buf += "[";
      for (var i = 0; i < sortedConfigs.length; i++) {
        if (i > 0) {
          buf += ", ";
        }
        buf += sortedConfigs[i].toString(undefined, true, showContext);
      }
      buf += "]";
      if (this._hasSemanticContext) {
        buf += ",hasSemanticContext=" + this._hasSemanticContext;
      }
      if (this._uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
        buf += ",uniqueAlt=" + this._uniqueAlt;
      }
      if (this._conflictInfo != null) {
        buf += ",conflictingAlts=" + this._conflictInfo.conflictedAlts;
        if (!this._conflictInfo.isExact) {
          buf += "*";
        }
      }
      if (this._dipsIntoOuterContext) {
        buf += ",dipsIntoOuterContext";
      }
      return buf.toString();
    }
  }, {
    key: "uniqueAlt",
    get: function get() {
      return this._uniqueAlt;
    }
  }, {
    key: "hasSemanticContext",
    get: function get() {
      return this._hasSemanticContext;
    }
  }, {
    key: "hasSemanticContext",
    set: function set(value) {
      this.ensureWritable();
      this._hasSemanticContext = value;
    }
  }, {
    key: "conflictInfo",
    get: function get() {
      return this._conflictInfo;
    }
  }, {
    key: "conflictInfo",
    set: function set(conflictInfo) {
      this.ensureWritable();
      this._conflictInfo = conflictInfo;
    }
  }, {
    key: "conflictingAlts",
    get: function get() {
      if (this._conflictInfo == null) {
        return undefined;
      }
      return this._conflictInfo.conflictedAlts;
    }
  }, {
    key: "isExactConflict",
    get: function get() {
      if (this._conflictInfo == null) {
        return false;
      }
      return this._conflictInfo.isExact;
    }
  }, {
    key: "dipsIntoOuterContext",
    get: function get() {
      return this._dipsIntoOuterContext;
    }
  }, {
    key: "get",
    value: function get(index) {
      return this.configs[index];
    }
  }, {
    key: "ensureWritable",
    value: function ensureWritable() {
      if (this.isReadOnly) {
        throw new Error("This ATNConfigSet is read only.");
      }
    }
  }]);
  return ATNConfigSet;
}();
__decorate([Decorators_1.NotNull], ATNConfigSet.prototype, "getRepresentedAlternatives", null);
__decorate([Decorators_1.Override], ATNConfigSet.prototype, "size", null);
__decorate([Decorators_1.Override], ATNConfigSet.prototype, "isEmpty", null);
__decorate([Decorators_1.Override], ATNConfigSet.prototype, "contains", null);
__decorate([Decorators_1.Override], ATNConfigSet.prototype, Symbol.iterator, null);
__decorate([Decorators_1.Override], ATNConfigSet.prototype, "toArray", null);
__decorate([Decorators_1.Override], ATNConfigSet.prototype, "containsAll", null);
__decorate([Decorators_1.Override], ATNConfigSet.prototype, "clear", null);
__decorate([Decorators_1.Override], ATNConfigSet.prototype, "equals", null);
__decorate([Decorators_1.Override], ATNConfigSet.prototype, "hashCode", null);
exports.ATNConfigSet = ATNConfigSet;

},{"../Decorators":272,"../misc/Array2DHashMap":369,"../misc/Array2DHashSet":370,"../misc/ArrayEqualityComparator":371,"../misc/BitSet":373,"../misc/ObjectEqualityComparator":382,"../misc/Utils":385,"./ATN":299,"./ATNConfig":300,"./PredictionContext":346,"./PredictionContextCache":347,"./SemanticContext":354,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"@babel/runtime/regenerator":255,"assert":413,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.join.js":578,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.array.sort.js":581,"core-js/modules/es.array.splice.js":582,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],302:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:25.8187912-07:00
var Decorators_1 = require("../Decorators");
/**
 *
 * @author Sam Harwell
 */
var ATNDeserializationOptions = /*#__PURE__*/function () {
  function ATNDeserializationOptions(options) {
    (0, _classCallCheck2.default)(this, ATNDeserializationOptions);
    this.readOnly = false;
    if (options) {
      this.verifyATN = options.verifyATN;
      this.generateRuleBypassTransitions = options.generateRuleBypassTransitions;
      this.optimize = options.optimize;
    } else {
      this.verifyATN = true;
      this.generateRuleBypassTransitions = false;
      this.optimize = true;
    }
  }
  (0, _createClass2.default)(ATNDeserializationOptions, [{
    key: "isReadOnly",
    get: function get() {
      return this.readOnly;
    }
  }, {
    key: "makeReadOnly",
    value: function makeReadOnly() {
      this.readOnly = true;
    }
  }, {
    key: "isVerifyATN",
    get: function get() {
      return this.verifyATN;
    },
    set: function set(verifyATN) {
      this.throwIfReadOnly();
      this.verifyATN = verifyATN;
    }
  }, {
    key: "isGenerateRuleBypassTransitions",
    get: function get() {
      return this.generateRuleBypassTransitions;
    },
    set: function set(generateRuleBypassTransitions) {
      this.throwIfReadOnly();
      this.generateRuleBypassTransitions = generateRuleBypassTransitions;
    }
  }, {
    key: "isOptimize",
    get: function get() {
      return this.optimize;
    },
    set: function set(optimize) {
      this.throwIfReadOnly();
      this.optimize = optimize;
    }
  }, {
    key: "throwIfReadOnly",
    value: function throwIfReadOnly() {
      if (this.isReadOnly) {
        throw new Error("The object is read only.");
      }
    }
  }], [{
    key: "defaultOptions",
    get: function get() {
      if (ATNDeserializationOptions._defaultOptions == null) {
        ATNDeserializationOptions._defaultOptions = new ATNDeserializationOptions();
        ATNDeserializationOptions._defaultOptions.makeReadOnly();
      }
      return ATNDeserializationOptions._defaultOptions;
    }
  }]);
  return ATNDeserializationOptions;
}();
__decorate([Decorators_1.NotNull], ATNDeserializationOptions, "defaultOptions", null);
exports.ATNDeserializationOptions = ATNDeserializationOptions;

},{"../Decorators":272,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612}],303:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.array.concat.js");
require("core-js/modules/es.array.find-index.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array-buffer.slice.js");
require("core-js/modules/es.typed-array.int32-array.js");
require("core-js/modules/es.typed-array.copy-within.js");
require("core-js/modules/es.typed-array.every.js");
require("core-js/modules/es.typed-array.fill.js");
require("core-js/modules/es.typed-array.filter.js");
require("core-js/modules/es.typed-array.find.js");
require("core-js/modules/es.typed-array.find-index.js");
require("core-js/modules/es.typed-array.for-each.js");
require("core-js/modules/es.typed-array.includes.js");
require("core-js/modules/es.typed-array.index-of.js");
require("core-js/modules/es.typed-array.iterator.js");
require("core-js/modules/es.typed-array.join.js");
require("core-js/modules/es.typed-array.last-index-of.js");
require("core-js/modules/es.typed-array.map.js");
require("core-js/modules/es.typed-array.reduce.js");
require("core-js/modules/es.typed-array.reduce-right.js");
require("core-js/modules/es.typed-array.reverse.js");
require("core-js/modules/es.typed-array.set.js");
require("core-js/modules/es.typed-array.slice.js");
require("core-js/modules/es.typed-array.some.js");
require("core-js/modules/es.typed-array.sort.js");
require("core-js/modules/es.typed-array.subarray.js");
require("core-js/modules/es.typed-array.to-locale-string.js");
require("core-js/modules/es.typed-array.to-string.js");
require("core-js/modules/es.map.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:25.9683447-07:00
var ActionTransition_1 = require("./ActionTransition");
var Array2DHashSet_1 = require("../misc/Array2DHashSet");
var ATN_1 = require("./ATN");
var ATNDeserializationOptions_1 = require("./ATNDeserializationOptions");
var ATNStateType_1 = require("./ATNStateType");
var AtomTransition_1 = require("./AtomTransition");
var BasicBlockStartState_1 = require("./BasicBlockStartState");
var BasicState_1 = require("./BasicState");
var BitSet_1 = require("../misc/BitSet");
var BlockEndState_1 = require("./BlockEndState");
var BlockStartState_1 = require("./BlockStartState");
var DecisionState_1 = require("./DecisionState");
var DFA_1 = require("../dfa/DFA");
var EpsilonTransition_1 = require("./EpsilonTransition");
var IntervalSet_1 = require("../misc/IntervalSet");
var InvalidState_1 = require("./InvalidState");
var LexerChannelAction_1 = require("./LexerChannelAction");
var LexerCustomAction_1 = require("./LexerCustomAction");
var LexerModeAction_1 = require("./LexerModeAction");
var LexerMoreAction_1 = require("./LexerMoreAction");
var LexerPopModeAction_1 = require("./LexerPopModeAction");
var LexerPushModeAction_1 = require("./LexerPushModeAction");
var LexerSkipAction_1 = require("./LexerSkipAction");
var LexerTypeAction_1 = require("./LexerTypeAction");
var LoopEndState_1 = require("./LoopEndState");
var Decorators_1 = require("../Decorators");
var NotSetTransition_1 = require("./NotSetTransition");
var ParserATNSimulator_1 = require("./ParserATNSimulator");
var PlusBlockStartState_1 = require("./PlusBlockStartState");
var PlusLoopbackState_1 = require("./PlusLoopbackState");
var PrecedencePredicateTransition_1 = require("./PrecedencePredicateTransition");
var PredicateTransition_1 = require("./PredicateTransition");
var RangeTransition_1 = require("./RangeTransition");
var RuleStartState_1 = require("./RuleStartState");
var RuleStopState_1 = require("./RuleStopState");
var RuleTransition_1 = require("./RuleTransition");
var SetTransition_1 = require("./SetTransition");
var StarBlockStartState_1 = require("./StarBlockStartState");
var StarLoopbackState_1 = require("./StarLoopbackState");
var StarLoopEntryState_1 = require("./StarLoopEntryState");
var Token_1 = require("../Token");
var TokensStartState_1 = require("./TokensStartState");
var UUID_1 = require("../misc/UUID");
var WildcardTransition_1 = require("./WildcardTransition");
var UnicodeDeserializingMode;
(function (UnicodeDeserializingMode) {
  UnicodeDeserializingMode[UnicodeDeserializingMode["UNICODE_BMP"] = 0] = "UNICODE_BMP";
  UnicodeDeserializingMode[UnicodeDeserializingMode["UNICODE_SMP"] = 1] = "UNICODE_SMP";
})(UnicodeDeserializingMode || (UnicodeDeserializingMode = {}));
/**
 *
 * @author Sam Harwell
 */
var ATNDeserializer = /*#__PURE__*/function () {
  function ATNDeserializer(deserializationOptions) {
    (0, _classCallCheck2.default)(this, ATNDeserializer);
    if (deserializationOptions == null) {
      deserializationOptions = ATNDeserializationOptions_1.ATNDeserializationOptions.defaultOptions;
    }
    this.deserializationOptions = deserializationOptions;
  }
  (0, _createClass2.default)(ATNDeserializer, [{
    key: "deserialize",
    value: function deserialize(data) {
      data = data.slice(0);
      // Each Uint16 value in data is shifted by +2 at the entry to this method. This is an encoding optimization
      // targeting the serialized values 0 and -1 (serialized to 0xFFFF), each of which are very common in the
      // serialized form of the ATN. In the modified UTF-8 that Java uses for compiled string literals, these two
      // character values have multi-byte forms. By shifting each value by +2, they become characters 2 and 1 prior to
      // writing the string, each of which have single-byte representations. Since the shift occurs in the tool during
      // ATN serialization, each target is responsible for adjusting the values during deserialization.
      //
      // As a special case, note that the first element of data is not adjusted because it contains the major version
      // number of the serialized ATN, which was fixed at 3 at the time the value shifting was implemented.
      for (var i = 1; i < data.length; i++) {
        data[i] = data[i] - 2 & 0xFFFF;
      }
      var p = 0;
      var version = ATNDeserializer.toInt(data[p++]);
      if (version !== ATNDeserializer.SERIALIZED_VERSION) {
        var reason = "Could not deserialize ATN with version ".concat(version, " (expected ").concat(ATNDeserializer.SERIALIZED_VERSION, ").");
        throw new Error(reason);
      }
      var uuid = ATNDeserializer.toUUID(data, p);
      p += 8;
      if (ATNDeserializer.SUPPORTED_UUIDS.findIndex(function (e) {
        return e.equals(uuid);
      }) < 0) {
        var _reason = "Could not deserialize ATN with UUID ".concat(uuid, " (expected ").concat(ATNDeserializer.SERIALIZED_UUID, " or a legacy UUID).");
        throw new Error(_reason);
      }
      var supportsLexerActions = ATNDeserializer.isFeatureSupported(ATNDeserializer.ADDED_LEXER_ACTIONS, uuid);
      var grammarType = ATNDeserializer.toInt(data[p++]);
      var maxTokenType = ATNDeserializer.toInt(data[p++]);
      var atn = new ATN_1.ATN(grammarType, maxTokenType);
      //
      // STATES
      //
      var loopBackStateNumbers = [];
      var endStateNumbers = [];
      var nstates = ATNDeserializer.toInt(data[p++]);
      for (var _i = 0; _i < nstates; _i++) {
        var stype = ATNDeserializer.toInt(data[p++]);
        // ignore bad type of states
        if (stype === ATNStateType_1.ATNStateType.INVALID_TYPE) {
          atn.addState(new InvalidState_1.InvalidState());
          continue;
        }
        var ruleIndex = ATNDeserializer.toInt(data[p++]);
        if (ruleIndex === 0xFFFF) {
          ruleIndex = -1;
        }
        var s = this.stateFactory(stype, ruleIndex);
        if (stype === ATNStateType_1.ATNStateType.LOOP_END) {
          // special case
          var loopBackStateNumber = ATNDeserializer.toInt(data[p++]);
          loopBackStateNumbers.push([s, loopBackStateNumber]);
        } else if (s instanceof BlockStartState_1.BlockStartState) {
          var endStateNumber = ATNDeserializer.toInt(data[p++]);
          endStateNumbers.push([s, endStateNumber]);
        }
        atn.addState(s);
      }
      // delay the assignment of loop back and end states until we know all the state instances have been initialized
      for (var _i2 = 0, _loopBackStateNumbers = loopBackStateNumbers; _i2 < _loopBackStateNumbers.length; _i2++) {
        var pair = _loopBackStateNumbers[_i2];
        pair[0].loopBackState = atn.states[pair[1]];
      }
      for (var _i3 = 0, _endStateNumbers = endStateNumbers; _i3 < _endStateNumbers.length; _i3++) {
        var _pair = _endStateNumbers[_i3];
        _pair[0].endState = atn.states[_pair[1]];
      }
      var numNonGreedyStates = ATNDeserializer.toInt(data[p++]);
      for (var _i4 = 0; _i4 < numNonGreedyStates; _i4++) {
        var stateNumber = ATNDeserializer.toInt(data[p++]);
        atn.states[stateNumber].nonGreedy = true;
      }
      var numSllDecisions = ATNDeserializer.toInt(data[p++]);
      for (var _i5 = 0; _i5 < numSllDecisions; _i5++) {
        var _stateNumber = ATNDeserializer.toInt(data[p++]);
        atn.states[_stateNumber].sll = true;
      }
      var numPrecedenceStates = ATNDeserializer.toInt(data[p++]);
      for (var _i6 = 0; _i6 < numPrecedenceStates; _i6++) {
        var _stateNumber2 = ATNDeserializer.toInt(data[p++]);
        atn.states[_stateNumber2].isPrecedenceRule = true;
      }
      //
      // RULES
      //
      var nrules = ATNDeserializer.toInt(data[p++]);
      if (atn.grammarType === 0 /* LEXER */) {
        atn.ruleToTokenType = new Int32Array(nrules);
      }
      atn.ruleToStartState = new Array(nrules);
      for (var _i7 = 0; _i7 < nrules; _i7++) {
        var _s = ATNDeserializer.toInt(data[p++]);
        var startState = atn.states[_s];
        startState.leftFactored = ATNDeserializer.toInt(data[p++]) !== 0;
        atn.ruleToStartState[_i7] = startState;
        if (atn.grammarType === 0 /* LEXER */) {
          var tokenType = ATNDeserializer.toInt(data[p++]);
          if (tokenType === 0xFFFF) {
            tokenType = Token_1.Token.EOF;
          }
          atn.ruleToTokenType[_i7] = tokenType;
          if (!ATNDeserializer.isFeatureSupported(ATNDeserializer.ADDED_LEXER_ACTIONS, uuid)) {
            // this piece of unused metadata was serialized prior to the
            // addition of LexerAction
            var actionIndexIgnored = ATNDeserializer.toInt(data[p++]);
            if (actionIndexIgnored === 0xFFFF) {
              actionIndexIgnored = -1;
            }
          }
        }
      }
      atn.ruleToStopState = new Array(nrules);
      var _iterator = _createForOfIteratorHelper(atn.states),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _state3 = _step.value;
          if (!(_state3 instanceof RuleStopState_1.RuleStopState)) {
            continue;
          }
          atn.ruleToStopState[_state3.ruleIndex] = _state3;
          atn.ruleToStartState[_state3.ruleIndex].stopState = _state3;
        }
        //
        // MODES
        //
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      var nmodes = ATNDeserializer.toInt(data[p++]);
      for (var _i8 = 0; _i8 < nmodes; _i8++) {
        var _s2 = ATNDeserializer.toInt(data[p++]);
        atn.modeToStartState.push(atn.states[_s2]);
      }
      atn.modeToDFA = new Array(nmodes);
      for (var _i9 = 0; _i9 < nmodes; _i9++) {
        atn.modeToDFA[_i9] = new DFA_1.DFA(atn.modeToStartState[_i9]);
      }
      //
      // SETS
      //
      var sets = [];
      // First, read all sets with 16-bit Unicode code points <= U+FFFF.
      p = this.deserializeSets(data, p, sets, ATNDeserializer.getUnicodeDeserializer(0 /* UNICODE_BMP */));
      // Next, if the ATN was serialized with the Unicode SMP feature,
      // deserialize sets with 32-bit arguments <= U+10FFFF.
      if (ATNDeserializer.isFeatureSupported(ATNDeserializer.ADDED_UNICODE_SMP, uuid)) {
        p = this.deserializeSets(data, p, sets, ATNDeserializer.getUnicodeDeserializer(1 /* UNICODE_SMP */));
      }
      //
      // EDGES
      //
      var nedges = ATNDeserializer.toInt(data[p++]);
      for (var _i10 = 0; _i10 < nedges; _i10++) {
        var src = ATNDeserializer.toInt(data[p]);
        var trg = ATNDeserializer.toInt(data[p + 1]);
        var ttype = ATNDeserializer.toInt(data[p + 2]);
        var arg1 = ATNDeserializer.toInt(data[p + 3]);
        var arg2 = ATNDeserializer.toInt(data[p + 4]);
        var arg3 = ATNDeserializer.toInt(data[p + 5]);
        var trans = this.edgeFactory(atn, ttype, src, trg, arg1, arg2, arg3, sets);
        // console.log(`EDGE ${trans.constructor.name} ${src}->${trg} ${Transition.serializationNames[ttype]} ${arg1},${arg2},${arg3}`);
        var srcState = atn.states[src];
        srcState.addTransition(trans);
        p += 6;
      }
      var returnTransitionsSet = new Array2DHashSet_1.Array2DHashSet({
        hashCode: function hashCode(o) {
          return o.stopState ^ o.returnState ^ o.outermostPrecedenceReturn;
        },
        equals: function equals(a, b) {
          return a.stopState === b.stopState && a.returnState === b.returnState && a.outermostPrecedenceReturn === b.outermostPrecedenceReturn;
        }
      });
      var returnTransitions = [];
      var _iterator2 = _createForOfIteratorHelper(atn.states),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _state4 = _step2.value;
          var returningToLeftFactored = _state4.ruleIndex >= 0 && atn.ruleToStartState[_state4.ruleIndex].leftFactored;
          for (var _i19 = 0; _i19 < _state4.numberOfTransitions; _i19++) {
            var t = _state4.transition(_i19);
            if (!(t instanceof RuleTransition_1.RuleTransition)) {
              continue;
            }
            var ruleTransition = t;
            var returningFromLeftFactored = atn.ruleToStartState[ruleTransition.target.ruleIndex].leftFactored;
            if (!returningFromLeftFactored && returningToLeftFactored) {
              continue;
            }
            var outermostPrecedenceReturn = -1;
            if (atn.ruleToStartState[ruleTransition.target.ruleIndex].isPrecedenceRule) {
              if (ruleTransition.precedence === 0) {
                outermostPrecedenceReturn = ruleTransition.target.ruleIndex;
              }
            }
            var current = {
              stopState: ruleTransition.target.ruleIndex,
              returnState: ruleTransition.followState.stateNumber,
              outermostPrecedenceReturn: outermostPrecedenceReturn
            };
            if (returnTransitionsSet.add(current)) {
              returnTransitions.push(current);
            }
          }
        }
        // Add all elements from returnTransitions to the ATN
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      for (var _i11 = 0, _returnTransitions = returnTransitions; _i11 < _returnTransitions.length; _i11++) {
        var returnTransition = _returnTransitions[_i11];
        var transition = new EpsilonTransition_1.EpsilonTransition(atn.states[returnTransition.returnState], returnTransition.outermostPrecedenceReturn);
        atn.ruleToStopState[returnTransition.stopState].addTransition(transition);
      }
      var _iterator3 = _createForOfIteratorHelper(atn.states),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var _state5 = _step3.value;
          if (_state5 instanceof BlockStartState_1.BlockStartState) {
            // we need to know the end state to set its start state
            if (_state5.endState == null) {
              throw new Error("IllegalStateException");
            }
            // block end states can only be associated to a single block start state
            if (_state5.endState.startState != null) {
              throw new Error("IllegalStateException");
            }
            _state5.endState.startState = _state5;
          }
          if (_state5 instanceof PlusLoopbackState_1.PlusLoopbackState) {
            var loopbackState = _state5;
            for (var _i20 = 0; _i20 < loopbackState.numberOfTransitions; _i20++) {
              var target = loopbackState.transition(_i20).target;
              if (target instanceof PlusBlockStartState_1.PlusBlockStartState) {
                target.loopBackState = loopbackState;
              }
            }
          } else if (_state5 instanceof StarLoopbackState_1.StarLoopbackState) {
            var _loopbackState = _state5;
            for (var _i21 = 0; _i21 < _loopbackState.numberOfTransitions; _i21++) {
              var _target = _loopbackState.transition(_i21).target;
              if (_target instanceof StarLoopEntryState_1.StarLoopEntryState) {
                _target.loopBackState = _loopbackState;
              }
            }
          }
        }
        //
        // DECISIONS
        //
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      var ndecisions = ATNDeserializer.toInt(data[p++]);
      for (var _i12 = 1; _i12 <= ndecisions; _i12++) {
        var _s3 = ATNDeserializer.toInt(data[p++]);
        var decState = atn.states[_s3];
        atn.decisionToState.push(decState);
        decState.decision = _i12 - 1;
      }
      //
      // LEXER ACTIONS
      //
      if (atn.grammarType === 0 /* LEXER */) {
        if (supportsLexerActions) {
          atn.lexerActions = new Array(ATNDeserializer.toInt(data[p++]));
          for (var _i13 = 0; _i13 < atn.lexerActions.length; _i13++) {
            var actionType = ATNDeserializer.toInt(data[p++]);
            var data1 = ATNDeserializer.toInt(data[p++]);
            if (data1 === 0xFFFF) {
              data1 = -1;
            }
            var data2 = ATNDeserializer.toInt(data[p++]);
            if (data2 === 0xFFFF) {
              data2 = -1;
            }
            var lexerAction = this.lexerActionFactory(actionType, data1, data2);
            atn.lexerActions[_i13] = lexerAction;
          }
        } else {
          // for compatibility with older serialized ATNs, convert the old
          // serialized action index for action transitions to the new
          // form, which is the index of a LexerCustomAction
          var legacyLexerActions = [];
          var _iterator4 = _createForOfIteratorHelper(atn.states),
            _step4;
          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var state = _step4.value;
              for (var _i14 = 0; _i14 < state.numberOfTransitions; _i14++) {
                var _transition = state.transition(_i14);
                if (!(_transition instanceof ActionTransition_1.ActionTransition)) {
                  continue;
                }
                var _ruleIndex = _transition.ruleIndex;
                var actionIndex = _transition.actionIndex;
                var _lexerAction = new LexerCustomAction_1.LexerCustomAction(_ruleIndex, actionIndex);
                state.setTransition(_i14, new ActionTransition_1.ActionTransition(_transition.target, _ruleIndex, legacyLexerActions.length, false));
                legacyLexerActions.push(_lexerAction);
              }
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
          atn.lexerActions = legacyLexerActions;
        }
      }
      this.markPrecedenceDecisions(atn);
      atn.decisionToDFA = new Array(ndecisions);
      for (var _i15 = 0; _i15 < ndecisions; _i15++) {
        atn.decisionToDFA[_i15] = new DFA_1.DFA(atn.decisionToState[_i15], _i15);
      }
      if (this.deserializationOptions.isVerifyATN) {
        this.verifyATN(atn);
      }
      if (this.deserializationOptions.isGenerateRuleBypassTransitions && atn.grammarType === 1 /* PARSER */) {
        atn.ruleToTokenType = new Int32Array(atn.ruleToStartState.length);
        for (var _i16 = 0; _i16 < atn.ruleToStartState.length; _i16++) {
          atn.ruleToTokenType[_i16] = atn.maxTokenType + _i16 + 1;
        }
        for (var _i17 = 0; _i17 < atn.ruleToStartState.length; _i17++) {
          var bypassStart = new BasicBlockStartState_1.BasicBlockStartState();
          bypassStart.ruleIndex = _i17;
          atn.addState(bypassStart);
          var bypassStop = new BlockEndState_1.BlockEndState();
          bypassStop.ruleIndex = _i17;
          atn.addState(bypassStop);
          bypassStart.endState = bypassStop;
          atn.defineDecisionState(bypassStart);
          bypassStop.startState = bypassStart;
          var endState = void 0;
          var excludeTransition = void 0;
          if (atn.ruleToStartState[_i17].isPrecedenceRule) {
            // wrap from the beginning of the rule to the StarLoopEntryState
            endState = undefined;
            var _iterator5 = _createForOfIteratorHelper(atn.states),
              _step5;
            try {
              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                var _state = _step5.value;
                if (_state.ruleIndex !== _i17) {
                  continue;
                }
                if (!(_state instanceof StarLoopEntryState_1.StarLoopEntryState)) {
                  continue;
                }
                var maybeLoopEndState = _state.transition(_state.numberOfTransitions - 1).target;
                if (!(maybeLoopEndState instanceof LoopEndState_1.LoopEndState)) {
                  continue;
                }
                if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transition(0).target instanceof RuleStopState_1.RuleStopState) {
                  endState = _state;
                  break;
                }
              }
            } catch (err) {
              _iterator5.e(err);
            } finally {
              _iterator5.f();
            }
            if (!endState) {
              throw new Error("Couldn't identify final state of the precedence rule prefix section.");
            }
            excludeTransition = endState.loopBackState.transition(0);
          } else {
            endState = atn.ruleToStopState[_i17];
          }
          // all non-excluded transitions that currently target end state need to target blockEnd instead
          var _iterator6 = _createForOfIteratorHelper(atn.states),
            _step6;
          try {
            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
              var _state2 = _step6.value;
              for (var _i18 = 0; _i18 < _state2.numberOfTransitions; _i18++) {
                var _transition3 = _state2.transition(_i18);
                if (_transition3 === excludeTransition) {
                  continue;
                }
                if (_transition3.target === endState) {
                  _transition3.target = bypassStop;
                }
              }
            }
            // all transitions leaving the rule start state need to leave blockStart instead
          } catch (err) {
            _iterator6.e(err);
          } finally {
            _iterator6.f();
          }
          while (atn.ruleToStartState[_i17].numberOfTransitions > 0) {
            var _transition2 = atn.ruleToStartState[_i17].removeTransition(atn.ruleToStartState[_i17].numberOfTransitions - 1);
            bypassStart.addTransition(_transition2);
          }
          // link the new states
          atn.ruleToStartState[_i17].addTransition(new EpsilonTransition_1.EpsilonTransition(bypassStart));
          bypassStop.addTransition(new EpsilonTransition_1.EpsilonTransition(endState));
          var matchState = new BasicState_1.BasicState();
          atn.addState(matchState);
          matchState.addTransition(new AtomTransition_1.AtomTransition(bypassStop, atn.ruleToTokenType[_i17]));
          bypassStart.addTransition(new EpsilonTransition_1.EpsilonTransition(matchState));
        }
        if (this.deserializationOptions.isVerifyATN) {
          // reverify after modification
          this.verifyATN(atn);
        }
      }
      if (this.deserializationOptions.isOptimize) {
        while (true) {
          var optimizationCount = 0;
          optimizationCount += ATNDeserializer.inlineSetRules(atn);
          optimizationCount += ATNDeserializer.combineChainedEpsilons(atn);
          var preserveOrder = atn.grammarType === 0 /* LEXER */;
          optimizationCount += ATNDeserializer.optimizeSets(atn, preserveOrder);
          if (optimizationCount === 0) {
            break;
          }
        }
        if (this.deserializationOptions.isVerifyATN) {
          // reverify after modification
          this.verifyATN(atn);
        }
      }
      ATNDeserializer.identifyTailCalls(atn);
      return atn;
    }
  }, {
    key: "deserializeSets",
    value: function deserializeSets(data, p, sets, unicodeDeserializer) {
      var nsets = ATNDeserializer.toInt(data[p++]);
      for (var i = 0; i < nsets; i++) {
        var nintervals = ATNDeserializer.toInt(data[p]);
        p++;
        var set = new IntervalSet_1.IntervalSet();
        sets.push(set);
        var containsEof = ATNDeserializer.toInt(data[p++]) !== 0;
        if (containsEof) {
          set.add(-1);
        }
        for (var j = 0; j < nintervals; j++) {
          var a = unicodeDeserializer.readUnicode(data, p);
          p += unicodeDeserializer.size;
          var b = unicodeDeserializer.readUnicode(data, p);
          p += unicodeDeserializer.size;
          set.add(a, b);
        }
      }
      return p;
    }
    /**
     * Analyze the {@link StarLoopEntryState} states in the specified ATN to set
     * the {@link StarLoopEntryState#precedenceRuleDecision} field to the
     * correct value.
     *
     * @param atn The ATN.
     */
  }, {
    key: "markPrecedenceDecisions",
    value: function markPrecedenceDecisions(atn) {
      // Map rule index -> precedence decision for that rule
      var rulePrecedenceDecisions = new Map();
      var _iterator7 = _createForOfIteratorHelper(atn.states),
        _step7;
      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var state = _step7.value;
          if (!(state instanceof StarLoopEntryState_1.StarLoopEntryState)) {
            continue;
          }
          /* We analyze the ATN to determine if this ATN decision state is the
           * decision for the closure block that determines whether a
           * precedence rule should continue or complete.
           */
          if (atn.ruleToStartState[state.ruleIndex].isPrecedenceRule) {
            var maybeLoopEndState = state.transition(state.numberOfTransitions - 1).target;
            if (maybeLoopEndState instanceof LoopEndState_1.LoopEndState) {
              if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transition(0).target instanceof RuleStopState_1.RuleStopState) {
                rulePrecedenceDecisions.set(state.ruleIndex, state);
                state.precedenceRuleDecision = true;
                state.precedenceLoopbackStates = new BitSet_1.BitSet(atn.states.length);
              }
            }
          }
        }
        // After marking precedence decisions, we go back through and fill in
        // StarLoopEntryState.precedenceLoopbackStates.
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }
      var _iterator8 = _createForOfIteratorHelper(rulePrecedenceDecisions),
        _step8;
      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var precedenceDecision = _step8.value;
          var _iterator9 = _createForOfIteratorHelper(atn.ruleToStopState[precedenceDecision[0]].getTransitions()),
            _step9;
          try {
            for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
              var transition = _step9.value;
              if (transition.serializationType !== 1 /* EPSILON */) {
                continue;
              }
              var epsilonTransition = transition;
              if (epsilonTransition.outermostPrecedenceReturn !== -1) {
                continue;
              }
              precedenceDecision[1].precedenceLoopbackStates.set(transition.target.stateNumber);
            }
          } catch (err) {
            _iterator9.e(err);
          } finally {
            _iterator9.f();
          }
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }
    }
  }, {
    key: "verifyATN",
    value: function verifyATN(atn) {
      // verify assumptions
      var _iterator10 = _createForOfIteratorHelper(atn.states),
        _step10;
      try {
        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
          var state = _step10.value;
          this.checkCondition(state != null, "ATN states should not be null.");
          if (state.stateType === ATNStateType_1.ATNStateType.INVALID_TYPE) {
            continue;
          }
          this.checkCondition(state.onlyHasEpsilonTransitions || state.numberOfTransitions <= 1);
          if (state instanceof PlusBlockStartState_1.PlusBlockStartState) {
            this.checkCondition(state.loopBackState != null);
          }
          if (state instanceof StarLoopEntryState_1.StarLoopEntryState) {
            var starLoopEntryState = state;
            this.checkCondition(starLoopEntryState.loopBackState != null);
            this.checkCondition(starLoopEntryState.numberOfTransitions === 2);
            if (starLoopEntryState.transition(0).target instanceof StarBlockStartState_1.StarBlockStartState) {
              this.checkCondition(starLoopEntryState.transition(1).target instanceof LoopEndState_1.LoopEndState);
              this.checkCondition(!starLoopEntryState.nonGreedy);
            } else if (starLoopEntryState.transition(0).target instanceof LoopEndState_1.LoopEndState) {
              this.checkCondition(starLoopEntryState.transition(1).target instanceof StarBlockStartState_1.StarBlockStartState);
              this.checkCondition(starLoopEntryState.nonGreedy);
            } else {
              throw new Error("IllegalStateException");
            }
          }
          if (state instanceof StarLoopbackState_1.StarLoopbackState) {
            this.checkCondition(state.numberOfTransitions === 1);
            this.checkCondition(state.transition(0).target instanceof StarLoopEntryState_1.StarLoopEntryState);
          }
          if (state instanceof LoopEndState_1.LoopEndState) {
            this.checkCondition(state.loopBackState != null);
          }
          if (state instanceof RuleStartState_1.RuleStartState) {
            this.checkCondition(state.stopState != null);
          }
          if (state instanceof BlockStartState_1.BlockStartState) {
            this.checkCondition(state.endState != null);
          }
          if (state instanceof BlockEndState_1.BlockEndState) {
            this.checkCondition(state.startState != null);
          }
          if (state instanceof DecisionState_1.DecisionState) {
            var decisionState = state;
            this.checkCondition(decisionState.numberOfTransitions <= 1 || decisionState.decision >= 0);
          } else {
            this.checkCondition(state.numberOfTransitions <= 1 || state instanceof RuleStopState_1.RuleStopState);
          }
        }
      } catch (err) {
        _iterator10.e(err);
      } finally {
        _iterator10.f();
      }
    }
  }, {
    key: "checkCondition",
    value: function checkCondition(condition, message) {
      if (!condition) {
        throw new Error("IllegalStateException: " + message);
      }
    }
  }, {
    key: "edgeFactory",
    value: function edgeFactory(atn, type, src, trg, arg1, arg2, arg3, sets) {
      var target = atn.states[trg];
      switch (type) {
        case 1 /* EPSILON */:
          return new EpsilonTransition_1.EpsilonTransition(target);
        case 2 /* RANGE */:
          if (arg3 !== 0) {
            return new RangeTransition_1.RangeTransition(target, Token_1.Token.EOF, arg2);
          } else {
            return new RangeTransition_1.RangeTransition(target, arg1, arg2);
          }
        case 3 /* RULE */:
          var rt = new RuleTransition_1.RuleTransition(atn.states[arg1], arg2, arg3, target);
          return rt;
        case 4 /* PREDICATE */:
          var pt = new PredicateTransition_1.PredicateTransition(target, arg1, arg2, arg3 !== 0);
          return pt;
        case 10 /* PRECEDENCE */:
          return new PrecedencePredicateTransition_1.PrecedencePredicateTransition(target, arg1);
        case 5 /* ATOM */:
          if (arg3 !== 0) {
            return new AtomTransition_1.AtomTransition(target, Token_1.Token.EOF);
          } else {
            return new AtomTransition_1.AtomTransition(target, arg1);
          }
        case 6 /* ACTION */:
          var a = new ActionTransition_1.ActionTransition(target, arg1, arg2, arg3 !== 0);
          return a;
        case 7 /* SET */:
          return new SetTransition_1.SetTransition(target, sets[arg1]);
        case 8 /* NOT_SET */:
          return new NotSetTransition_1.NotSetTransition(target, sets[arg1]);
        case 9 /* WILDCARD */:
          return new WildcardTransition_1.WildcardTransition(target);
      }
      throw new Error("The specified transition type is not valid.");
    }
  }, {
    key: "stateFactory",
    value: function stateFactory(type, ruleIndex) {
      var s;
      switch (type) {
        case ATNStateType_1.ATNStateType.INVALID_TYPE:
          return new InvalidState_1.InvalidState();
        case ATNStateType_1.ATNStateType.BASIC:
          s = new BasicState_1.BasicState();
          break;
        case ATNStateType_1.ATNStateType.RULE_START:
          s = new RuleStartState_1.RuleStartState();
          break;
        case ATNStateType_1.ATNStateType.BLOCK_START:
          s = new BasicBlockStartState_1.BasicBlockStartState();
          break;
        case ATNStateType_1.ATNStateType.PLUS_BLOCK_START:
          s = new PlusBlockStartState_1.PlusBlockStartState();
          break;
        case ATNStateType_1.ATNStateType.STAR_BLOCK_START:
          s = new StarBlockStartState_1.StarBlockStartState();
          break;
        case ATNStateType_1.ATNStateType.TOKEN_START:
          s = new TokensStartState_1.TokensStartState();
          break;
        case ATNStateType_1.ATNStateType.RULE_STOP:
          s = new RuleStopState_1.RuleStopState();
          break;
        case ATNStateType_1.ATNStateType.BLOCK_END:
          s = new BlockEndState_1.BlockEndState();
          break;
        case ATNStateType_1.ATNStateType.STAR_LOOP_BACK:
          s = new StarLoopbackState_1.StarLoopbackState();
          break;
        case ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY:
          s = new StarLoopEntryState_1.StarLoopEntryState();
          break;
        case ATNStateType_1.ATNStateType.PLUS_LOOP_BACK:
          s = new PlusLoopbackState_1.PlusLoopbackState();
          break;
        case ATNStateType_1.ATNStateType.LOOP_END:
          s = new LoopEndState_1.LoopEndState();
          break;
        default:
          var message = "The specified state type ".concat(type, " is not valid.");
          throw new Error(message);
      }
      s.ruleIndex = ruleIndex;
      return s;
    }
  }, {
    key: "lexerActionFactory",
    value: function lexerActionFactory(type, data1, data2) {
      switch (type) {
        case 0 /* CHANNEL */:
          return new LexerChannelAction_1.LexerChannelAction(data1);
        case 1 /* CUSTOM */:
          return new LexerCustomAction_1.LexerCustomAction(data1, data2);
        case 2 /* MODE */:
          return new LexerModeAction_1.LexerModeAction(data1);
        case 3 /* MORE */:
          return LexerMoreAction_1.LexerMoreAction.INSTANCE;
        case 4 /* POP_MODE */:
          return LexerPopModeAction_1.LexerPopModeAction.INSTANCE;
        case 5 /* PUSH_MODE */:
          return new LexerPushModeAction_1.LexerPushModeAction(data1);
        case 6 /* SKIP */:
          return LexerSkipAction_1.LexerSkipAction.INSTANCE;
        case 7 /* TYPE */:
          return new LexerTypeAction_1.LexerTypeAction(data1);
        default:
          var message = "The specified lexer action type ".concat(type, " is not valid.");
          throw new Error(message);
      }
    }
  }], [{
    key: "SERIALIZED_VERSION",
    get: function get() {
      /* This value should never change. Updates following this version are
       * reflected as change in the unique ID SERIALIZED_UUID.
       */
      return 3;
    }
    /**
     * Determines if a particular serialized representation of an ATN supports
     * a particular feature, identified by the {@link UUID} used for serializing
     * the ATN at the time the feature was first introduced.
     *
     * @param feature The {@link UUID} marking the first time the feature was
     * supported in the serialized ATN.
     * @param actualUuid The {@link UUID} of the actual serialized ATN which is
     * currently being deserialized.
     * @returns `true` if the `actualUuid` value represents a
     * serialized ATN at or after the feature identified by `feature` was
     * introduced; otherwise, `false`.
     */
  }, {
    key: "isFeatureSupported",
    value: function isFeatureSupported(feature, actualUuid) {
      var featureIndex = ATNDeserializer.SUPPORTED_UUIDS.findIndex(function (e) {
        return e.equals(feature);
      });
      if (featureIndex < 0) {
        return false;
      }
      return ATNDeserializer.SUPPORTED_UUIDS.findIndex(function (e) {
        return e.equals(actualUuid);
      }) >= featureIndex;
    }
  }, {
    key: "getUnicodeDeserializer",
    value: function getUnicodeDeserializer(mode) {
      if (mode === 0 /* UNICODE_BMP */) {
        return {
          readUnicode: function readUnicode(data, p) {
            return ATNDeserializer.toInt(data[p]);
          },
          size: 1
        };
      } else {
        return {
          readUnicode: function readUnicode(data, p) {
            return ATNDeserializer.toInt32(data, p);
          },
          size: 2
        };
      }
    }
  }, {
    key: "inlineSetRules",
    value: function inlineSetRules(atn) {
      var inlinedCalls = 0;
      var ruleToInlineTransition = new Array(atn.ruleToStartState.length);
      for (var i = 0; i < atn.ruleToStartState.length; i++) {
        var startState = atn.ruleToStartState[i];
        var middleState = startState;
        while (middleState.onlyHasEpsilonTransitions && middleState.numberOfOptimizedTransitions === 1 && middleState.getOptimizedTransition(0).serializationType === 1 /* EPSILON */) {
          middleState = middleState.getOptimizedTransition(0).target;
        }
        if (middleState.numberOfOptimizedTransitions !== 1) {
          continue;
        }
        var matchTransition = middleState.getOptimizedTransition(0);
        var matchTarget = matchTransition.target;
        if (matchTransition.isEpsilon || !matchTarget.onlyHasEpsilonTransitions || matchTarget.numberOfOptimizedTransitions !== 1 || !(matchTarget.getOptimizedTransition(0).target instanceof RuleStopState_1.RuleStopState)) {
          continue;
        }
        switch (matchTransition.serializationType) {
          case 5 /* ATOM */:
          case 2 /* RANGE */:
          case 7 /* SET */:
            ruleToInlineTransition[i] = matchTransition;
            break;
          case 8 /* NOT_SET */:
          case 9 /* WILDCARD */:
            // not implemented yet
            continue;
          default:
            continue;
        }
      }
      var _iterator11 = _createForOfIteratorHelper(atn.states),
        _step11;
      try {
        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
          var state = _step11.value;
          if (state.ruleIndex < 0) {
            continue;
          }
          var optimizedTransitions = void 0;
          for (var _i22 = 0; _i22 < state.numberOfOptimizedTransitions; _i22++) {
            var transition = state.getOptimizedTransition(_i22);
            if (!(transition instanceof RuleTransition_1.RuleTransition)) {
              if (optimizedTransitions != null) {
                optimizedTransitions.push(transition);
              }
              continue;
            }
            var ruleTransition = transition;
            var effective = ruleToInlineTransition[ruleTransition.target.ruleIndex];
            if (effective == null) {
              if (optimizedTransitions != null) {
                optimizedTransitions.push(transition);
              }
              continue;
            }
            if (optimizedTransitions == null) {
              optimizedTransitions = [];
              for (var j = 0; j < _i22; j++) {
                optimizedTransitions.push(state.getOptimizedTransition(_i22));
              }
            }
            inlinedCalls++;
            var target = ruleTransition.followState;
            var intermediateState = new BasicState_1.BasicState();
            intermediateState.setRuleIndex(target.ruleIndex);
            atn.addState(intermediateState);
            optimizedTransitions.push(new EpsilonTransition_1.EpsilonTransition(intermediateState));
            switch (effective.serializationType) {
              case 5 /* ATOM */:
                intermediateState.addTransition(new AtomTransition_1.AtomTransition(target, effective._label));
                break;
              case 2 /* RANGE */:
                intermediateState.addTransition(new RangeTransition_1.RangeTransition(target, effective.from, effective.to));
                break;
              case 7 /* SET */:
                intermediateState.addTransition(new SetTransition_1.SetTransition(target, effective.label));
                break;
              default:
                throw new Error("UnsupportedOperationException");
            }
          }
          if (optimizedTransitions != null) {
            if (state.isOptimized) {
              while (state.numberOfOptimizedTransitions > 0) {
                state.removeOptimizedTransition(state.numberOfOptimizedTransitions - 1);
              }
            }
            var _iterator12 = _createForOfIteratorHelper(optimizedTransitions),
              _step12;
            try {
              for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
                var _transition4 = _step12.value;
                state.addOptimizedTransition(_transition4);
              }
            } catch (err) {
              _iterator12.e(err);
            } finally {
              _iterator12.f();
            }
          }
        }
      } catch (err) {
        _iterator11.e(err);
      } finally {
        _iterator11.f();
      }
      if (ParserATNSimulator_1.ParserATNSimulator.debug) {
        console.log("ATN runtime optimizer removed " + inlinedCalls + " rule invocations by inlining sets.");
      }
      return inlinedCalls;
    }
  }, {
    key: "combineChainedEpsilons",
    value: function combineChainedEpsilons(atn) {
      var removedEdges = 0;
      var _iterator13 = _createForOfIteratorHelper(atn.states),
        _step13;
      try {
        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
          var state = _step13.value;
          if (!state.onlyHasEpsilonTransitions || state instanceof RuleStopState_1.RuleStopState) {
            continue;
          }
          var optimizedTransitions = void 0;
          nextTransition: for (var i = 0; i < state.numberOfOptimizedTransitions; i++) {
            var transition = state.getOptimizedTransition(i);
            var intermediate = transition.target;
            if (transition.serializationType !== 1 /* EPSILON */ || transition.outermostPrecedenceReturn !== -1 || intermediate.stateType !== ATNStateType_1.ATNStateType.BASIC || !intermediate.onlyHasEpsilonTransitions) {
              if (optimizedTransitions != null) {
                optimizedTransitions.push(transition);
              }
              continue nextTransition;
            }
            for (var j = 0; j < intermediate.numberOfOptimizedTransitions; j++) {
              if (intermediate.getOptimizedTransition(j).serializationType !== 1 /* EPSILON */ || intermediate.getOptimizedTransition(j).outermostPrecedenceReturn !== -1) {
                if (optimizedTransitions != null) {
                  optimizedTransitions.push(transition);
                }
                continue nextTransition;
              }
            }
            removedEdges++;
            if (optimizedTransitions == null) {
              optimizedTransitions = [];
              for (var _j = 0; _j < i; _j++) {
                optimizedTransitions.push(state.getOptimizedTransition(_j));
              }
            }
            for (var _j2 = 0; _j2 < intermediate.numberOfOptimizedTransitions; _j2++) {
              var target = intermediate.getOptimizedTransition(_j2).target;
              optimizedTransitions.push(new EpsilonTransition_1.EpsilonTransition(target));
            }
          }
          if (optimizedTransitions != null) {
            if (state.isOptimized) {
              while (state.numberOfOptimizedTransitions > 0) {
                state.removeOptimizedTransition(state.numberOfOptimizedTransitions - 1);
              }
            }
            var _iterator14 = _createForOfIteratorHelper(optimizedTransitions),
              _step14;
            try {
              for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
                var _transition5 = _step14.value;
                state.addOptimizedTransition(_transition5);
              }
            } catch (err) {
              _iterator14.e(err);
            } finally {
              _iterator14.f();
            }
          }
        }
      } catch (err) {
        _iterator13.e(err);
      } finally {
        _iterator13.f();
      }
      if (ParserATNSimulator_1.ParserATNSimulator.debug) {
        console.log("ATN runtime optimizer removed " + removedEdges + " transitions by combining chained epsilon transitions.");
      }
      return removedEdges;
    }
  }, {
    key: "optimizeSets",
    value: function optimizeSets(atn, preserveOrder) {
      if (preserveOrder) {
        // this optimization currently doesn't preserve edge order.
        return 0;
      }
      var removedPaths = 0;
      var decisions = atn.decisionToState;
      var _iterator15 = _createForOfIteratorHelper(decisions),
        _step15;
      try {
        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
          var decision = _step15.value;
          var setTransitions = new IntervalSet_1.IntervalSet();
          for (var i = 0; i < decision.numberOfOptimizedTransitions; i++) {
            var epsTransition = decision.getOptimizedTransition(i);
            if (!(epsTransition instanceof EpsilonTransition_1.EpsilonTransition)) {
              continue;
            }
            if (epsTransition.target.numberOfOptimizedTransitions !== 1) {
              continue;
            }
            var transition = epsTransition.target.getOptimizedTransition(0);
            if (!(transition.target instanceof BlockEndState_1.BlockEndState)) {
              continue;
            }
            if (transition instanceof NotSetTransition_1.NotSetTransition) {
              // TODO: not yet implemented
              continue;
            }
            if (transition instanceof AtomTransition_1.AtomTransition || transition instanceof RangeTransition_1.RangeTransition || transition instanceof SetTransition_1.SetTransition) {
              setTransitions.add(i);
            }
          }
          if (setTransitions.size <= 1) {
            continue;
          }
          var optimizedTransitions = [];
          for (var _i23 = 0; _i23 < decision.numberOfOptimizedTransitions; _i23++) {
            if (!setTransitions.contains(_i23)) {
              optimizedTransitions.push(decision.getOptimizedTransition(_i23));
            }
          }
          var blockEndState = decision.getOptimizedTransition(setTransitions.minElement).target.getOptimizedTransition(0).target;
          var matchSet = new IntervalSet_1.IntervalSet();
          var _iterator16 = _createForOfIteratorHelper(setTransitions.intervals),
            _step16;
          try {
            for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
              var interval = _step16.value;
              for (var j = interval.a; j <= interval.b; j++) {
                var matchTransition = decision.getOptimizedTransition(j).target.getOptimizedTransition(0);
                if (matchTransition instanceof NotSetTransition_1.NotSetTransition) {
                  throw new Error("Not yet implemented.");
                } else {
                  matchSet.addAll(matchTransition.label);
                }
              }
            }
          } catch (err) {
            _iterator16.e(err);
          } finally {
            _iterator16.f();
          }
          var newTransition = void 0;
          if (matchSet.intervals.length === 1) {
            if (matchSet.size === 1) {
              newTransition = new AtomTransition_1.AtomTransition(blockEndState, matchSet.minElement);
            } else {
              var matchInterval = matchSet.intervals[0];
              newTransition = new RangeTransition_1.RangeTransition(blockEndState, matchInterval.a, matchInterval.b);
            }
          } else {
            newTransition = new SetTransition_1.SetTransition(blockEndState, matchSet);
          }
          var setOptimizedState = new BasicState_1.BasicState();
          setOptimizedState.setRuleIndex(decision.ruleIndex);
          atn.addState(setOptimizedState);
          setOptimizedState.addTransition(newTransition);
          optimizedTransitions.push(new EpsilonTransition_1.EpsilonTransition(setOptimizedState));
          removedPaths += decision.numberOfOptimizedTransitions - optimizedTransitions.length;
          if (decision.isOptimized) {
            while (decision.numberOfOptimizedTransitions > 0) {
              decision.removeOptimizedTransition(decision.numberOfOptimizedTransitions - 1);
            }
          }
          for (var _i24 = 0, _optimizedTransitions = optimizedTransitions; _i24 < _optimizedTransitions.length; _i24++) {
            var _transition6 = _optimizedTransitions[_i24];
            decision.addOptimizedTransition(_transition6);
          }
        }
      } catch (err) {
        _iterator15.e(err);
      } finally {
        _iterator15.f();
      }
      if (ParserATNSimulator_1.ParserATNSimulator.debug) {
        console.log("ATN runtime optimizer removed " + removedPaths + " paths by collapsing sets.");
      }
      return removedPaths;
    }
  }, {
    key: "identifyTailCalls",
    value: function identifyTailCalls(atn) {
      var _iterator17 = _createForOfIteratorHelper(atn.states),
        _step17;
      try {
        for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
          var state = _step17.value;
          for (var i = 0; i < state.numberOfTransitions; i++) {
            var transition = state.transition(i);
            if (!(transition instanceof RuleTransition_1.RuleTransition)) {
              continue;
            }
            transition.tailCall = this.testTailCall(atn, transition, false);
            transition.optimizedTailCall = this.testTailCall(atn, transition, true);
          }
          if (!state.isOptimized) {
            continue;
          }
          for (var _i25 = 0; _i25 < state.numberOfOptimizedTransitions; _i25++) {
            var _transition7 = state.getOptimizedTransition(_i25);
            if (!(_transition7 instanceof RuleTransition_1.RuleTransition)) {
              continue;
            }
            _transition7.tailCall = this.testTailCall(atn, _transition7, false);
            _transition7.optimizedTailCall = this.testTailCall(atn, _transition7, true);
          }
        }
      } catch (err) {
        _iterator17.e(err);
      } finally {
        _iterator17.f();
      }
    }
  }, {
    key: "testTailCall",
    value: function testTailCall(atn, transition, optimizedPath) {
      if (!optimizedPath && transition.tailCall) {
        return true;
      }
      if (optimizedPath && transition.optimizedTailCall) {
        return true;
      }
      var reachable = new BitSet_1.BitSet(atn.states.length);
      var worklist = [];
      worklist.push(transition.followState);
      while (true) {
        var state = worklist.pop();
        if (!state) {
          break;
        }
        if (reachable.get(state.stateNumber)) {
          continue;
        }
        if (state instanceof RuleStopState_1.RuleStopState) {
          continue;
        }
        if (!state.onlyHasEpsilonTransitions) {
          return false;
        }
        var transitionCount = optimizedPath ? state.numberOfOptimizedTransitions : state.numberOfTransitions;
        for (var i = 0; i < transitionCount; i++) {
          var t = optimizedPath ? state.getOptimizedTransition(i) : state.transition(i);
          if (t.serializationType !== 1 /* EPSILON */) {
            return false;
          }
          worklist.push(t.target);
        }
      }
      return true;
    }
  }, {
    key: "toInt",
    value: function toInt(c) {
      return c;
    }
  }, {
    key: "toInt32",
    value: function toInt32(data, offset) {
      return (data[offset] | data[offset + 1] << 16) >>> 0;
    }
  }, {
    key: "toUUID",
    value: function toUUID(data, offset) {
      var leastSigBits = ATNDeserializer.toInt32(data, offset);
      var lessSigBits = ATNDeserializer.toInt32(data, offset + 2);
      var moreSigBits = ATNDeserializer.toInt32(data, offset + 4);
      var mostSigBits = ATNDeserializer.toInt32(data, offset + 6);
      return new UUID_1.UUID(mostSigBits, moreSigBits, lessSigBits, leastSigBits);
    }
  }]);
  return ATNDeserializer;
}();
/* WARNING: DO NOT MERGE THESE LINES. If UUIDs differ during a merge,
 * resolve the conflict by generating a new ID!
 */
/**
 * This is the earliest supported serialized UUID.
 */
ATNDeserializer.BASE_SERIALIZED_UUID = UUID_1.UUID.fromString("E4178468-DF95-44D0-AD87-F22A5D5FB6D3");
/**
 * This UUID indicates an extension of {@link #ADDED_PRECEDENCE_TRANSITIONS}
 * for the addition of lexer actions encoded as a sequence of
 * {@link LexerAction} instances.
 */
ATNDeserializer.ADDED_LEXER_ACTIONS = UUID_1.UUID.fromString("AB35191A-1603-487E-B75A-479B831EAF6D");
/**
 * This UUID indicates the serialized ATN contains two sets of
 * IntervalSets, where the second set's values are encoded as
 * 32-bit integers to support the full Unicode SMP range up to U+10FFFF.
 */
ATNDeserializer.ADDED_UNICODE_SMP = UUID_1.UUID.fromString("C23FEA89-0605-4f51-AFB8-058BCAB8C91B");
/**
 * This list contains all of the currently supported UUIDs, ordered by when
 * the feature first appeared in this branch.
 */
ATNDeserializer.SUPPORTED_UUIDS = [ATNDeserializer.BASE_SERIALIZED_UUID, ATNDeserializer.ADDED_LEXER_ACTIONS, ATNDeserializer.ADDED_UNICODE_SMP];
/**
 * This is the current serialized UUID.
 */
ATNDeserializer.SERIALIZED_UUID = ATNDeserializer.ADDED_UNICODE_SMP;
__decorate([Decorators_1.NotNull], ATNDeserializer.prototype, "deserializationOptions", void 0);
__decorate([__param(0, Decorators_1.NotNull)], ATNDeserializer.prototype, "deserialize", null);
__decorate([__param(0, Decorators_1.NotNull)], ATNDeserializer.prototype, "markPrecedenceDecisions", null);
__decorate([Decorators_1.NotNull, __param(0, Decorators_1.NotNull)], ATNDeserializer.prototype, "edgeFactory", null);
exports.ATNDeserializer = ATNDeserializer;

},{"../Decorators":272,"../Token":296,"../dfa/DFA":364,"../misc/Array2DHashSet":370,"../misc/BitSet":373,"../misc/IntervalSet":379,"../misc/UUID":384,"./ATN":299,"./ATNDeserializationOptions":302,"./ATNStateType":306,"./ActionTransition":308,"./AtomTransition":310,"./BasicBlockStartState":311,"./BasicState":312,"./BlockEndState":313,"./BlockStartState":314,"./DecisionState":319,"./EpsilonTransition":320,"./InvalidState":322,"./LexerChannelAction":326,"./LexerCustomAction":327,"./LexerModeAction":329,"./LexerMoreAction":330,"./LexerPopModeAction":331,"./LexerPushModeAction":332,"./LexerSkipAction":333,"./LexerTypeAction":334,"./LoopEndState":336,"./NotSetTransition":337,"./ParserATNSimulator":340,"./PlusBlockStartState":341,"./PlusLoopbackState":342,"./PrecedencePredicateTransition":343,"./PredicateTransition":345,"./RangeTransition":350,"./RuleStartState":351,"./RuleStopState":352,"./RuleTransition":353,"./SetTransition":355,"./StarBlockStartState":357,"./StarLoopEntryState":358,"./StarLoopbackState":359,"./TokensStartState":360,"./WildcardTransition":362,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array-buffer.slice.js":568,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.array.find-index.js":573,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.map.js":587,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/es.typed-array.copy-within.js":641,"core-js/modules/es.typed-array.every.js":642,"core-js/modules/es.typed-array.fill.js":643,"core-js/modules/es.typed-array.filter.js":644,"core-js/modules/es.typed-array.find-index.js":645,"core-js/modules/es.typed-array.find.js":646,"core-js/modules/es.typed-array.for-each.js":649,"core-js/modules/es.typed-array.includes.js":650,"core-js/modules/es.typed-array.index-of.js":651,"core-js/modules/es.typed-array.int32-array.js":653,"core-js/modules/es.typed-array.iterator.js":655,"core-js/modules/es.typed-array.join.js":656,"core-js/modules/es.typed-array.last-index-of.js":657,"core-js/modules/es.typed-array.map.js":658,"core-js/modules/es.typed-array.reduce-right.js":659,"core-js/modules/es.typed-array.reduce.js":660,"core-js/modules/es.typed-array.reverse.js":661,"core-js/modules/es.typed-array.set.js":662,"core-js/modules/es.typed-array.slice.js":663,"core-js/modules/es.typed-array.some.js":664,"core-js/modules/es.typed-array.sort.js":665,"core-js/modules/es.typed-array.subarray.js":666,"core-js/modules/es.typed-array.to-locale-string.js":667,"core-js/modules/es.typed-array.to-string.js":668,"core-js/modules/web.dom-collections.iterator.js":677}],304:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var ATNConfigSet_1 = require("./ATNConfigSet");
var DFAState_1 = require("../dfa/DFAState");
var Decorators_1 = require("../Decorators");
var PredictionContext_1 = require("./PredictionContext");
var ATNSimulator = /*#__PURE__*/function () {
  function ATNSimulator(atn) {
    (0, _classCallCheck2.default)(this, ATNSimulator);
    this.atn = atn;
  }
  (0, _createClass2.default)(ATNSimulator, [{
    key: "clearDFA",
    value:
    /**
     * Clear the DFA cache used by the current instance. Since the DFA cache may
     * be shared by multiple ATN simulators, this method may affect the
     * performance (but not accuracy) of other parsers which are being used
     * concurrently.
     *
     * @ if the current instance does not
     * support clearing the DFA.
     *
     * @since 4.3
     */
    function clearDFA() {
      this.atn.clearDFA();
    }
  }], [{
    key: "ERROR",
    get: function get() {
      if (!ATNSimulator._ERROR) {
        ATNSimulator._ERROR = new DFAState_1.DFAState(new ATNConfigSet_1.ATNConfigSet());
        ATNSimulator._ERROR.stateNumber = PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
      }
      return ATNSimulator._ERROR;
    }
  }]);
  return ATNSimulator;
}();
__decorate([Decorators_1.NotNull], ATNSimulator.prototype, "atn", void 0);
__decorate([Decorators_1.NotNull], ATNSimulator, "ERROR", null);
ATNSimulator = __decorate([__param(0, Decorators_1.NotNull)], ATNSimulator);
exports.ATNSimulator = ATNSimulator;
(function (ATNSimulator) {
  var RULE_VARIANT_DELIMITER = "$";
  var RULE_LF_VARIANT_MARKER = "$lf$";
  var RULE_NOLF_VARIANT_MARKER = "$nolf$";
})(ATNSimulator = exports.ATNSimulator || (exports.ATNSimulator = {}));
exports.ATNSimulator = ATNSimulator;

},{"../Decorators":272,"../dfa/DFAState":366,"./ATNConfigSet":301,"./PredictionContext":346,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612}],305:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.array.splice.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var Decorators_1 = require("../Decorators");
var INITIAL_NUM_TRANSITIONS = 4;
/**
 * The following images show the relation of states and
 * {@link ATNState#transitions} for various grammar constructs.
 *
 * * Solid edges marked with an &#0949; indicate a required
 *   {@link EpsilonTransition}.
 *
 * * Dashed edges indicate locations where any transition derived from
 *   {@link Transition} might appear.
 *
 * * Dashed nodes are place holders for either a sequence of linked
 *   {@link BasicState} states or the inclusion of a block representing a nested
 *   construct in one of the forms below.
 *
 * * Nodes showing multiple outgoing alternatives with a `...` support
 *   any number of alternatives (one or more). Nodes without the `...` only
 *   support the exact number of alternatives shown in the diagram.
 *
 * <h2>Basic Blocks</h2>
 *
 * <h3>Rule</h3>
 *
 * <embed src="images/Rule.svg" type="image/svg+xml"/>
 *
 * <h3>Block of 1 or more alternatives</h3>
 *
 * <embed src="images/Block.svg" type="image/svg+xml"/>
 *
 * <h2>Greedy Loops</h2>
 *
 * <h3>Greedy Closure: `(...)*`</h3>
 *
 * <embed src="images/ClosureGreedy.svg" type="image/svg+xml"/>
 *
 * <h3>Greedy Positive Closure: `(...)+`</h3>
 *
 * <embed src="images/PositiveClosureGreedy.svg" type="image/svg+xml"/>
 *
 * <h3>Greedy Optional: `(...)?`</h3>
 *
 * <embed src="images/OptionalGreedy.svg" type="image/svg+xml"/>
 *
 * <h2>Non-Greedy Loops</h2>
 *
 * <h3>Non-Greedy Closure: `(...)*?`</h3>
 *
 * <embed src="images/ClosureNonGreedy.svg" type="image/svg+xml"/>
 *
 * <h3>Non-Greedy Positive Closure: `(...)+?`</h3>
 *
 * <embed src="images/PositiveClosureNonGreedy.svg" type="image/svg+xml"/>
 *
 * <h3>Non-Greedy Optional: `(...)??`</h3>
 *
 * <embed src="images/OptionalNonGreedy.svg" type="image/svg+xml"/>
 */
var ATNState = /*#__PURE__*/function () {
  function ATNState() {
    (0, _classCallCheck2.default)(this, ATNState);
    this.stateNumber = ATNState.INVALID_STATE_NUMBER;
    this.ruleIndex = 0; // at runtime, we don't have Rule objects
    this.epsilonOnlyTransitions = false;
    /** Track the transitions emanating from this ATN state. */
    this.transitions = [];
    this.optimizedTransitions = this.transitions;
  }
  /**
   * Gets the state number.
   *
   * @returns the state number
   */
  (0, _createClass2.default)(ATNState, [{
    key: "getStateNumber",
    value: function getStateNumber() {
      return this.stateNumber;
    }
    /**
     * For all states except {@link RuleStopState}, this returns the state
     * number. Returns -1 for stop states.
     *
     * @returns -1 for {@link RuleStopState}, otherwise the state number
     */
  }, {
    key: "nonStopStateNumber",
    get: function get() {
      return this.getStateNumber();
    }
  }, {
    key: "hashCode",
    value: function hashCode() {
      return this.stateNumber;
    }
  }, {
    key: "equals",
    value: function equals(o) {
      // are these states same object?
      if (o instanceof ATNState) {
        return this.stateNumber === o.stateNumber;
      }
      return false;
    }
  }, {
    key: "isNonGreedyExitState",
    get: function get() {
      return false;
    }
  }, {
    key: "toString",
    value: function toString() {
      return String(this.stateNumber);
    }
  }, {
    key: "getTransitions",
    value: function getTransitions() {
      return this.transitions.slice(0);
    }
  }, {
    key: "numberOfTransitions",
    get: function get() {
      return this.transitions.length;
    }
  }, {
    key: "addTransition",
    value: function addTransition(e, index) {
      if (this.transitions.length === 0) {
        this.epsilonOnlyTransitions = e.isEpsilon;
      } else if (this.epsilonOnlyTransitions !== e.isEpsilon) {
        this.epsilonOnlyTransitions = false;
        throw new Error("ATN state " + this.stateNumber + " has both epsilon and non-epsilon transitions.");
      }
      this.transitions.splice(index !== undefined ? index : this.transitions.length, 0, e);
    }
  }, {
    key: "transition",
    value: function transition(i) {
      return this.transitions[i];
    }
  }, {
    key: "setTransition",
    value: function setTransition(i, e) {
      this.transitions[i] = e;
    }
  }, {
    key: "removeTransition",
    value: function removeTransition(index) {
      return this.transitions.splice(index, 1)[0];
    }
  }, {
    key: "onlyHasEpsilonTransitions",
    get: function get() {
      return this.epsilonOnlyTransitions;
    }
  }, {
    key: "setRuleIndex",
    value: function setRuleIndex(ruleIndex) {
      this.ruleIndex = ruleIndex;
    }
  }, {
    key: "isOptimized",
    get: function get() {
      return this.optimizedTransitions !== this.transitions;
    }
  }, {
    key: "numberOfOptimizedTransitions",
    get: function get() {
      return this.optimizedTransitions.length;
    }
  }, {
    key: "getOptimizedTransition",
    value: function getOptimizedTransition(i) {
      return this.optimizedTransitions[i];
    }
  }, {
    key: "addOptimizedTransition",
    value: function addOptimizedTransition(e) {
      if (!this.isOptimized) {
        this.optimizedTransitions = new Array();
      }
      this.optimizedTransitions.push(e);
    }
  }, {
    key: "setOptimizedTransition",
    value: function setOptimizedTransition(i, e) {
      if (!this.isOptimized) {
        throw new Error("This ATNState is not optimized.");
      }
      this.optimizedTransitions[i] = e;
    }
  }, {
    key: "removeOptimizedTransition",
    value: function removeOptimizedTransition(i) {
      if (!this.isOptimized) {
        throw new Error("This ATNState is not optimized.");
      }
      this.optimizedTransitions.splice(i, 1);
    }
  }]);
  return ATNState;
}();
__decorate([Decorators_1.Override], ATNState.prototype, "hashCode", null);
__decorate([Decorators_1.Override], ATNState.prototype, "equals", null);
__decorate([Decorators_1.Override], ATNState.prototype, "toString", null);
exports.ATNState = ATNState;
(function (ATNState) {
  ATNState.INVALID_STATE_NUMBER = -1;
})(ATNState = exports.ATNState || (exports.ATNState = {}));

},{"../Decorators":272,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.array.splice.js":582,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612}],306:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:27.4734328-07:00
var ATNStateType;
(function (ATNStateType) {
  ATNStateType[ATNStateType["INVALID_TYPE"] = 0] = "INVALID_TYPE";
  ATNStateType[ATNStateType["BASIC"] = 1] = "BASIC";
  ATNStateType[ATNStateType["RULE_START"] = 2] = "RULE_START";
  ATNStateType[ATNStateType["BLOCK_START"] = 3] = "BLOCK_START";
  ATNStateType[ATNStateType["PLUS_BLOCK_START"] = 4] = "PLUS_BLOCK_START";
  ATNStateType[ATNStateType["STAR_BLOCK_START"] = 5] = "STAR_BLOCK_START";
  ATNStateType[ATNStateType["TOKEN_START"] = 6] = "TOKEN_START";
  ATNStateType[ATNStateType["RULE_STOP"] = 7] = "RULE_STOP";
  ATNStateType[ATNStateType["BLOCK_END"] = 8] = "BLOCK_END";
  ATNStateType[ATNStateType["STAR_LOOP_BACK"] = 9] = "STAR_LOOP_BACK";
  ATNStateType[ATNStateType["STAR_LOOP_ENTRY"] = 10] = "STAR_LOOP_ENTRY";
  ATNStateType[ATNStateType["PLUS_LOOP_BACK"] = 11] = "PLUS_LOOP_BACK";
  ATNStateType[ATNStateType["LOOP_END"] = 12] = "LOOP_END";
})(ATNStateType = exports.ATNStateType || (exports.ATNStateType = {}));

},{}],307:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var Transition_1 = require("./Transition");
/**
 *
 * @author Sam Harwell
 */
var AbstractPredicateTransition = /*#__PURE__*/function (_Transition_1$Transit) {
  (0, _inherits2.default)(AbstractPredicateTransition, _Transition_1$Transit);
  var _super = _createSuper(AbstractPredicateTransition);
  function AbstractPredicateTransition(target) {
    (0, _classCallCheck2.default)(this, AbstractPredicateTransition);
    return _super.call(this, target);
  }
  return (0, _createClass2.default)(AbstractPredicateTransition);
}(Transition_1.Transition);
exports.AbstractPredicateTransition = AbstractPredicateTransition;

},{"./Transition":361,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],308:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var Decorators_1 = require("../Decorators");
var Transition_1 = require("./Transition");
var ActionTransition = /*#__PURE__*/function (_Transition_1$Transit) {
  (0, _inherits2.default)(ActionTransition, _Transition_1$Transit);
  var _super = _createSuper(ActionTransition);
  function ActionTransition(target, ruleIndex) {
    var _this;
    var actionIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
    var isCtxDependent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    (0, _classCallCheck2.default)(this, ActionTransition);
    _this = _super.call(this, target);
    _this.ruleIndex = ruleIndex;
    _this.actionIndex = actionIndex;
    _this.isCtxDependent = isCtxDependent;
    return _this;
  }
  (0, _createClass2.default)(ActionTransition, [{
    key: "serializationType",
    get: function get() {
      return 6 /* ACTION */;
    }
  }, {
    key: "isEpsilon",
    get: function get() {
      return true; // we are to be ignored by analysis 'cept for predicates
    }
  }, {
    key: "matches",
    value: function matches(symbol, minVocabSymbol, maxVocabSymbol) {
      return false;
    }
  }, {
    key: "toString",
    value: function toString() {
      return "action_" + this.ruleIndex + ":" + this.actionIndex;
    }
  }]);
  return ActionTransition;
}(Transition_1.Transition);
__decorate([Decorators_1.Override], ActionTransition.prototype, "serializationType", null);
__decorate([Decorators_1.Override], ActionTransition.prototype, "isEpsilon", null);
__decorate([Decorators_1.Override], ActionTransition.prototype, "matches", null);
__decorate([Decorators_1.Override], ActionTransition.prototype, "toString", null);
ActionTransition = __decorate([__param(0, Decorators_1.NotNull)], ActionTransition);
exports.ActionTransition = ActionTransition;

},{"../Decorators":272,"./Transition":361,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],309:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var DecisionEventInfo_1 = require("./DecisionEventInfo");
var Decorators_1 = require("../Decorators");
/**
 * This class represents profiling event information for an ambiguity.
 * Ambiguities are decisions where a particular input resulted in an SLL
 * conflict, followed by LL prediction also reaching a conflict state
 * (indicating a true ambiguity in the grammar).
 *
 * This event may be reported during SLL prediction in cases where the
 * conflicting SLL configuration set provides sufficient information to
 * determine that the SLL conflict is truly an ambiguity. For example, if none
 * of the ATN configurations in the conflicting SLL configuration set have
 * traversed a global follow transition (i.e.
 * {@link ATNConfig#getReachesIntoOuterContext} is `false` for all
 * configurations), then the result of SLL prediction for that input is known to
 * be equivalent to the result of LL prediction for that input.
 *
 * In some cases, the minimum represented alternative in the conflicting LL
 * configuration set is not equal to the minimum represented alternative in the
 * conflicting SLL configuration set. Grammars and inputs which result in this
 * scenario are unable to use {@link PredictionMode#SLL}, which in turn means
 * they cannot use the two-stage parsing strategy to improve parsing performance
 * for that input.
 *
 * @see ParserATNSimulator#reportAmbiguity
 * @see ParserErrorListener#reportAmbiguity
 *
 * @since 4.3
 */
var AmbiguityInfo = /*#__PURE__*/function (_DecisionEventInfo_1$) {
  (0, _inherits2.default)(AmbiguityInfo, _DecisionEventInfo_1$);
  var _super = _createSuper(AmbiguityInfo);
  /**
   * Constructs a new instance of the {@link AmbiguityInfo} class with the
   * specified detailed ambiguity information.
   *
   * @param decision The decision number
   * @param state The final simulator state identifying the ambiguous
   * alternatives for the current input
   * @param ambigAlts The set of alternatives in the decision that lead to a valid parse.
   *                  The predicted alt is the min(ambigAlts)
   * @param input The input token stream
   * @param startIndex The start index for the current prediction
   * @param stopIndex The index at which the ambiguity was identified during
   * prediction
   */
  function AmbiguityInfo(decision, state, ambigAlts, input, startIndex, stopIndex) {
    var _this;
    (0, _classCallCheck2.default)(this, AmbiguityInfo);
    _this = _super.call(this, decision, state, input, startIndex, stopIndex, state.useContext);
    _this.ambigAlts = ambigAlts;
    return _this;
  }
  /**
   * Gets the set of alternatives in the decision that lead to a valid parse.
   *
   * @since 4.5
   */
  (0, _createClass2.default)(AmbiguityInfo, [{
    key: "ambiguousAlternatives",
    get: function get() {
      return this.ambigAlts;
    }
  }]);
  return AmbiguityInfo;
}(DecisionEventInfo_1.DecisionEventInfo);
__decorate([Decorators_1.NotNull], AmbiguityInfo.prototype, "ambigAlts", void 0);
__decorate([Decorators_1.NotNull], AmbiguityInfo.prototype, "ambiguousAlternatives", null);
AmbiguityInfo = __decorate([__param(1, Decorators_1.NotNull), __param(2, Decorators_1.NotNull), __param(3, Decorators_1.NotNull)], AmbiguityInfo);
exports.AmbiguityInfo = AmbiguityInfo;

},{"../Decorators":272,"./DecisionEventInfo":317,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],310:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var IntervalSet_1 = require("../misc/IntervalSet");
var Decorators_1 = require("../Decorators");
var Transition_1 = require("./Transition");
/** TODO: make all transitions sets? no, should remove set edges */
var AtomTransition = /*#__PURE__*/function (_Transition_1$Transit) {
  (0, _inherits2.default)(AtomTransition, _Transition_1$Transit);
  var _super = _createSuper(AtomTransition);
  function AtomTransition(target, label) {
    var _this;
    (0, _classCallCheck2.default)(this, AtomTransition);
    _this = _super.call(this, target);
    _this._label = label;
    return _this;
  }
  (0, _createClass2.default)(AtomTransition, [{
    key: "serializationType",
    get: function get() {
      return 5 /* ATOM */;
    }
  }, {
    key: "label",
    get: function get() {
      return IntervalSet_1.IntervalSet.of(this._label);
    }
  }, {
    key: "matches",
    value: function matches(symbol, minVocabSymbol, maxVocabSymbol) {
      return this._label === symbol;
    }
  }, {
    key: "toString",
    value: function toString() {
      return String(this.label);
    }
  }]);
  return AtomTransition;
}(Transition_1.Transition);
__decorate([Decorators_1.Override], AtomTransition.prototype, "serializationType", null);
__decorate([Decorators_1.Override, Decorators_1.NotNull], AtomTransition.prototype, "label", null);
__decorate([Decorators_1.Override], AtomTransition.prototype, "matches", null);
__decorate([Decorators_1.Override, Decorators_1.NotNull], AtomTransition.prototype, "toString", null);
AtomTransition = __decorate([__param(0, Decorators_1.NotNull)], AtomTransition);
exports.AtomTransition = AtomTransition;

},{"../Decorators":272,"../misc/IntervalSet":379,"./Transition":361,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],311:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:27.7669801-07:00
var ATNStateType_1 = require("./ATNStateType");
var BlockStartState_1 = require("./BlockStartState");
var Decorators_1 = require("../Decorators");
/**
 *
 * @author Sam Harwell
 */
var BasicBlockStartState = /*#__PURE__*/function (_BlockStartState_1$Bl) {
  (0, _inherits2.default)(BasicBlockStartState, _BlockStartState_1$Bl);
  var _super = _createSuper(BasicBlockStartState);
  function BasicBlockStartState() {
    (0, _classCallCheck2.default)(this, BasicBlockStartState);
    return _super.apply(this, arguments);
  }
  (0, _createClass2.default)(BasicBlockStartState, [{
    key: "stateType",
    get: function get() {
      return ATNStateType_1.ATNStateType.BLOCK_START;
    }
  }]);
  return BasicBlockStartState;
}(BlockStartState_1.BlockStartState);
__decorate([Decorators_1.Override], BasicBlockStartState.prototype, "stateType", null);
exports.BasicBlockStartState = BasicBlockStartState;

},{"../Decorators":272,"./ATNStateType":306,"./BlockStartState":314,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],312:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:27.8389930-07:00
var ATNState_1 = require("./ATNState");
var ATNStateType_1 = require("./ATNStateType");
var Decorators_1 = require("../Decorators");
/**
 *
 * @author Sam Harwell
 */
var BasicState = /*#__PURE__*/function (_ATNState_1$ATNState) {
  (0, _inherits2.default)(BasicState, _ATNState_1$ATNState);
  var _super = _createSuper(BasicState);
  function BasicState() {
    (0, _classCallCheck2.default)(this, BasicState);
    return _super.apply(this, arguments);
  }
  (0, _createClass2.default)(BasicState, [{
    key: "stateType",
    get: function get() {
      return ATNStateType_1.ATNStateType.BASIC;
    }
  }]);
  return BasicState;
}(ATNState_1.ATNState);
__decorate([Decorators_1.Override], BasicState.prototype, "stateType", null);
exports.BasicState = BasicState;

},{"../Decorators":272,"./ATNState":305,"./ATNStateType":306,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],313:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:27.9125304-07:00
var ATNState_1 = require("./ATNState");
var ATNStateType_1 = require("./ATNStateType");
var Decorators_1 = require("../Decorators");
/** Terminal node of a simple `(a|b|c)` block. */
var BlockEndState = /*#__PURE__*/function (_ATNState_1$ATNState) {
  (0, _inherits2.default)(BlockEndState, _ATNState_1$ATNState);
  var _super = _createSuper(BlockEndState);
  function BlockEndState() {
    (0, _classCallCheck2.default)(this, BlockEndState);
    return _super.apply(this, arguments);
  }
  (0, _createClass2.default)(BlockEndState, [{
    key: "stateType",
    get: function get() {
      return ATNStateType_1.ATNStateType.BLOCK_END;
    }
  }]);
  return BlockEndState;
}(ATNState_1.ATNState);
__decorate([Decorators_1.Override], BlockEndState.prototype, "stateType", null);
exports.BlockEndState = BlockEndState;

},{"../Decorators":272,"./ATNState":305,"./ATNStateType":306,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],314:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var DecisionState_1 = require("./DecisionState");
/**  The start of a regular `(...)` block. */
var BlockStartState = /*#__PURE__*/function (_DecisionState_1$Deci) {
  (0, _inherits2.default)(BlockStartState, _DecisionState_1$Deci);
  var _super = _createSuper(BlockStartState);
  function BlockStartState() {
    (0, _classCallCheck2.default)(this, BlockStartState);
    return _super.apply(this, arguments);
  }
  return (0, _createClass2.default)(BlockStartState);
}(DecisionState_1.DecisionState);
exports.BlockStartState = BlockStartState;

},{"./DecisionState":319,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],315:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var Decorators_1 = require("../Decorators");
var Utils = require("../misc/Utils");
/**
 * This class stores information about a configuration conflict.
 *
 * @author Sam Harwell
 */
var ConflictInfo = /*#__PURE__*/function () {
  function ConflictInfo(conflictedAlts, exact) {
    (0, _classCallCheck2.default)(this, ConflictInfo);
    this._conflictedAlts = conflictedAlts;
    this.exact = exact;
  }
  /**
   * Gets the set of conflicting alternatives for the configuration set.
   */
  (0, _createClass2.default)(ConflictInfo, [{
    key: "conflictedAlts",
    get: function get() {
      return this._conflictedAlts;
    }
    /**
     * Gets whether or not the configuration conflict is an exact conflict.
     * An exact conflict occurs when the prediction algorithm determines that
     * the represented alternatives for a particular configuration set cannot be
     * further reduced by consuming additional input. After reaching an exact
     * conflict during an SLL prediction, only switch to full-context prediction
     * could reduce the set of viable alternatives. In LL prediction, an exact
     * conflict indicates a true ambiguity in the input.
     *
     * For the {@link PredictionMode#LL_EXACT_AMBIG_DETECTION} prediction mode,
     * accept states are conflicting but not exact are treated as non-accept
     * states.
     */
  }, {
    key: "isExact",
    get: function get() {
      return this.exact;
    }
  }, {
    key: "equals",
    value: function equals(obj) {
      if (obj === this) {
        return true;
      } else if (!(obj instanceof ConflictInfo)) {
        return false;
      }
      return this.isExact === obj.isExact && Utils.equals(this.conflictedAlts, obj.conflictedAlts);
    }
  }, {
    key: "hashCode",
    value: function hashCode() {
      return this.conflictedAlts.hashCode();
    }
  }]);
  return ConflictInfo;
}();
__decorate([Decorators_1.Override], ConflictInfo.prototype, "equals", null);
__decorate([Decorators_1.Override], ConflictInfo.prototype, "hashCode", null);
exports.ConflictInfo = ConflictInfo;

},{"../Decorators":272,"../misc/Utils":385,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612}],316:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:28.1575933-07:00
var DecisionEventInfo_1 = require("./DecisionEventInfo");
var Decorators_1 = require("../Decorators");
/**
 * This class represents profiling event information for a context sensitivity.
 * Context sensitivities are decisions where a particular input resulted in an
 * SLL conflict, but LL prediction produced a single unique alternative.
 *
 * In some cases, the unique alternative identified by LL prediction is not
 * equal to the minimum represented alternative in the conflicting SLL
 * configuration set. Grammars and inputs which result in this scenario are
 * unable to use {@link PredictionMode#SLL}, which in turn means they cannot use
 * the two-stage parsing strategy to improve parsing performance for that
 * input.
 *
 * @see ParserATNSimulator#reportContextSensitivity
 * @see ParserErrorListener#reportContextSensitivity
 *
 * @since 4.3
 */
var ContextSensitivityInfo = /*#__PURE__*/function (_DecisionEventInfo_1$) {
  (0, _inherits2.default)(ContextSensitivityInfo, _DecisionEventInfo_1$);
  var _super = _createSuper(ContextSensitivityInfo);
  /**
   * Constructs a new instance of the {@link ContextSensitivityInfo} class
   * with the specified detailed context sensitivity information.
   *
   * @param decision The decision number
   * @param state The final simulator state containing the unique
   * alternative identified by full-context prediction
   * @param input The input token stream
   * @param startIndex The start index for the current prediction
   * @param stopIndex The index at which the context sensitivity was
   * identified during full-context prediction
   */
  function ContextSensitivityInfo(decision, state, input, startIndex, stopIndex) {
    (0, _classCallCheck2.default)(this, ContextSensitivityInfo);
    return _super.call(this, decision, state, input, startIndex, stopIndex, true);
  }
  return (0, _createClass2.default)(ContextSensitivityInfo);
}(DecisionEventInfo_1.DecisionEventInfo);
ContextSensitivityInfo = __decorate([__param(1, Decorators_1.NotNull), __param(2, Decorators_1.NotNull)], ContextSensitivityInfo);
exports.ContextSensitivityInfo = ContextSensitivityInfo;

},{"../Decorators":272,"./DecisionEventInfo":317,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],317:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:28.2401032-07:00
var Decorators_1 = require("../Decorators");
/**
 * This is the base class for gathering detailed information about prediction
 * events which occur during parsing.
 *
 * Note that we could record the parser call stack at the time this event
 * occurred but in the presence of left recursive rules, the stack is kind of
 * meaningless. It's better to look at the individual configurations for their
 * individual stacks. Of course that is a {@link PredictionContext} object
 * not a parse tree node and so it does not have information about the extent
 * (start...stop) of the various subtrees. Examining the stack tops of all
 * configurations provide the return states for the rule invocations.
 * From there you can get the enclosing rule.
 *
 * @since 4.3
 */
var DecisionEventInfo = /*#__PURE__*/(0, _createClass2.default)(function DecisionEventInfo(decision, state, input, startIndex, stopIndex, fullCtx) {
  (0, _classCallCheck2.default)(this, DecisionEventInfo);
  this.decision = decision;
  this.fullCtx = fullCtx;
  this.stopIndex = stopIndex;
  this.input = input;
  this.startIndex = startIndex;
  this.state = state;
});
__decorate([Decorators_1.NotNull], DecisionEventInfo.prototype, "input", void 0);
DecisionEventInfo = __decorate([__param(2, Decorators_1.NotNull)], DecisionEventInfo);
exports.DecisionEventInfo = DecisionEventInfo;

},{"../Decorators":272,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612}],318:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var Decorators_1 = require("../Decorators");
/**
 * This class contains profiling gathered for a particular decision.
 *
 * Parsing performance in ANTLR 4 is heavily influenced by both static factors
 * (e.g. the form of the rules in the grammar) and dynamic factors (e.g. the
 * choice of input and the state of the DFA cache at the time profiling
 * operations are started). For best results, gather and use aggregate
 * statistics from a large sample of inputs representing the inputs expected in
 * production before using the results to make changes in the grammar.
 *
 * @since 4.3
 */
var DecisionInfo = /*#__PURE__*/function () {
  /**
   * Constructs a new instance of the {@link DecisionInfo} class to contain
   * statistics for a particular decision.
   *
   * @param decision The decision number
   */
  function DecisionInfo(decision) {
    (0, _classCallCheck2.default)(this, DecisionInfo);
    /**
     * The total number of times {@link ParserATNSimulator#adaptivePredict} was
     * invoked for this decision.
     */
    this.invocations = 0;
    /**
     * The total time spent in {@link ParserATNSimulator#adaptivePredict} for
     * this decision, in nanoseconds.
     *
     * The value of this field contains the sum of differential results obtained
     * by {@link System#nanoTime()}, and is not adjusted to compensate for JIT
     * and/or garbage collection overhead. For best accuracy, use a modern JVM
     * implementation that provides precise results from
     * {@link System#nanoTime()}, and perform profiling in a separate process
     * which is warmed up by parsing the input prior to profiling. If desired,
     * call {@link ATNSimulator#clearDFA} to reset the DFA cache to its initial
     * state before starting the profiling measurement pass.
     */
    this.timeInPrediction = 0;
    /**
     * The sum of the lookahead required for SLL prediction for this decision.
     * Note that SLL prediction is used before LL prediction for performance
     * reasons even when {@link PredictionMode#LL} or
     * {@link PredictionMode#LL_EXACT_AMBIG_DETECTION} is used.
     */
    this.SLL_TotalLook = 0;
    /**
     * Gets the minimum lookahead required for any single SLL prediction to
     * complete for this decision, by reaching a unique prediction, reaching an
     * SLL conflict state, or encountering a syntax error.
     */
    this.SLL_MinLook = 0;
    /**
     * Gets the maximum lookahead required for any single SLL prediction to
     * complete for this decision, by reaching a unique prediction, reaching an
     * SLL conflict state, or encountering a syntax error.
     */
    this.SLL_MaxLook = 0;
    /**
     * The sum of the lookahead required for LL prediction for this decision.
     * Note that LL prediction is only used when SLL prediction reaches a
     * conflict state.
     */
    this.LL_TotalLook = 0;
    /**
     * Gets the minimum lookahead required for any single LL prediction to
     * complete for this decision. An LL prediction completes when the algorithm
     * reaches a unique prediction, a conflict state (for
     * {@link PredictionMode#LL}, an ambiguity state (for
     * {@link PredictionMode#LL_EXACT_AMBIG_DETECTION}, or a syntax error.
     */
    this.LL_MinLook = 0;
    /**
     * Gets the maximum lookahead required for any single LL prediction to
     * complete for this decision. An LL prediction completes when the algorithm
     * reaches a unique prediction, a conflict state (for
     * {@link PredictionMode#LL}, an ambiguity state (for
     * {@link PredictionMode#LL_EXACT_AMBIG_DETECTION}, or a syntax error.
     */
    this.LL_MaxLook = 0;
    /**
     * A collection of {@link ContextSensitivityInfo} instances describing the
     * context sensitivities encountered during LL prediction for this decision.
     *
     * @see ContextSensitivityInfo
     */
    this.contextSensitivities = [];
    /**
     * A collection of {@link ErrorInfo} instances describing the parse errors
     * identified during calls to {@link ParserATNSimulator#adaptivePredict} for
     * this decision.
     *
     * @see ErrorInfo
     */
    this.errors = [];
    /**
     * A collection of {@link AmbiguityInfo} instances describing the
     * ambiguities encountered during LL prediction for this decision.
     *
     * @see AmbiguityInfo
     */
    this.ambiguities = [];
    /**
     * A collection of {@link PredicateEvalInfo} instances describing the
     * results of evaluating individual predicates during prediction for this
     * decision.
     *
     * @see PredicateEvalInfo
     */
    this.predicateEvals = [];
    /**
     * The total number of ATN transitions required during SLL prediction for
     * this decision. An ATN transition is determined by the number of times the
     * DFA does not contain an edge that is required for prediction, resulting
     * in on-the-fly computation of that edge.
     *
     * If DFA caching of SLL transitions is employed by the implementation, ATN
     * computation may cache the computed edge for efficient lookup during
     * future parsing of this decision. Otherwise, the SLL parsing algorithm
     * will use ATN transitions exclusively.
     *
     * @see #SLL_ATNTransitions
     * @see ParserATNSimulator#computeTargetState
     * @see LexerATNSimulator#computeTargetState
     */
    this.SLL_ATNTransitions = 0;
    /**
     * The total number of DFA transitions required during SLL prediction for
     * this decision.
     *
     * If the ATN simulator implementation does not use DFA caching for SLL
     * transitions, this value will be 0.
     *
     * @see ParserATNSimulator#getExistingTargetState
     * @see LexerATNSimulator#getExistingTargetState
     */
    this.SLL_DFATransitions = 0;
    /**
     * Gets the total number of times SLL prediction completed in a conflict
     * state, resulting in fallback to LL prediction.
     *
     * Note that this value is not related to whether or not
     * {@link PredictionMode#SLL} may be used successfully with a particular
     * grammar. If the ambiguity resolution algorithm applied to the SLL
     * conflicts for this decision produce the same result as LL prediction for
     * this decision, {@link PredictionMode#SLL} would produce the same overall
     * parsing result as {@link PredictionMode#LL}.
     */
    this.LL_Fallback = 0;
    /**
     * The total number of ATN transitions required during LL prediction for
     * this decision. An ATN transition is determined by the number of times the
     * DFA does not contain an edge that is required for prediction, resulting
     * in on-the-fly computation of that edge.
     *
     * If DFA caching of LL transitions is employed by the implementation, ATN
     * computation may cache the computed edge for efficient lookup during
     * future parsing of this decision. Otherwise, the LL parsing algorithm will
     * use ATN transitions exclusively.
     *
     * @see #LL_DFATransitions
     * @see ParserATNSimulator#computeTargetState
     * @see LexerATNSimulator#computeTargetState
     */
    this.LL_ATNTransitions = 0;
    /**
     * The total number of DFA transitions required during LL prediction for
     * this decision.
     *
     * If the ATN simulator implementation does not use DFA caching for LL
     * transitions, this value will be 0.
     *
     * @see ParserATNSimulator#getExistingTargetState
     * @see LexerATNSimulator#getExistingTargetState
     */
    this.LL_DFATransitions = 0;
    this.decision = decision;
  }
  (0, _createClass2.default)(DecisionInfo, [{
    key: "toString",
    value: function toString() {
      return "{" + "decision=" + this.decision + ", contextSensitivities=" + this.contextSensitivities.length + ", errors=" + this.errors.length + ", ambiguities=" + this.ambiguities.length + ", SLL_lookahead=" + this.SLL_TotalLook + ", SLL_ATNTransitions=" + this.SLL_ATNTransitions + ", SLL_DFATransitions=" + this.SLL_DFATransitions + ", LL_Fallback=" + this.LL_Fallback + ", LL_lookahead=" + this.LL_TotalLook + ", LL_ATNTransitions=" + this.LL_ATNTransitions + "}";
    }
  }]);
  return DecisionInfo;
}();
__decorate([Decorators_1.Override], DecisionInfo.prototype, "toString", null);
exports.DecisionInfo = DecisionInfo;

},{"../Decorators":272,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612}],319:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:28.4381103-07:00
var ATNState_1 = require("./ATNState");
var DecisionState = /*#__PURE__*/function (_ATNState_1$ATNState) {
  (0, _inherits2.default)(DecisionState, _ATNState_1$ATNState);
  var _super = _createSuper(DecisionState);
  function DecisionState() {
    var _this;
    (0, _classCallCheck2.default)(this, DecisionState);
    _this = _super.apply(this, arguments);
    _this.decision = -1;
    _this.nonGreedy = false;
    _this.sll = false;
    return _this;
  }
  return (0, _createClass2.default)(DecisionState);
}(ATNState_1.ATNState);
exports.DecisionState = DecisionState;

},{"./ATNState":305,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],320:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var Decorators_1 = require("../Decorators");
var Transition_1 = require("./Transition");
var EpsilonTransition = /*#__PURE__*/function (_Transition_1$Transit) {
  (0, _inherits2.default)(EpsilonTransition, _Transition_1$Transit);
  var _super = _createSuper(EpsilonTransition);
  function EpsilonTransition(target) {
    var _this;
    var outermostPrecedenceReturn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
    (0, _classCallCheck2.default)(this, EpsilonTransition);
    _this = _super.call(this, target);
    _this._outermostPrecedenceReturn = outermostPrecedenceReturn;
    return _this;
  }
  /**
   * @returns the rule index of a precedence rule for which this transition is
   * returning from, where the precedence value is 0; otherwise, -1.
   *
   * @see ATNConfig.isPrecedenceFilterSuppressed
   * @see ParserATNSimulator#applyPrecedenceFilter(ATNConfigSet, ParserRuleContext, PredictionContextCache)
   * @since 4.4.1
   */
  (0, _createClass2.default)(EpsilonTransition, [{
    key: "outermostPrecedenceReturn",
    get: function get() {
      return this._outermostPrecedenceReturn;
    }
  }, {
    key: "serializationType",
    get: function get() {
      return 1 /* EPSILON */;
    }
  }, {
    key: "isEpsilon",
    get: function get() {
      return true;
    }
  }, {
    key: "matches",
    value: function matches(symbol, minVocabSymbol, maxVocabSymbol) {
      return false;
    }
  }, {
    key: "toString",
    value: function toString() {
      return "epsilon";
    }
  }]);
  return EpsilonTransition;
}(Transition_1.Transition);
__decorate([Decorators_1.Override], EpsilonTransition.prototype, "serializationType", null);
__decorate([Decorators_1.Override], EpsilonTransition.prototype, "isEpsilon", null);
__decorate([Decorators_1.Override], EpsilonTransition.prototype, "matches", null);
__decorate([Decorators_1.Override, Decorators_1.NotNull], EpsilonTransition.prototype, "toString", null);
EpsilonTransition = __decorate([__param(0, Decorators_1.NotNull)], EpsilonTransition);
exports.EpsilonTransition = EpsilonTransition;

},{"../Decorators":272,"./Transition":361,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],321:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:28.7213647-07:00
var DecisionEventInfo_1 = require("./DecisionEventInfo");
var Decorators_1 = require("../Decorators");
/**
 * This class represents profiling event information for a syntax error
 * identified during prediction. Syntax errors occur when the prediction
 * algorithm is unable to identify an alternative which would lead to a
 * successful parse.
 *
 * @see Parser#notifyErrorListeners(Token, String, RecognitionException)
 * @see ANTLRErrorListener#syntaxError
 *
 * @since 4.3
 */
var ErrorInfo = /*#__PURE__*/function (_DecisionEventInfo_1$) {
  (0, _inherits2.default)(ErrorInfo, _DecisionEventInfo_1$);
  var _super = _createSuper(ErrorInfo);
  /**
   * Constructs a new instance of the {@link ErrorInfo} class with the
   * specified detailed syntax error information.
   *
   * @param decision The decision number
   * @param state The final simulator state reached during prediction
   * prior to reaching the {@link ATNSimulator#ERROR} state
   * @param input The input token stream
   * @param startIndex The start index for the current prediction
   * @param stopIndex The index at which the syntax error was identified
   */
  function ErrorInfo(decision, state, input, startIndex, stopIndex) {
    (0, _classCallCheck2.default)(this, ErrorInfo);
    return _super.call(this, decision, state, input, startIndex, stopIndex, state.useContext);
  }
  return (0, _createClass2.default)(ErrorInfo);
}(DecisionEventInfo_1.DecisionEventInfo);
ErrorInfo = __decorate([__param(1, Decorators_1.NotNull), __param(2, Decorators_1.NotNull)], ErrorInfo);
exports.ErrorInfo = ErrorInfo;

},{"../Decorators":272,"./DecisionEventInfo":317,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],322:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var ATNStateType_1 = require("./ATNStateType");
var BasicState_1 = require("./BasicState");
var Decorators_1 = require("../Decorators");
/**
 *
 * @author Sam Harwell
 */
var InvalidState = /*#__PURE__*/function (_BasicState_1$BasicSt) {
  (0, _inherits2.default)(InvalidState, _BasicState_1$BasicSt);
  var _super = _createSuper(InvalidState);
  function InvalidState() {
    (0, _classCallCheck2.default)(this, InvalidState);
    return _super.apply(this, arguments);
  }
  (0, _createClass2.default)(InvalidState, [{
    key: "stateType",
    get: function get() {
      return ATNStateType_1.ATNStateType.INVALID_TYPE;
    }
  }]);
  return InvalidState;
}(BasicState_1.BasicState);
__decorate([Decorators_1.Override], InvalidState.prototype, "stateType", null);
exports.InvalidState = InvalidState;

},{"../Decorators":272,"./ATNStateType":306,"./BasicState":312,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],323:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:30.4445360-07:00
var AbstractPredicateTransition_1 = require("./AbstractPredicateTransition");
var Array2DHashSet_1 = require("../misc/Array2DHashSet");
var ATNConfig_1 = require("./ATNConfig");
var BitSet_1 = require("../misc/BitSet");
var IntervalSet_1 = require("../misc/IntervalSet");
var Decorators_1 = require("../Decorators");
var NotSetTransition_1 = require("./NotSetTransition");
var ObjectEqualityComparator_1 = require("../misc/ObjectEqualityComparator");
var PredictionContext_1 = require("./PredictionContext");
var RuleStopState_1 = require("./RuleStopState");
var RuleTransition_1 = require("./RuleTransition");
var Token_1 = require("../Token");
var WildcardTransition_1 = require("./WildcardTransition");
var LL1Analyzer = /*#__PURE__*/function () {
  function LL1Analyzer(atn) {
    (0, _classCallCheck2.default)(this, LL1Analyzer);
    this.atn = atn;
  }
  /**
   * Calculates the SLL(1) expected lookahead set for each outgoing transition
   * of an {@link ATNState}. The returned array has one element for each
   * outgoing transition in `s`. If the closure from transition
   * *i* leads to a semantic predicate before matching a symbol, the
   * element at index *i* of the result will be `undefined`.
   *
   * @param s the ATN state
   * @returns the expected symbols for each outgoing transition of `s`.
   */
  (0, _createClass2.default)(LL1Analyzer, [{
    key: "getDecisionLookahead",
    value: function getDecisionLookahead(s) {
      //		System.out.println("LOOK("+s.stateNumber+")");
      if (s == null) {
        return undefined;
      }
      var look = new Array(s.numberOfTransitions);
      for (var alt = 0; alt < s.numberOfTransitions; alt++) {
        var current = new IntervalSet_1.IntervalSet();
        look[alt] = current;
        var lookBusy = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
        var seeThruPreds = false; // fail to get lookahead upon pred
        this._LOOK(s.transition(alt).target, undefined, PredictionContext_1.PredictionContext.EMPTY_LOCAL, current, lookBusy, new BitSet_1.BitSet(), seeThruPreds, false);
        // Wipe out lookahead for this alternative if we found nothing
        // or we had a predicate when we !seeThruPreds
        if (current.size === 0 || current.contains(LL1Analyzer.HIT_PRED)) {
          current = undefined;
          look[alt] = current;
        }
      }
      return look;
    }
  }, {
    key: "LOOK",
    value: function LOOK(s, ctx, stopState) {
      if (stopState === undefined) {
        if (s.atn == null) {
          throw new Error("Illegal state");
        }
        stopState = s.atn.ruleToStopState[s.ruleIndex];
      } else if (stopState === null) {
        // This is an explicit request to pass undefined as the stopState to _LOOK. Used to distinguish an overload
        // from the method which simply omits the stopState parameter.
        stopState = undefined;
      }
      var r = new IntervalSet_1.IntervalSet();
      var seeThruPreds = true; // ignore preds; get all lookahead
      var addEOF = true;
      this._LOOK(s, stopState, ctx, r, new Array2DHashSet_1.Array2DHashSet(), new BitSet_1.BitSet(), seeThruPreds, addEOF);
      return r;
    }
    /**
     * Compute set of tokens that can follow `s` in the ATN in the
     * specified `ctx`.
     * <p/>
     * If `ctx` is {@link PredictionContext#EMPTY_LOCAL} and
     * `stopState` or the end of the rule containing `s` is reached,
     * {@link Token#EPSILON} is added to the result set. If `ctx` is not
     * {@link PredictionContext#EMPTY_LOCAL} and `addEOF` is `true`
     * and `stopState` or the end of the outermost rule is reached,
     * {@link Token#EOF} is added to the result set.
     *
     * @param s the ATN state.
     * @param stopState the ATN state to stop at. This can be a
     * {@link BlockEndState} to detect epsilon paths through a closure.
     * @param ctx The outer context, or {@link PredictionContext#EMPTY_LOCAL} if
     * the outer context should not be used.
     * @param look The result lookahead set.
     * @param lookBusy A set used for preventing epsilon closures in the ATN
     * from causing a stack overflow. Outside code should pass
     * `new HashSet<ATNConfig>` for this argument.
     * @param calledRuleStack A set used for preventing left recursion in the
     * ATN from causing a stack overflow. Outside code should pass
     * `new BitSet()` for this argument.
     * @param seeThruPreds `true` to true semantic predicates as
     * implicitly `true` and "see through them", otherwise `false`
     * to treat semantic predicates as opaque and add {@link #HIT_PRED} to the
     * result if one is encountered.
     * @param addEOF Add {@link Token#EOF} to the result if the end of the
     * outermost context is reached. This parameter has no effect if `ctx`
     * is {@link PredictionContext#EMPTY_LOCAL}.
     */
  }, {
    key: "_LOOK",
    value: function _LOOK(s, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF) {
      //		System.out.println("_LOOK("+s.stateNumber+", ctx="+ctx);
      var c = ATNConfig_1.ATNConfig.create(s, 0, ctx);
      if (!lookBusy.add(c)) {
        return;
      }
      if (s === stopState) {
        if (PredictionContext_1.PredictionContext.isEmptyLocal(ctx)) {
          look.add(Token_1.Token.EPSILON);
          return;
        } else if (ctx.isEmpty) {
          if (addEOF) {
            look.add(Token_1.Token.EOF);
          }
          return;
        }
      }
      if (s instanceof RuleStopState_1.RuleStopState) {
        if (ctx.isEmpty && !PredictionContext_1.PredictionContext.isEmptyLocal(ctx)) {
          if (addEOF) {
            look.add(Token_1.Token.EOF);
          }
          return;
        }
        var removed = calledRuleStack.get(s.ruleIndex);
        try {
          calledRuleStack.clear(s.ruleIndex);
          for (var i = 0; i < ctx.size; i++) {
            if (ctx.getReturnState(i) === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
              continue;
            }
            var returnState = this.atn.states[ctx.getReturnState(i)];
            //					System.out.println("popping back to "+retState);
            this._LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
          }
        } finally {
          if (removed) {
            calledRuleStack.set(s.ruleIndex);
          }
        }
      }
      var n = s.numberOfTransitions;
      for (var _i = 0; _i < n; _i++) {
        var t = s.transition(_i);
        if (t instanceof RuleTransition_1.RuleTransition) {
          if (calledRuleStack.get(t.ruleIndex)) {
            continue;
          }
          var newContext = ctx.getChild(t.followState.stateNumber);
          try {
            calledRuleStack.set(t.ruleIndex);
            this._LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
          } finally {
            calledRuleStack.clear(t.ruleIndex);
          }
        } else if (t instanceof AbstractPredicateTransition_1.AbstractPredicateTransition) {
          if (seeThruPreds) {
            this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
          } else {
            look.add(LL1Analyzer.HIT_PRED);
          }
        } else if (t.isEpsilon) {
          this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
        } else if (t instanceof WildcardTransition_1.WildcardTransition) {
          look.addAll(IntervalSet_1.IntervalSet.of(Token_1.Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType));
        } else {
          //				System.out.println("adding "+ t);
          var set = t.label;
          if (set != null) {
            if (t instanceof NotSetTransition_1.NotSetTransition) {
              set = set.complement(IntervalSet_1.IntervalSet.of(Token_1.Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType));
            }
            look.addAll(set);
          }
        }
      }
    }
  }]);
  return LL1Analyzer;
}();
/** Special value added to the lookahead sets to indicate that we hit
 *  a predicate during analysis if `seeThruPreds==false`.
 */
LL1Analyzer.HIT_PRED = Token_1.Token.INVALID_TYPE;
__decorate([Decorators_1.NotNull], LL1Analyzer.prototype, "atn", void 0);
__decorate([Decorators_1.NotNull, __param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)], LL1Analyzer.prototype, "LOOK", null);
__decorate([__param(0, Decorators_1.NotNull), __param(2, Decorators_1.NotNull), __param(3, Decorators_1.NotNull), __param(4, Decorators_1.NotNull), __param(5, Decorators_1.NotNull)], LL1Analyzer.prototype, "_LOOK", null);
LL1Analyzer = __decorate([__param(0, Decorators_1.NotNull)], LL1Analyzer);
exports.LL1Analyzer = LL1Analyzer;

},{"../Decorators":272,"../Token":296,"../misc/Array2DHashSet":370,"../misc/BitSet":373,"../misc/IntervalSet":379,"../misc/ObjectEqualityComparator":382,"./ATNConfig":300,"./AbstractPredicateTransition":307,"./NotSetTransition":337,"./PredictionContext":346,"./RuleStopState":352,"./RuleTransition":353,"./WildcardTransition":362,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612}],324:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.array.concat.js");
require("core-js/modules/es.regexp.to-string.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:29.1083066-07:00
var AcceptStateInfo_1 = require("../dfa/AcceptStateInfo");
var ATN_1 = require("./ATN");
var ATNConfig_1 = require("./ATNConfig");
var ATNConfigSet_1 = require("./ATNConfigSet");
var ATNSimulator_1 = require("./ATNSimulator");
var DFAState_1 = require("../dfa/DFAState");
var Interval_1 = require("../misc/Interval");
var IntStream_1 = require("../IntStream");
var Lexer_1 = require("../Lexer");
var LexerActionExecutor_1 = require("./LexerActionExecutor");
var LexerNoViableAltException_1 = require("../LexerNoViableAltException");
var Decorators_1 = require("../Decorators");
var OrderedATNConfigSet_1 = require("./OrderedATNConfigSet");
var PredictionContext_1 = require("./PredictionContext");
var RuleStopState_1 = require("./RuleStopState");
var Token_1 = require("../Token");
var assert = require("assert");
/** "dup" of ParserInterpreter */
var LexerATNSimulator = /*#__PURE__*/function (_ATNSimulator_1$ATNSi) {
  (0, _inherits2.default)(LexerATNSimulator, _ATNSimulator_1$ATNSi);
  var _super = _createSuper(LexerATNSimulator);
  function LexerATNSimulator(atn, recog) {
    var _this;
    (0, _classCallCheck2.default)(this, LexerATNSimulator);
    _this = _super.call(this, atn);
    _this.optimize_tail_calls = true;
    /** The current token's starting index into the character stream.
     *  Shared across DFA to ATN simulation in case the ATN fails and the
     *  DFA did not have a previous accept state. In this case, we use the
     *  ATN-generated exception object.
     */
    _this.startIndex = -1;
    /** line number 1..n within the input */
    _this._line = 1;
    /** The index of the character relative to the beginning of the line 0..n-1 */
    _this._charPositionInLine = 0;
    _this.mode = Lexer_1.Lexer.DEFAULT_MODE;
    /** Used during DFA/ATN exec to record the most recent accept configuration info */
    _this.prevAccept = new LexerATNSimulator.SimState();
    _this.recog = recog;
    return _this;
  }
  (0, _createClass2.default)(LexerATNSimulator, [{
    key: "copyState",
    value: function copyState(simulator) {
      this._charPositionInLine = simulator.charPositionInLine;
      this._line = simulator._line;
      this.mode = simulator.mode;
      this.startIndex = simulator.startIndex;
    }
  }, {
    key: "match",
    value: function match(input, mode) {
      LexerATNSimulator.match_calls++;
      this.mode = mode;
      var mark = input.mark();
      try {
        this.startIndex = input.index;
        this.prevAccept.reset();
        var s0 = this.atn.modeToDFA[mode].s0;
        if (s0 == null) {
          return this.matchATN(input);
        } else {
          return this.execATN(input, s0);
        }
      } finally {
        input.release(mark);
      }
    }
  }, {
    key: "reset",
    value: function reset() {
      this.prevAccept.reset();
      this.startIndex = -1;
      this._line = 1;
      this._charPositionInLine = 0;
      this.mode = Lexer_1.Lexer.DEFAULT_MODE;
    }
  }, {
    key: "matchATN",
    value: function matchATN(input) {
      var startState = this.atn.modeToStartState[this.mode];
      if (LexerATNSimulator.debug) {
        console.log("matchATN mode ".concat(this.mode, " start: ").concat(startState));
      }
      var old_mode = this.mode;
      var s0_closure = this.computeStartState(input, startState);
      var suppressEdge = s0_closure.hasSemanticContext;
      if (suppressEdge) {
        s0_closure.hasSemanticContext = false;
      }
      var next = this.addDFAState(s0_closure);
      if (!suppressEdge) {
        var dfa = this.atn.modeToDFA[this.mode];
        if (!dfa.s0) {
          dfa.s0 = next;
        } else {
          next = dfa.s0;
        }
      }
      var predict = this.execATN(input, next);
      if (LexerATNSimulator.debug) {
        console.log("DFA after matchATN: ".concat(this.atn.modeToDFA[old_mode].toLexerString()));
      }
      return predict;
    }
  }, {
    key: "execATN",
    value: function execATN(input, ds0) {
      // console.log("enter exec index "+input.index+" from "+ds0.configs);
      if (LexerATNSimulator.debug) {
        console.log("start state closure=".concat(ds0.configs));
      }
      if (ds0.isAcceptState) {
        // allow zero-length tokens
        this.captureSimState(this.prevAccept, input, ds0);
      }
      var t = input.LA(1);
      // @NotNull
      var s = ds0; // s is current/from DFA state
      while (true) {
        // while more work
        if (LexerATNSimulator.debug) {
          console.log("execATN loop starting closure: ".concat(s.configs));
        }
        // As we move src->trg, src->trg, we keep track of the previous trg to
        // avoid looking up the DFA state again, which is expensive.
        // If the previous target was already part of the DFA, we might
        // be able to avoid doing a reach operation upon t. If s!=null,
        // it means that semantic predicates didn't prevent us from
        // creating a DFA state. Once we know s!=null, we check to see if
        // the DFA state has an edge already for t. If so, we can just reuse
        // it's configuration set; there's no point in re-computing it.
        // This is kind of like doing DFA simulation within the ATN
        // simulation because DFA simulation is really just a way to avoid
        // computing reach/closure sets. Technically, once we know that
        // we have a previously added DFA state, we could jump over to
        // the DFA simulator. But, that would mean popping back and forth
        // a lot and making things more complicated algorithmically.
        // This optimization makes a lot of sense for loops within DFA.
        // A character will take us back to an existing DFA state
        // that already has lots of edges out of it. e.g., .* in comments.
        var target = this.getExistingTargetState(s, t);
        if (target == null) {
          target = this.computeTargetState(input, s, t);
        }
        if (target === ATNSimulator_1.ATNSimulator.ERROR) {
          break;
        }
        // If this is a consumable input element, make sure to consume before
        // capturing the accept state so the input index, line, and char
        // position accurately reflect the state of the interpreter at the
        // end of the token.
        if (t !== IntStream_1.IntStream.EOF) {
          this.consume(input);
        }
        if (target.isAcceptState) {
          this.captureSimState(this.prevAccept, input, target);
          if (t === IntStream_1.IntStream.EOF) {
            break;
          }
        }
        t = input.LA(1);
        s = target; // flip; current DFA target becomes new src/from state
      }

      return this.failOrAccept(this.prevAccept, input, s.configs, t);
    }
    /**
     * Get an existing target state for an edge in the DFA. If the target state
     * for the edge has not yet been computed or is otherwise not available,
     * this method returns `undefined`.
     *
     * @param s The current DFA state
     * @param t The next input symbol
     * @returns The existing target DFA state for the given input symbol
     * `t`, or `undefined` if the target state for this edge is not
     * already cached
     */
  }, {
    key: "getExistingTargetState",
    value: function getExistingTargetState(s, t) {
      var target = s.getTarget(t);
      if (LexerATNSimulator.debug && target != null) {
        console.log("reuse state " + s.stateNumber + " edge to " + target.stateNumber);
      }
      return target;
    }
    /**
     * Compute a target state for an edge in the DFA, and attempt to add the
     * computed state and corresponding edge to the DFA.
     *
     * @param input The input stream
     * @param s The current DFA state
     * @param t The next input symbol
     *
     * @returns The computed target DFA state for the given input symbol
     * `t`. If `t` does not lead to a valid DFA state, this method
     * returns {@link #ERROR}.
     */
  }, {
    key: "computeTargetState",
    value: function computeTargetState(input, s, t) {
      var reach = new OrderedATNConfigSet_1.OrderedATNConfigSet();
      // if we don't find an existing DFA state
      // Fill reach starting from closure, following t transitions
      this.getReachableConfigSet(input, s.configs, reach, t);
      if (reach.isEmpty) {
        // we got nowhere on t from s
        if (!reach.hasSemanticContext) {
          // we got nowhere on t, don't throw out this knowledge; it'd
          // cause a failover from DFA later.
          this.addDFAEdge(s, t, ATNSimulator_1.ATNSimulator.ERROR);
        }
        // stop when we can't match any more char
        return ATNSimulator_1.ATNSimulator.ERROR;
      }
      // Add an edge from s to target DFA found/created for reach
      return this.addDFAEdge(s, t, reach);
    }
  }, {
    key: "failOrAccept",
    value: function failOrAccept(prevAccept, input, reach, t) {
      if (prevAccept.dfaState != null) {
        var lexerActionExecutor = prevAccept.dfaState.lexerActionExecutor;
        this.accept(input, lexerActionExecutor, this.startIndex, prevAccept.index, prevAccept.line, prevAccept.charPos);
        return prevAccept.dfaState.prediction;
      } else {
        // if no accept and EOF is first char, return EOF
        if (t === IntStream_1.IntStream.EOF && input.index === this.startIndex) {
          return Token_1.Token.EOF;
        }
        throw new LexerNoViableAltException_1.LexerNoViableAltException(this.recog, input, this.startIndex, reach);
      }
    }
    /** Given a starting configuration set, figure out all ATN configurations
     *  we can reach upon input `t`. Parameter `reach` is a return
     *  parameter.
     */
  }, {
    key: "getReachableConfigSet",
    value: function getReachableConfigSet(input, closure, reach, t) {
      // this is used to skip processing for configs which have a lower priority
      // than a config that already reached an accept state for the same rule
      var skipAlt = ATN_1.ATN.INVALID_ALT_NUMBER;
      var _iterator = _createForOfIteratorHelper(closure),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var c = _step.value;
          var currentAltReachedAcceptState = c.alt === skipAlt;
          if (currentAltReachedAcceptState && c.hasPassedThroughNonGreedyDecision) {
            continue;
          }
          if (LexerATNSimulator.debug) {
            console.log("testing ".concat(this.getTokenName(t), " at ").concat(c.toString(this.recog, true)));
          }
          var n = c.state.numberOfOptimizedTransitions;
          for (var ti = 0; ti < n; ti++) {
            // for each optimized transition
            var trans = c.state.getOptimizedTransition(ti);
            var target = this.getReachableTarget(trans, t);
            if (target != null) {
              var lexerActionExecutor = c.lexerActionExecutor;
              var config = void 0;
              if (lexerActionExecutor != null) {
                lexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);
                config = c.transform(target, true, lexerActionExecutor);
              } else {
                assert(c.lexerActionExecutor == null);
                config = c.transform(target, true);
              }
              var treatEofAsEpsilon = t === IntStream_1.IntStream.EOF;
              if (this.closure(input, config, reach, currentAltReachedAcceptState, true, treatEofAsEpsilon)) {
                // any remaining configs for this alt have a lower priority than
                // the one that just reached an accept state.
                skipAlt = c.alt;
                break;
              }
            }
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "accept",
    value: function accept(input, lexerActionExecutor, startIndex, index, line, charPos) {
      if (LexerATNSimulator.debug) {
        console.log("ACTION ".concat(lexerActionExecutor));
      }
      // seek to after last char in token
      input.seek(index);
      this._line = line;
      this._charPositionInLine = charPos;
      if (lexerActionExecutor != null && this.recog != null) {
        lexerActionExecutor.execute(this.recog, input, startIndex);
      }
    }
  }, {
    key: "getReachableTarget",
    value: function getReachableTarget(trans, t) {
      if (trans.matches(t, Lexer_1.Lexer.MIN_CHAR_VALUE, Lexer_1.Lexer.MAX_CHAR_VALUE)) {
        return trans.target;
      }
      return undefined;
    }
  }, {
    key: "computeStartState",
    value: function computeStartState(input, p) {
      var initialContext = PredictionContext_1.PredictionContext.EMPTY_FULL;
      var configs = new OrderedATNConfigSet_1.OrderedATNConfigSet();
      for (var i = 0; i < p.numberOfTransitions; i++) {
        var target = p.transition(i).target;
        var c = ATNConfig_1.ATNConfig.create(target, i + 1, initialContext);
        this.closure(input, c, configs, false, false, false);
      }
      return configs;
    }
    /**
     * Since the alternatives within any lexer decision are ordered by
     * preference, this method stops pursuing the closure as soon as an accept
     * state is reached. After the first accept state is reached by depth-first
     * search from `config`, all other (potentially reachable) states for
     * this rule would have a lower priority.
     *
     * @returns `true` if an accept state is reached, otherwise
     * `false`.
     */
  }, {
    key: "closure",
    value: function closure(input, config, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon) {
      if (LexerATNSimulator.debug) {
        console.log("closure(" + config.toString(this.recog, true) + ")");
      }
      if (config.state instanceof RuleStopState_1.RuleStopState) {
        if (LexerATNSimulator.debug) {
          if (this.recog != null) {
            console.log("closure at ".concat(this.recog.ruleNames[config.state.ruleIndex], " rule stop ").concat(config));
          } else {
            console.log("closure at rule stop ".concat(config));
          }
        }
        var context = config.context;
        if (context.isEmpty) {
          configs.add(config);
          return true;
        } else if (context.hasEmpty) {
          configs.add(config.transform(config.state, true, PredictionContext_1.PredictionContext.EMPTY_FULL));
          currentAltReachedAcceptState = true;
        }
        for (var i = 0; i < context.size; i++) {
          var returnStateNumber = context.getReturnState(i);
          if (returnStateNumber === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
            continue;
          }
          var newContext = context.getParent(i); // "pop" return state
          var returnState = this.atn.states[returnStateNumber];
          var c = config.transform(returnState, false, newContext);
          currentAltReachedAcceptState = this.closure(input, c, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);
        }
        return currentAltReachedAcceptState;
      }
      // optimization
      if (!config.state.onlyHasEpsilonTransitions) {
        if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision) {
          configs.add(config);
        }
      }
      var p = config.state;
      for (var _i = 0; _i < p.numberOfOptimizedTransitions; _i++) {
        var t = p.getOptimizedTransition(_i);
        var _c = this.getEpsilonTarget(input, config, t, configs, speculative, treatEofAsEpsilon);
        if (_c != null) {
          currentAltReachedAcceptState = this.closure(input, _c, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);
        }
      }
      return currentAltReachedAcceptState;
    }
    // side-effect: can alter configs.hasSemanticContext
  }, {
    key: "getEpsilonTarget",
    value: function getEpsilonTarget(input, config, t, configs, speculative, treatEofAsEpsilon) {
      var c;
      switch (t.serializationType) {
        case 3 /* RULE */:
          var ruleTransition = t;
          if (this.optimize_tail_calls && ruleTransition.optimizedTailCall && !config.context.hasEmpty) {
            c = config.transform(t.target, true);
          } else {
            var newContext = config.context.getChild(ruleTransition.followState.stateNumber);
            c = config.transform(t.target, true, newContext);
          }
          break;
        case 10 /* PRECEDENCE */:
          throw new Error("Precedence predicates are not supported in lexers.");
        case 4 /* PREDICATE */:
          /*  Track traversing semantic predicates. If we traverse,
              we cannot add a DFA state for this "reach" computation
              because the DFA would not test the predicate again in the
              future. Rather than creating collections of semantic predicates
              like v3 and testing them on prediction, v4 will test them on the
              fly all the time using the ATN not the DFA. This is slower but
              semantically it's not used that often. One of the key elements to
              this predicate mechanism is not adding DFA states that see
              predicates immediately afterwards in the ATN. For example,
                    a : ID {p1}? | ID {p2}? ;
                    should create the start state for rule 'a' (to save start state
              competition), but should not create target of ID state. The
              collection of ATN states the following ID references includes
              states reached by traversing predicates. Since this is when we
              test them, we cannot cash the DFA state target of ID.
          */
          var pt = t;
          if (LexerATNSimulator.debug) {
            console.log("EVAL rule " + pt.ruleIndex + ":" + pt.predIndex);
          }
          configs.hasSemanticContext = true;
          if (this.evaluatePredicate(input, pt.ruleIndex, pt.predIndex, speculative)) {
            c = config.transform(t.target, true);
          } else {
            c = undefined;
          }
          break;
        case 6 /* ACTION */:
          if (config.context.hasEmpty) {
            // execute actions anywhere in the start rule for a token.
            //
            // TODO: if the entry rule is invoked recursively, some
            // actions may be executed during the recursive call. The
            // problem can appear when hasEmpty is true but
            // isEmpty is false. In this case, the config needs to be
            // split into two contexts - one with just the empty path
            // and another with everything but the empty path.
            // Unfortunately, the current algorithm does not allow
            // getEpsilonTarget to return two configurations, so
            // additional modifications are needed before we can support
            // the split operation.
            var lexerActionExecutor = LexerActionExecutor_1.LexerActionExecutor.append(config.lexerActionExecutor, this.atn.lexerActions[t.actionIndex]);
            c = config.transform(t.target, true, lexerActionExecutor);
            break;
          } else {
            // ignore actions in referenced rules
            c = config.transform(t.target, true);
            break;
          }
        case 1 /* EPSILON */:
          c = config.transform(t.target, true);
          break;
        case 5 /* ATOM */:
        case 2 /* RANGE */:
        case 7 /* SET */:
          if (treatEofAsEpsilon) {
            if (t.matches(IntStream_1.IntStream.EOF, Lexer_1.Lexer.MIN_CHAR_VALUE, Lexer_1.Lexer.MAX_CHAR_VALUE)) {
              c = config.transform(t.target, false);
              break;
            }
          }
          c = undefined;
          break;
        default:
          c = undefined;
          break;
      }
      return c;
    }
    /**
     * Evaluate a predicate specified in the lexer.
     *
     * If `speculative` is `true`, this method was called before
     * {@link #consume} for the matched character. This method should call
     * {@link #consume} before evaluating the predicate to ensure position
     * sensitive values, including {@link Lexer#getText}, {@link Lexer#getLine},
     * and {@link Lexer#getCharPositionInLine}, properly reflect the current
     * lexer state. This method should restore `input` and the simulator
     * to the original state before returning (i.e. undo the actions made by the
     * call to {@link #consume}.
     *
     * @param input The input stream.
     * @param ruleIndex The rule containing the predicate.
     * @param predIndex The index of the predicate within the rule.
     * @param speculative `true` if the current index in `input` is
     * one character before the predicate's location.
     *
     * @returns `true` if the specified predicate evaluates to
     * `true`.
     */
  }, {
    key: "evaluatePredicate",
    value: function evaluatePredicate(input, ruleIndex, predIndex, speculative) {
      // assume true if no recognizer was provided
      if (this.recog == null) {
        return true;
      }
      if (!speculative) {
        return this.recog.sempred(undefined, ruleIndex, predIndex);
      }
      var savedCharPositionInLine = this._charPositionInLine;
      var savedLine = this._line;
      var index = input.index;
      var marker = input.mark();
      try {
        this.consume(input);
        return this.recog.sempred(undefined, ruleIndex, predIndex);
      } finally {
        this._charPositionInLine = savedCharPositionInLine;
        this._line = savedLine;
        input.seek(index);
        input.release(marker);
      }
    }
  }, {
    key: "captureSimState",
    value: function captureSimState(settings, input, dfaState) {
      settings.index = input.index;
      settings.line = this._line;
      settings.charPos = this._charPositionInLine;
      settings.dfaState = dfaState;
    }
  }, {
    key: "addDFAEdge",
    value: function addDFAEdge(p, t, q) {
      if (q instanceof ATNConfigSet_1.ATNConfigSet) {
        /* leading to this call, ATNConfigSet.hasSemanticContext is used as a
        * marker indicating dynamic predicate evaluation makes this edge
        * dependent on the specific input sequence, so the static edge in the
        * DFA should be omitted. The target DFAState is still created since
        * execATN has the ability to resynchronize with the DFA state cache
        * following the predicate evaluation step.
        *
        * TJP notes: next time through the DFA, we see a pred again and eval.
        * If that gets us to a previously created (but dangling) DFA
        * state, we can continue in pure DFA mode from there.
        */
        var suppressEdge = q.hasSemanticContext;
        if (suppressEdge) {
          q.hasSemanticContext = false;
        }
        // @NotNull
        var to = this.addDFAState(q);
        if (suppressEdge) {
          return to;
        }
        this.addDFAEdge(p, t, to);
        return to;
      } else {
        if (LexerATNSimulator.debug) {
          console.log("EDGE " + p + " -> " + q + " upon " + String.fromCharCode(t));
        }
        if (p != null) {
          p.setTarget(t, q);
        }
      }
    }
    /** Add a new DFA state if there isn't one with this set of
     * 	configurations already. This method also detects the first
     * 	configuration containing an ATN rule stop state. Later, when
     * 	traversing the DFA, we will know which rule to accept.
     */
  }, {
    key: "addDFAState",
    value: function addDFAState(configs) {
      /* the lexer evaluates predicates on-the-fly; by this point configs
       * should not contain any configurations with unevaluated predicates.
       */
      assert(!configs.hasSemanticContext);
      var proposed = new DFAState_1.DFAState(configs);
      var existing = this.atn.modeToDFA[this.mode].states.get(proposed);
      if (existing != null) {
        return existing;
      }
      configs.optimizeConfigs(this);
      var newState = new DFAState_1.DFAState(configs.clone(true));
      var firstConfigWithRuleStopState;
      var _iterator2 = _createForOfIteratorHelper(configs),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var c = _step2.value;
          if (c.state instanceof RuleStopState_1.RuleStopState) {
            firstConfigWithRuleStopState = c;
            break;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      if (firstConfigWithRuleStopState != null) {
        var prediction = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];
        var lexerActionExecutor = firstConfigWithRuleStopState.lexerActionExecutor;
        newState.acceptStateInfo = new AcceptStateInfo_1.AcceptStateInfo(prediction, lexerActionExecutor);
      }
      return this.atn.modeToDFA[this.mode].addState(newState);
    }
  }, {
    key: "getDFA",
    value: function getDFA(mode) {
      return this.atn.modeToDFA[mode];
    }
    /** Get the text matched so far for the current token.
     */
  }, {
    key: "getText",
    value: function getText(input) {
      // index is first lookahead char, don't include.
      return input.getText(Interval_1.Interval.of(this.startIndex, input.index - 1));
    }
  }, {
    key: "line",
    get: function get() {
      return this._line;
    },
    set: function set(line) {
      this._line = line;
    }
  }, {
    key: "charPositionInLine",
    get: function get() {
      return this._charPositionInLine;
    },
    set: function set(charPositionInLine) {
      this._charPositionInLine = charPositionInLine;
    }
  }, {
    key: "consume",
    value: function consume(input) {
      var curChar = input.LA(1);
      if (curChar === "\n".charCodeAt(0)) {
        this._line++;
        this._charPositionInLine = 0;
      } else {
        this._charPositionInLine++;
      }
      input.consume();
    }
  }, {
    key: "getTokenName",
    value: function getTokenName(t) {
      if (t === -1) {
        return "EOF";
      }
      //if ( atn.g!=null ) return atn.g.getTokenDisplayName(t);
      return "'" + String.fromCharCode(t) + "'";
    }
  }]);
  return LexerATNSimulator;
}(ATNSimulator_1.ATNSimulator);
LexerATNSimulator.match_calls = 0;
__decorate([Decorators_1.NotNull], LexerATNSimulator.prototype, "prevAccept", void 0);
__decorate([__param(0, Decorators_1.NotNull)], LexerATNSimulator.prototype, "copyState", null);
__decorate([__param(0, Decorators_1.NotNull)], LexerATNSimulator.prototype, "match", null);
__decorate([Decorators_1.Override], LexerATNSimulator.prototype, "reset", null);
__decorate([__param(0, Decorators_1.NotNull)], LexerATNSimulator.prototype, "matchATN", null);
__decorate([__param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)], LexerATNSimulator.prototype, "execATN", null);
__decorate([__param(0, Decorators_1.NotNull)], LexerATNSimulator.prototype, "getExistingTargetState", null);
__decorate([Decorators_1.NotNull, __param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)], LexerATNSimulator.prototype, "computeTargetState", null);
__decorate([__param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull), __param(2, Decorators_1.NotNull)], LexerATNSimulator.prototype, "getReachableConfigSet", null);
__decorate([__param(0, Decorators_1.NotNull)], LexerATNSimulator.prototype, "accept", null);
__decorate([Decorators_1.NotNull, __param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)], LexerATNSimulator.prototype, "computeStartState", null);
__decorate([__param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull), __param(2, Decorators_1.NotNull)], LexerATNSimulator.prototype, "closure", null);
__decorate([__param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull), __param(2, Decorators_1.NotNull), __param(3, Decorators_1.NotNull)], LexerATNSimulator.prototype, "getEpsilonTarget", null);
__decorate([__param(0, Decorators_1.NotNull)], LexerATNSimulator.prototype, "evaluatePredicate", null);
__decorate([__param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull), __param(2, Decorators_1.NotNull)], LexerATNSimulator.prototype, "captureSimState", null);
__decorate([Decorators_1.NotNull, __param(0, Decorators_1.NotNull)], LexerATNSimulator.prototype, "addDFAState", null);
__decorate([Decorators_1.NotNull], LexerATNSimulator.prototype, "getDFA", null);
__decorate([Decorators_1.NotNull, __param(0, Decorators_1.NotNull)], LexerATNSimulator.prototype, "getText", null);
__decorate([__param(0, Decorators_1.NotNull)], LexerATNSimulator.prototype, "consume", null);
__decorate([Decorators_1.NotNull], LexerATNSimulator.prototype, "getTokenName", null);
LexerATNSimulator = __decorate([__param(0, Decorators_1.NotNull)], LexerATNSimulator);
exports.LexerATNSimulator = LexerATNSimulator;
(function (LexerATNSimulator) {
  LexerATNSimulator.debug = false;
  LexerATNSimulator.dfa_debug = false;
  /** When we hit an accept state in either the DFA or the ATN, we
   *  have to notify the character stream to start buffering characters
   *  via {@link IntStream#mark} and record the current state. The current sim state
   *  includes the current index into the input, the current line,
   *  and current character position in that line. Note that the Lexer is
   *  tracking the starting line and characterization of the token. These
   *  variables track the "state" of the simulator when it hits an accept state.
   *
   *  We track these variables separately for the DFA and ATN simulation
   *  because the DFA simulation often has to fail over to the ATN
   *  simulation. If the ATN simulation fails, we need the DFA to fall
   *  back to its previously accepted state, if any. If the ATN succeeds,
   *  then the ATN does the accept and the DFA simulator that invoked it
   *  can simply return the predicted token type.
   */
  var SimState = /*#__PURE__*/function () {
    function SimState() {
      (0, _classCallCheck2.default)(this, SimState);
      this.index = -1;
      this.line = 0;
      this.charPos = -1;
    }
    (0, _createClass2.default)(SimState, [{
      key: "reset",
      value: function reset() {
        this.index = -1;
        this.line = 0;
        this.charPos = -1;
        this.dfaState = undefined;
      }
    }]);
    return SimState;
  }();
  LexerATNSimulator.SimState = SimState;
})(LexerATNSimulator = exports.LexerATNSimulator || (exports.LexerATNSimulator = {}));
exports.LexerATNSimulator = LexerATNSimulator;

},{"../Decorators":272,"../IntStream":278,"../Lexer":280,"../LexerNoViableAltException":282,"../Token":296,"../dfa/AcceptStateInfo":363,"../dfa/DFAState":366,"../misc/Interval":378,"./ATN":299,"./ATNConfig":300,"./ATNConfigSet":301,"./ATNSimulator":304,"./LexerActionExecutor":325,"./OrderedATNConfigSet":338,"./PredictionContext":346,"./RuleStopState":352,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"assert":413,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],325:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.array.slice.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:28.8810453-07:00
var ArrayEqualityComparator_1 = require("../misc/ArrayEqualityComparator");
var LexerIndexedCustomAction_1 = require("./LexerIndexedCustomAction");
var MurmurHash_1 = require("../misc/MurmurHash");
var Decorators_1 = require("../Decorators");
/**
 * Represents an executor for a sequence of lexer actions which traversed during
 * the matching operation of a lexer rule (token).
 *
 * The executor tracks position information for position-dependent lexer actions
 * efficiently, ensuring that actions appearing only at the end of the rule do
 * not cause bloating of the {@link DFA} created for the lexer.
 *
 * @author Sam Harwell
 * @since 4.2
 */
var LexerActionExecutor = /*#__PURE__*/function () {
  /**
   * Constructs an executor for a sequence of {@link LexerAction} actions.
   * @param lexerActions The lexer actions to execute.
   */
  function LexerActionExecutor(lexerActions) {
    (0, _classCallCheck2.default)(this, LexerActionExecutor);
    this._lexerActions = lexerActions;
    var hash = MurmurHash_1.MurmurHash.initialize();
    var _iterator = _createForOfIteratorHelper(lexerActions),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var lexerAction = _step.value;
        hash = MurmurHash_1.MurmurHash.update(hash, lexerAction);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    this.cachedHashCode = MurmurHash_1.MurmurHash.finish(hash, lexerActions.length);
  }
  /**
   * Creates a {@link LexerActionExecutor} which executes the actions for
   * the input `lexerActionExecutor` followed by a specified
   * `lexerAction`.
   *
   * @param lexerActionExecutor The executor for actions already traversed by
   * the lexer while matching a token within a particular
   * {@link ATNConfig}. If this is `undefined`, the method behaves as though
   * it were an empty executor.
   * @param lexerAction The lexer action to execute after the actions
   * specified in `lexerActionExecutor`.
   *
   * @returns A {@link LexerActionExecutor} for executing the combine actions
   * of `lexerActionExecutor` and `lexerAction`.
   */
  (0, _createClass2.default)(LexerActionExecutor, [{
    key: "fixOffsetBeforeMatch",
    value:
    /**
     * Creates a {@link LexerActionExecutor} which encodes the current offset
     * for position-dependent lexer actions.
     *
     * Normally, when the executor encounters lexer actions where
     * {@link LexerAction#isPositionDependent} returns `true`, it calls
     * {@link IntStream#seek} on the input {@link CharStream} to set the input
     * position to the *end* of the current token. This behavior provides
     * for efficient DFA representation of lexer actions which appear at the end
     * of a lexer rule, even when the lexer rule matches a variable number of
     * characters.
     *
     * Prior to traversing a match transition in the ATN, the current offset
     * from the token start index is assigned to all position-dependent lexer
     * actions which have not already been assigned a fixed offset. By storing
     * the offsets relative to the token start index, the DFA representation of
     * lexer actions which appear in the middle of tokens remains efficient due
     * to sharing among tokens of the same length, regardless of their absolute
     * position in the input stream.
     *
     * If the current executor already has offsets assigned to all
     * position-dependent lexer actions, the method returns `this`.
     *
     * @param offset The current offset to assign to all position-dependent
     * lexer actions which do not already have offsets assigned.
     *
     * @returns A {@link LexerActionExecutor} which stores input stream offsets
     * for all position-dependent lexer actions.
     */
    function fixOffsetBeforeMatch(offset) {
      var updatedLexerActions;
      for (var i = 0; i < this._lexerActions.length; i++) {
        if (this._lexerActions[i].isPositionDependent && !(this._lexerActions[i] instanceof LexerIndexedCustomAction_1.LexerIndexedCustomAction)) {
          if (!updatedLexerActions) {
            updatedLexerActions = this._lexerActions.slice(0);
          }
          updatedLexerActions[i] = new LexerIndexedCustomAction_1.LexerIndexedCustomAction(offset, this._lexerActions[i]);
        }
      }
      if (!updatedLexerActions) {
        return this;
      }
      return new LexerActionExecutor(updatedLexerActions);
    }
    /**
     * Gets the lexer actions to be executed by this executor.
     * @returns The lexer actions to be executed by this executor.
     */
  }, {
    key: "lexerActions",
    get: function get() {
      return this._lexerActions;
    }
    /**
     * Execute the actions encapsulated by this executor within the context of a
     * particular {@link Lexer}.
     *
     * This method calls {@link IntStream#seek} to set the position of the
     * `input` {@link CharStream} prior to calling
     * {@link LexerAction#execute} on a position-dependent action. Before the
     * method returns, the input position will be restored to the same position
     * it was in when the method was invoked.
     *
     * @param lexer The lexer instance.
     * @param input The input stream which is the source for the current token.
     * When this method is called, the current {@link IntStream#index} for
     * `input` should be the start of the following token, i.e. 1
     * character past the end of the current token.
     * @param startIndex The token start index. This value may be passed to
     * {@link IntStream#seek} to set the `input` position to the beginning
     * of the token.
     */
  }, {
    key: "execute",
    value: function execute(lexer, input, startIndex) {
      var requiresSeek = false;
      var stopIndex = input.index;
      try {
        var _iterator2 = _createForOfIteratorHelper(this._lexerActions),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var lexerAction = _step2.value;
            if (lexerAction instanceof LexerIndexedCustomAction_1.LexerIndexedCustomAction) {
              var offset = lexerAction.offset;
              input.seek(startIndex + offset);
              lexerAction = lexerAction.action;
              requiresSeek = startIndex + offset !== stopIndex;
            } else if (lexerAction.isPositionDependent) {
              input.seek(stopIndex);
              requiresSeek = false;
            }
            lexerAction.execute(lexer);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      } finally {
        if (requiresSeek) {
          input.seek(stopIndex);
        }
      }
    }
  }, {
    key: "hashCode",
    value: function hashCode() {
      return this.cachedHashCode;
    }
  }, {
    key: "equals",
    value: function equals(obj) {
      if (obj === this) {
        return true;
      } else if (!(obj instanceof LexerActionExecutor)) {
        return false;
      }
      return this.cachedHashCode === obj.cachedHashCode && ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this._lexerActions, obj._lexerActions);
    }
  }], [{
    key: "append",
    value: function append(lexerActionExecutor, lexerAction) {
      if (!lexerActionExecutor) {
        return new LexerActionExecutor([lexerAction]);
      }
      var lexerActions = lexerActionExecutor._lexerActions.slice(0);
      lexerActions.push(lexerAction);
      return new LexerActionExecutor(lexerActions);
    }
  }]);
  return LexerActionExecutor;
}();
__decorate([Decorators_1.NotNull], LexerActionExecutor.prototype, "_lexerActions", void 0);
__decorate([Decorators_1.NotNull], LexerActionExecutor.prototype, "lexerActions", null);
__decorate([__param(0, Decorators_1.NotNull)], LexerActionExecutor.prototype, "execute", null);
__decorate([Decorators_1.Override], LexerActionExecutor.prototype, "hashCode", null);
__decorate([Decorators_1.Override], LexerActionExecutor.prototype, "equals", null);
__decorate([Decorators_1.NotNull, __param(1, Decorators_1.NotNull)], LexerActionExecutor, "append", null);
LexerActionExecutor = __decorate([__param(0, Decorators_1.NotNull)], LexerActionExecutor);
exports.LexerActionExecutor = LexerActionExecutor;

},{"../Decorators":272,"../misc/ArrayEqualityComparator":371,"../misc/MurmurHash":381,"./LexerIndexedCustomAction":328,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],326:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var MurmurHash_1 = require("../misc/MurmurHash");
var Decorators_1 = require("../Decorators");
/**
 * Implements the `channel` lexer action by calling
 * {@link Lexer#setChannel} with the assigned channel.
 *
 * @author Sam Harwell
 * @since 4.2
 */
var LexerChannelAction = /*#__PURE__*/function () {
  /**
   * Constructs a new `channel` action with the specified channel value.
   * @param channel The channel value to pass to {@link Lexer#setChannel}.
   */
  function LexerChannelAction(channel) {
    (0, _classCallCheck2.default)(this, LexerChannelAction);
    this._channel = channel;
  }
  /**
   * Gets the channel to use for the {@link Token} created by the lexer.
   *
   * @returns The channel to use for the {@link Token} created by the lexer.
   */
  (0, _createClass2.default)(LexerChannelAction, [{
    key: "channel",
    get: function get() {
      return this._channel;
    }
    /**
     * {@inheritDoc}
     * @returns This method returns {@link LexerActionType#CHANNEL}.
     */
  }, {
    key: "actionType",
    get: function get() {
      return 0 /* CHANNEL */;
    }
    /**
     * {@inheritDoc}
     * @returns This method returns `false`.
     */
  }, {
    key: "isPositionDependent",
    get: function get() {
      return false;
    }
    /**
     * {@inheritDoc}
     *
     * This action is implemented by calling {@link Lexer#setChannel} with the
     * value provided by {@link #getChannel}.
     */
  }, {
    key: "execute",
    value: function execute(lexer) {
      lexer.channel = this._channel;
    }
  }, {
    key: "hashCode",
    value: function hashCode() {
      var hash = MurmurHash_1.MurmurHash.initialize();
      hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
      hash = MurmurHash_1.MurmurHash.update(hash, this._channel);
      return MurmurHash_1.MurmurHash.finish(hash, 2);
    }
  }, {
    key: "equals",
    value: function equals(obj) {
      if (obj === this) {
        return true;
      } else if (!(obj instanceof LexerChannelAction)) {
        return false;
      }
      return this._channel === obj._channel;
    }
  }, {
    key: "toString",
    value: function toString() {
      return "channel(".concat(this._channel, ")");
    }
  }]);
  return LexerChannelAction;
}();
__decorate([Decorators_1.Override], LexerChannelAction.prototype, "actionType", null);
__decorate([Decorators_1.Override], LexerChannelAction.prototype, "isPositionDependent", null);
__decorate([Decorators_1.Override, __param(0, Decorators_1.NotNull)], LexerChannelAction.prototype, "execute", null);
__decorate([Decorators_1.Override], LexerChannelAction.prototype, "hashCode", null);
__decorate([Decorators_1.Override], LexerChannelAction.prototype, "equals", null);
__decorate([Decorators_1.Override], LexerChannelAction.prototype, "toString", null);
exports.LexerChannelAction = LexerChannelAction;

},{"../Decorators":272,"../misc/MurmurHash":381,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612}],327:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var MurmurHash_1 = require("../misc/MurmurHash");
var Decorators_1 = require("../Decorators");
/**
 * Executes a custom lexer action by calling {@link Recognizer#action} with the
 * rule and action indexes assigned to the custom action. The implementation of
 * a custom action is added to the generated code for the lexer in an override
 * of {@link Recognizer#action} when the grammar is compiled.
 *
 * This class may represent embedded actions created with the `{...}`
 * syntax in ANTLR 4, as well as actions created for lexer commands where the
 * command argument could not be evaluated when the grammar was compiled.
 *
 * @author Sam Harwell
 * @since 4.2
 */
var LexerCustomAction = /*#__PURE__*/function () {
  /**
   * Constructs a custom lexer action with the specified rule and action
   * indexes.
   *
   * @param ruleIndex The rule index to use for calls to
   * {@link Recognizer#action}.
   * @param actionIndex The action index to use for calls to
   * {@link Recognizer#action}.
   */
  function LexerCustomAction(ruleIndex, actionIndex) {
    (0, _classCallCheck2.default)(this, LexerCustomAction);
    this._ruleIndex = ruleIndex;
    this._actionIndex = actionIndex;
  }
  /**
   * Gets the rule index to use for calls to {@link Recognizer#action}.
   *
   * @returns The rule index for the custom action.
   */
  (0, _createClass2.default)(LexerCustomAction, [{
    key: "ruleIndex",
    get: function get() {
      return this._ruleIndex;
    }
    /**
     * Gets the action index to use for calls to {@link Recognizer#action}.
     *
     * @returns The action index for the custom action.
     */
  }, {
    key: "actionIndex",
    get: function get() {
      return this._actionIndex;
    }
    /**
     * {@inheritDoc}
     *
     * @returns This method returns {@link LexerActionType#CUSTOM}.
     */
  }, {
    key: "actionType",
    get: function get() {
      return 1 /* CUSTOM */;
    }
    /**
     * Gets whether the lexer action is position-dependent. Position-dependent
     * actions may have different semantics depending on the {@link CharStream}
     * index at the time the action is executed.
     *
     * Custom actions are position-dependent since they may represent a
     * user-defined embedded action which makes calls to methods like
     * {@link Lexer#getText}.
     *
     * @returns This method returns `true`.
     */
  }, {
    key: "isPositionDependent",
    get: function get() {
      return true;
    }
    /**
     * {@inheritDoc}
     *
     * Custom actions are implemented by calling {@link Lexer#action} with the
     * appropriate rule and action indexes.
     */
  }, {
    key: "execute",
    value: function execute(lexer) {
      lexer.action(undefined, this._ruleIndex, this._actionIndex);
    }
  }, {
    key: "hashCode",
    value: function hashCode() {
      var hash = MurmurHash_1.MurmurHash.initialize();
      hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
      hash = MurmurHash_1.MurmurHash.update(hash, this._ruleIndex);
      hash = MurmurHash_1.MurmurHash.update(hash, this._actionIndex);
      return MurmurHash_1.MurmurHash.finish(hash, 3);
    }
  }, {
    key: "equals",
    value: function equals(obj) {
      if (obj === this) {
        return true;
      } else if (!(obj instanceof LexerCustomAction)) {
        return false;
      }
      return this._ruleIndex === obj._ruleIndex && this._actionIndex === obj._actionIndex;
    }
  }]);
  return LexerCustomAction;
}();
__decorate([Decorators_1.Override], LexerCustomAction.prototype, "actionType", null);
__decorate([Decorators_1.Override], LexerCustomAction.prototype, "isPositionDependent", null);
__decorate([Decorators_1.Override, __param(0, Decorators_1.NotNull)], LexerCustomAction.prototype, "execute", null);
__decorate([Decorators_1.Override], LexerCustomAction.prototype, "hashCode", null);
__decorate([Decorators_1.Override], LexerCustomAction.prototype, "equals", null);
exports.LexerCustomAction = LexerCustomAction;

},{"../Decorators":272,"../misc/MurmurHash":381,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612}],328:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var MurmurHash_1 = require("../misc/MurmurHash");
var Decorators_1 = require("../Decorators");
/**
 * This implementation of {@link LexerAction} is used for tracking input offsets
 * for position-dependent actions within a {@link LexerActionExecutor}.
 *
 * This action is not serialized as part of the ATN, and is only required for
 * position-dependent lexer actions which appear at a location other than the
 * end of a rule. For more information about DFA optimizations employed for
 * lexer actions, see {@link LexerActionExecutor#append} and
 * {@link LexerActionExecutor#fixOffsetBeforeMatch}.
 *
 * @author Sam Harwell
 * @since 4.2
 */
var LexerIndexedCustomAction = /*#__PURE__*/function () {
  /**
   * Constructs a new indexed custom action by associating a character offset
   * with a {@link LexerAction}.
   *
   * Note: This class is only required for lexer actions for which
   * {@link LexerAction#isPositionDependent} returns `true`.
   *
   * @param offset The offset into the input {@link CharStream}, relative to
   * the token start index, at which the specified lexer action should be
   * executed.
   * @param action The lexer action to execute at a particular offset in the
   * input {@link CharStream}.
   */
  function LexerIndexedCustomAction(offset, action) {
    (0, _classCallCheck2.default)(this, LexerIndexedCustomAction);
    this._offset = offset;
    this._action = action;
  }
  /**
   * Gets the location in the input {@link CharStream} at which the lexer
   * action should be executed. The value is interpreted as an offset relative
   * to the token start index.
   *
   * @returns The location in the input {@link CharStream} at which the lexer
   * action should be executed.
   */
  (0, _createClass2.default)(LexerIndexedCustomAction, [{
    key: "offset",
    get: function get() {
      return this._offset;
    }
    /**
     * Gets the lexer action to execute.
     *
     * @returns A {@link LexerAction} object which executes the lexer action.
     */
  }, {
    key: "action",
    get: function get() {
      return this._action;
    }
    /**
     * {@inheritDoc}
     *
     * @returns This method returns the result of calling {@link #getActionType}
     * on the {@link LexerAction} returned by {@link #getAction}.
     */
  }, {
    key: "actionType",
    get: function get() {
      return this._action.actionType;
    }
    /**
     * {@inheritDoc}
     * @returns This method returns `true`.
     */
  }, {
    key: "isPositionDependent",
    get: function get() {
      return true;
    }
    /**
     * {@inheritDoc}
     *
     * This method calls {@link #execute} on the result of {@link #getAction}
     * using the provided `lexer`.
     */
  }, {
    key: "execute",
    value: function execute(lexer) {
      // assume the input stream position was properly set by the calling code
      this._action.execute(lexer);
    }
  }, {
    key: "hashCode",
    value: function hashCode() {
      var hash = MurmurHash_1.MurmurHash.initialize();
      hash = MurmurHash_1.MurmurHash.update(hash, this._offset);
      hash = MurmurHash_1.MurmurHash.update(hash, this._action);
      return MurmurHash_1.MurmurHash.finish(hash, 2);
    }
  }, {
    key: "equals",
    value: function equals(obj) {
      if (obj === this) {
        return true;
      } else if (!(obj instanceof LexerIndexedCustomAction)) {
        return false;
      }
      return this._offset === obj._offset && this._action.equals(obj._action);
    }
  }]);
  return LexerIndexedCustomAction;
}();
__decorate([Decorators_1.NotNull], LexerIndexedCustomAction.prototype, "action", null);
__decorate([Decorators_1.Override], LexerIndexedCustomAction.prototype, "actionType", null);
__decorate([Decorators_1.Override], LexerIndexedCustomAction.prototype, "isPositionDependent", null);
__decorate([Decorators_1.Override], LexerIndexedCustomAction.prototype, "execute", null);
__decorate([Decorators_1.Override], LexerIndexedCustomAction.prototype, "hashCode", null);
__decorate([Decorators_1.Override], LexerIndexedCustomAction.prototype, "equals", null);
LexerIndexedCustomAction = __decorate([__param(1, Decorators_1.NotNull)], LexerIndexedCustomAction);
exports.LexerIndexedCustomAction = LexerIndexedCustomAction;

},{"../Decorators":272,"../misc/MurmurHash":381,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612}],329:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var MurmurHash_1 = require("../misc/MurmurHash");
var Decorators_1 = require("../Decorators");
/**
 * Implements the `mode` lexer action by calling {@link Lexer#mode} with
 * the assigned mode.
 *
 * @author Sam Harwell
 * @since 4.2
 */
var LexerModeAction = /*#__PURE__*/function () {
  /**
   * Constructs a new `mode` action with the specified mode value.
   * @param mode The mode value to pass to {@link Lexer#mode}.
   */
  function LexerModeAction(mode) {
    (0, _classCallCheck2.default)(this, LexerModeAction);
    this._mode = mode;
  }
  /**
   * Get the lexer mode this action should transition the lexer to.
   *
   * @returns The lexer mode for this `mode` command.
   */
  (0, _createClass2.default)(LexerModeAction, [{
    key: "mode",
    get: function get() {
      return this._mode;
    }
    /**
     * {@inheritDoc}
     * @returns This method returns {@link LexerActionType#MODE}.
     */
  }, {
    key: "actionType",
    get: function get() {
      return 2 /* MODE */;
    }
    /**
     * {@inheritDoc}
     * @returns This method returns `false`.
     */
  }, {
    key: "isPositionDependent",
    get: function get() {
      return false;
    }
    /**
     * {@inheritDoc}
     *
     * This action is implemented by calling {@link Lexer#mode} with the
     * value provided by {@link #getMode}.
     */
  }, {
    key: "execute",
    value: function execute(lexer) {
      lexer.mode(this._mode);
    }
  }, {
    key: "hashCode",
    value: function hashCode() {
      var hash = MurmurHash_1.MurmurHash.initialize();
      hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
      hash = MurmurHash_1.MurmurHash.update(hash, this._mode);
      return MurmurHash_1.MurmurHash.finish(hash, 2);
    }
  }, {
    key: "equals",
    value: function equals(obj) {
      if (obj === this) {
        return true;
      } else if (!(obj instanceof LexerModeAction)) {
        return false;
      }
      return this._mode === obj._mode;
    }
  }, {
    key: "toString",
    value: function toString() {
      return "mode(".concat(this._mode, ")");
    }
  }]);
  return LexerModeAction;
}();
__decorate([Decorators_1.Override], LexerModeAction.prototype, "actionType", null);
__decorate([Decorators_1.Override], LexerModeAction.prototype, "isPositionDependent", null);
__decorate([Decorators_1.Override, __param(0, Decorators_1.NotNull)], LexerModeAction.prototype, "execute", null);
__decorate([Decorators_1.Override], LexerModeAction.prototype, "hashCode", null);
__decorate([Decorators_1.Override], LexerModeAction.prototype, "equals", null);
__decorate([Decorators_1.Override], LexerModeAction.prototype, "toString", null);
exports.LexerModeAction = LexerModeAction;

},{"../Decorators":272,"../misc/MurmurHash":381,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612}],330:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var MurmurHash_1 = require("../misc/MurmurHash");
var Decorators_1 = require("../Decorators");
/**
 * Implements the `more` lexer action by calling {@link Lexer#more}.
 *
 * The `more` command does not have any parameters, so this action is
 * implemented as a singleton instance exposed by {@link #INSTANCE}.
 *
 * @author Sam Harwell
 * @since 4.2
 */
var LexerMoreAction = /*#__PURE__*/function () {
  /**
   * Constructs the singleton instance of the lexer `more` command.
   */
  function LexerMoreAction() {
    (0, _classCallCheck2.default)(this, LexerMoreAction);
  } // intentionally empty
  /**
   * {@inheritDoc}
   * @returns This method returns {@link LexerActionType#MORE}.
   */
  (0, _createClass2.default)(LexerMoreAction, [{
    key: "actionType",
    get: function get() {
      return 3 /* MORE */;
    }
    /**
     * {@inheritDoc}
     * @returns This method returns `false`.
     */
  }, {
    key: "isPositionDependent",
    get: function get() {
      return false;
    }
    /**
     * {@inheritDoc}
     *
     * This action is implemented by calling {@link Lexer#more}.
     */
  }, {
    key: "execute",
    value: function execute(lexer) {
      lexer.more();
    }
  }, {
    key: "hashCode",
    value: function hashCode() {
      var hash = MurmurHash_1.MurmurHash.initialize();
      hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
      return MurmurHash_1.MurmurHash.finish(hash, 1);
    }
  }, {
    key: "equals",
    value: function equals(obj) {
      return obj === this;
    }
  }, {
    key: "toString",
    value: function toString() {
      return "more";
    }
  }]);
  return LexerMoreAction;
}();
__decorate([Decorators_1.Override], LexerMoreAction.prototype, "actionType", null);
__decorate([Decorators_1.Override], LexerMoreAction.prototype, "isPositionDependent", null);
__decorate([Decorators_1.Override, __param(0, Decorators_1.NotNull)], LexerMoreAction.prototype, "execute", null);
__decorate([Decorators_1.Override], LexerMoreAction.prototype, "hashCode", null);
__decorate([Decorators_1.Override], LexerMoreAction.prototype, "equals", null);
__decorate([Decorators_1.Override], LexerMoreAction.prototype, "toString", null);
exports.LexerMoreAction = LexerMoreAction;
(function (LexerMoreAction) {
  /**
   * Provides a singleton instance of this parameterless lexer action.
   */
  LexerMoreAction.INSTANCE = new LexerMoreAction();
})(LexerMoreAction = exports.LexerMoreAction || (exports.LexerMoreAction = {}));

},{"../Decorators":272,"../misc/MurmurHash":381,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612}],331:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var MurmurHash_1 = require("../misc/MurmurHash");
var Decorators_1 = require("../Decorators");
/**
 * Implements the `popMode` lexer action by calling {@link Lexer#popMode}.
 *
 * The `popMode` command does not have any parameters, so this action is
 * implemented as a singleton instance exposed by {@link #INSTANCE}.
 *
 * @author Sam Harwell
 * @since 4.2
 */
var LexerPopModeAction = /*#__PURE__*/function () {
  /**
   * Constructs the singleton instance of the lexer `popMode` command.
   */
  function LexerPopModeAction() {
    (0, _classCallCheck2.default)(this, LexerPopModeAction);
  } // intentionally empty
  /**
   * {@inheritDoc}
   * @returns This method returns {@link LexerActionType#POP_MODE}.
   */
  (0, _createClass2.default)(LexerPopModeAction, [{
    key: "actionType",
    get: function get() {
      return 4 /* POP_MODE */;
    }
    /**
     * {@inheritDoc}
     * @returns This method returns `false`.
     */
  }, {
    key: "isPositionDependent",
    get: function get() {
      return false;
    }
    /**
     * {@inheritDoc}
     *
     * This action is implemented by calling {@link Lexer#popMode}.
     */
  }, {
    key: "execute",
    value: function execute(lexer) {
      lexer.popMode();
    }
  }, {
    key: "hashCode",
    value: function hashCode() {
      var hash = MurmurHash_1.MurmurHash.initialize();
      hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
      return MurmurHash_1.MurmurHash.finish(hash, 1);
    }
  }, {
    key: "equals",
    value: function equals(obj) {
      return obj === this;
    }
  }, {
    key: "toString",
    value: function toString() {
      return "popMode";
    }
  }]);
  return LexerPopModeAction;
}();
__decorate([Decorators_1.Override], LexerPopModeAction.prototype, "actionType", null);
__decorate([Decorators_1.Override], LexerPopModeAction.prototype, "isPositionDependent", null);
__decorate([Decorators_1.Override, __param(0, Decorators_1.NotNull)], LexerPopModeAction.prototype, "execute", null);
__decorate([Decorators_1.Override], LexerPopModeAction.prototype, "hashCode", null);
__decorate([Decorators_1.Override], LexerPopModeAction.prototype, "equals", null);
__decorate([Decorators_1.Override], LexerPopModeAction.prototype, "toString", null);
exports.LexerPopModeAction = LexerPopModeAction;
(function (LexerPopModeAction) {
  /**
   * Provides a singleton instance of this parameterless lexer action.
   */
  LexerPopModeAction.INSTANCE = new LexerPopModeAction();
})(LexerPopModeAction = exports.LexerPopModeAction || (exports.LexerPopModeAction = {}));

},{"../Decorators":272,"../misc/MurmurHash":381,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612}],332:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var MurmurHash_1 = require("../misc/MurmurHash");
var Decorators_1 = require("../Decorators");
/**
 * Implements the `pushMode` lexer action by calling
 * {@link Lexer#pushMode} with the assigned mode.
 *
 * @author Sam Harwell
 * @since 4.2
 */
var LexerPushModeAction = /*#__PURE__*/function () {
  /**
   * Constructs a new `pushMode` action with the specified mode value.
   * @param mode The mode value to pass to {@link Lexer#pushMode}.
   */
  function LexerPushModeAction(mode) {
    (0, _classCallCheck2.default)(this, LexerPushModeAction);
    this._mode = mode;
  }
  /**
   * Get the lexer mode this action should transition the lexer to.
   *
   * @returns The lexer mode for this `pushMode` command.
   */
  (0, _createClass2.default)(LexerPushModeAction, [{
    key: "mode",
    get: function get() {
      return this._mode;
    }
    /**
     * {@inheritDoc}
     * @returns This method returns {@link LexerActionType#PUSH_MODE}.
     */
  }, {
    key: "actionType",
    get: function get() {
      return 5 /* PUSH_MODE */;
    }
    /**
     * {@inheritDoc}
     * @returns This method returns `false`.
     */
  }, {
    key: "isPositionDependent",
    get: function get() {
      return false;
    }
    /**
     * {@inheritDoc}
     *
     * This action is implemented by calling {@link Lexer#pushMode} with the
     * value provided by {@link #getMode}.
     */
  }, {
    key: "execute",
    value: function execute(lexer) {
      lexer.pushMode(this._mode);
    }
  }, {
    key: "hashCode",
    value: function hashCode() {
      var hash = MurmurHash_1.MurmurHash.initialize();
      hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
      hash = MurmurHash_1.MurmurHash.update(hash, this._mode);
      return MurmurHash_1.MurmurHash.finish(hash, 2);
    }
  }, {
    key: "equals",
    value: function equals(obj) {
      if (obj === this) {
        return true;
      } else if (!(obj instanceof LexerPushModeAction)) {
        return false;
      }
      return this._mode === obj._mode;
    }
  }, {
    key: "toString",
    value: function toString() {
      return "pushMode(".concat(this._mode, ")");
    }
  }]);
  return LexerPushModeAction;
}();
__decorate([Decorators_1.Override], LexerPushModeAction.prototype, "actionType", null);
__decorate([Decorators_1.Override], LexerPushModeAction.prototype, "isPositionDependent", null);
__decorate([Decorators_1.Override, __param(0, Decorators_1.NotNull)], LexerPushModeAction.prototype, "execute", null);
__decorate([Decorators_1.Override], LexerPushModeAction.prototype, "hashCode", null);
__decorate([Decorators_1.Override], LexerPushModeAction.prototype, "equals", null);
__decorate([Decorators_1.Override], LexerPushModeAction.prototype, "toString", null);
exports.LexerPushModeAction = LexerPushModeAction;

},{"../Decorators":272,"../misc/MurmurHash":381,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612}],333:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var MurmurHash_1 = require("../misc/MurmurHash");
var Decorators_1 = require("../Decorators");
/**
 * Implements the `skip` lexer action by calling {@link Lexer#skip}.
 *
 * The `skip` command does not have any parameters, so this action is
 * implemented as a singleton instance exposed by {@link #INSTANCE}.
 *
 * @author Sam Harwell
 * @since 4.2
 */
var LexerSkipAction = /*#__PURE__*/function () {
  /**
   * Constructs the singleton instance of the lexer `skip` command.
   */
  function LexerSkipAction() {
    (0, _classCallCheck2.default)(this, LexerSkipAction);
  } // intentionally empty
  /**
   * {@inheritDoc}
   * @returns This method returns {@link LexerActionType#SKIP}.
   */
  (0, _createClass2.default)(LexerSkipAction, [{
    key: "actionType",
    get: function get() {
      return 6 /* SKIP */;
    }
    /**
     * {@inheritDoc}
     * @returns This method returns `false`.
     */
  }, {
    key: "isPositionDependent",
    get: function get() {
      return false;
    }
    /**
     * {@inheritDoc}
     *
     * This action is implemented by calling {@link Lexer#skip}.
     */
  }, {
    key: "execute",
    value: function execute(lexer) {
      lexer.skip();
    }
  }, {
    key: "hashCode",
    value: function hashCode() {
      var hash = MurmurHash_1.MurmurHash.initialize();
      hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
      return MurmurHash_1.MurmurHash.finish(hash, 1);
    }
  }, {
    key: "equals",
    value: function equals(obj) {
      return obj === this;
    }
  }, {
    key: "toString",
    value: function toString() {
      return "skip";
    }
  }]);
  return LexerSkipAction;
}();
__decorate([Decorators_1.Override], LexerSkipAction.prototype, "actionType", null);
__decorate([Decorators_1.Override], LexerSkipAction.prototype, "isPositionDependent", null);
__decorate([Decorators_1.Override, __param(0, Decorators_1.NotNull)], LexerSkipAction.prototype, "execute", null);
__decorate([Decorators_1.Override], LexerSkipAction.prototype, "hashCode", null);
__decorate([Decorators_1.Override], LexerSkipAction.prototype, "equals", null);
__decorate([Decorators_1.Override], LexerSkipAction.prototype, "toString", null);
exports.LexerSkipAction = LexerSkipAction;
(function (LexerSkipAction) {
  /**
   * Provides a singleton instance of this parameterless lexer action.
   */
  LexerSkipAction.INSTANCE = new LexerSkipAction();
})(LexerSkipAction = exports.LexerSkipAction || (exports.LexerSkipAction = {}));

},{"../Decorators":272,"../misc/MurmurHash":381,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612}],334:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var MurmurHash_1 = require("../misc/MurmurHash");
var Decorators_1 = require("../Decorators");
/**
 * Implements the `type` lexer action by setting `Lexer.type`
 * with the assigned type.
 *
 * @author Sam Harwell
 * @since 4.2
 */
var LexerTypeAction = /*#__PURE__*/function () {
  /**
   * Constructs a new `type` action with the specified token type value.
   * @param type The type to assign to the token using `Lexer.type`.
   */
  function LexerTypeAction(type) {
    (0, _classCallCheck2.default)(this, LexerTypeAction);
    this._type = type;
  }
  /**
   * Gets the type to assign to a token created by the lexer.
   * @returns The type to assign to a token created by the lexer.
   */
  (0, _createClass2.default)(LexerTypeAction, [{
    key: "type",
    get: function get() {
      return this._type;
    }
    /**
     * {@inheritDoc}
     * @returns This method returns {@link LexerActionType#TYPE}.
     */
  }, {
    key: "actionType",
    get: function get() {
      return 7 /* TYPE */;
    }
    /**
     * {@inheritDoc}
     * @returns This method returns `false`.
     */
  }, {
    key: "isPositionDependent",
    get: function get() {
      return false;
    }
    /**
     * {@inheritDoc}
     *
     * This action is implemented by setting `Lexer.type` with the
     * value provided by `type`.
     */
  }, {
    key: "execute",
    value: function execute(lexer) {
      lexer.type = this._type;
    }
  }, {
    key: "hashCode",
    value: function hashCode() {
      var hash = MurmurHash_1.MurmurHash.initialize();
      hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
      hash = MurmurHash_1.MurmurHash.update(hash, this._type);
      return MurmurHash_1.MurmurHash.finish(hash, 2);
    }
  }, {
    key: "equals",
    value: function equals(obj) {
      if (obj === this) {
        return true;
      } else if (!(obj instanceof LexerTypeAction)) {
        return false;
      }
      return this._type === obj._type;
    }
  }, {
    key: "toString",
    value: function toString() {
      return "type(".concat(this._type, ")");
    }
  }]);
  return LexerTypeAction;
}();
__decorate([Decorators_1.Override], LexerTypeAction.prototype, "actionType", null);
__decorate([Decorators_1.Override], LexerTypeAction.prototype, "isPositionDependent", null);
__decorate([Decorators_1.Override, __param(0, Decorators_1.NotNull)], LexerTypeAction.prototype, "execute", null);
__decorate([Decorators_1.Override], LexerTypeAction.prototype, "hashCode", null);
__decorate([Decorators_1.Override], LexerTypeAction.prototype, "equals", null);
__decorate([Decorators_1.Override], LexerTypeAction.prototype, "toString", null);
exports.LexerTypeAction = LexerTypeAction;

},{"../Decorators":272,"../misc/MurmurHash":381,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612}],335:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:30.6852565-07:00
var DecisionEventInfo_1 = require("./DecisionEventInfo");
var Decorators_1 = require("../Decorators");
/**
 * This class represents profiling event information for tracking the lookahead
 * depth required in order to make a prediction.
 *
 * @since 4.3
 */
var LookaheadEventInfo = /*#__PURE__*/function (_DecisionEventInfo_1$) {
  (0, _inherits2.default)(LookaheadEventInfo, _DecisionEventInfo_1$);
  var _super = _createSuper(LookaheadEventInfo);
  /**
   * Constructs a new instance of the {@link LookaheadEventInfo} class with
   * the specified detailed lookahead information.
   *
   * @param decision The decision number
   * @param state The final simulator state containing the necessary
   * information to determine the result of a prediction, or `undefined` if
   * the final state is not available
   * @param input The input token stream
   * @param startIndex The start index for the current prediction
   * @param stopIndex The index at which the prediction was finally made
   * @param fullCtx `true` if the current lookahead is part of an LL
   * prediction; otherwise, `false` if the current lookahead is part of
   * an SLL prediction
   */
  function LookaheadEventInfo(decision, state, predictedAlt, input, startIndex, stopIndex, fullCtx) {
    var _this;
    (0, _classCallCheck2.default)(this, LookaheadEventInfo);
    _this = _super.call(this, decision, state, input, startIndex, stopIndex, fullCtx);
    _this.predictedAlt = predictedAlt;
    return _this;
  }
  return (0, _createClass2.default)(LookaheadEventInfo);
}(DecisionEventInfo_1.DecisionEventInfo);
LookaheadEventInfo = __decorate([__param(3, Decorators_1.NotNull)], LookaheadEventInfo);
exports.LookaheadEventInfo = LookaheadEventInfo;

},{"../Decorators":272,"./DecisionEventInfo":317,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],336:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:30.7737978-07:00
var ATNState_1 = require("./ATNState");
var ATNStateType_1 = require("./ATNStateType");
var Decorators_1 = require("../Decorators");
/** Mark the end of a * or + loop. */
var LoopEndState = /*#__PURE__*/function (_ATNState_1$ATNState) {
  (0, _inherits2.default)(LoopEndState, _ATNState_1$ATNState);
  var _super = _createSuper(LoopEndState);
  function LoopEndState() {
    (0, _classCallCheck2.default)(this, LoopEndState);
    return _super.apply(this, arguments);
  }
  (0, _createClass2.default)(LoopEndState, [{
    key: "stateType",
    get: function get() {
      return ATNStateType_1.ATNStateType.LOOP_END;
    }
  }]);
  return LoopEndState;
}(ATNState_1.ATNState);
__decorate([Decorators_1.Override], LoopEndState.prototype, "stateType", null);
exports.LoopEndState = LoopEndState;

},{"../Decorators":272,"./ATNState":305,"./ATNStateType":306,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],337:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var Decorators_1 = require("../Decorators");
var SetTransition_1 = require("./SetTransition");
var NotSetTransition = /*#__PURE__*/function (_SetTransition_1$SetT) {
  (0, _inherits2.default)(NotSetTransition, _SetTransition_1$SetT);
  var _super = _createSuper(NotSetTransition);
  function NotSetTransition(target, set) {
    (0, _classCallCheck2.default)(this, NotSetTransition);
    return _super.call(this, target, set);
  }
  (0, _createClass2.default)(NotSetTransition, [{
    key: "serializationType",
    get: function get() {
      return 8 /* NOT_SET */;
    }
  }, {
    key: "matches",
    value: function matches(symbol, minVocabSymbol, maxVocabSymbol) {
      return symbol >= minVocabSymbol && symbol <= maxVocabSymbol && !(0, _get2.default)((0, _getPrototypeOf2.default)(NotSetTransition.prototype), "matches", this).call(this, symbol, minVocabSymbol, maxVocabSymbol);
    }
  }, {
    key: "toString",
    value: function toString() {
      return "~" + (0, _get2.default)((0, _getPrototypeOf2.default)(NotSetTransition.prototype), "toString", this).call(this);
    }
  }]);
  return NotSetTransition;
}(SetTransition_1.SetTransition);
__decorate([Decorators_1.Override], NotSetTransition.prototype, "serializationType", null);
__decorate([Decorators_1.Override], NotSetTransition.prototype, "matches", null);
__decorate([Decorators_1.Override], NotSetTransition.prototype, "toString", null);
NotSetTransition = __decorate([__param(0, Decorators_1.NotNull), __param(1, Decorators_1.Nullable)], NotSetTransition);
exports.NotSetTransition = NotSetTransition;

},{"../Decorators":272,"./SetTransition":355,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/get":234,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],338:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var ATNConfigSet_1 = require("./ATNConfigSet");
var Decorators_1 = require("../Decorators");
/**
 *
 * @author Sam Harwell
 */
var OrderedATNConfigSet = /*#__PURE__*/function (_ATNConfigSet_1$ATNCo) {
  (0, _inherits2.default)(OrderedATNConfigSet, _ATNConfigSet_1$ATNCo);
  var _super = _createSuper(OrderedATNConfigSet);
  function OrderedATNConfigSet(set, readonly) {
    var _this;
    (0, _classCallCheck2.default)(this, OrderedATNConfigSet);
    if (set != null && readonly != null) {
      _this = _super.call(this, set, readonly);
    } else {
      _this = _super.call(this);
    }
    return (0, _possibleConstructorReturn2.default)(_this);
  }
  (0, _createClass2.default)(OrderedATNConfigSet, [{
    key: "clone",
    value: function clone(readonly) {
      var copy = new OrderedATNConfigSet(this, readonly);
      if (!readonly && this.isReadOnly) {
        copy.addAll(this);
      }
      return copy;
    }
  }, {
    key: "getKey",
    value: function getKey(e) {
      // This is a specially crafted key to ensure configurations are only merged if they are equal
      return {
        state: 0,
        alt: e.hashCode()
      };
    }
  }, {
    key: "canMerge",
    value: function canMerge(left, leftKey, right) {
      return left.equals(right);
    }
  }]);
  return OrderedATNConfigSet;
}(ATNConfigSet_1.ATNConfigSet);
__decorate([Decorators_1.Override], OrderedATNConfigSet.prototype, "clone", null);
__decorate([Decorators_1.Override], OrderedATNConfigSet.prototype, "getKey", null);
__decorate([Decorators_1.Override], OrderedATNConfigSet.prototype, "canMerge", null);
exports.OrderedATNConfigSet = OrderedATNConfigSet;

},{"../Decorators":272,"./ATNConfigSet":301,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],339:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var Decorators_1 = require("../Decorators");
/**
 * This class provides access to specific and aggregate statistics gathered
 * during profiling of a parser.
 *
 * @since 4.3
 */
var ParseInfo = /*#__PURE__*/function () {
  function ParseInfo(atnSimulator) {
    (0, _classCallCheck2.default)(this, ParseInfo);
    this.atnSimulator = atnSimulator;
  }
  /**
   * Gets an array of {@link DecisionInfo} instances containing the profiling
   * information gathered for each decision in the ATN.
   *
   * @returns An array of {@link DecisionInfo} instances, indexed by decision
   * number.
   */
  (0, _createClass2.default)(ParseInfo, [{
    key: "getDecisionInfo",
    value: function getDecisionInfo() {
      return this.atnSimulator.getDecisionInfo();
    }
    /**
     * Gets the decision numbers for decisions that required one or more
     * full-context predictions during parsing. These are decisions for which
     * {@link DecisionInfo#LL_Fallback} is non-zero.
     *
     * @returns A list of decision numbers which required one or more
     * full-context predictions during parsing.
     */
  }, {
    key: "getLLDecisions",
    value: function getLLDecisions() {
      var decisions = this.atnSimulator.getDecisionInfo();
      var LL = [];
      for (var i = 0; i < decisions.length; i++) {
        var fallBack = decisions[i].LL_Fallback;
        if (fallBack > 0) {
          LL.push(i);
        }
      }
      return LL;
    }
    /**
     * Gets the total time spent during prediction across all decisions made
     * during parsing. This value is the sum of
     * {@link DecisionInfo#timeInPrediction} for all decisions.
     */
  }, {
    key: "getTotalTimeInPrediction",
    value: function getTotalTimeInPrediction() {
      var decisions = this.atnSimulator.getDecisionInfo();
      var t = 0;
      var _iterator = _createForOfIteratorHelper(decisions),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var decision = _step.value;
          t += decision.timeInPrediction;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return t;
    }
    /**
     * Gets the total number of SLL lookahead operations across all decisions
     * made during parsing. This value is the sum of
     * {@link DecisionInfo#SLL_TotalLook} for all decisions.
     */
  }, {
    key: "getTotalSLLLookaheadOps",
    value: function getTotalSLLLookaheadOps() {
      var decisions = this.atnSimulator.getDecisionInfo();
      var k = 0;
      var _iterator2 = _createForOfIteratorHelper(decisions),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var decision = _step2.value;
          k += decision.SLL_TotalLook;
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return k;
    }
    /**
     * Gets the total number of LL lookahead operations across all decisions
     * made during parsing. This value is the sum of
     * {@link DecisionInfo#LL_TotalLook} for all decisions.
     */
  }, {
    key: "getTotalLLLookaheadOps",
    value: function getTotalLLLookaheadOps() {
      var decisions = this.atnSimulator.getDecisionInfo();
      var k = 0;
      var _iterator3 = _createForOfIteratorHelper(decisions),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var decision = _step3.value;
          k += decision.LL_TotalLook;
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      return k;
    }
    /**
     * Gets the total number of ATN lookahead operations for SLL prediction
     * across all decisions made during parsing.
     */
  }, {
    key: "getTotalSLLATNLookaheadOps",
    value: function getTotalSLLATNLookaheadOps() {
      var decisions = this.atnSimulator.getDecisionInfo();
      var k = 0;
      var _iterator4 = _createForOfIteratorHelper(decisions),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var decision = _step4.value;
          k += decision.SLL_ATNTransitions;
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      return k;
    }
    /**
     * Gets the total number of ATN lookahead operations for LL prediction
     * across all decisions made during parsing.
     */
  }, {
    key: "getTotalLLATNLookaheadOps",
    value: function getTotalLLATNLookaheadOps() {
      var decisions = this.atnSimulator.getDecisionInfo();
      var k = 0;
      var _iterator5 = _createForOfIteratorHelper(decisions),
        _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var decision = _step5.value;
          k += decision.LL_ATNTransitions;
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
      return k;
    }
    /**
     * Gets the total number of ATN lookahead operations for SLL and LL
     * prediction across all decisions made during parsing.
     *
     * This value is the sum of {@link #getTotalSLLATNLookaheadOps} and
     * {@link #getTotalLLATNLookaheadOps}.
     */
  }, {
    key: "getTotalATNLookaheadOps",
    value: function getTotalATNLookaheadOps() {
      var decisions = this.atnSimulator.getDecisionInfo();
      var k = 0;
      var _iterator6 = _createForOfIteratorHelper(decisions),
        _step6;
      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var decision = _step6.value;
          k += decision.SLL_ATNTransitions;
          k += decision.LL_ATNTransitions;
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
      return k;
    }
  }, {
    key: "getDFASize",
    value: function getDFASize(decision) {
      if (decision) {
        var decisionToDFA = this.atnSimulator.atn.decisionToDFA[decision];
        return decisionToDFA.states.size;
      } else {
        var n = 0;
        var _decisionToDFA = this.atnSimulator.atn.decisionToDFA;
        for (var i = 0; i < _decisionToDFA.length; i++) {
          n += this.getDFASize(i);
        }
        return n;
      }
    }
  }]);
  return ParseInfo;
}();
__decorate([Decorators_1.NotNull], ParseInfo.prototype, "getDecisionInfo", null);
__decorate([Decorators_1.NotNull], ParseInfo.prototype, "getLLDecisions", null);
ParseInfo = __decorate([__param(0, Decorators_1.NotNull)], ParseInfo);
exports.ParseInfo = ParseInfo;

},{"../Decorators":272,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],340:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.map.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.array.sort.js");
require("core-js/modules/es.array.join.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:31.1989835-07:00
var AcceptStateInfo_1 = require("../dfa/AcceptStateInfo");
var ActionTransition_1 = require("./ActionTransition");
var Array2DHashSet_1 = require("../misc/Array2DHashSet");
var Arrays_1 = require("../misc/Arrays");
var ATN_1 = require("./ATN");
var ATNConfig_1 = require("./ATNConfig");
var ATNConfigSet_1 = require("./ATNConfigSet");
var ATNSimulator_1 = require("./ATNSimulator");
var ATNStateType_1 = require("./ATNStateType");
var AtomTransition_1 = require("./AtomTransition");
var BitSet_1 = require("../misc/BitSet");
var ConflictInfo_1 = require("./ConflictInfo");
var DecisionState_1 = require("./DecisionState");
var DFAState_1 = require("../dfa/DFAState");
var IntegerList_1 = require("../misc/IntegerList");
var Interval_1 = require("../misc/Interval");
var IntStream_1 = require("../IntStream");
var Decorators_1 = require("../Decorators");
var NotSetTransition_1 = require("./NotSetTransition");
var NoViableAltException_1 = require("../NoViableAltException");
var ObjectEqualityComparator_1 = require("../misc/ObjectEqualityComparator");
var ParserRuleContext_1 = require("../ParserRuleContext");
var PredictionContext_1 = require("./PredictionContext");
var PredictionContextCache_1 = require("./PredictionContextCache");
var PredictionMode_1 = require("./PredictionMode");
var RuleStopState_1 = require("./RuleStopState");
var RuleTransition_1 = require("./RuleTransition");
var SemanticContext_1 = require("./SemanticContext");
var SetTransition_1 = require("./SetTransition");
var SimulatorState_1 = require("./SimulatorState");
var Token_1 = require("../Token");
var VocabularyImpl_1 = require("../VocabularyImpl");
var assert = require("assert");
var MAX_SHORT_VALUE = 0xFFFF;
var MIN_INTEGER_VALUE = -(1 << 31 >>> 0);
/**
 * The embodiment of the adaptive LL(*), ALL(*), parsing strategy.
 *
 * The basic complexity of the adaptive strategy makes it harder to understand.
 * We begin with ATN simulation to build paths in a DFA. Subsequent prediction
 * requests go through the DFA first. If they reach a state without an edge for
 * the current symbol, the algorithm fails over to the ATN simulation to
 * complete the DFA path for the current input (until it finds a conflict state
 * or uniquely predicting state).
 *
 * All of that is done without using the outer context because we want to create
 * a DFA that is not dependent upon the rule invocation stack when we do a
 * prediction. One DFA works in all contexts. We avoid using context not
 * necessarily because it's slower, although it can be, but because of the DFA
 * caching problem. The closure routine only considers the rule invocation stack
 * created during prediction beginning in the decision rule. For example, if
 * prediction occurs without invoking another rule's ATN, there are no context
 * stacks in the configurations. When lack of context leads to a conflict, we
 * don't know if it's an ambiguity or a weakness in the strong LL(*) parsing
 * strategy (versus full LL(*)).
 *
 * When SLL yields a configuration set with conflict, we rewind the input and
 * retry the ATN simulation, this time using full outer context without adding
 * to the DFA. Configuration context stacks will be the full invocation stacks
 * from the start rule. If we get a conflict using full context, then we can
 * definitively say we have a true ambiguity for that input sequence. If we
 * don't get a conflict, it implies that the decision is sensitive to the outer
 * context. (It is not context-sensitive in the sense of context-sensitive
 * grammars.)
 *
 * The next time we reach this DFA state with an SLL conflict, through DFA
 * simulation, we will again retry the ATN simulation using full context mode.
 * This is slow because we can't save the results and have to "interpret" the
 * ATN each time we get that input.
 *
 * **CACHING FULL CONTEXT PREDICTIONS**
 *
 * We could cache results from full context to predicted alternative easily and
 * that saves a lot of time but doesn't work in presence of predicates. The set
 * of visible predicates from the ATN start state changes depending on the
 * context, because closure can fall off the end of a rule. I tried to cache
 * tuples (stack context, semantic context, predicted alt) but it was slower
 * than interpreting and much more complicated. Also required a huge amount of
 * memory. The goal is not to create the world's fastest parser anyway. I'd like
 * to keep this algorithm simple. By launching multiple threads, we can improve
 * the speed of parsing across a large number of files.
 *
 * There is no strict ordering between the amount of input used by SLL vs LL,
 * which makes it really hard to build a cache for full context. Let's say that
 * we have input A B C that leads to an SLL conflict with full context X. That
 * implies that using X we might only use A B but we could also use A B C D to
 * resolve conflict. Input A B C D could predict alternative 1 in one position
 * in the input and A B C E could predict alternative 2 in another position in
 * input. The conflicting SLL configurations could still be non-unique in the
 * full context prediction, which would lead us to requiring more input than the
 * original A B C.	To make a	prediction cache work, we have to track	the exact
 * input	used during the previous prediction. That amounts to a cache that maps
 * X to a specific DFA for that context.
 *
 * Something should be done for left-recursive expression predictions. They are
 * likely LL(1) + pred eval. Easier to do the whole SLL unless error and retry
 * with full LL thing Sam does.
 *
 * **AVOIDING FULL CONTEXT PREDICTION**
 *
 * We avoid doing full context retry when the outer context is empty, we did not
 * dip into the outer context by falling off the end of the decision state rule,
 * or when we force SLL mode.
 *
 * As an example of the not dip into outer context case, consider as super
 * constructor calls versus function calls. One grammar might look like
 * this:
 *
 * ```antlr
 * ctorBody
 *   : '{' superCall? stat* '}'
 *   ;
 * ```
 *
 * Or, you might see something like
 *
 * ```antlr
 * stat
 *   : superCall ';'
 *   | expression ';'
 *   | ...
 *   ;
 * ```
 *
 * In both cases I believe that no closure operations will dip into the outer
 * context. In the first case ctorBody in the worst case will stop at the '}'.
 * In the 2nd case it should stop at the ';'. Both cases should stay within the
 * entry rule and not dip into the outer context.
 *
 * **PREDICATES**
 *
 * Predicates are always evaluated if present in either SLL or LL both. SLL and
 * LL simulation deals with predicates differently. SLL collects predicates as
 * it performs closure operations like ANTLR v3 did. It delays predicate
 * evaluation until it reaches and accept state. This allows us to cache the SLL
 * ATN simulation whereas, if we had evaluated predicates on-the-fly during
 * closure, the DFA state configuration sets would be different and we couldn't
 * build up a suitable DFA.
 *
 * When building a DFA accept state during ATN simulation, we evaluate any
 * predicates and return the sole semantically valid alternative. If there is
 * more than 1 alternative, we report an ambiguity. If there are 0 alternatives,
 * we throw an exception. Alternatives without predicates act like they have
 * true predicates. The simple way to think about it is to strip away all
 * alternatives with false predicates and choose the minimum alternative that
 * remains.
 *
 * When we start in the DFA and reach an accept state that's predicated, we test
 * those and return the minimum semantically viable alternative. If no
 * alternatives are viable, we throw an exception.
 *
 * During full LL ATN simulation, closure always evaluates predicates and
 * on-the-fly. This is crucial to reducing the configuration set size during
 * closure. It hits a landmine when parsing with the Java grammar, for example,
 * without this on-the-fly evaluation.
 *
 * **SHARING DFA**
 *
 * All instances of the same parser share the same decision DFAs through a
 * static field. Each instance gets its own ATN simulator but they share the
 * same {@link ATN#decisionToDFA} field. They also share a
 * {@link PredictionContextCache} object that makes sure that all
 * {@link PredictionContext} objects are shared among the DFA states. This makes
 * a big size difference.
 *
 * **THREAD SAFETY**
 *
 * The {@link ParserATNSimulator} locks on the {@link ATN#decisionToDFA} field when
 * it adds a new DFA object to that array. {@link #addDFAEdge}
 * locks on the DFA for the current decision when setting the
 * {@link DFAState#edges} field. {@link #addDFAState} locks on
 * the DFA for the current decision when looking up a DFA state to see if it
 * already exists. We must make sure that all requests to add DFA states that
 * are equivalent result in the same shared DFA object. This is because lots of
 * threads will be trying to update the DFA at once. The
 * {@link #addDFAState} method also locks inside the DFA lock
 * but this time on the shared context cache when it rebuilds the
 * configurations' {@link PredictionContext} objects using cached
 * subgraphs/nodes. No other locking occurs, even during DFA simulation. This is
 * safe as long as we can guarantee that all threads referencing
 * `s.edge[t]` get the same physical target {@link DFAState}, or
 * `undefined`. Once into the DFA, the DFA simulation does not reference the
 * {@link DFA#states} map. It follows the {@link DFAState#edges} field to new
 * targets. The DFA simulator will either find {@link DFAState#edges} to be
 * `undefined`, to be non-`undefined` and `dfa.edges[t]` undefined, or
 * `dfa.edges[t]` to be non-undefined. The
 * {@link #addDFAEdge} method could be racing to set the field
 * but in either case the DFA simulator works; if `undefined`, and requests ATN
 * simulation. It could also race trying to get `dfa.edges[t]`, but either
 * way it will work because it's not doing a test and set operation.
 *
 * **Starting with SLL then failing to combined SLL/LL (Two-Stage
 * Parsing)**
 *
 * Sam pointed out that if SLL does not give a syntax error, then there is no
 * point in doing full LL, which is slower. We only have to try LL if we get a
 * syntax error. For maximum speed, Sam starts the parser set to pure SLL
 * mode with the {@link BailErrorStrategy}:
 *
 * ```
 * parser.interpreter.{@link #setPredictionMode setPredictionMode}`(`{@link PredictionMode#SLL}`)`;
 * parser.{@link Parser#setErrorHandler setErrorHandler}(new {@link BailErrorStrategy}());
 * ```
 *
 * If it does not get a syntax error, then we're done. If it does get a syntax
 * error, we need to retry with the combined SLL/LL strategy.
 *
 * The reason this works is as follows. If there are no SLL conflicts, then the
 * grammar is SLL (at least for that input set). If there is an SLL conflict,
 * the full LL analysis must yield a set of viable alternatives which is a
 * subset of the alternatives reported by SLL. If the LL set is a singleton,
 * then the grammar is LL but not SLL. If the LL set is the same size as the SLL
 * set, the decision is SLL. If the LL set has size &gt; 1, then that decision
 * is truly ambiguous on the current input. If the LL set is smaller, then the
 * SLL conflict resolution might choose an alternative that the full LL would
 * rule out as a possibility based upon better context information. If that's
 * the case, then the SLL parse will definitely get an error because the full LL
 * analysis says it's not viable. If SLL conflict resolution chooses an
 * alternative within the LL set, them both SLL and LL would choose the same
 * alternative because they both choose the minimum of multiple conflicting
 * alternatives.
 *
 * Let's say we have a set of SLL conflicting alternatives `{1, 2, 3}` and
 * a smaller LL set called *s*. If *s* is `{2, 3}`, then SLL
 * parsing will get an error because SLL will pursue alternative 1. If
 * *s* is `{1, 2}` or `{1, 3}` then both SLL and LL will
 * choose the same alternative because alternative one is the minimum of either
 * set. If *s* is `{2}` or `{3}` then SLL will get a syntax
 * error. If *s* is `{1}` then SLL will succeed.
 *
 * Of course, if the input is invalid, then we will get an error for sure in
 * both SLL and LL parsing. Erroneous input will therefore require 2 passes over
 * the input.
 */
var ParserATNSimulator = /*#__PURE__*/function (_ATNSimulator_1$ATNSi) {
  (0, _inherits2.default)(ParserATNSimulator, _ATNSimulator_1$ATNSi);
  var _super = _createSuper(ParserATNSimulator);
  function ParserATNSimulator(atn, parser) {
    var _this;
    (0, _classCallCheck2.default)(this, ParserATNSimulator);
    _this = _super.call(this, atn);
    _this.predictionMode = PredictionMode_1.PredictionMode.LL;
    _this.force_global_context = false;
    _this.always_try_local_context = true;
    /**
     * Determines whether the DFA is used for full-context predictions. When
     * `true`, the DFA stores transition information for both full-context
     * and SLL parsing; otherwise, the DFA only stores SLL transition
     * information.
     *
     * For some grammars, enabling the full-context DFA can result in a
     * substantial performance improvement. However, this improvement typically
     * comes at the expense of memory used for storing the cached DFA states,
     * configuration sets, and prediction contexts.
     *
     * The default value is `false`.
     */
    _this.enable_global_context_dfa = false;
    _this.optimize_unique_closure = true;
    _this.optimize_ll1 = true;
    _this.optimize_tail_calls = true;
    _this.tail_call_preserves_sll = true;
    _this.treat_sllk1_conflict_as_ambiguity = false;
    /**
     * When `true`, ambiguous alternatives are reported when they are
     * encountered within {@link #execATN}. When `false`, these messages
     * are suppressed. The default is `false`.
     *
     * When messages about ambiguous alternatives are not required, setting this
     * to `false` enables additional internal optimizations which may lose
     * this information.
     */
    _this.reportAmbiguities = false;
    /** By default we do full context-sensitive LL(*) parsing not
     *  Strong LL(*) parsing. If we fail with Strong LL(*) we
     *  try full LL(*). That means we rewind and use context information
     *  when closure operations fall off the end of the rule that
     *  holds the decision were evaluating.
     */
    _this.userWantsCtxSensitive = true;
    _this._parser = parser;
    return _this;
  }
  (0, _createClass2.default)(ParserATNSimulator, [{
    key: "getPredictionMode",
    value: function getPredictionMode() {
      return this.predictionMode;
    }
  }, {
    key: "setPredictionMode",
    value: function setPredictionMode(predictionMode) {
      this.predictionMode = predictionMode;
    }
  }, {
    key: "reset",
    value: function reset() {
      // intentionally empty
    }
  }, {
    key: "adaptivePredict",
    value: function adaptivePredict(input, decision, outerContext, useContext) {
      if (useContext === undefined) {
        useContext = false;
      }
      var dfa = this.atn.decisionToDFA[decision];
      assert(dfa != null);
      if (this.optimize_ll1 && !dfa.isPrecedenceDfa && !dfa.isEmpty) {
        var ll_1 = input.LA(1);
        if (ll_1 >= 0 && ll_1 <= 0xFFFF) {
          var key = (decision << 16 >>> 0) + ll_1;
          var alt = this.atn.LL1Table.get(key);
          if (alt != null) {
            return alt;
          }
        }
      }
      this.dfa = dfa;
      if (this.force_global_context) {
        useContext = true;
      } else if (!this.always_try_local_context) {
        useContext = useContext || dfa.isContextSensitive;
      }
      this.userWantsCtxSensitive = useContext || this.predictionMode !== PredictionMode_1.PredictionMode.SLL && outerContext != null && !this.atn.decisionToState[decision].sll;
      if (outerContext == null) {
        outerContext = ParserRuleContext_1.ParserRuleContext.emptyContext();
      }
      var state;
      if (!dfa.isEmpty) {
        state = this.getStartState(dfa, input, outerContext, useContext);
      }
      if (state == null) {
        if (outerContext == null) {
          outerContext = ParserRuleContext_1.ParserRuleContext.emptyContext();
        }
        if (ParserATNSimulator.debug) {
          console.log("ATN decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input) + ", outerContext=" + outerContext.toString(this._parser));
        }
        state = this.computeStartState(dfa, outerContext, useContext);
      }
      var m = input.mark();
      var index = input.index;
      try {
        var _alt = this.execDFA(dfa, input, index, state);
        if (ParserATNSimulator.debug) {
          console.log("DFA after predictATN: " + dfa.toString(this._parser.vocabulary, this._parser.ruleNames));
        }
        return _alt;
      } finally {
        this.dfa = undefined;
        input.seek(index);
        input.release(m);
      }
    }
  }, {
    key: "getStartState",
    value: function getStartState(dfa, input, outerContext, useContext) {
      if (!useContext) {
        if (dfa.isPrecedenceDfa) {
          // the start state for a precedence DFA depends on the current
          // parser precedence, and is provided by a DFA method.
          var state = dfa.getPrecedenceStartState(this._parser.precedence, false);
          if (state == null) {
            return undefined;
          }
          return new SimulatorState_1.SimulatorState(outerContext, state, false, outerContext);
        } else {
          if (dfa.s0 == null) {
            return undefined;
          }
          return new SimulatorState_1.SimulatorState(outerContext, dfa.s0, false, outerContext);
        }
      }
      if (!this.enable_global_context_dfa) {
        return undefined;
      }
      var remainingContext = outerContext;
      assert(outerContext != null);
      var s0;
      if (dfa.isPrecedenceDfa) {
        s0 = dfa.getPrecedenceStartState(this._parser.precedence, true);
      } else {
        s0 = dfa.s0full;
      }
      while (remainingContext != null && s0 != null && s0.isContextSensitive) {
        remainingContext = this.skipTailCalls(remainingContext);
        s0 = s0.getContextTarget(this.getReturnState(remainingContext));
        if (remainingContext.isEmpty) {
          assert(s0 == null || !s0.isContextSensitive);
        } else {
          remainingContext = remainingContext.parent;
        }
      }
      if (s0 == null) {
        return undefined;
      }
      return new SimulatorState_1.SimulatorState(outerContext, s0, useContext, remainingContext);
    }
  }, {
    key: "execDFA",
    value: function execDFA(dfa, input, startIndex, state) {
      var outerContext = state.outerContext;
      if (ParserATNSimulator.dfa_debug) {
        console.log("DFA decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input) + ", outerContext=" + outerContext.toString(this._parser));
      }
      if (ParserATNSimulator.dfa_debug) {
        console.log(dfa.toString(this._parser.vocabulary, this._parser.ruleNames));
      }
      var s = state.s0;
      var t = input.LA(1);
      var remainingOuterContext = state.remainingOuterContext;
      while (true) {
        if (ParserATNSimulator.dfa_debug) {
          console.log("DFA state " + s.stateNumber + " LA(1)==" + this.getLookaheadName(input));
        }
        if (state.useContext) {
          while (s.isContextSymbol(t)) {
            var next = void 0;
            if (remainingOuterContext != null) {
              remainingOuterContext = this.skipTailCalls(remainingOuterContext);
              next = s.getContextTarget(this.getReturnState(remainingOuterContext));
            }
            if (next == null) {
              // fail over to ATN
              var initialState = new SimulatorState_1.SimulatorState(state.outerContext, s, state.useContext, remainingOuterContext);
              return this.execATN(dfa, input, startIndex, initialState);
            }
            assert(remainingOuterContext != null);
            remainingOuterContext = remainingOuterContext.parent;
            s = next;
          }
        }
        if (this.isAcceptState(s, state.useContext)) {
          if (s.predicates != null) {
            if (ParserATNSimulator.dfa_debug) {
              console.log("accept " + s);
            }
          } else {
            if (ParserATNSimulator.dfa_debug) {
              console.log("accept; predict " + s.prediction + " in state " + s.stateNumber);
            }
          }
          // keep going unless we're at EOF or state only has one alt number
          // mentioned in configs; check if something else could match
          // TODO: don't we always stop? only lexer would keep going
          // TODO: v3 dfa don't do this.
          break;
        }
        // t is not updated if one of these states is reached
        assert(!this.isAcceptState(s, state.useContext));
        // if no edge, pop over to ATN interpreter, update DFA and return
        var target = this.getExistingTargetState(s, t);
        if (target == null) {
          if (ParserATNSimulator.dfa_debug && t >= 0) {
            console.log("no edge for " + this._parser.vocabulary.getDisplayName(t));
          }
          var alt = void 0;
          if (ParserATNSimulator.dfa_debug) {
            var interval = Interval_1.Interval.of(startIndex, this._parser.inputStream.index);
            console.log("ATN exec upon " + this._parser.inputStream.getText(interval) + " at DFA state " + s.stateNumber);
          }
          var _initialState = new SimulatorState_1.SimulatorState(outerContext, s, state.useContext, remainingOuterContext);
          alt = this.execATN(dfa, input, startIndex, _initialState);
          if (ParserATNSimulator.dfa_debug) {
            console.log("back from DFA update, alt=" + alt + ", dfa=\n" + dfa.toString(this._parser.vocabulary, this._parser.ruleNames));
            //dump(dfa);
          }
          // action already executed
          if (ParserATNSimulator.dfa_debug) {
            console.log("DFA decision " + dfa.decision + " predicts " + alt);
          }
          return alt; // we've updated DFA, exec'd action, and have our deepest answer
        } else if (target === ATNSimulator_1.ATNSimulator.ERROR) {
          var errorState = new SimulatorState_1.SimulatorState(outerContext, s, state.useContext, remainingOuterContext);
          return this.handleNoViableAlt(input, startIndex, errorState);
        }
        s = target;
        if (!this.isAcceptState(s, state.useContext) && t !== IntStream_1.IntStream.EOF) {
          input.consume();
          t = input.LA(1);
        }
      }
      //		if ( acceptState==null ) {
      //			if ( debug ) System.out.println("!!! no viable alt in dfa");
      //			return -1;
      //		}
      if (!state.useContext && s.configs.conflictInfo != null) {
        if (dfa.atnStartState instanceof DecisionState_1.DecisionState) {
          if (!this.userWantsCtxSensitive || !s.configs.dipsIntoOuterContext && s.configs.isExactConflict || this.treat_sllk1_conflict_as_ambiguity && input.index === startIndex) {
            // we don't report the ambiguity again
            //if ( !this.acceptState.configset.hasSemanticContext ) {
            // 	this.reportAmbiguity(dfa, acceptState, startIndex, input.index, acceptState.configset.conflictingAlts, acceptState.configset);
            //}
          } else {
            assert(!state.useContext);
            // Before attempting full context prediction, check to see if there are
            // disambiguating or validating predicates to evaluate which allow an
            // immediate decision
            var conflictingAlts;
            var _predicates = s.predicates;
            if (_predicates != null) {
              var conflictIndex = input.index;
              if (conflictIndex !== startIndex) {
                input.seek(startIndex);
              }
              conflictingAlts = this.evalSemanticContext(_predicates, outerContext, true);
              if (conflictingAlts.cardinality() === 1) {
                return conflictingAlts.nextSetBit(0);
              }
              if (conflictIndex !== startIndex) {
                // restore the index so reporting the fallback to full
                // context occurs with the index at the correct spot
                input.seek(conflictIndex);
              }
            }
            if (this.reportAmbiguities) {
              var conflictState = new SimulatorState_1.SimulatorState(outerContext, s, state.useContext, remainingOuterContext);
              this.reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, input.index);
            }
            input.seek(startIndex);
            return this.adaptivePredict(input, dfa.decision, outerContext, true);
          }
        }
      }
      // Before jumping to prediction, check to see if there are
      // disambiguating or validating predicates to evaluate
      var predicates = s.predicates;
      if (predicates != null) {
        var stopIndex = input.index;
        if (startIndex !== stopIndex) {
          input.seek(startIndex);
        }
        var alts = this.evalSemanticContext(predicates, outerContext, this.reportAmbiguities && this.predictionMode === PredictionMode_1.PredictionMode.LL_EXACT_AMBIG_DETECTION);
        switch (alts.cardinality()) {
          case 0:
            throw this.noViableAlt(input, outerContext, s.configs, startIndex);
          case 1:
            return alts.nextSetBit(0);
          default:
            // report ambiguity after predicate evaluation to make sure the correct
            // set of ambig alts is reported.
            if (startIndex !== stopIndex) {
              input.seek(stopIndex);
            }
            this.reportAmbiguity(dfa, s, startIndex, stopIndex, s.configs.isExactConflict, alts, s.configs);
            return alts.nextSetBit(0);
        }
      }
      if (ParserATNSimulator.dfa_debug) {
        console.log("DFA decision " + dfa.decision + " predicts " + s.prediction);
      }
      return s.prediction;
    }
    /**
     * Determines if a particular DFA state should be treated as an accept state
     * for the current prediction mode. In addition to the `useContext`
     * parameter, the {@link #getPredictionMode()} method provides the
     * prediction mode controlling the prediction algorithm as a whole.
     *
     * The default implementation simply returns the value of
     * `DFAState.isAcceptState` except for conflict states when
     * `useContext` is `true` and {@link #getPredictionMode()} is
     * {@link PredictionMode#LL_EXACT_AMBIG_DETECTION}. In that case, only
     * conflict states where {@link ATNConfigSet#isExactConflict} is
     * `true` are considered accept states.
     *
     * @param state The DFA state to check.
     * @param useContext `true` if the prediction algorithm is currently
     * considering the full parser context; otherwise, `false` if the
     * algorithm is currently performing a local context prediction.
     *
     * @returns `true` if the specified `state` is an accept state;
     * otherwise, `false`.
     */
  }, {
    key: "isAcceptState",
    value: function isAcceptState(state, useContext) {
      if (!state.isAcceptState) {
        return false;
      }
      if (state.configs.conflictingAlts == null) {
        // unambiguous
        return true;
      }
      // More picky when we need exact conflicts
      if (useContext && this.predictionMode === PredictionMode_1.PredictionMode.LL_EXACT_AMBIG_DETECTION) {
        return state.configs.isExactConflict;
      }
      return true;
    }
    /** Performs ATN simulation to compute a predicted alternative based
     *  upon the remaining input, but also updates the DFA cache to avoid
     *  having to traverse the ATN again for the same input sequence.
     *
     * There are some key conditions we're looking for after computing a new
     * set of ATN configs (proposed DFA state):
     *
     * * if the set is empty, there is no viable alternative for current symbol
     * * does the state uniquely predict an alternative?
     * * does the state have a conflict that would prevent us from
     *   putting it on the work list?
     * * if in non-greedy decision is there a config at a rule stop state?
     *
     * We also have some key operations to do:
     *
     * * add an edge from previous DFA state to potentially new DFA state, D,
     *   upon current symbol but only if adding to work list, which means in all
     *   cases except no viable alternative (and possibly non-greedy decisions?)
     * * collecting predicates and adding semantic context to DFA accept states
     * * adding rule context to context-sensitive DFA accept states
     * * consuming an input symbol
     * * reporting a conflict
     * * reporting an ambiguity
     * * reporting a context sensitivity
     * * reporting insufficient predicates
     *
     * We should isolate those operations, which are side-effecting, to the
     * main work loop. We can isolate lots of code into other functions, but
     * they should be side effect free. They can return package that
     * indicates whether we should report something, whether we need to add a
     * DFA edge, whether we need to augment accept state with semantic
     * context or rule invocation context. Actually, it seems like we always
     * add predicates if they exist, so that can simply be done in the main
     * loop for any accept state creation or modification request.
     *
     * cover these cases:
     *   dead end
     *   single alt
     *   single alt + preds
     *   conflict
     *   conflict + preds
     *
     * TODO: greedy + those
     */
  }, {
    key: "execATN",
    value: function execATN(dfa, input, startIndex, initialState) {
      if (ParserATNSimulator.debug) {
        console.log("execATN decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input));
      }
      var outerContext = initialState.outerContext;
      var useContext = initialState.useContext;
      var t = input.LA(1);
      var previous = initialState;
      var contextCache = new PredictionContextCache_1.PredictionContextCache();
      while (true) {
        // while more work
        var nextState = this.computeReachSet(dfa, previous, t, contextCache);
        if (nextState == null) {
          this.setDFAEdge(previous.s0, input.LA(1), ATNSimulator_1.ATNSimulator.ERROR);
          return this.handleNoViableAlt(input, startIndex, previous);
        }
        var D = nextState.s0;
        // predicted alt => accept state
        assert(D.isAcceptState || D.prediction === ATN_1.ATN.INVALID_ALT_NUMBER);
        // conflicted => accept state
        assert(D.isAcceptState || D.configs.conflictInfo == null);
        if (this.isAcceptState(D, useContext)) {
          var conflictingAlts = D.configs.conflictingAlts;
          var predictedAlt = conflictingAlts == null ? D.prediction : ATN_1.ATN.INVALID_ALT_NUMBER;
          if (predictedAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
            if (this.optimize_ll1 && input.index === startIndex && !dfa.isPrecedenceDfa && nextState.outerContext === nextState.remainingOuterContext && dfa.decision >= 0 && !D.configs.hasSemanticContext) {
              if (t >= 0 && t <= MAX_SHORT_VALUE) {
                var key = (dfa.decision << 16 >>> 0) + t;
                this.atn.LL1Table.set(key, predictedAlt);
              }
            }
            if (useContext && this.always_try_local_context) {
              this.reportContextSensitivity(dfa, predictedAlt, nextState, startIndex, input.index);
            }
          }
          predictedAlt = D.prediction;
          //				int k = input.index - startIndex + 1; // how much input we used
          //				System.out.println("used k="+k);
          var attemptFullContext = conflictingAlts != null && this.userWantsCtxSensitive;
          if (attemptFullContext) {
            // Only exact conflicts are known to be ambiguous when local
            // prediction does not step out of the decision rule.
            attemptFullContext = !useContext && (D.configs.dipsIntoOuterContext || !D.configs.isExactConflict) && (!this.treat_sllk1_conflict_as_ambiguity || input.index !== startIndex);
          }
          if (D.configs.hasSemanticContext) {
            var predPredictions = D.predicates;
            if (predPredictions != null) {
              var conflictIndex = input.index;
              if (conflictIndex !== startIndex) {
                input.seek(startIndex);
              }
              // use complete evaluation here if we'll want to retry with full context if still ambiguous
              conflictingAlts = this.evalSemanticContext(predPredictions, outerContext, attemptFullContext || this.reportAmbiguities);
              switch (conflictingAlts.cardinality()) {
                case 0:
                  throw this.noViableAlt(input, outerContext, D.configs, startIndex);
                case 1:
                  return conflictingAlts.nextSetBit(0);
                default:
                  break;
              }
              if (conflictIndex !== startIndex) {
                // restore the index so reporting the fallback to full
                // context occurs with the index at the correct spot
                input.seek(conflictIndex);
              }
            }
          }
          if (!attemptFullContext) {
            if (conflictingAlts != null) {
              if (this.reportAmbiguities && conflictingAlts.cardinality() > 1) {
                this.reportAmbiguity(dfa, D, startIndex, input.index, D.configs.isExactConflict, conflictingAlts, D.configs);
              }
              predictedAlt = conflictingAlts.nextSetBit(0);
            }
            return predictedAlt;
          } else {
            assert(!useContext);
            assert(this.isAcceptState(D, false));
            if (ParserATNSimulator.debug) {
              console.log("RETRY with outerContext=" + outerContext);
            }
            var fullContextState = this.computeStartState(dfa, outerContext, true);
            if (this.reportAmbiguities) {
              this.reportAttemptingFullContext(dfa, conflictingAlts, nextState, startIndex, input.index);
            }
            input.seek(startIndex);
            return this.execATN(dfa, input, startIndex, fullContextState);
          }
        }
        previous = nextState;
        if (t !== IntStream_1.IntStream.EOF) {
          input.consume();
          t = input.LA(1);
        }
      }
    }
    /**
     * This method is used to improve the localization of error messages by
     * choosing an alternative rather than throwing a
     * {@link NoViableAltException} in particular prediction scenarios where the
     * {@link #ERROR} state was reached during ATN simulation.
     *
     * The default implementation of this method uses the following
     * algorithm to identify an ATN configuration which successfully parsed the
     * decision entry rule. Choosing such an alternative ensures that the
     * {@link ParserRuleContext} returned by the calling rule will be complete
     * and valid, and the syntax error will be reported later at a more
     * localized location.
     *
     * * If no configuration in `configs` reached the end of the
     *   decision rule, return {@link ATN#INVALID_ALT_NUMBER}.
     * * If all configurations in `configs` which reached the end of the
     *   decision rule predict the same alternative, return that alternative.
     * * If the configurations in `configs` which reached the end of the
     *   decision rule predict multiple alternatives (call this *S*),
     *   choose an alternative in the following order.
     *
     *     1. Filter the configurations in `configs` to only those
     *        configurations which remain viable after evaluating semantic predicates.
     *        If the set of these filtered configurations which also reached the end of
     *        the decision rule is not empty, return the minimum alternative
     *        represented in this set.
     *     1. Otherwise, choose the minimum alternative in *S*.
     *
     * In some scenarios, the algorithm described above could predict an
     * alternative which will result in a {@link FailedPredicateException} in
     * parser. Specifically, this could occur if the *only* configuration
     * capable of successfully parsing to the end of the decision rule is
     * blocked by a semantic predicate. By choosing this alternative within
     * {@link #adaptivePredict} instead of throwing a
     * {@link NoViableAltException}, the resulting
     * {@link FailedPredicateException} in the parser will identify the specific
     * predicate which is preventing the parser from successfully parsing the
     * decision rule, which helps developers identify and correct logic errors
     * in semantic predicates.
     *
     * @param input The input {@link TokenStream}
     * @param startIndex The start index for the current prediction, which is
     * the input index where any semantic context in `configs` should be
     * evaluated
     * @param previous The ATN simulation state immediately before the
     * {@link #ERROR} state was reached
     *
     * @returns The value to return from {@link #adaptivePredict}, or
     * {@link ATN#INVALID_ALT_NUMBER} if a suitable alternative was not
     * identified and {@link #adaptivePredict} should report an error instead.
     */
  }, {
    key: "handleNoViableAlt",
    value: function handleNoViableAlt(input, startIndex, previous) {
      if (previous.s0 != null) {
        var alts = new BitSet_1.BitSet();
        var maxAlt = 0;
        var _iterator = _createForOfIteratorHelper(previous.s0.configs),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _config = _step.value;
            if (_config.reachesIntoOuterContext || _config.state instanceof RuleStopState_1.RuleStopState) {
              alts.set(_config.alt);
              maxAlt = Math.max(maxAlt, _config.alt);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        switch (alts.cardinality()) {
          case 0:
            break;
          case 1:
            return alts.nextSetBit(0);
          default:
            if (!previous.s0.configs.hasSemanticContext) {
              // configs doesn't contain any predicates, so the predicate
              // filtering code below would be pointless
              return alts.nextSetBit(0);
            }
            /*
             * Try to find a configuration set that not only dipped into the outer
             * context, but also isn't eliminated by a predicate.
             */
            var filteredConfigs = new ATNConfigSet_1.ATNConfigSet();
            var _iterator2 = _createForOfIteratorHelper(previous.s0.configs),
              _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var config = _step2.value;
                if (config.reachesIntoOuterContext || config.state instanceof RuleStopState_1.RuleStopState) {
                  filteredConfigs.add(config);
                }
              }
              /* The following code blocks are adapted from predicateDFAState with
               * the following key changes.
               *
               *  1. The code operates on an ATNConfigSet rather than a DFAState.
               *  2. Predicates are collected for all alternatives represented in
               *     filteredConfigs, rather than restricting the evaluation to
               *     conflicting and/or unique configurations.
               */
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
            var altToPred = this.getPredsForAmbigAlts(alts, filteredConfigs, maxAlt);
            if (altToPred != null) {
              var predicates = this.getPredicatePredictions(alts, altToPred);
              if (predicates != null) {
                var stopIndex = input.index;
                try {
                  input.seek(startIndex);
                  var filteredAlts = this.evalSemanticContext(predicates, previous.outerContext, false);
                  if (!filteredAlts.isEmpty) {
                    return filteredAlts.nextSetBit(0);
                  }
                } finally {
                  input.seek(stopIndex);
                }
              }
            }
            return alts.nextSetBit(0);
        }
      }
      throw this.noViableAlt(input, previous.outerContext, previous.s0.configs, startIndex);
    }
  }, {
    key: "computeReachSet",
    value: function computeReachSet(dfa, previous, t, contextCache) {
      var useContext = previous.useContext;
      var remainingGlobalContext = previous.remainingOuterContext;
      var s = previous.s0;
      if (useContext) {
        while (s.isContextSymbol(t)) {
          var next = void 0;
          if (remainingGlobalContext != null) {
            remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
            next = s.getContextTarget(this.getReturnState(remainingGlobalContext));
          }
          if (next == null) {
            break;
          }
          assert(remainingGlobalContext != null);
          remainingGlobalContext = remainingGlobalContext.parent;
          s = next;
        }
      }
      assert(!this.isAcceptState(s, useContext));
      if (this.isAcceptState(s, useContext)) {
        return new SimulatorState_1.SimulatorState(previous.outerContext, s, useContext, remainingGlobalContext);
      }
      var s0 = s;
      var target = this.getExistingTargetState(s0, t);
      if (target == null) {
        var result = this.computeTargetState(dfa, s0, remainingGlobalContext, t, useContext, contextCache);
        target = result[0];
        remainingGlobalContext = result[1];
      }
      if (target === ATNSimulator_1.ATNSimulator.ERROR) {
        return undefined;
      }
      assert(!useContext || !target.configs.dipsIntoOuterContext);
      return new SimulatorState_1.SimulatorState(previous.outerContext, target, useContext, remainingGlobalContext);
    }
    /**
     * Get an existing target state for an edge in the DFA. If the target state
     * for the edge has not yet been computed or is otherwise not available,
     * this method returns `undefined`.
     *
     * @param s The current DFA state
     * @param t The next input symbol
     * @returns The existing target DFA state for the given input symbol
     * `t`, or `undefined` if the target state for this edge is not
     * already cached
     */
  }, {
    key: "getExistingTargetState",
    value: function getExistingTargetState(s, t) {
      return s.getTarget(t);
    }
    /**
     * Compute a target state for an edge in the DFA, and attempt to add the
     * computed state and corresponding edge to the DFA.
     *
     * @param dfa
     * @param s The current DFA state
     * @param remainingGlobalContext
     * @param t The next input symbol
     * @param useContext
     * @param contextCache
     *
     * @returns The computed target DFA state for the given input symbol
     * `t`. If `t` does not lead to a valid DFA state, this method
     * returns {@link #ERROR}.
     */
  }, {
    key: "computeTargetState",
    value: function computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache) {
      var closureConfigs = s.configs.toArray();
      var contextElements;
      var reach = new ATNConfigSet_1.ATNConfigSet();
      var stepIntoGlobal;
      do {
        var hasMoreContext = !useContext || remainingGlobalContext != null;
        if (!hasMoreContext) {
          reach.isOutermostConfigSet = true;
        }
        var reachIntermediate = new ATNConfigSet_1.ATNConfigSet();
        /* Configurations already in a rule stop state indicate reaching the end
         * of the decision rule (local context) or end of the start rule (full
         * context). Once reached, these configurations are never updated by a
         * closure operation, so they are handled separately for the performance
         * advantage of having a smaller intermediate set when calling closure.
         *
         * For full-context reach operations, separate handling is required to
         * ensure that the alternative matching the longest overall sequence is
         * chosen when multiple such configurations can match the input.
         */
        var skippedStopStates = void 0;
        var _iterator3 = _createForOfIteratorHelper(closureConfigs),
          _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var _c = _step3.value;
            if (ParserATNSimulator.debug) {
              console.log("testing " + this.getTokenName(t) + " at " + _c.toString());
            }
            if (_c.state instanceof RuleStopState_1.RuleStopState) {
              assert(_c.context.isEmpty);
              if (useContext && !_c.reachesIntoOuterContext || t === IntStream_1.IntStream.EOF) {
                if (skippedStopStates == null) {
                  skippedStopStates = [];
                }
                skippedStopStates.push(_c);
              }
              continue;
            }
            var n = _c.state.numberOfOptimizedTransitions;
            for (var ti = 0; ti < n; ti++) {
              // for each optimized transition
              var trans = _c.state.getOptimizedTransition(ti);
              var target = this.getReachableTarget(_c, trans, t);
              if (target != null) {
                reachIntermediate.add(_c.transform(target, false), contextCache);
              }
            }
          }
          /* This block optimizes the reach operation for intermediate sets which
           * trivially indicate a termination state for the overall
           * adaptivePredict operation.
           *
           * The conditions assume that intermediate
           * contains all configurations relevant to the reach set, but this
           * condition is not true when one or more configurations have been
           * withheld in skippedStopStates, or when the current symbol is EOF.
           */
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        if (this.optimize_unique_closure && skippedStopStates == null && t !== Token_1.Token.EOF && reachIntermediate.uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
          reachIntermediate.isOutermostConfigSet = reach.isOutermostConfigSet;
          reach = reachIntermediate;
          break;
        }
        /* If the reach set could not be trivially determined, perform a closure
         * operation on the intermediate set to compute its initial value.
         */
        var collectPredicates = false;
        var treatEofAsEpsilon = t === Token_1.Token.EOF;
        this.closure(reachIntermediate, reach, collectPredicates, hasMoreContext, contextCache, treatEofAsEpsilon);
        stepIntoGlobal = reach.dipsIntoOuterContext;
        if (t === IntStream_1.IntStream.EOF) {
          /* After consuming EOF no additional input is possible, so we are
           * only interested in configurations which reached the end of the
           * decision rule (local context) or end of the start rule (full
           * context). Update reach to contain only these configurations. This
           * handles both explicit EOF transitions in the grammar and implicit
           * EOF transitions following the end of the decision or start rule.
           *
           * This is handled before the configurations in skippedStopStates,
           * because any configurations potentially added from that list are
           * already guaranteed to meet this condition whether or not it's
           * required.
           */
          reach = this.removeAllConfigsNotInRuleStopState(reach, contextCache);
        }
        /* If skippedStopStates is not undefined, then it contains at least one
         * configuration. For full-context reach operations, these
         * configurations reached the end of the start rule, in which case we
         * only add them back to reach if no configuration during the current
         * closure operation reached such a state. This ensures adaptivePredict
         * chooses an alternative matching the longest overall sequence when
         * multiple alternatives are viable.
         */
        if (skippedStopStates != null && (!useContext || !PredictionMode_1.PredictionMode.hasConfigInRuleStopState(reach))) {
          assert(skippedStopStates.length > 0);
          var _iterator4 = _createForOfIteratorHelper(skippedStopStates),
            _step4;
          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var c = _step4.value;
              reach.add(c, contextCache);
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
        }
        if (useContext && stepIntoGlobal) {
          reach.clear();
          // We know remainingGlobalContext is not undefined at this point (why?)
          remainingGlobalContext = remainingGlobalContext;
          remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
          var nextContextElement = this.getReturnState(remainingGlobalContext);
          if (contextElements == null) {
            contextElements = new IntegerList_1.IntegerList();
          }
          if (remainingGlobalContext.isEmpty) {
            remainingGlobalContext = undefined;
          } else {
            remainingGlobalContext = remainingGlobalContext.parent;
          }
          contextElements.add(nextContextElement);
          if (nextContextElement !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
            for (var i = 0; i < closureConfigs.length; i++) {
              closureConfigs[i] = closureConfigs[i].appendContext(nextContextElement, contextCache);
            }
          }
        }
      } while (useContext && stepIntoGlobal);
      if (reach.isEmpty) {
        this.setDFAEdge(s, t, ATNSimulator_1.ATNSimulator.ERROR);
        return [ATNSimulator_1.ATNSimulator.ERROR, remainingGlobalContext];
      }
      var result = this.addDFAEdge(dfa, s, t, contextElements, reach, contextCache);
      return [result, remainingGlobalContext];
    }
    /**
     * Return a configuration set containing only the configurations from
     * `configs` which are in a {@link RuleStopState}. If all
     * configurations in `configs` are already in a rule stop state, this
     * method simply returns `configs`.
     *
     * @param configs the configuration set to update
     * @param contextCache the {@link PredictionContext} cache
     *
     * @returns `configs` if all configurations in `configs` are in a
     * rule stop state, otherwise return a new configuration set containing only
     * the configurations from `configs` which are in a rule stop state
     */
  }, {
    key: "removeAllConfigsNotInRuleStopState",
    value: function removeAllConfigsNotInRuleStopState(configs, contextCache) {
      if (PredictionMode_1.PredictionMode.allConfigsInRuleStopStates(configs)) {
        return configs;
      }
      var result = new ATNConfigSet_1.ATNConfigSet();
      var _iterator5 = _createForOfIteratorHelper(configs),
        _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var config = _step5.value;
          if (!(config.state instanceof RuleStopState_1.RuleStopState)) {
            continue;
          }
          result.add(config, contextCache);
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
      return result;
    }
  }, {
    key: "computeStartState",
    value: function computeStartState(dfa, globalContext, useContext) {
      var s0 = dfa.isPrecedenceDfa ? dfa.getPrecedenceStartState(this._parser.precedence, useContext) : useContext ? dfa.s0full : dfa.s0;
      if (s0 != null) {
        if (!useContext) {
          return new SimulatorState_1.SimulatorState(globalContext, s0, useContext, globalContext);
        }
        s0.setContextSensitive(this.atn);
      }
      var decision = dfa.decision;
      // @NotNull
      var p = dfa.atnStartState;
      var previousContext = 0;
      var remainingGlobalContext = globalContext;
      var initialContext = useContext ? PredictionContext_1.PredictionContext.EMPTY_FULL : PredictionContext_1.PredictionContext.EMPTY_LOCAL; // always at least the implicit call to start rule
      var contextCache = new PredictionContextCache_1.PredictionContextCache();
      if (useContext) {
        if (!this.enable_global_context_dfa) {
          while (remainingGlobalContext != null) {
            if (remainingGlobalContext.isEmpty) {
              previousContext = PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
              remainingGlobalContext = undefined;
            } else {
              previousContext = this.getReturnState(remainingGlobalContext);
              initialContext = initialContext.appendSingleContext(previousContext, contextCache);
              remainingGlobalContext = remainingGlobalContext.parent;
            }
          }
        }
        while (s0 != null && s0.isContextSensitive && remainingGlobalContext != null) {
          var next = void 0;
          remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
          if (remainingGlobalContext.isEmpty) {
            next = s0.getContextTarget(PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY);
            previousContext = PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
            remainingGlobalContext = undefined;
          } else {
            previousContext = this.getReturnState(remainingGlobalContext);
            next = s0.getContextTarget(previousContext);
            initialContext = initialContext.appendSingleContext(previousContext, contextCache);
            remainingGlobalContext = remainingGlobalContext.parent;
          }
          if (next == null) {
            break;
          }
          s0 = next;
        }
      }
      if (s0 != null && !s0.isContextSensitive) {
        return new SimulatorState_1.SimulatorState(globalContext, s0, useContext, remainingGlobalContext);
      }
      var configs = new ATNConfigSet_1.ATNConfigSet();
      while (true) {
        var reachIntermediate = new ATNConfigSet_1.ATNConfigSet();
        var n = p.numberOfTransitions;
        for (var ti = 0; ti < n; ti++) {
          // for each transition
          var target = p.transition(ti).target;
          reachIntermediate.add(ATNConfig_1.ATNConfig.create(target, ti + 1, initialContext));
        }
        var hasMoreContext = remainingGlobalContext != null;
        if (!hasMoreContext) {
          configs.isOutermostConfigSet = true;
        }
        var collectPredicates = true;
        this.closure(reachIntermediate, configs, collectPredicates, hasMoreContext, contextCache, false);
        var stepIntoGlobal = configs.dipsIntoOuterContext;
        var _next = void 0;
        if (useContext && !this.enable_global_context_dfa) {
          s0 = this.addDFAState(dfa, configs, contextCache);
          break;
        } else if (s0 == null) {
          if (!dfa.isPrecedenceDfa) {
            _next = this.addDFAState(dfa, configs, contextCache);
            if (useContext) {
              if (!dfa.s0full) {
                dfa.s0full = _next;
              } else {
                _next = dfa.s0full;
              }
            } else {
              if (!dfa.s0) {
                dfa.s0 = _next;
              } else {
                _next = dfa.s0;
              }
            }
          } else {
            /* If this is a precedence DFA, we use applyPrecedenceFilter
             * to convert the computed start state to a precedence start
             * state. We then use DFA.setPrecedenceStartState to set the
             * appropriate start state for the precedence level rather
             * than simply setting DFA.s0.
             */
            configs = this.applyPrecedenceFilter(configs, globalContext, contextCache);
            _next = this.addDFAState(dfa, configs, contextCache);
            dfa.setPrecedenceStartState(this._parser.precedence, useContext, _next);
          }
        } else {
          if (dfa.isPrecedenceDfa) {
            configs = this.applyPrecedenceFilter(configs, globalContext, contextCache);
          }
          _next = this.addDFAState(dfa, configs, contextCache);
          s0.setContextTarget(previousContext, _next);
        }
        s0 = _next;
        if (!useContext || !stepIntoGlobal) {
          break;
        }
        // TODO: make sure it distinguishes empty stack states
        _next.setContextSensitive(this.atn);
        // We know remainingGlobalContext is not undefined at this point (why?)
        remainingGlobalContext = remainingGlobalContext;
        configs.clear();
        remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
        var nextContextElement = this.getReturnState(remainingGlobalContext);
        if (remainingGlobalContext.isEmpty) {
          remainingGlobalContext = undefined;
        } else {
          remainingGlobalContext = remainingGlobalContext.parent;
        }
        if (nextContextElement !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
          initialContext = initialContext.appendSingleContext(nextContextElement, contextCache);
        }
        previousContext = nextContextElement;
      }
      return new SimulatorState_1.SimulatorState(globalContext, s0, useContext, remainingGlobalContext);
    }
    /**
     * This method transforms the start state computed by
     * {@link #computeStartState} to the special start state used by a
     * precedence DFA for a particular precedence value. The transformation
     * process applies the following changes to the start state's configuration
     * set.
     *
     * 1. Evaluate the precedence predicates for each configuration using
     *    {@link SemanticContext#evalPrecedence}.
     * 1. When {@link ATNConfig#isPrecedenceFilterSuppressed} is `false`,
     *    remove all configurations which predict an alternative greater than 1,
     *    for which another configuration that predicts alternative 1 is in the
     *    same ATN state with the same prediction context. This transformation is
     *    valid for the following reasons:
     *
     *     * The closure block cannot contain any epsilon transitions which bypass
     *       the body of the closure, so all states reachable via alternative 1 are
     *       part of the precedence alternatives of the transformed left-recursive
     *       rule.
     *     * The "primary" portion of a left recursive rule cannot contain an
     *       epsilon transition, so the only way an alternative other than 1 can exist
     *       in a state that is also reachable via alternative 1 is by nesting calls
     *       to the left-recursive rule, with the outer calls not being at the
     *       preferred precedence level. The
     *       {@link ATNConfig#isPrecedenceFilterSuppressed} property marks ATN
     *       configurations which do not meet this condition, and therefore are not
     *       eligible for elimination during the filtering process.
     *
     * The prediction context must be considered by this filter to address
     * situations like the following.
     *
     * ```antlr
     * grammar TA;
     * prog: statement* EOF;
     * statement: letterA | statement letterA 'b' ;
     * letterA: 'a';
     * ```
     *
     * If the above grammar, the ATN state immediately before the token
     * reference `'a'` in `letterA` is reachable from the left edge
     * of both the primary and closure blocks of the left-recursive rule
     * `statement`. The prediction context associated with each of these
     * configurations distinguishes between them, and prevents the alternative
     * which stepped out to `prog` (and then back in to `statement`
     * from being eliminated by the filter.
     *
     * @param configs The configuration set computed by
     * {@link #computeStartState} as the start state for the DFA.
     * @returns The transformed configuration set representing the start state
     * for a precedence DFA at a particular precedence level (determined by
     * calling {@link Parser#getPrecedence}).
     */
  }, {
    key: "applyPrecedenceFilter",
    value: function applyPrecedenceFilter(configs, globalContext, contextCache) {
      var statesFromAlt1 = new Map();
      var configSet = new ATNConfigSet_1.ATNConfigSet();
      var _iterator6 = _createForOfIteratorHelper(configs),
        _step6;
      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var config = _step6.value;
          // handle alt 1 first
          if (config.alt !== 1) {
            continue;
          }
          var updatedContext = config.semanticContext.evalPrecedence(this._parser, globalContext);
          if (updatedContext == null) {
            // the configuration was eliminated
            continue;
          }
          statesFromAlt1.set(config.state.stateNumber, config.context);
          if (updatedContext !== config.semanticContext) {
            configSet.add(config.transform(config.state, false, updatedContext), contextCache);
          } else {
            configSet.add(config, contextCache);
          }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
      var _iterator7 = _createForOfIteratorHelper(configs),
        _step7;
      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var _config2 = _step7.value;
          if (_config2.alt === 1) {
            // already handled
            continue;
          }
          if (!_config2.isPrecedenceFilterSuppressed) {
            /* In the future, this elimination step could be updated to also
             * filter the prediction context for alternatives predicting alt>1
             * (basically a graph subtraction algorithm).
             */
            var context = statesFromAlt1.get(_config2.state.stateNumber);
            if (context != null && context.equals(_config2.context)) {
              // eliminated
              continue;
            }
          }
          configSet.add(_config2, contextCache);
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }
      return configSet;
    }
  }, {
    key: "getReachableTarget",
    value: function getReachableTarget(source, trans, ttype) {
      if (trans.matches(ttype, 0, this.atn.maxTokenType)) {
        return trans.target;
      }
      return undefined;
    }
    /** collect and set D's semantic context */
  }, {
    key: "predicateDFAState",
    value: function predicateDFAState(D, configs, nalts) {
      var conflictingAlts = this.getConflictingAltsFromConfigSet(configs);
      if (!conflictingAlts) {
        throw new Error("This unhandled scenario is intended to be unreachable, but I'm currently not sure of why we know that's the case.");
      }
      if (ParserATNSimulator.debug) {
        console.log("predicateDFAState " + D);
      }
      var altToPred = this.getPredsForAmbigAlts(conflictingAlts, configs, nalts);
      // altToPred[uniqueAlt] is now our validating predicate (if any)
      var predPredictions;
      if (altToPred != null) {
        // we have a validating predicate; test it
        // Update DFA so reach becomes accept state with predicate
        predPredictions = this.getPredicatePredictions(conflictingAlts, altToPred);
        D.predicates = predPredictions;
      }
      return predPredictions;
    }
  }, {
    key: "getPredsForAmbigAlts",
    value: function getPredsForAmbigAlts(ambigAlts, configs, nalts) {
      // REACH=[1|1|[]|0:0, 1|2|[]|0:1]
      /* altToPred starts as an array of all undefined contexts. The entry at index i
       * corresponds to alternative i. altToPred[i] may have one of three values:
       *   1. undefined: no ATNConfig c is found such that c.alt===i
       *   2. SemanticContext.NONE: At least one ATNConfig c exists such that
       *      c.alt===i and c.semanticContext===SemanticContext.NONE. In other words,
       *      alt i has at least one unpredicated config.
       *   3. Non-NONE Semantic Context: There exists at least one, and for all
       *      ATNConfig c such that c.alt===i, c.semanticContext!==SemanticContext.NONE.
       *
       * From this, it is clear that NONE||anything==NONE.
       */
      var altToPred = new Array(nalts + 1);
      var n = altToPred.length;
      var _iterator8 = _createForOfIteratorHelper(configs),
        _step8;
      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var c = _step8.value;
          if (ambigAlts.get(c.alt)) {
            altToPred[c.alt] = SemanticContext_1.SemanticContext.or(altToPred[c.alt], c.semanticContext);
          }
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }
      var nPredAlts = 0;
      for (var i = 0; i < n; i++) {
        if (altToPred[i] == null) {
          altToPred[i] = SemanticContext_1.SemanticContext.NONE;
        } else if (altToPred[i] !== SemanticContext_1.SemanticContext.NONE) {
          nPredAlts++;
        }
      }
      // At this point we know `altToPred` doesn't contain any undefined entries
      var result = altToPred;
      // nonambig alts are undefined in result
      if (nPredAlts === 0) {
        result = undefined;
      }
      if (ParserATNSimulator.debug) {
        console.log("getPredsForAmbigAlts result " + (result ? Arrays_1.Arrays.toString(result) : "undefined"));
      }
      return result;
    }
  }, {
    key: "getPredicatePredictions",
    value: function getPredicatePredictions(ambigAlts, altToPred) {
      var pairs = [];
      var containsPredicate = false;
      for (var i = 1; i < altToPred.length; i++) {
        var pred = altToPred[i];
        // unpredicated is indicated by SemanticContext.NONE
        assert(pred != null);
        // find first unpredicated but ambig alternative, if any.
        // Only ambiguous alternatives will have SemanticContext.NONE.
        // Any unambig alts or ambig naked alts after first ambig naked are ignored
        // (undefined, i) means alt i is the default prediction
        // if no (undefined, i), then no default prediction.
        if (ambigAlts != null && ambigAlts.get(i) && pred === SemanticContext_1.SemanticContext.NONE) {
          pairs.push(new DFAState_1.DFAState.PredPrediction(pred, i));
        } else if (pred !== SemanticContext_1.SemanticContext.NONE) {
          containsPredicate = true;
          pairs.push(new DFAState_1.DFAState.PredPrediction(pred, i));
        }
      }
      if (!containsPredicate) {
        return undefined;
      }
      //		System.out.println(Arrays.toString(altToPred)+"->"+pairs);
      return pairs;
    }
    /** Look through a list of predicate/alt pairs, returning alts for the
     *  pairs that win. An `undefined` predicate indicates an alt containing an
     *  unpredicated config which behaves as "always true."
     */
  }, {
    key: "evalSemanticContext",
    value: function evalSemanticContext(predPredictions, outerContext, complete) {
      var predictions = new BitSet_1.BitSet();
      var _iterator9 = _createForOfIteratorHelper(predPredictions),
        _step9;
      try {
        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
          var pair = _step9.value;
          if (pair.pred === SemanticContext_1.SemanticContext.NONE) {
            predictions.set(pair.alt);
            if (!complete) {
              break;
            }
            continue;
          }
          var evaluatedResult = this.evalSemanticContextImpl(pair.pred, outerContext, pair.alt);
          if (ParserATNSimulator.debug || ParserATNSimulator.dfa_debug) {
            console.log("eval pred " + pair + "=" + evaluatedResult);
          }
          if (evaluatedResult) {
            if (ParserATNSimulator.debug || ParserATNSimulator.dfa_debug) {
              console.log("PREDICT " + pair.alt);
            }
            predictions.set(pair.alt);
            if (!complete) {
              break;
            }
          }
        }
      } catch (err) {
        _iterator9.e(err);
      } finally {
        _iterator9.f();
      }
      return predictions;
    }
    /**
     * Evaluate a semantic context within a specific parser context.
     *
     * This method might not be called for every semantic context evaluated
     * during the prediction process. In particular, we currently do not
     * evaluate the following but it may change in the future:
     *
     * * Precedence predicates (represented by
     *   {@link SemanticContext.PrecedencePredicate}) are not currently evaluated
     *   through this method.
     * * Operator predicates (represented by {@link SemanticContext.AND} and
     *   {@link SemanticContext.OR}) are evaluated as a single semantic
     *   context, rather than evaluating the operands individually.
     *   Implementations which require evaluation results from individual
     *   predicates should override this method to explicitly handle evaluation of
     *   the operands within operator predicates.
     *
     * @param pred The semantic context to evaluate
     * @param parserCallStack The parser context in which to evaluate the
     * semantic context
     * @param alt The alternative which is guarded by `pred`
     *
     * @since 4.3
     */
  }, {
    key: "evalSemanticContextImpl",
    value: function evalSemanticContextImpl(pred, parserCallStack, alt) {
      return pred.eval(this._parser, parserCallStack);
    }
    /* TODO: If we are doing predicates, there is no point in pursuing
         closure operations if we reach a DFA state that uniquely predicts
         alternative. We will not be caching that DFA state and it is a
         waste to pursue the closure. Might have to advance when we do
         ambig detection thought :(
          */
  }, {
    key: "closure",
    value: function closure(sourceConfigs, configs, collectPredicates, hasMoreContext, contextCache, treatEofAsEpsilon) {
      if (contextCache == null) {
        contextCache = PredictionContextCache_1.PredictionContextCache.UNCACHED;
      }
      var currentConfigs = sourceConfigs;
      var closureBusy = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
      while (currentConfigs.size > 0) {
        var intermediate = new ATNConfigSet_1.ATNConfigSet();
        var _iterator10 = _createForOfIteratorHelper(currentConfigs),
          _step10;
        try {
          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
            var config = _step10.value;
            this.closureImpl(config, configs, intermediate, closureBusy, collectPredicates, hasMoreContext, contextCache, 0, treatEofAsEpsilon);
          }
        } catch (err) {
          _iterator10.e(err);
        } finally {
          _iterator10.f();
        }
        currentConfigs = intermediate;
      }
    }
  }, {
    key: "closureImpl",
    value: function closureImpl(config, configs, intermediate, closureBusy, collectPredicates, hasMoreContexts, contextCache, depth, treatEofAsEpsilon) {
      if (ParserATNSimulator.debug) {
        console.log("closure(" + config.toString(this._parser, true) + ")");
      }
      if (config.state instanceof RuleStopState_1.RuleStopState) {
        // We hit rule end. If we have context info, use it
        if (!config.context.isEmpty) {
          var hasEmpty = config.context.hasEmpty;
          var nonEmptySize = config.context.size - (hasEmpty ? 1 : 0);
          for (var i = 0; i < nonEmptySize; i++) {
            var newContext = config.context.getParent(i); // "pop" return state
            var returnState = this.atn.states[config.context.getReturnState(i)];
            var c = ATNConfig_1.ATNConfig.create(returnState, config.alt, newContext, config.semanticContext);
            // While we have context to pop back from, we may have
            // gotten that context AFTER having fallen off a rule.
            // Make sure we track that we are now out of context.
            c.outerContextDepth = config.outerContextDepth;
            c.isPrecedenceFilterSuppressed = config.isPrecedenceFilterSuppressed;
            assert(depth > MIN_INTEGER_VALUE);
            this.closureImpl(c, configs, intermediate, closureBusy, collectPredicates, hasMoreContexts, contextCache, depth - 1, treatEofAsEpsilon);
          }
          if (!hasEmpty || !hasMoreContexts) {
            return;
          }
          config = config.transform(config.state, false, PredictionContext_1.PredictionContext.EMPTY_LOCAL);
        } else if (!hasMoreContexts) {
          configs.add(config, contextCache);
          return;
        } else {
          // else if we have no context info, just chase follow links (if greedy)
          if (ParserATNSimulator.debug) {
            console.log("FALLING off rule " + this.getRuleName(config.state.ruleIndex));
          }
          if (config.context === PredictionContext_1.PredictionContext.EMPTY_FULL) {
            // no need to keep full context overhead when we step out
            config = config.transform(config.state, false, PredictionContext_1.PredictionContext.EMPTY_LOCAL);
          } else if (!config.reachesIntoOuterContext && PredictionContext_1.PredictionContext.isEmptyLocal(config.context)) {
            // add stop state when leaving decision rule for the first time
            configs.add(config, contextCache);
          }
        }
      }
      var p = config.state;
      // optimization
      if (!p.onlyHasEpsilonTransitions) {
        configs.add(config, contextCache);
        // make sure to not return here, because EOF transitions can act as
        // both epsilon transitions and non-epsilon transitions.
        if (ParserATNSimulator.debug) {
          console.log("added config " + configs);
        }
      }
      for (var _i = 0; _i < p.numberOfOptimizedTransitions; _i++) {
        // This block implements first-edge elimination of ambiguous LR
        // alternatives as part of dynamic disambiguation during prediction.
        // See antlr/antlr4#1398.
        if (_i === 0 && p.stateType === ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY && p.precedenceRuleDecision && !config.context.hasEmpty) {
          var precedenceDecision = p;
          // When suppress is true, it means the outgoing edge i==0 is
          // ambiguous with the outgoing edge i==1, and thus the closure
          // operation can dynamically disambiguate by suppressing this
          // edge during the closure operation.
          var suppress = true;
          for (var j = 0; j < config.context.size; j++) {
            if (!precedenceDecision.precedenceLoopbackStates.get(config.context.getReturnState(j))) {
              suppress = false;
              break;
            }
          }
          if (suppress) {
            continue;
          }
        }
        var t = p.getOptimizedTransition(_i);
        var continueCollecting = !(t instanceof ActionTransition_1.ActionTransition) && collectPredicates;
        var _c2 = this.getEpsilonTarget(config, t, continueCollecting, depth === 0, contextCache, treatEofAsEpsilon);
        if (_c2 != null) {
          if (t instanceof RuleTransition_1.RuleTransition) {
            if (intermediate != null && !collectPredicates) {
              intermediate.add(_c2, contextCache);
              continue;
            }
          }
          var newDepth = depth;
          if (config.state instanceof RuleStopState_1.RuleStopState) {
            // target fell off end of rule; mark resulting c as having dipped into outer context
            // We can't get here if incoming config was rule stop and we had context
            // track how far we dip into outer context.  Might
            // come in handy and we avoid evaluating context dependent
            // preds if this is > 0.
            if (this.dfa != null && this.dfa.isPrecedenceDfa) {
              var outermostPrecedenceReturn = t.outermostPrecedenceReturn;
              if (outermostPrecedenceReturn === this.dfa.atnStartState.ruleIndex) {
                _c2.isPrecedenceFilterSuppressed = true;
              }
            }
            _c2.outerContextDepth = _c2.outerContextDepth + 1;
            if (!closureBusy.add(_c2)) {
              // avoid infinite recursion for right-recursive rules
              continue;
            }
            assert(newDepth > MIN_INTEGER_VALUE);
            newDepth--;
            if (ParserATNSimulator.debug) {
              console.log("dips into outer ctx: " + _c2);
            }
          } else if (t instanceof RuleTransition_1.RuleTransition) {
            if (this.optimize_tail_calls && t.optimizedTailCall && (!this.tail_call_preserves_sll || !PredictionContext_1.PredictionContext.isEmptyLocal(config.context))) {
              assert(_c2.context === config.context);
              if (newDepth === 0) {
                // the pop/push of a tail call would keep the depth
                // constant, except we latch if it goes negative
                newDepth--;
                if (!this.tail_call_preserves_sll && PredictionContext_1.PredictionContext.isEmptyLocal(config.context)) {
                  // make sure the SLL config "dips into the outer context" or prediction may not fall back to LL on conflict
                  _c2.outerContextDepth = _c2.outerContextDepth + 1;
                }
              }
            } else {
              // latch when newDepth goes negative - once we step out of the entry context we can't return
              if (newDepth >= 0) {
                newDepth++;
              }
            }
          } else {
            if (!t.isEpsilon && !closureBusy.add(_c2)) {
              // avoid infinite recursion for EOF* and EOF+
              continue;
            }
          }
          this.closureImpl(_c2, configs, intermediate, closureBusy, continueCollecting, hasMoreContexts, contextCache, newDepth, treatEofAsEpsilon);
        }
      }
    }
  }, {
    key: "getRuleName",
    value: function getRuleName(index) {
      if (this._parser != null && index >= 0) {
        return this._parser.ruleNames[index];
      }
      return "<rule " + index + ">";
    }
  }, {
    key: "getEpsilonTarget",
    value: function getEpsilonTarget(config, t, collectPredicates, inContext, contextCache, treatEofAsEpsilon) {
      switch (t.serializationType) {
        case 3 /* RULE */:
          return this.ruleTransition(config, t, contextCache);
        case 10 /* PRECEDENCE */:
          return this.precedenceTransition(config, t, collectPredicates, inContext);
        case 4 /* PREDICATE */:
          return this.predTransition(config, t, collectPredicates, inContext);
        case 6 /* ACTION */:
          return this.actionTransition(config, t);
        case 1 /* EPSILON */:
          return config.transform(t.target, false);
        case 5 /* ATOM */:
        case 2 /* RANGE */:
        case 7 /* SET */:
          // EOF transitions act like epsilon transitions after the first EOF
          // transition is traversed
          if (treatEofAsEpsilon) {
            if (t.matches(Token_1.Token.EOF, 0, 1)) {
              return config.transform(t.target, false);
            }
          }
          return undefined;
        default:
          return undefined;
      }
    }
  }, {
    key: "actionTransition",
    value: function actionTransition(config, t) {
      if (ParserATNSimulator.debug) {
        console.log("ACTION edge " + t.ruleIndex + ":" + t.actionIndex);
      }
      return config.transform(t.target, false);
    }
  }, {
    key: "precedenceTransition",
    value: function precedenceTransition(config, pt, collectPredicates, inContext) {
      if (ParserATNSimulator.debug) {
        console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.precedence + ">=_p" + ", ctx dependent=true");
        if (this._parser != null) {
          console.log("context surrounding pred is " + this._parser.getRuleInvocationStack());
        }
      }
      var c;
      if (collectPredicates && inContext) {
        var newSemCtx = SemanticContext_1.SemanticContext.and(config.semanticContext, pt.predicate);
        c = config.transform(pt.target, false, newSemCtx);
      } else {
        c = config.transform(pt.target, false);
      }
      if (ParserATNSimulator.debug) {
        console.log("config from pred transition=" + c);
      }
      return c;
    }
  }, {
    key: "predTransition",
    value: function predTransition(config, pt, collectPredicates, inContext) {
      if (ParserATNSimulator.debug) {
        console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.ruleIndex + ":" + pt.predIndex + ", ctx dependent=" + pt.isCtxDependent);
        if (this._parser != null) {
          console.log("context surrounding pred is " + this._parser.getRuleInvocationStack());
        }
      }
      var c;
      if (collectPredicates && (!pt.isCtxDependent || pt.isCtxDependent && inContext)) {
        var newSemCtx = SemanticContext_1.SemanticContext.and(config.semanticContext, pt.predicate);
        c = config.transform(pt.target, false, newSemCtx);
      } else {
        c = config.transform(pt.target, false);
      }
      if (ParserATNSimulator.debug) {
        console.log("config from pred transition=" + c);
      }
      return c;
    }
  }, {
    key: "ruleTransition",
    value: function ruleTransition(config, t, contextCache) {
      if (ParserATNSimulator.debug) {
        console.log("CALL rule " + this.getRuleName(t.target.ruleIndex) + ", ctx=" + config.context);
      }
      var returnState = t.followState;
      var newContext;
      if (this.optimize_tail_calls && t.optimizedTailCall && (!this.tail_call_preserves_sll || !PredictionContext_1.PredictionContext.isEmptyLocal(config.context))) {
        newContext = config.context;
      } else if (contextCache != null) {
        newContext = contextCache.getChild(config.context, returnState.stateNumber);
      } else {
        newContext = config.context.getChild(returnState.stateNumber);
      }
      return config.transform(t.target, false, newContext);
    }
  }, {
    key: "isConflicted",
    value: function isConflicted(configset, contextCache) {
      if (configset.uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER || configset.size <= 1) {
        return undefined;
      }
      var configs = configset.toArray();
      configs.sort(ParserATNSimulator.STATE_ALT_SORT_COMPARATOR);
      var exact = !configset.dipsIntoOuterContext;
      var alts = new BitSet_1.BitSet();
      var minAlt = configs[0].alt;
      alts.set(minAlt);
      /* Quick checks come first (single pass, no context joining):
       *  1. Make sure first config in the sorted list predicts the minimum
       *     represented alternative.
       *  2. Make sure every represented state has at least one configuration
       *     which predicts the minimum represented alternative.
       *  3. (exact only) make sure every represented state has at least one
       *     configuration which predicts each represented alternative.
       */
      // quick check 1 & 2 => if we assume #1 holds and check #2 against the
      // minAlt from the first state, #2 will fail if the assumption was
      // incorrect
      var currentState = configs[0].state.nonStopStateNumber;
      var _iterator11 = _createForOfIteratorHelper(configs),
        _step11;
      try {
        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
          var _config7 = _step11.value;
          var _stateNumber = _config7.state.nonStopStateNumber;
          if (_stateNumber !== currentState) {
            if (_config7.alt !== minAlt) {
              return undefined;
            }
            currentState = _stateNumber;
          }
        }
      } catch (err) {
        _iterator11.e(err);
      } finally {
        _iterator11.f();
      }
      var representedAlts;
      if (exact) {
        currentState = configs[0].state.nonStopStateNumber;
        // get the represented alternatives of the first state
        representedAlts = new BitSet_1.BitSet();
        var maxAlt = minAlt;
        var _iterator12 = _createForOfIteratorHelper(configs),
          _step12;
        try {
          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
            var config = _step12.value;
            if (config.state.nonStopStateNumber !== currentState) {
              break;
            }
            var alt = config.alt;
            representedAlts.set(alt);
            maxAlt = alt;
          }
          // quick check #3:
        } catch (err) {
          _iterator12.e(err);
        } finally {
          _iterator12.f();
        }
        currentState = configs[0].state.nonStopStateNumber;
        var currentAlt = minAlt;
        var _iterator13 = _createForOfIteratorHelper(configs),
          _step13;
        try {
          for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
            var _config3 = _step13.value;
            var stateNumber = _config3.state.nonStopStateNumber;
            var _alt2 = _config3.alt;
            if (stateNumber !== currentState) {
              if (currentAlt !== maxAlt) {
                exact = false;
                break;
              }
              currentState = stateNumber;
              currentAlt = minAlt;
            } else if (_alt2 !== currentAlt) {
              if (_alt2 !== representedAlts.nextSetBit(currentAlt + 1)) {
                exact = false;
                break;
              }
              currentAlt = _alt2;
            }
          }
        } catch (err) {
          _iterator13.e(err);
        } finally {
          _iterator13.f();
        }
      }
      currentState = configs[0].state.nonStopStateNumber;
      var firstIndexCurrentState = 0;
      var lastIndexCurrentStateMinAlt = 0;
      var joinedCheckContext = configs[0].context;
      for (var i = 1; i < configs.length; i++) {
        var _config4 = configs[i];
        if (_config4.alt !== minAlt) {
          break;
        }
        if (_config4.state.nonStopStateNumber !== currentState) {
          break;
        }
        lastIndexCurrentStateMinAlt = i;
        joinedCheckContext = contextCache.join(joinedCheckContext, configs[i].context);
      }
      for (var _i2 = lastIndexCurrentStateMinAlt + 1; _i2 < configs.length; _i2++) {
        var _config5 = configs[_i2];
        var state = _config5.state;
        alts.set(_config5.alt);
        if (state.nonStopStateNumber !== currentState) {
          currentState = state.nonStopStateNumber;
          firstIndexCurrentState = _i2;
          lastIndexCurrentStateMinAlt = _i2;
          joinedCheckContext = _config5.context;
          for (var j = firstIndexCurrentState + 1; j < configs.length; j++) {
            var config2 = configs[j];
            if (config2.alt !== minAlt) {
              break;
            }
            if (config2.state.nonStopStateNumber !== currentState) {
              break;
            }
            lastIndexCurrentStateMinAlt = j;
            joinedCheckContext = contextCache.join(joinedCheckContext, config2.context);
          }
          _i2 = lastIndexCurrentStateMinAlt;
          continue;
        }
        var joinedCheckContext2 = _config5.context;
        var _currentAlt = _config5.alt;
        var lastIndexCurrentStateCurrentAlt = _i2;
        for (var _j = lastIndexCurrentStateCurrentAlt + 1; _j < configs.length; _j++) {
          var _config6 = configs[_j];
          if (_config6.alt !== _currentAlt) {
            break;
          }
          if (_config6.state.nonStopStateNumber !== currentState) {
            break;
          }
          lastIndexCurrentStateCurrentAlt = _j;
          joinedCheckContext2 = contextCache.join(joinedCheckContext2, _config6.context);
        }
        _i2 = lastIndexCurrentStateCurrentAlt;
        var check = contextCache.join(joinedCheckContext, joinedCheckContext2);
        if (!joinedCheckContext.equals(check)) {
          return undefined;
        }
        // update exact if necessary
        exact = exact && joinedCheckContext.equals(joinedCheckContext2);
      }
      return new ConflictInfo_1.ConflictInfo(alts, exact);
    }
  }, {
    key: "getConflictingAltsFromConfigSet",
    value: function getConflictingAltsFromConfigSet(configs) {
      var conflictingAlts = configs.conflictingAlts;
      if (conflictingAlts == null && configs.uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
        conflictingAlts = new BitSet_1.BitSet();
        conflictingAlts.set(configs.uniqueAlt);
      }
      return conflictingAlts;
    }
  }, {
    key: "getTokenName",
    value: function getTokenName(t) {
      if (t === Token_1.Token.EOF) {
        return "EOF";
      }
      var vocabulary = this._parser != null ? this._parser.vocabulary : VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY;
      var displayName = vocabulary.getDisplayName(t);
      if (displayName === String(t)) {
        return displayName;
      }
      return displayName + "<" + t + ">";
    }
  }, {
    key: "getLookaheadName",
    value: function getLookaheadName(input) {
      return this.getTokenName(input.LA(1));
    }
  }, {
    key: "dumpDeadEndConfigs",
    value: function dumpDeadEndConfigs(nvae) {
      console.log("dead end configs: ");
      var deadEndConfigs = nvae.deadEndConfigs;
      if (!deadEndConfigs) {
        return;
      }
      var _iterator14 = _createForOfIteratorHelper(deadEndConfigs),
        _step14;
      try {
        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
          var c = _step14.value;
          var trans = "no edges";
          if (c.state.numberOfOptimizedTransitions > 0) {
            var t = c.state.getOptimizedTransition(0);
            if (t instanceof AtomTransition_1.AtomTransition) {
              trans = "Atom " + this.getTokenName(t._label);
            } else if (t instanceof SetTransition_1.SetTransition) {
              var not = t instanceof NotSetTransition_1.NotSetTransition;
              trans = (not ? "~" : "") + "Set " + t.set.toString();
            }
          }
          console.log(c.toString(this._parser, true) + ":" + trans);
        }
      } catch (err) {
        _iterator14.e(err);
      } finally {
        _iterator14.f();
      }
    }
  }, {
    key: "noViableAlt",
    value: function noViableAlt(input, outerContext, configs, startIndex) {
      return new NoViableAltException_1.NoViableAltException(this._parser, input, input.get(startIndex), input.LT(1), configs, outerContext);
    }
  }, {
    key: "getUniqueAlt",
    value: function getUniqueAlt(configs) {
      var alt = ATN_1.ATN.INVALID_ALT_NUMBER;
      var _iterator15 = _createForOfIteratorHelper(configs),
        _step15;
      try {
        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
          var c = _step15.value;
          if (alt === ATN_1.ATN.INVALID_ALT_NUMBER) {
            alt = c.alt; // found first alt
          } else if (c.alt !== alt) {
            return ATN_1.ATN.INVALID_ALT_NUMBER;
          }
        }
      } catch (err) {
        _iterator15.e(err);
      } finally {
        _iterator15.f();
      }
      return alt;
    }
  }, {
    key: "configWithAltAtStopState",
    value: function configWithAltAtStopState(configs, alt) {
      var _iterator16 = _createForOfIteratorHelper(configs),
        _step16;
      try {
        for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
          var c = _step16.value;
          if (c.alt === alt) {
            if (c.state instanceof RuleStopState_1.RuleStopState) {
              return true;
            }
          }
        }
      } catch (err) {
        _iterator16.e(err);
      } finally {
        _iterator16.f();
      }
      return false;
    }
  }, {
    key: "addDFAEdge",
    value: function addDFAEdge(dfa, fromState, t, contextTransitions, toConfigs, contextCache) {
      assert(contextTransitions == null || contextTransitions.isEmpty || dfa.isContextSensitive);
      var from = fromState;
      var to = this.addDFAState(dfa, toConfigs, contextCache);
      if (contextTransitions != null) {
        var _iterator17 = _createForOfIteratorHelper(contextTransitions.toArray()),
          _step17;
        try {
          for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
            var context = _step17.value;
            if (context === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
              if (from.configs.isOutermostConfigSet) {
                continue;
              }
            }
            from.setContextSensitive(this.atn);
            from.setContextSymbol(t);
            var next = from.getContextTarget(context);
            if (next != null) {
              from = next;
              continue;
            }
            next = this.addDFAContextState(dfa, from.configs, context, contextCache);
            assert(context !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY || next.configs.isOutermostConfigSet);
            from.setContextTarget(context, next);
            from = next;
          }
        } catch (err) {
          _iterator17.e(err);
        } finally {
          _iterator17.f();
        }
      }
      if (ParserATNSimulator.debug) {
        console.log("EDGE " + from + " -> " + to + " upon " + this.getTokenName(t));
      }
      this.setDFAEdge(from, t, to);
      if (ParserATNSimulator.debug) {
        console.log("DFA=\n" + dfa.toString(this._parser != null ? this._parser.vocabulary : VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY, this._parser != null ? this._parser.ruleNames : undefined));
      }
      return to;
    }
  }, {
    key: "setDFAEdge",
    value: function setDFAEdge(p, t, q) {
      if (p != null) {
        p.setTarget(t, q);
      }
    }
    /** See comment on LexerInterpreter.addDFAState. */
  }, {
    key: "addDFAContextState",
    value: function addDFAContextState(dfa, configs, returnContext, contextCache) {
      if (returnContext !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
        var contextConfigs = new ATNConfigSet_1.ATNConfigSet();
        var _iterator18 = _createForOfIteratorHelper(configs),
          _step18;
        try {
          for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
            var config = _step18.value;
            contextConfigs.add(config.appendContext(returnContext, contextCache));
          }
        } catch (err) {
          _iterator18.e(err);
        } finally {
          _iterator18.f();
        }
        return this.addDFAState(dfa, contextConfigs, contextCache);
      } else {
        assert(!configs.isOutermostConfigSet, "Shouldn't be adding a duplicate edge.");
        configs = configs.clone(true);
        configs.isOutermostConfigSet = true;
        return this.addDFAState(dfa, configs, contextCache);
      }
    }
    /** See comment on LexerInterpreter.addDFAState. */
  }, {
    key: "addDFAState",
    value: function addDFAState(dfa, configs, contextCache) {
      var enableDfa = this.enable_global_context_dfa || !configs.isOutermostConfigSet;
      if (enableDfa) {
        if (!configs.isReadOnly) {
          configs.optimizeConfigs(this);
        }
        var proposed = this.createDFAState(dfa, configs);
        var existing = dfa.states.get(proposed);
        if (existing != null) {
          return existing;
        }
      }
      if (!configs.isReadOnly) {
        if (configs.conflictInfo == null) {
          configs.conflictInfo = this.isConflicted(configs, contextCache);
        }
      }
      var newState = this.createDFAState(dfa, configs.clone(true));
      // getDecisionState won't return undefined when we request a known valid decision
      var decisionState = this.atn.getDecisionState(dfa.decision);
      var predictedAlt = this.getUniqueAlt(configs);
      if (predictedAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
        newState.acceptStateInfo = new AcceptStateInfo_1.AcceptStateInfo(predictedAlt);
      } else if (configs.conflictingAlts != null) {
        var conflictingAlts = configs.conflictingAlts;
        if (conflictingAlts) {
          newState.acceptStateInfo = new AcceptStateInfo_1.AcceptStateInfo(conflictingAlts.nextSetBit(0));
        }
      }
      if (newState.isAcceptState && configs.hasSemanticContext) {
        this.predicateDFAState(newState, configs, decisionState.numberOfTransitions);
      }
      if (!enableDfa) {
        return newState;
      }
      var added = dfa.addState(newState);
      if (ParserATNSimulator.debug && added === newState) {
        console.log("adding new DFA state: " + newState);
      }
      return added;
    }
  }, {
    key: "createDFAState",
    value: function createDFAState(dfa, configs) {
      return new DFAState_1.DFAState(configs);
    }
  }, {
    key: "reportAttemptingFullContext",
    value: function reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex) {
      if (ParserATNSimulator.debug || ParserATNSimulator.retry_debug) {
        var interval = Interval_1.Interval.of(startIndex, stopIndex);
        console.log("reportAttemptingFullContext decision=" + dfa.decision + ":" + conflictState.s0.configs + ", input=" + this._parser.inputStream.getText(interval));
      }
      if (this._parser != null) {
        var listener = this._parser.getErrorListenerDispatch();
        if (listener.reportAttemptingFullContext) {
          listener.reportAttemptingFullContext(this._parser, dfa, startIndex, stopIndex, conflictingAlts, conflictState);
        }
      }
    }
  }, {
    key: "reportContextSensitivity",
    value: function reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex) {
      if (ParserATNSimulator.debug || ParserATNSimulator.retry_debug) {
        var interval = Interval_1.Interval.of(startIndex, stopIndex);
        console.log("reportContextSensitivity decision=" + dfa.decision + ":" + acceptState.s0.configs + ", input=" + this._parser.inputStream.getText(interval));
      }
      if (this._parser != null) {
        var listener = this._parser.getErrorListenerDispatch();
        if (listener.reportContextSensitivity) {
          listener.reportContextSensitivity(this._parser, dfa, startIndex, stopIndex, prediction, acceptState);
        }
      }
    }
    /** If context sensitive parsing, we know it's ambiguity not conflict */
  }, {
    key: "reportAmbiguity",
    value: function reportAmbiguity(dfa, D,
    // the DFA state from execATN(): void that had SLL conflicts
    startIndex, stopIndex, exact, ambigAlts, configs) {
      if (ParserATNSimulator.debug || ParserATNSimulator.retry_debug) {
        var interval = Interval_1.Interval.of(startIndex, stopIndex);
        console.log("reportAmbiguity " + ambigAlts + ":" + configs + ", input=" + this._parser.inputStream.getText(interval));
      }
      if (this._parser != null) {
        var listener = this._parser.getErrorListenerDispatch();
        if (listener.reportAmbiguity) {
          listener.reportAmbiguity(this._parser, dfa, startIndex, stopIndex, exact, ambigAlts, configs);
        }
      }
    }
  }, {
    key: "getReturnState",
    value: function getReturnState(context) {
      if (context.isEmpty) {
        return PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
      }
      var state = this.atn.states[context.invokingState];
      var transition = state.transition(0);
      return transition.followState.stateNumber;
    }
  }, {
    key: "skipTailCalls",
    value: function skipTailCalls(context) {
      if (!this.optimize_tail_calls) {
        return context;
      }
      while (!context.isEmpty) {
        var state = this.atn.states[context.invokingState];
        assert(state.numberOfTransitions === 1 && state.transition(0).serializationType === 3 /* RULE */);
        var transition = state.transition(0);
        if (!transition.tailCall) {
          break;
        }
        // This method requires that the root ancestor of the ParserRuleContext be empty. If we make it to this
        // line, we know the current node is not empty, which means it does have a parent.
        context = context.parent;
      }
      return context;
    }
    /**
     * @since 4.3
     */
  }, {
    key: "parser",
    get: function get() {
      return this._parser;
    }
  }]);
  return ParserATNSimulator;
}(ATNSimulator_1.ATNSimulator);
ParserATNSimulator.debug = false;
ParserATNSimulator.dfa_debug = false;
ParserATNSimulator.retry_debug = false;
ParserATNSimulator.STATE_ALT_SORT_COMPARATOR = function (o1, o2) {
  var diff = o1.state.nonStopStateNumber - o2.state.nonStopStateNumber;
  if (diff !== 0) {
    return diff;
  }
  diff = o1.alt - o2.alt;
  if (diff !== 0) {
    return diff;
  }
  return 0;
};
__decorate([Decorators_1.NotNull], ParserATNSimulator.prototype, "predictionMode", void 0);
__decorate([Decorators_1.NotNull], ParserATNSimulator.prototype, "getPredictionMode", null);
__decorate([__param(0, Decorators_1.NotNull)], ParserATNSimulator.prototype, "setPredictionMode", null);
__decorate([Decorators_1.Override], ParserATNSimulator.prototype, "reset", null);
__decorate([__param(0, Decorators_1.NotNull)], ParserATNSimulator.prototype, "adaptivePredict", null);
__decorate([__param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull), __param(2, Decorators_1.NotNull)], ParserATNSimulator.prototype, "getStartState", null);
__decorate([__param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull), __param(3, Decorators_1.NotNull)], ParserATNSimulator.prototype, "execDFA", null);
__decorate([__param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull), __param(3, Decorators_1.NotNull)], ParserATNSimulator.prototype, "execATN", null);
__decorate([__param(0, Decorators_1.NotNull), __param(2, Decorators_1.NotNull)], ParserATNSimulator.prototype, "handleNoViableAlt", null);
__decorate([__param(0, Decorators_1.NotNull)], ParserATNSimulator.prototype, "getExistingTargetState", null);
__decorate([Decorators_1.NotNull, __param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)], ParserATNSimulator.prototype, "computeTargetState", null);
__decorate([Decorators_1.NotNull, __param(0, Decorators_1.NotNull)], ParserATNSimulator.prototype, "removeAllConfigsNotInRuleStopState", null);
__decorate([Decorators_1.NotNull], ParserATNSimulator.prototype, "computeStartState", null);
__decorate([Decorators_1.NotNull, __param(0, Decorators_1.NotNull)], ParserATNSimulator.prototype, "applyPrecedenceFilter", null);
__decorate([__param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)], ParserATNSimulator.prototype, "getReachableTarget", null);
__decorate([__param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)], ParserATNSimulator.prototype, "getPredsForAmbigAlts", null);
__decorate([__param(0, Decorators_1.NotNull)], ParserATNSimulator.prototype, "evalSemanticContext", null);
__decorate([__param(0, Decorators_1.NotNull)], ParserATNSimulator.prototype, "evalSemanticContextImpl", null);
__decorate([__param(1, Decorators_1.NotNull), __param(4, Decorators_1.Nullable)], ParserATNSimulator.prototype, "closure", null);
__decorate([__param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull), __param(2, Decorators_1.Nullable), __param(3, Decorators_1.NotNull), __param(6, Decorators_1.NotNull)], ParserATNSimulator.prototype, "closureImpl", null);
__decorate([Decorators_1.NotNull], ParserATNSimulator.prototype, "getRuleName", null);
__decorate([__param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)], ParserATNSimulator.prototype, "getEpsilonTarget", null);
__decorate([Decorators_1.NotNull, __param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)], ParserATNSimulator.prototype, "actionTransition", null);
__decorate([Decorators_1.Nullable, __param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)], ParserATNSimulator.prototype, "precedenceTransition", null);
__decorate([Decorators_1.Nullable, __param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)], ParserATNSimulator.prototype, "predTransition", null);
__decorate([Decorators_1.NotNull, __param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull), __param(2, Decorators_1.Nullable)], ParserATNSimulator.prototype, "ruleTransition", null);
__decorate([__param(0, Decorators_1.NotNull)], ParserATNSimulator.prototype, "isConflicted", null);
__decorate([Decorators_1.NotNull], ParserATNSimulator.prototype, "getTokenName", null);
__decorate([__param(0, Decorators_1.NotNull)], ParserATNSimulator.prototype, "dumpDeadEndConfigs", null);
__decorate([Decorators_1.NotNull, __param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull), __param(2, Decorators_1.NotNull)], ParserATNSimulator.prototype, "noViableAlt", null);
__decorate([__param(0, Decorators_1.NotNull)], ParserATNSimulator.prototype, "getUniqueAlt", null);
__decorate([__param(0, Decorators_1.NotNull)], ParserATNSimulator.prototype, "configWithAltAtStopState", null);
__decorate([Decorators_1.NotNull, __param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull), __param(4, Decorators_1.NotNull)], ParserATNSimulator.prototype, "addDFAEdge", null);
__decorate([__param(0, Decorators_1.Nullable), __param(2, Decorators_1.Nullable)], ParserATNSimulator.prototype, "setDFAEdge", null);
__decorate([Decorators_1.NotNull, __param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)], ParserATNSimulator.prototype, "addDFAContextState", null);
__decorate([Decorators_1.NotNull, __param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)], ParserATNSimulator.prototype, "addDFAState", null);
__decorate([Decorators_1.NotNull, __param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)], ParserATNSimulator.prototype, "createDFAState", null);
__decorate([__param(0, Decorators_1.NotNull), __param(2, Decorators_1.NotNull)], ParserATNSimulator.prototype, "reportAttemptingFullContext", null);
__decorate([__param(0, Decorators_1.NotNull), __param(2, Decorators_1.NotNull)], ParserATNSimulator.prototype, "reportContextSensitivity", null);
__decorate([__param(0, Decorators_1.NotNull), __param(5, Decorators_1.NotNull), __param(6, Decorators_1.NotNull)], ParserATNSimulator.prototype, "reportAmbiguity", null);
ParserATNSimulator = __decorate([__param(0, Decorators_1.NotNull)], ParserATNSimulator);
exports.ParserATNSimulator = ParserATNSimulator;

},{"../Decorators":272,"../IntStream":278,"../NoViableAltException":284,"../ParserRuleContext":287,"../Token":296,"../VocabularyImpl":298,"../dfa/AcceptStateInfo":363,"../dfa/DFAState":366,"../misc/Array2DHashSet":370,"../misc/Arrays":372,"../misc/BitSet":373,"../misc/IntegerList":376,"../misc/Interval":378,"../misc/ObjectEqualityComparator":382,"./ATN":299,"./ATNConfig":300,"./ATNConfigSet":301,"./ATNSimulator":304,"./ATNStateType":306,"./ActionTransition":308,"./AtomTransition":310,"./ConflictInfo":315,"./DecisionState":319,"./NotSetTransition":337,"./PredictionContext":346,"./PredictionContextCache":347,"./PredictionMode":348,"./RuleStopState":352,"./RuleTransition":353,"./SemanticContext":354,"./SetTransition":355,"./SimulatorState":356,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"assert":413,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.join.js":578,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.array.sort.js":581,"core-js/modules/es.function.name.js":584,"core-js/modules/es.map.js":587,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.promise.js":614,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],341:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:34.9572142-07:00
var ATNStateType_1 = require("./ATNStateType");
var BlockStartState_1 = require("./BlockStartState");
var Decorators_1 = require("../Decorators");
/** Start of `(A|B|...)+` loop. Technically a decision state, but
 *  we don't use for code generation; somebody might need it, so I'm defining
 *  it for completeness. In reality, the {@link PlusLoopbackState} node is the
 *  real decision-making note for `A+`.
 */
var PlusBlockStartState = /*#__PURE__*/function (_BlockStartState_1$Bl) {
  (0, _inherits2.default)(PlusBlockStartState, _BlockStartState_1$Bl);
  var _super = _createSuper(PlusBlockStartState);
  function PlusBlockStartState() {
    (0, _classCallCheck2.default)(this, PlusBlockStartState);
    return _super.apply(this, arguments);
  }
  (0, _createClass2.default)(PlusBlockStartState, [{
    key: "stateType",
    get: function get() {
      return ATNStateType_1.ATNStateType.PLUS_BLOCK_START;
    }
  }]);
  return PlusBlockStartState;
}(BlockStartState_1.BlockStartState);
__decorate([Decorators_1.Override], PlusBlockStartState.prototype, "stateType", null);
exports.PlusBlockStartState = PlusBlockStartState;

},{"../Decorators":272,"./ATNStateType":306,"./BlockStartState":314,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],342:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:35.0257730-07:00
var ATNStateType_1 = require("./ATNStateType");
var DecisionState_1 = require("./DecisionState");
var Decorators_1 = require("../Decorators");
/** Decision state for `A+` and `(A|B)+`.  It has two transitions:
 *  one to the loop back to start of the block and one to exit.
 */
var PlusLoopbackState = /*#__PURE__*/function (_DecisionState_1$Deci) {
  (0, _inherits2.default)(PlusLoopbackState, _DecisionState_1$Deci);
  var _super = _createSuper(PlusLoopbackState);
  function PlusLoopbackState() {
    (0, _classCallCheck2.default)(this, PlusLoopbackState);
    return _super.apply(this, arguments);
  }
  (0, _createClass2.default)(PlusLoopbackState, [{
    key: "stateType",
    get: function get() {
      return ATNStateType_1.ATNStateType.PLUS_LOOP_BACK;
    }
  }]);
  return PlusLoopbackState;
}(DecisionState_1.DecisionState);
__decorate([Decorators_1.Override], PlusLoopbackState.prototype, "stateType", null);
exports.PlusLoopbackState = PlusLoopbackState;

},{"../Decorators":272,"./ATNStateType":306,"./DecisionState":319,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],343:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:35.0994191-07:00
var AbstractPredicateTransition_1 = require("./AbstractPredicateTransition");
var Decorators_1 = require("../Decorators");
var SemanticContext_1 = require("./SemanticContext");
/**
 *
 * @author Sam Harwell
 */
var PrecedencePredicateTransition = /*#__PURE__*/function (_AbstractPredicateTra) {
  (0, _inherits2.default)(PrecedencePredicateTransition, _AbstractPredicateTra);
  var _super = _createSuper(PrecedencePredicateTransition);
  function PrecedencePredicateTransition(target, precedence) {
    var _this;
    (0, _classCallCheck2.default)(this, PrecedencePredicateTransition);
    _this = _super.call(this, target);
    _this.precedence = precedence;
    return _this;
  }
  (0, _createClass2.default)(PrecedencePredicateTransition, [{
    key: "serializationType",
    get: function get() {
      return 10 /* PRECEDENCE */;
    }
  }, {
    key: "isEpsilon",
    get: function get() {
      return true;
    }
  }, {
    key: "matches",
    value: function matches(symbol, minVocabSymbol, maxVocabSymbol) {
      return false;
    }
  }, {
    key: "predicate",
    get: function get() {
      return new SemanticContext_1.SemanticContext.PrecedencePredicate(this.precedence);
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.precedence + " >= _p";
    }
  }]);
  return PrecedencePredicateTransition;
}(AbstractPredicateTransition_1.AbstractPredicateTransition);
__decorate([Decorators_1.Override], PrecedencePredicateTransition.prototype, "serializationType", null);
__decorate([Decorators_1.Override], PrecedencePredicateTransition.prototype, "isEpsilon", null);
__decorate([Decorators_1.Override], PrecedencePredicateTransition.prototype, "matches", null);
__decorate([Decorators_1.Override], PrecedencePredicateTransition.prototype, "toString", null);
PrecedencePredicateTransition = __decorate([__param(0, Decorators_1.NotNull)], PrecedencePredicateTransition);
exports.PrecedencePredicateTransition = PrecedencePredicateTransition;

},{"../Decorators":272,"./AbstractPredicateTransition":307,"./SemanticContext":354,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],344:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:35.1914305-07:00
var DecisionEventInfo_1 = require("./DecisionEventInfo");
var Decorators_1 = require("../Decorators");
/**
 * This class represents profiling event information for semantic predicate
 * evaluations which occur during prediction.
 *
 * @see ParserATNSimulator#evalSemanticContext
 *
 * @since 4.3
 */
var PredicateEvalInfo = /*#__PURE__*/function (_DecisionEventInfo_1$) {
  (0, _inherits2.default)(PredicateEvalInfo, _DecisionEventInfo_1$);
  var _super = _createSuper(PredicateEvalInfo);
  /**
   * Constructs a new instance of the {@link PredicateEvalInfo} class with the
   * specified detailed predicate evaluation information.
   *
   * @param state The simulator state
   * @param decision The decision number
   * @param input The input token stream
   * @param startIndex The start index for the current prediction
   * @param stopIndex The index at which the predicate evaluation was
   * triggered. Note that the input stream may be reset to other positions for
   * the actual evaluation of individual predicates.
   * @param semctx The semantic context which was evaluated
   * @param evalResult The results of evaluating the semantic context
   * @param predictedAlt The alternative number for the decision which is
   * guarded by the semantic context `semctx`. See {@link #predictedAlt}
   * for more information.
   *
   * @see ParserATNSimulator#evalSemanticContext(SemanticContext, ParserRuleContext, int)
   * @see SemanticContext#eval(Recognizer, RuleContext)
   */
  function PredicateEvalInfo(state, decision, input, startIndex, stopIndex, semctx, evalResult, predictedAlt) {
    var _this;
    (0, _classCallCheck2.default)(this, PredicateEvalInfo);
    _this = _super.call(this, decision, state, input, startIndex, stopIndex, state.useContext);
    _this.semctx = semctx;
    _this.evalResult = evalResult;
    _this.predictedAlt = predictedAlt;
    return _this;
  }
  return (0, _createClass2.default)(PredicateEvalInfo);
}(DecisionEventInfo_1.DecisionEventInfo);
PredicateEvalInfo = __decorate([__param(0, Decorators_1.NotNull), __param(2, Decorators_1.NotNull), __param(5, Decorators_1.NotNull)], PredicateEvalInfo);
exports.PredicateEvalInfo = PredicateEvalInfo;

},{"../Decorators":272,"./DecisionEventInfo":317,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],345:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:35.2826960-07:00
var AbstractPredicateTransition_1 = require("./AbstractPredicateTransition");
var Decorators_1 = require("../Decorators");
var SemanticContext_1 = require("./SemanticContext");
/** TODO: this is old comment:
 *  A tree of semantic predicates from the grammar AST if label==SEMPRED.
 *  In the ATN, labels will always be exactly one predicate, but the DFA
 *  may have to combine a bunch of them as it collects predicates from
 *  multiple ATN configurations into a single DFA state.
 */
var PredicateTransition = /*#__PURE__*/function (_AbstractPredicateTra) {
  (0, _inherits2.default)(PredicateTransition, _AbstractPredicateTra);
  var _super = _createSuper(PredicateTransition);
  function PredicateTransition(target, ruleIndex, predIndex, isCtxDependent) {
    var _this;
    (0, _classCallCheck2.default)(this, PredicateTransition);
    _this = _super.call(this, target);
    _this.ruleIndex = ruleIndex;
    _this.predIndex = predIndex;
    _this.isCtxDependent = isCtxDependent;
    return _this;
  }
  (0, _createClass2.default)(PredicateTransition, [{
    key: "serializationType",
    get: function get() {
      return 4 /* PREDICATE */;
    }
  }, {
    key: "isEpsilon",
    get: function get() {
      return true;
    }
  }, {
    key: "matches",
    value: function matches(symbol, minVocabSymbol, maxVocabSymbol) {
      return false;
    }
  }, {
    key: "predicate",
    get: function get() {
      return new SemanticContext_1.SemanticContext.Predicate(this.ruleIndex, this.predIndex, this.isCtxDependent);
    }
  }, {
    key: "toString",
    value: function toString() {
      return "pred_" + this.ruleIndex + ":" + this.predIndex;
    }
  }]);
  return PredicateTransition;
}(AbstractPredicateTransition_1.AbstractPredicateTransition);
__decorate([Decorators_1.Override], PredicateTransition.prototype, "serializationType", null);
__decorate([Decorators_1.Override], PredicateTransition.prototype, "isEpsilon", null);
__decorate([Decorators_1.Override], PredicateTransition.prototype, "matches", null);
__decorate([Decorators_1.Override, Decorators_1.NotNull], PredicateTransition.prototype, "toString", null);
PredicateTransition = __decorate([__param(0, Decorators_1.NotNull)], PredicateTransition);
exports.PredicateTransition = PredicateTransition;

},{"../Decorators":272,"./AbstractPredicateTransition":307,"./SemanticContext":354,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],346:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.array.join.js");
require("core-js/modules/es.array.slice.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:35.3812636-07:00
var Array2DHashMap_1 = require("../misc/Array2DHashMap");
var Array2DHashSet_1 = require("../misc/Array2DHashSet");
var Arrays_1 = require("../misc/Arrays");
var MurmurHash_1 = require("../misc/MurmurHash");
var Decorators_1 = require("../Decorators");
var PredictionContextCache_1 = require("./PredictionContextCache");
var assert = require("assert");
var INITIAL_HASH = 1;
var PredictionContext = /*#__PURE__*/function () {
  function PredictionContext(cachedHashCode) {
    (0, _classCallCheck2.default)(this, PredictionContext);
    this.cachedHashCode = cachedHashCode;
  }
  (0, _createClass2.default)(PredictionContext, [{
    key: "appendSingleContext",
    value: function appendSingleContext(returnContext, contextCache) {
      return this.appendContext(PredictionContext.EMPTY_FULL.getChild(returnContext), contextCache);
    }
  }, {
    key: "getChild",
    value: function getChild(returnState) {
      return new SingletonPredictionContext(this, returnState);
    }
  }, {
    key: "hashCode",
    value: function hashCode() {
      return this.cachedHashCode;
    }
  }, {
    key: "toStrings",
    value: function toStrings(recognizer, currentState) {
      var stop = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : PredictionContext.EMPTY_FULL;
      var result = [];
      outer: for (var perm = 0;; perm++) {
        var offset = 0;
        var last = true;
        var p = this;
        var stateNumber = currentState;
        var localBuffer = "";
        localBuffer += "[";
        while (!p.isEmpty && p !== stop) {
          var index = 0;
          if (p.size > 0) {
            var bits = 1;
            while (1 << bits >>> 0 < p.size) {
              bits++;
            }
            var mask = (1 << bits >>> 0) - 1;
            index = perm >> offset & mask;
            last = last && index >= p.size - 1;
            if (index >= p.size) {
              continue outer;
            }
            offset += bits;
          }
          if (recognizer) {
            if (localBuffer.length > 1) {
              // first char is '[', if more than that this isn't the first rule
              localBuffer += " ";
            }
            var atn = recognizer.atn;
            var s = atn.states[stateNumber];
            var ruleName = recognizer.ruleNames[s.ruleIndex];
            localBuffer += ruleName;
          } else if (p.getReturnState(index) !== PredictionContext.EMPTY_FULL_STATE_KEY) {
            if (!p.isEmpty) {
              if (localBuffer.length > 1) {
                // first char is '[', if more than that this isn't the first rule
                localBuffer += " ";
              }
              localBuffer += p.getReturnState(index);
            }
          }
          stateNumber = p.getReturnState(index);
          p = p.getParent(index);
        }
        localBuffer += "]";
        result.push(localBuffer);
        if (last) {
          break;
        }
      }
      return result;
    }
  }], [{
    key: "calculateEmptyHashCode",
    value: function calculateEmptyHashCode() {
      var hash = MurmurHash_1.MurmurHash.initialize(INITIAL_HASH);
      hash = MurmurHash_1.MurmurHash.finish(hash, 0);
      return hash;
    }
  }, {
    key: "calculateSingleHashCode",
    value: function calculateSingleHashCode(parent, returnState) {
      var hash = MurmurHash_1.MurmurHash.initialize(INITIAL_HASH);
      hash = MurmurHash_1.MurmurHash.update(hash, parent);
      hash = MurmurHash_1.MurmurHash.update(hash, returnState);
      hash = MurmurHash_1.MurmurHash.finish(hash, 2);
      return hash;
    }
  }, {
    key: "calculateHashCode",
    value: function calculateHashCode(parents, returnStates) {
      var hash = MurmurHash_1.MurmurHash.initialize(INITIAL_HASH);
      var _iterator = _createForOfIteratorHelper(parents),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var parent = _step.value;
          hash = MurmurHash_1.MurmurHash.update(hash, parent);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      var _iterator2 = _createForOfIteratorHelper(returnStates),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var returnState = _step2.value;
          hash = MurmurHash_1.MurmurHash.update(hash, returnState);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      hash = MurmurHash_1.MurmurHash.finish(hash, 2 * parents.length);
      return hash;
    }
  }, {
    key: "fromRuleContext",
    value: function fromRuleContext(atn, outerContext) {
      var fullContext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      if (outerContext.isEmpty) {
        return fullContext ? PredictionContext.EMPTY_FULL : PredictionContext.EMPTY_LOCAL;
      }
      var parent;
      if (outerContext._parent) {
        parent = PredictionContext.fromRuleContext(atn, outerContext._parent, fullContext);
      } else {
        parent = fullContext ? PredictionContext.EMPTY_FULL : PredictionContext.EMPTY_LOCAL;
      }
      var state = atn.states[outerContext.invokingState];
      var transition = state.transition(0);
      return parent.getChild(transition.followState.stateNumber);
    }
  }, {
    key: "addEmptyContext",
    value: function addEmptyContext(context) {
      return context.addEmptyContext();
    }
  }, {
    key: "removeEmptyContext",
    value: function removeEmptyContext(context) {
      return context.removeEmptyContext();
    }
  }, {
    key: "join",
    value: function join(context0, context1) {
      var contextCache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : PredictionContextCache_1.PredictionContextCache.UNCACHED;
      if (context0 === context1) {
        return context0;
      }
      if (context0.isEmpty) {
        return PredictionContext.isEmptyLocal(context0) ? context0 : PredictionContext.addEmptyContext(context1);
      } else if (context1.isEmpty) {
        return PredictionContext.isEmptyLocal(context1) ? context1 : PredictionContext.addEmptyContext(context0);
      }
      var context0size = context0.size;
      var context1size = context1.size;
      if (context0size === 1 && context1size === 1 && context0.getReturnState(0) === context1.getReturnState(0)) {
        var merged = contextCache.join(context0.getParent(0), context1.getParent(0));
        if (merged === context0.getParent(0)) {
          return context0;
        } else if (merged === context1.getParent(0)) {
          return context1;
        } else {
          return merged.getChild(context0.getReturnState(0));
        }
      }
      var count = 0;
      var parentsList = new Array(context0size + context1size);
      var returnStatesList = new Array(parentsList.length);
      var leftIndex = 0;
      var rightIndex = 0;
      var canReturnLeft = true;
      var canReturnRight = true;
      while (leftIndex < context0size && rightIndex < context1size) {
        if (context0.getReturnState(leftIndex) === context1.getReturnState(rightIndex)) {
          parentsList[count] = contextCache.join(context0.getParent(leftIndex), context1.getParent(rightIndex));
          returnStatesList[count] = context0.getReturnState(leftIndex);
          canReturnLeft = canReturnLeft && parentsList[count] === context0.getParent(leftIndex);
          canReturnRight = canReturnRight && parentsList[count] === context1.getParent(rightIndex);
          leftIndex++;
          rightIndex++;
        } else if (context0.getReturnState(leftIndex) < context1.getReturnState(rightIndex)) {
          parentsList[count] = context0.getParent(leftIndex);
          returnStatesList[count] = context0.getReturnState(leftIndex);
          canReturnRight = false;
          leftIndex++;
        } else {
          assert(context1.getReturnState(rightIndex) < context0.getReturnState(leftIndex));
          parentsList[count] = context1.getParent(rightIndex);
          returnStatesList[count] = context1.getReturnState(rightIndex);
          canReturnLeft = false;
          rightIndex++;
        }
        count++;
      }
      while (leftIndex < context0size) {
        parentsList[count] = context0.getParent(leftIndex);
        returnStatesList[count] = context0.getReturnState(leftIndex);
        leftIndex++;
        canReturnRight = false;
        count++;
      }
      while (rightIndex < context1size) {
        parentsList[count] = context1.getParent(rightIndex);
        returnStatesList[count] = context1.getReturnState(rightIndex);
        rightIndex++;
        canReturnLeft = false;
        count++;
      }
      if (canReturnLeft) {
        return context0;
      } else if (canReturnRight) {
        return context1;
      }
      if (count < parentsList.length) {
        parentsList = parentsList.slice(0, count);
        returnStatesList = returnStatesList.slice(0, count);
      }
      if (parentsList.length === 0) {
        // if one of them was EMPTY_LOCAL, it would be empty and handled at the beginning of the method
        return PredictionContext.EMPTY_FULL;
      } else if (parentsList.length === 1) {
        return new SingletonPredictionContext(parentsList[0], returnStatesList[0]);
      } else {
        return new ArrayPredictionContext(parentsList, returnStatesList);
      }
    }
  }, {
    key: "isEmptyLocal",
    value: function isEmptyLocal(context) {
      return context === PredictionContext.EMPTY_LOCAL;
    }
  }, {
    key: "getCachedContext",
    value: function getCachedContext(context, contextCache, visited) {
      if (context.isEmpty) {
        return context;
      }
      var existing = visited.get(context);
      if (existing) {
        return existing;
      }
      existing = contextCache.get(context);
      if (existing) {
        visited.put(context, existing);
        return existing;
      }
      var changed = false;
      var parents = new Array(context.size);
      for (var i = 0; i < parents.length; i++) {
        var parent = PredictionContext.getCachedContext(context.getParent(i), contextCache, visited);
        if (changed || parent !== context.getParent(i)) {
          if (!changed) {
            parents = new Array(context.size);
            for (var j = 0; j < context.size; j++) {
              parents[j] = context.getParent(j);
            }
            changed = true;
          }
          parents[i] = parent;
        }
      }
      if (!changed) {
        existing = contextCache.putIfAbsent(context, context);
        visited.put(context, existing != null ? existing : context);
        return context;
      }
      // We know parents.length>0 because context.isEmpty is checked at the beginning of the method.
      var updated;
      if (parents.length === 1) {
        updated = new SingletonPredictionContext(parents[0], context.getReturnState(0));
      } else {
        var returnStates = new Array(context.size);
        for (var _i = 0; _i < context.size; _i++) {
          returnStates[_i] = context.getReturnState(_i);
        }
        updated = new ArrayPredictionContext(parents, returnStates, context.hashCode());
      }
      existing = contextCache.putIfAbsent(updated, updated);
      visited.put(updated, existing || updated);
      visited.put(context, existing || updated);
      return updated;
    }
  }]);
  return PredictionContext;
}();
__decorate([Decorators_1.Override], PredictionContext.prototype, "hashCode", null);
__decorate([__param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull), __param(2, Decorators_1.NotNull)], PredictionContext, "join", null);
__decorate([__param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull), __param(2, Decorators_1.NotNull)], PredictionContext, "getCachedContext", null);
exports.PredictionContext = PredictionContext;
var EmptyPredictionContext = /*#__PURE__*/function (_PredictionContext) {
  (0, _inherits2.default)(EmptyPredictionContext, _PredictionContext);
  var _super = _createSuper(EmptyPredictionContext);
  function EmptyPredictionContext(fullContext) {
    var _this;
    (0, _classCallCheck2.default)(this, EmptyPredictionContext);
    _this = _super.call(this, PredictionContext.calculateEmptyHashCode());
    _this.fullContext = fullContext;
    return _this;
  }
  (0, _createClass2.default)(EmptyPredictionContext, [{
    key: "isFullContext",
    get: function get() {
      return this.fullContext;
    }
  }, {
    key: "addEmptyContext",
    value: function addEmptyContext() {
      return this;
    }
  }, {
    key: "removeEmptyContext",
    value: function removeEmptyContext() {
      throw new Error("Cannot remove the empty context from itself.");
    }
  }, {
    key: "getParent",
    value: function getParent(index) {
      throw new Error("index out of bounds");
    }
  }, {
    key: "getReturnState",
    value: function getReturnState(index) {
      throw new Error("index out of bounds");
    }
  }, {
    key: "findReturnState",
    value: function findReturnState(returnState) {
      return -1;
    }
  }, {
    key: "size",
    get: function get() {
      return 0;
    }
  }, {
    key: "appendSingleContext",
    value: function appendSingleContext(returnContext, contextCache) {
      return contextCache.getChild(this, returnContext);
    }
  }, {
    key: "appendContext",
    value: function appendContext(suffix, contextCache) {
      return suffix;
    }
  }, {
    key: "isEmpty",
    get: function get() {
      return true;
    }
  }, {
    key: "hasEmpty",
    get: function get() {
      return true;
    }
  }, {
    key: "equals",
    value: function equals(o) {
      return this === o;
    }
  }, {
    key: "toStrings",
    value: function toStrings(recognizer, currentState, stop) {
      return ["[]"];
    }
  }]);
  return EmptyPredictionContext;
}(PredictionContext);
__decorate([Decorators_1.Override], EmptyPredictionContext.prototype, "addEmptyContext", null);
__decorate([Decorators_1.Override], EmptyPredictionContext.prototype, "removeEmptyContext", null);
__decorate([Decorators_1.Override], EmptyPredictionContext.prototype, "getParent", null);
__decorate([Decorators_1.Override], EmptyPredictionContext.prototype, "getReturnState", null);
__decorate([Decorators_1.Override], EmptyPredictionContext.prototype, "findReturnState", null);
__decorate([Decorators_1.Override], EmptyPredictionContext.prototype, "size", null);
__decorate([Decorators_1.Override], EmptyPredictionContext.prototype, "appendSingleContext", null);
__decorate([Decorators_1.Override], EmptyPredictionContext.prototype, "appendContext", null);
__decorate([Decorators_1.Override], EmptyPredictionContext.prototype, "isEmpty", null);
__decorate([Decorators_1.Override], EmptyPredictionContext.prototype, "hasEmpty", null);
__decorate([Decorators_1.Override], EmptyPredictionContext.prototype, "equals", null);
__decorate([Decorators_1.Override], EmptyPredictionContext.prototype, "toStrings", null);
var ArrayPredictionContext = /*#__PURE__*/function (_PredictionContext2) {
  (0, _inherits2.default)(ArrayPredictionContext, _PredictionContext2);
  var _super2 = _createSuper(ArrayPredictionContext);
  function ArrayPredictionContext(parents, returnStates, hashCode) {
    var _this2;
    (0, _classCallCheck2.default)(this, ArrayPredictionContext);
    _this2 = _super2.call(this, hashCode || PredictionContext.calculateHashCode(parents, returnStates));
    assert(parents.length === returnStates.length);
    assert(returnStates.length > 1 || returnStates[0] !== PredictionContext.EMPTY_FULL_STATE_KEY, "Should be using PredictionContext.EMPTY instead.");
    _this2.parents = parents;
    _this2.returnStates = returnStates;
    return _this2;
  }
  (0, _createClass2.default)(ArrayPredictionContext, [{
    key: "getParent",
    value: function getParent(index) {
      return this.parents[index];
    }
  }, {
    key: "getReturnState",
    value: function getReturnState(index) {
      return this.returnStates[index];
    }
  }, {
    key: "findReturnState",
    value: function findReturnState(returnState) {
      return Arrays_1.Arrays.binarySearch(this.returnStates, returnState);
    }
  }, {
    key: "size",
    get: function get() {
      return this.returnStates.length;
    }
  }, {
    key: "isEmpty",
    get: function get() {
      return false;
    }
  }, {
    key: "hasEmpty",
    get: function get() {
      return this.returnStates[this.returnStates.length - 1] === PredictionContext.EMPTY_FULL_STATE_KEY;
    }
  }, {
    key: "addEmptyContext",
    value: function addEmptyContext() {
      if (this.hasEmpty) {
        return this;
      }
      var parents2 = this.parents.slice(0);
      var returnStates2 = this.returnStates.slice(0);
      parents2.push(PredictionContext.EMPTY_FULL);
      returnStates2.push(PredictionContext.EMPTY_FULL_STATE_KEY);
      return new ArrayPredictionContext(parents2, returnStates2);
    }
  }, {
    key: "removeEmptyContext",
    value: function removeEmptyContext() {
      if (!this.hasEmpty) {
        return this;
      }
      if (this.returnStates.length === 2) {
        return new SingletonPredictionContext(this.parents[0], this.returnStates[0]);
      } else {
        var parents2 = this.parents.slice(0, this.parents.length - 1);
        var returnStates2 = this.returnStates.slice(0, this.returnStates.length - 1);
        return new ArrayPredictionContext(parents2, returnStates2);
      }
    }
  }, {
    key: "appendContext",
    value: function appendContext(suffix, contextCache) {
      return ArrayPredictionContext.appendContextImpl(this, suffix, new PredictionContext.IdentityHashMap());
    }
  }, {
    key: "equals",
    value: function equals(o) {
      if (this === o) {
        return true;
      } else if (!(o instanceof ArrayPredictionContext)) {
        return false;
      }
      if (this.hashCode() !== o.hashCode()) {
        // can't be same if hash is different
        return false;
      }
      var other = o;
      return this.equalsImpl(other, new Array2DHashSet_1.Array2DHashSet());
    }
  }, {
    key: "equalsImpl",
    value: function equalsImpl(other, visited) {
      var selfWorkList = [];
      var otherWorkList = [];
      selfWorkList.push(this);
      otherWorkList.push(other);
      while (true) {
        var currentSelf = selfWorkList.pop();
        var currentOther = otherWorkList.pop();
        if (!currentSelf || !currentOther) {
          break;
        }
        var operands = new PredictionContextCache_1.PredictionContextCache.IdentityCommutativePredictionContextOperands(currentSelf, currentOther);
        if (!visited.add(operands)) {
          continue;
        }
        var selfSize = operands.x.size;
        if (selfSize === 0) {
          if (!operands.x.equals(operands.y)) {
            return false;
          }
          continue;
        }
        var otherSize = operands.y.size;
        if (selfSize !== otherSize) {
          return false;
        }
        for (var i = 0; i < selfSize; i++) {
          if (operands.x.getReturnState(i) !== operands.y.getReturnState(i)) {
            return false;
          }
          var selfParent = operands.x.getParent(i);
          var otherParent = operands.y.getParent(i);
          if (selfParent.hashCode() !== otherParent.hashCode()) {
            return false;
          }
          if (selfParent !== otherParent) {
            selfWorkList.push(selfParent);
            otherWorkList.push(otherParent);
          }
        }
      }
      return true;
    }
  }], [{
    key: "appendContextImpl",
    value: function appendContextImpl(context, suffix, visited) {
      if (suffix.isEmpty) {
        if (PredictionContext.isEmptyLocal(suffix)) {
          if (context.hasEmpty) {
            return PredictionContext.EMPTY_LOCAL;
          }
          throw new Error("what to do here?");
        }
        return context;
      }
      if (suffix.size !== 1) {
        throw new Error("Appending a tree suffix is not yet supported.");
      }
      var result = visited.get(context);
      if (!result) {
        if (context.isEmpty) {
          result = suffix;
        } else {
          var parentCount = context.size;
          if (context.hasEmpty) {
            parentCount--;
          }
          var updatedParents = new Array(parentCount);
          var updatedReturnStates = new Array(parentCount);
          for (var i = 0; i < parentCount; i++) {
            updatedReturnStates[i] = context.getReturnState(i);
          }
          for (var _i2 = 0; _i2 < parentCount; _i2++) {
            updatedParents[_i2] = ArrayPredictionContext.appendContextImpl(context.getParent(_i2), suffix, visited);
          }
          if (updatedParents.length === 1) {
            result = new SingletonPredictionContext(updatedParents[0], updatedReturnStates[0]);
          } else {
            assert(updatedParents.length > 1);
            result = new ArrayPredictionContext(updatedParents, updatedReturnStates);
          }
          if (context.hasEmpty) {
            result = PredictionContext.join(result, suffix);
          }
        }
        visited.put(context, result);
      }
      return result;
    }
  }]);
  return ArrayPredictionContext;
}(PredictionContext);
__decorate([Decorators_1.NotNull], ArrayPredictionContext.prototype, "parents", void 0);
__decorate([Decorators_1.NotNull], ArrayPredictionContext.prototype, "returnStates", void 0);
__decorate([Decorators_1.Override], ArrayPredictionContext.prototype, "getParent", null);
__decorate([Decorators_1.Override], ArrayPredictionContext.prototype, "getReturnState", null);
__decorate([Decorators_1.Override], ArrayPredictionContext.prototype, "findReturnState", null);
__decorate([Decorators_1.Override], ArrayPredictionContext.prototype, "size", null);
__decorate([Decorators_1.Override], ArrayPredictionContext.prototype, "isEmpty", null);
__decorate([Decorators_1.Override], ArrayPredictionContext.prototype, "hasEmpty", null);
__decorate([Decorators_1.Override], ArrayPredictionContext.prototype, "addEmptyContext", null);
__decorate([Decorators_1.Override], ArrayPredictionContext.prototype, "removeEmptyContext", null);
__decorate([Decorators_1.Override], ArrayPredictionContext.prototype, "appendContext", null);
__decorate([Decorators_1.Override], ArrayPredictionContext.prototype, "equals", null);
ArrayPredictionContext = __decorate([__param(0, Decorators_1.NotNull)], ArrayPredictionContext);
var SingletonPredictionContext = /*#__PURE__*/function (_PredictionContext3) {
  (0, _inherits2.default)(SingletonPredictionContext, _PredictionContext3);
  var _super3 = _createSuper(SingletonPredictionContext);
  function SingletonPredictionContext(parent, returnState) {
    var _this3;
    (0, _classCallCheck2.default)(this, SingletonPredictionContext);
    _this3 = _super3.call(this, PredictionContext.calculateSingleHashCode(parent, returnState));
    // assert(returnState != PredictionContext.EMPTY_FULL_STATE_KEY && returnState != PredictionContext.EMPTY_LOCAL_STATE_KEY);
    _this3.parent = parent;
    _this3.returnState = returnState;
    return _this3;
  }
  (0, _createClass2.default)(SingletonPredictionContext, [{
    key: "getParent",
    value: function getParent(index) {
      // assert(index == 0);
      return this.parent;
    }
  }, {
    key: "getReturnState",
    value: function getReturnState(index) {
      // assert(index == 0);
      return this.returnState;
    }
  }, {
    key: "findReturnState",
    value: function findReturnState(returnState) {
      return this.returnState === returnState ? 0 : -1;
    }
  }, {
    key: "size",
    get: function get() {
      return 1;
    }
  }, {
    key: "isEmpty",
    get: function get() {
      return false;
    }
  }, {
    key: "hasEmpty",
    get: function get() {
      return false;
    }
  }, {
    key: "appendContext",
    value: function appendContext(suffix, contextCache) {
      return contextCache.getChild(this.parent.appendContext(suffix, contextCache), this.returnState);
    }
  }, {
    key: "addEmptyContext",
    value: function addEmptyContext() {
      var parents = [this.parent, PredictionContext.EMPTY_FULL];
      var returnStates = [this.returnState, PredictionContext.EMPTY_FULL_STATE_KEY];
      return new ArrayPredictionContext(parents, returnStates);
    }
  }, {
    key: "removeEmptyContext",
    value: function removeEmptyContext() {
      return this;
    }
  }, {
    key: "equals",
    value: function equals(o) {
      if (o === this) {
        return true;
      } else if (!(o instanceof SingletonPredictionContext)) {
        return false;
      }
      var other = o;
      if (this.hashCode() !== other.hashCode()) {
        return false;
      }
      return this.returnState === other.returnState && this.parent.equals(other.parent);
    }
  }]);
  return SingletonPredictionContext;
}(PredictionContext);
__decorate([Decorators_1.NotNull], SingletonPredictionContext.prototype, "parent", void 0);
__decorate([Decorators_1.Override], SingletonPredictionContext.prototype, "getParent", null);
__decorate([Decorators_1.Override], SingletonPredictionContext.prototype, "getReturnState", null);
__decorate([Decorators_1.Override], SingletonPredictionContext.prototype, "findReturnState", null);
__decorate([Decorators_1.Override], SingletonPredictionContext.prototype, "size", null);
__decorate([Decorators_1.Override], SingletonPredictionContext.prototype, "isEmpty", null);
__decorate([Decorators_1.Override], SingletonPredictionContext.prototype, "hasEmpty", null);
__decorate([Decorators_1.Override], SingletonPredictionContext.prototype, "appendContext", null);
__decorate([Decorators_1.Override], SingletonPredictionContext.prototype, "addEmptyContext", null);
__decorate([Decorators_1.Override], SingletonPredictionContext.prototype, "removeEmptyContext", null);
__decorate([Decorators_1.Override], SingletonPredictionContext.prototype, "equals", null);
SingletonPredictionContext = __decorate([__param(0, Decorators_1.NotNull)], SingletonPredictionContext);
exports.SingletonPredictionContext = SingletonPredictionContext;
(function (PredictionContext) {
  PredictionContext.EMPTY_LOCAL = new EmptyPredictionContext(false);
  PredictionContext.EMPTY_FULL = new EmptyPredictionContext(true);
  PredictionContext.EMPTY_LOCAL_STATE_KEY = -(1 << 31 >>> 0);
  PredictionContext.EMPTY_FULL_STATE_KEY = (1 << 31 >>> 0) - 1;
  var IdentityHashMap = /*#__PURE__*/function (_Array2DHashMap_1$Arr) {
    (0, _inherits2.default)(IdentityHashMap, _Array2DHashMap_1$Arr);
    var _super4 = _createSuper(IdentityHashMap);
    function IdentityHashMap() {
      (0, _classCallCheck2.default)(this, IdentityHashMap);
      return _super4.call(this, IdentityEqualityComparator.INSTANCE);
    }
    return (0, _createClass2.default)(IdentityHashMap);
  }(Array2DHashMap_1.Array2DHashMap);
  PredictionContext.IdentityHashMap = IdentityHashMap;
  var IdentityEqualityComparator = /*#__PURE__*/function () {
    function IdentityEqualityComparator() {
      (0, _classCallCheck2.default)(this, IdentityEqualityComparator);
    }
    (0, _createClass2.default)(IdentityEqualityComparator, [{
      key: "IdentityEqualityComparator",
      value: function IdentityEqualityComparator() {
        // intentionally empty
      }
    }, {
      key: "hashCode",
      value: function hashCode(obj) {
        return obj.hashCode();
      }
    }, {
      key: "equals",
      value: function equals(a, b) {
        return a === b;
      }
    }]);
    return IdentityEqualityComparator;
  }();
  IdentityEqualityComparator.INSTANCE = new IdentityEqualityComparator();
  __decorate([Decorators_1.Override], IdentityEqualityComparator.prototype, "hashCode", null);
  __decorate([Decorators_1.Override], IdentityEqualityComparator.prototype, "equals", null);
  PredictionContext.IdentityEqualityComparator = IdentityEqualityComparator;
})(PredictionContext = exports.PredictionContext || (exports.PredictionContext = {}));

},{"../Decorators":272,"../misc/Array2DHashMap":369,"../misc/Array2DHashSet":370,"../misc/Arrays":372,"../misc/MurmurHash":381,"./PredictionContextCache":347,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"assert":413,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.join.js":578,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],347:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.array.join.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:35.6390614-07:00
var Array2DHashMap_1 = require("../misc/Array2DHashMap");
var Decorators_1 = require("../Decorators");
var ObjectEqualityComparator_1 = require("../misc/ObjectEqualityComparator");
var PredictionContext_1 = require("./PredictionContext");
var assert = require("assert");
/** Used to cache {@link PredictionContext} objects. Its used for the shared
 *  context cash associated with contexts in DFA states. This cache
 *  can be used for both lexers and parsers.
 *
 * @author Sam Harwell
 */
var PredictionContextCache = /*#__PURE__*/function () {
  function PredictionContextCache() {
    var enableCache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    (0, _classCallCheck2.default)(this, PredictionContextCache);
    this.contexts = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
    this.childContexts = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
    this.joinContexts = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
    this.enableCache = enableCache;
  }
  (0, _createClass2.default)(PredictionContextCache, [{
    key: "getAsCached",
    value: function getAsCached(context) {
      if (!this.enableCache) {
        return context;
      }
      var result = this.contexts.get(context);
      if (!result) {
        result = context;
        this.contexts.put(context, context);
      }
      return result;
    }
  }, {
    key: "getChild",
    value: function getChild(context, invokingState) {
      if (!this.enableCache) {
        return context.getChild(invokingState);
      }
      var operands = new PredictionContextCache.PredictionContextAndInt(context, invokingState);
      var result = this.childContexts.get(operands);
      if (!result) {
        result = context.getChild(invokingState);
        result = this.getAsCached(result);
        this.childContexts.put(operands, result);
      }
      return result;
    }
  }, {
    key: "join",
    value: function join(x, y) {
      if (!this.enableCache) {
        return PredictionContext_1.PredictionContext.join(x, y, this);
      }
      var operands = new PredictionContextCache.IdentityCommutativePredictionContextOperands(x, y);
      var result = this.joinContexts.get(operands);
      if (result) {
        return result;
      }
      result = PredictionContext_1.PredictionContext.join(x, y, this);
      result = this.getAsCached(result);
      this.joinContexts.put(operands, result);
      return result;
    }
  }]);
  return PredictionContextCache;
}();
PredictionContextCache.UNCACHED = new PredictionContextCache(false);
exports.PredictionContextCache = PredictionContextCache;
(function (PredictionContextCache) {
  var PredictionContextAndInt = /*#__PURE__*/function () {
    function PredictionContextAndInt(obj, value) {
      (0, _classCallCheck2.default)(this, PredictionContextAndInt);
      this.obj = obj;
      this.value = value;
    }
    (0, _createClass2.default)(PredictionContextAndInt, [{
      key: "equals",
      value: function equals(obj) {
        if (!(obj instanceof PredictionContextAndInt)) {
          return false;
        } else if (obj === this) {
          return true;
        }
        var other = obj;
        return this.value === other.value && (this.obj === other.obj || this.obj != null && this.obj.equals(other.obj));
      }
    }, {
      key: "hashCode",
      value: function hashCode() {
        var hashCode = 5;
        hashCode = 7 * hashCode + (this.obj != null ? this.obj.hashCode() : 0);
        hashCode = 7 * hashCode + this.value;
        return hashCode;
      }
    }]);
    return PredictionContextAndInt;
  }();
  __decorate([Decorators_1.Override], PredictionContextAndInt.prototype, "equals", null);
  __decorate([Decorators_1.Override], PredictionContextAndInt.prototype, "hashCode", null);
  PredictionContextCache.PredictionContextAndInt = PredictionContextAndInt;
  var IdentityCommutativePredictionContextOperands = /*#__PURE__*/function () {
    function IdentityCommutativePredictionContextOperands(x, y) {
      (0, _classCallCheck2.default)(this, IdentityCommutativePredictionContextOperands);
      assert(x != null);
      assert(y != null);
      this._x = x;
      this._y = y;
    }
    (0, _createClass2.default)(IdentityCommutativePredictionContextOperands, [{
      key: "x",
      get: function get() {
        return this._x;
      }
    }, {
      key: "y",
      get: function get() {
        return this._y;
      }
    }, {
      key: "equals",
      value: function equals(o) {
        if (!(o instanceof IdentityCommutativePredictionContextOperands)) {
          return false;
        } else if (this === o) {
          return true;
        }
        var other = o;
        return this._x === other._x && this._y === other._y || this._x === other._y && this._y === other._x;
      }
    }, {
      key: "hashCode",
      value: function hashCode() {
        return this._x.hashCode() ^ this._y.hashCode();
      }
    }]);
    return IdentityCommutativePredictionContextOperands;
  }();
  __decorate([Decorators_1.Override], IdentityCommutativePredictionContextOperands.prototype, "equals", null);
  __decorate([Decorators_1.Override], IdentityCommutativePredictionContextOperands.prototype, "hashCode", null);
  PredictionContextCache.IdentityCommutativePredictionContextOperands = IdentityCommutativePredictionContextOperands;
})(PredictionContextCache = exports.PredictionContextCache || (exports.PredictionContextCache = {}));

},{"../Decorators":272,"../misc/Array2DHashMap":369,"../misc/ObjectEqualityComparator":382,"./PredictionContext":346,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"assert":413,"core-js/modules/es.array.join.js":578,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612}],348:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:36.2673893-07:00
var Array2DHashMap_1 = require("../misc/Array2DHashMap");
var MurmurHash_1 = require("../misc/MurmurHash");
var Decorators_1 = require("../Decorators");
var RuleStopState_1 = require("./RuleStopState");
/**
 * This enumeration defines the prediction modes available in ANTLR 4 along with
 * utility methods for analyzing configuration sets for conflicts and/or
 * ambiguities.
 */
var PredictionMode;
(function (PredictionMode) {
  /**
   * The SLL(*) prediction mode. This prediction mode ignores the current
   * parser context when making predictions. This is the fastest prediction
   * mode, and provides correct results for many grammars. This prediction
   * mode is more powerful than the prediction mode provided by ANTLR 3, but
   * may result in syntax errors for grammar and input combinations which are
   * not SLL.
   *
   * When using this prediction mode, the parser will either return a correct
   * parse tree (i.e. the same parse tree that would be returned with the
   * {@link #LL} prediction mode), or it will report a syntax error. If a
   * syntax error is encountered when using the {@link #SLL} prediction mode,
   * it may be due to either an actual syntax error in the input or indicate
   * that the particular combination of grammar and input requires the more
   * powerful {@link #LL} prediction abilities to complete successfully.
   *
   * This prediction mode does not provide any guarantees for prediction
   * behavior for syntactically-incorrect inputs.
   */
  PredictionMode[PredictionMode["SLL"] = 0] = "SLL";
  /**
   * The LL(*) prediction mode. This prediction mode allows the current parser
   * context to be used for resolving SLL conflicts that occur during
   * prediction. This is the fastest prediction mode that guarantees correct
   * parse results for all combinations of grammars with syntactically correct
   * inputs.
   *
   * When using this prediction mode, the parser will make correct decisions
   * for all syntactically-correct grammar and input combinations. However, in
   * cases where the grammar is truly ambiguous this prediction mode might not
   * report a precise answer for *exactly which* alternatives are
   * ambiguous.
   *
   * This prediction mode does not provide any guarantees for prediction
   * behavior for syntactically-incorrect inputs.
   */
  PredictionMode[PredictionMode["LL"] = 1] = "LL";
  /**
   * The LL(*) prediction mode with exact ambiguity detection. In addition to
   * the correctness guarantees provided by the {@link #LL} prediction mode,
   * this prediction mode instructs the prediction algorithm to determine the
   * complete and exact set of ambiguous alternatives for every ambiguous
   * decision encountered while parsing.
   *
   * This prediction mode may be used for diagnosing ambiguities during
   * grammar development. Due to the performance overhead of calculating sets
   * of ambiguous alternatives, this prediction mode should be avoided when
   * the exact results are not necessary.
   *
   * This prediction mode does not provide any guarantees for prediction
   * behavior for syntactically-incorrect inputs.
   */
  PredictionMode[PredictionMode["LL_EXACT_AMBIG_DETECTION"] = 2] = "LL_EXACT_AMBIG_DETECTION";
})(PredictionMode = exports.PredictionMode || (exports.PredictionMode = {}));
(function (PredictionMode) {
  /** A Map that uses just the state and the stack context as the key. */
  // NOTE: Base type used to be FlexibleHashMap<ATNConfig, BitSet>
  var AltAndContextMap = /*#__PURE__*/function (_Array2DHashMap_1$Arr) {
    (0, _inherits2.default)(AltAndContextMap, _Array2DHashMap_1$Arr);
    var _super = _createSuper(AltAndContextMap);
    function AltAndContextMap() {
      (0, _classCallCheck2.default)(this, AltAndContextMap);
      return _super.call(this, AltAndContextConfigEqualityComparator.INSTANCE);
    }
    return (0, _createClass2.default)(AltAndContextMap);
  }(Array2DHashMap_1.Array2DHashMap);
  var AltAndContextConfigEqualityComparator = /*#__PURE__*/function () {
    function AltAndContextConfigEqualityComparator() {
      (0, _classCallCheck2.default)(this, AltAndContextConfigEqualityComparator);
    }
    (0, _createClass2.default)(AltAndContextConfigEqualityComparator, [{
      key: "AltAndContextConfigEqualityComparator",
      value: function AltAndContextConfigEqualityComparator() {
        // intentionally empty
      }
      /**
       * The hash code is only a function of the {@link ATNState#stateNumber}
       * and {@link ATNConfig#context}.
       */
    }, {
      key: "hashCode",
      value: function hashCode(o) {
        var hashCode = MurmurHash_1.MurmurHash.initialize(7);
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, o.state.stateNumber);
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, o.context);
        hashCode = MurmurHash_1.MurmurHash.finish(hashCode, 2);
        return hashCode;
      }
    }, {
      key: "equals",
      value: function equals(a, b) {
        if (a === b) {
          return true;
        }
        if (a == null || b == null) {
          return false;
        }
        return a.state.stateNumber === b.state.stateNumber && a.context.equals(b.context);
      }
    }]);
    return AltAndContextConfigEqualityComparator;
  }();
  AltAndContextConfigEqualityComparator.INSTANCE = new AltAndContextConfigEqualityComparator();
  __decorate([Decorators_1.Override], AltAndContextConfigEqualityComparator.prototype, "hashCode", null);
  __decorate([Decorators_1.Override], AltAndContextConfigEqualityComparator.prototype, "equals", null);
  /**
   * Checks if any configuration in `configs` is in a
   * {@link RuleStopState}. Configurations meeting this condition have reached
   * the end of the decision rule (local context) or end of start rule (full
   * context).
   *
   * @param configs the configuration set to test
   * @returns `true` if any configuration in `configs` is in a
   * {@link RuleStopState}, otherwise `false`
   */
  function hasConfigInRuleStopState(configs) {
    var _iterator = _createForOfIteratorHelper(configs),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var c = _step.value;
        if (c.state instanceof RuleStopState_1.RuleStopState) {
          return true;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return false;
  }
  PredictionMode.hasConfigInRuleStopState = hasConfigInRuleStopState;
  /**
   * Checks if all configurations in `configs` are in a
   * {@link RuleStopState}. Configurations meeting this condition have reached
   * the end of the decision rule (local context) or end of start rule (full
   * context).
   *
   * @param configs the configuration set to test
   * @returns `true` if all configurations in `configs` are in a
   * {@link RuleStopState}, otherwise `false`
   */
  function allConfigsInRuleStopStates( /*@NotNull*/configs) {
    var _iterator2 = _createForOfIteratorHelper(configs),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var config = _step2.value;
        if (!(config.state instanceof RuleStopState_1.RuleStopState)) {
          return false;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    return true;
  }
  PredictionMode.allConfigsInRuleStopStates = allConfigsInRuleStopStates;
})(PredictionMode = exports.PredictionMode || (exports.PredictionMode = {}));

},{"../Decorators":272,"../misc/Array2DHashMap":369,"../misc/MurmurHash":381,"./RuleStopState":352,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],349:[function(require,module,exports){
(function (process){(function (){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:36.4188352-07:00
var AmbiguityInfo_1 = require("./AmbiguityInfo");
var ATN_1 = require("./ATN");
var ATNSimulator_1 = require("./ATNSimulator");
var ContextSensitivityInfo_1 = require("./ContextSensitivityInfo");
var DecisionInfo_1 = require("./DecisionInfo");
var ErrorInfo_1 = require("./ErrorInfo");
var Decorators_1 = require("../Decorators");
var LookaheadEventInfo_1 = require("./LookaheadEventInfo");
var ParserATNSimulator_1 = require("./ParserATNSimulator");
var PredicateEvalInfo_1 = require("./PredicateEvalInfo");
var SemanticContext_1 = require("./SemanticContext");
var SimulatorState_1 = require("./SimulatorState");
/**
 * @since 4.3
 */
var ProfilingATNSimulator = /*#__PURE__*/function (_ParserATNSimulator_) {
  (0, _inherits2.default)(ProfilingATNSimulator, _ParserATNSimulator_);
  var _super = _createSuper(ProfilingATNSimulator);
  function ProfilingATNSimulator(parser) {
    var _this;
    (0, _classCallCheck2.default)(this, ProfilingATNSimulator);
    _this = _super.call(this, parser.interpreter.atn, parser);
    _this._startIndex = 0;
    _this._sllStopIndex = 0;
    _this._llStopIndex = 0;
    _this.currentDecision = 0;
    /** At the point of LL failover, we record how SLL would resolve the conflict so that
     *  we can determine whether or not a decision / input pair is context-sensitive.
     *  If LL gives a different result than SLL's predicted alternative, we have a
     *  context sensitivity for sure. The converse is not necessarily true, however.
     *  It's possible that after conflict resolution chooses minimum alternatives,
     *  SLL could get the same answer as LL. Regardless of whether or not the result indicates
     *  an ambiguity, it is not treated as a context sensitivity because LL prediction
     *  was not required in order to produce a correct prediction for this decision and input sequence.
     *  It may in fact still be a context sensitivity but we don't know by looking at the
     *  minimum alternatives for the current input.
     */
    _this.conflictingAltResolvedBySLL = 0;
    _this.optimize_ll1 = false;
    _this.reportAmbiguities = true;
    _this.numDecisions = _this.atn.decisionToState.length;
    _this.decisions = [];
    for (var i = 0; i < _this.numDecisions; i++) {
      _this.decisions.push(new DecisionInfo_1.DecisionInfo(i));
    }
    return _this;
  }
  (0, _createClass2.default)(ProfilingATNSimulator, [{
    key: "adaptivePredict",
    value: function adaptivePredict(input, decision, outerContext, useContext) {
      if (useContext !== undefined) {
        return (0, _get2.default)((0, _getPrototypeOf2.default)(ProfilingATNSimulator.prototype), "adaptivePredict", this).call(this, input, decision, outerContext, useContext);
      }
      try {
        this._input = input;
        this._startIndex = input.index;
        // it's possible for SLL to reach a conflict state without consuming any input
        this._sllStopIndex = this._startIndex - 1;
        this._llStopIndex = -1;
        this.currentDecision = decision;
        this.currentState = undefined;
        this.conflictingAltResolvedBySLL = ATN_1.ATN.INVALID_ALT_NUMBER;
        var start = process.hrtime();
        var alt = (0, _get2.default)((0, _getPrototypeOf2.default)(ProfilingATNSimulator.prototype), "adaptivePredict", this).call(this, input, decision, outerContext);
        var stop = process.hrtime();
        var nanoseconds = (stop[0] - start[0]) * 1000000000;
        if (nanoseconds === 0) {
          nanoseconds = stop[1] - start[1];
        } else {
          // Add nanoseconds from start to end of that second, plus start of the end second to end
          nanoseconds += 1000000000 - start[1] + stop[1];
        }
        this.decisions[decision].timeInPrediction += nanoseconds;
        this.decisions[decision].invocations++;
        var SLL_k = this._sllStopIndex - this._startIndex + 1;
        this.decisions[decision].SLL_TotalLook += SLL_k;
        this.decisions[decision].SLL_MinLook = this.decisions[decision].SLL_MinLook === 0 ? SLL_k : Math.min(this.decisions[decision].SLL_MinLook, SLL_k);
        if (SLL_k > this.decisions[decision].SLL_MaxLook) {
          this.decisions[decision].SLL_MaxLook = SLL_k;
          this.decisions[decision].SLL_MaxLookEvent = new LookaheadEventInfo_1.LookaheadEventInfo(decision, undefined, alt, input, this._startIndex, this._sllStopIndex, false);
        }
        if (this._llStopIndex >= 0) {
          var LL_k = this._llStopIndex - this._startIndex + 1;
          this.decisions[decision].LL_TotalLook += LL_k;
          this.decisions[decision].LL_MinLook = this.decisions[decision].LL_MinLook === 0 ? LL_k : Math.min(this.decisions[decision].LL_MinLook, LL_k);
          if (LL_k > this.decisions[decision].LL_MaxLook) {
            this.decisions[decision].LL_MaxLook = LL_k;
            this.decisions[decision].LL_MaxLookEvent = new LookaheadEventInfo_1.LookaheadEventInfo(decision, undefined, alt, input, this._startIndex, this._llStopIndex, true);
          }
        }
        return alt;
      } finally {
        this._input = undefined;
        this.currentDecision = -1;
      }
    }
  }, {
    key: "getStartState",
    value: function getStartState(dfa, input, outerContext, useContext) {
      var state = (0, _get2.default)((0, _getPrototypeOf2.default)(ProfilingATNSimulator.prototype), "getStartState", this).call(this, dfa, input, outerContext, useContext);
      this.currentState = state;
      return state;
    }
  }, {
    key: "computeStartState",
    value: function computeStartState(dfa, globalContext, useContext) {
      var state = (0, _get2.default)((0, _getPrototypeOf2.default)(ProfilingATNSimulator.prototype), "computeStartState", this).call(this, dfa, globalContext, useContext);
      this.currentState = state;
      return state;
    }
  }, {
    key: "computeReachSet",
    value: function computeReachSet(dfa, previous, t, contextCache) {
      if (this._input === undefined) {
        throw new Error("Invalid state");
      }
      var reachState = (0, _get2.default)((0, _getPrototypeOf2.default)(ProfilingATNSimulator.prototype), "computeReachSet", this).call(this, dfa, previous, t, contextCache);
      if (reachState == null) {
        // no reach on current lookahead symbol. ERROR.
        this.decisions[this.currentDecision].errors.push(new ErrorInfo_1.ErrorInfo(this.currentDecision, previous, this._input, this._startIndex, this._input.index));
      }
      this.currentState = reachState;
      return reachState;
    }
  }, {
    key: "getExistingTargetState",
    value: function getExistingTargetState(previousD, t) {
      if (this.currentState === undefined || this._input === undefined) {
        throw new Error("Invalid state");
      }
      // this method is called after each time the input position advances
      if (this.currentState.useContext) {
        this._llStopIndex = this._input.index;
      } else {
        this._sllStopIndex = this._input.index;
      }
      var existingTargetState = (0, _get2.default)((0, _getPrototypeOf2.default)(ProfilingATNSimulator.prototype), "getExistingTargetState", this).call(this, previousD, t);
      if (existingTargetState != null) {
        // this method is directly called by execDFA; must construct a SimulatorState
        // to represent the current state for this case
        this.currentState = new SimulatorState_1.SimulatorState(this.currentState.outerContext, existingTargetState, this.currentState.useContext, this.currentState.remainingOuterContext);
        if (this.currentState.useContext) {
          this.decisions[this.currentDecision].LL_DFATransitions++;
        } else {
          this.decisions[this.currentDecision].SLL_DFATransitions++; // count only if we transition over a DFA state
        }

        if (existingTargetState === ATNSimulator_1.ATNSimulator.ERROR) {
          var state = new SimulatorState_1.SimulatorState(this.currentState.outerContext, previousD, this.currentState.useContext, this.currentState.remainingOuterContext);
          this.decisions[this.currentDecision].errors.push(new ErrorInfo_1.ErrorInfo(this.currentDecision, state, this._input, this._startIndex, this._input.index));
        }
      }
      return existingTargetState;
    }
  }, {
    key: "computeTargetState",
    value: function computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache) {
      var targetState = (0, _get2.default)((0, _getPrototypeOf2.default)(ProfilingATNSimulator.prototype), "computeTargetState", this).call(this, dfa, s, remainingGlobalContext, t, useContext, contextCache);
      if (useContext) {
        this.decisions[this.currentDecision].LL_ATNTransitions++;
      } else {
        this.decisions[this.currentDecision].SLL_ATNTransitions++;
      }
      return targetState;
    }
  }, {
    key: "evalSemanticContextImpl",
    value: function evalSemanticContextImpl(pred, parserCallStack, alt) {
      if (this.currentState === undefined || this._input === undefined) {
        throw new Error("Invalid state");
      }
      var result = (0, _get2.default)((0, _getPrototypeOf2.default)(ProfilingATNSimulator.prototype), "evalSemanticContextImpl", this).call(this, pred, parserCallStack, alt);
      if (!(pred instanceof SemanticContext_1.SemanticContext.PrecedencePredicate)) {
        var fullContext = this._llStopIndex >= 0;
        var stopIndex = fullContext ? this._llStopIndex : this._sllStopIndex;
        this.decisions[this.currentDecision].predicateEvals.push(new PredicateEvalInfo_1.PredicateEvalInfo(this.currentState, this.currentDecision, this._input, this._startIndex, stopIndex, pred, result, alt));
      }
      return result;
    }
  }, {
    key: "reportContextSensitivity",
    value: function reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex) {
      if (this._input === undefined) {
        throw new Error("Invalid state");
      }
      if (prediction !== this.conflictingAltResolvedBySLL) {
        this.decisions[this.currentDecision].contextSensitivities.push(new ContextSensitivityInfo_1.ContextSensitivityInfo(this.currentDecision, acceptState, this._input, startIndex, stopIndex));
      }
      (0, _get2.default)((0, _getPrototypeOf2.default)(ProfilingATNSimulator.prototype), "reportContextSensitivity", this).call(this, dfa, prediction, acceptState, startIndex, stopIndex);
    }
  }, {
    key: "reportAttemptingFullContext",
    value: function reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex) {
      if (conflictingAlts != null) {
        this.conflictingAltResolvedBySLL = conflictingAlts.nextSetBit(0);
      } else {
        this.conflictingAltResolvedBySLL = conflictState.s0.configs.getRepresentedAlternatives().nextSetBit(0);
      }
      this.decisions[this.currentDecision].LL_Fallback++;
      (0, _get2.default)((0, _getPrototypeOf2.default)(ProfilingATNSimulator.prototype), "reportAttemptingFullContext", this).call(this, dfa, conflictingAlts, conflictState, startIndex, stopIndex);
    }
  }, {
    key: "reportAmbiguity",
    value: function reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs) {
      if (this.currentState === undefined || this._input === undefined) {
        throw new Error("Invalid state");
      }
      var prediction;
      if (ambigAlts != null) {
        prediction = ambigAlts.nextSetBit(0);
      } else {
        prediction = configs.getRepresentedAlternatives().nextSetBit(0);
      }
      if (this.conflictingAltResolvedBySLL !== ATN_1.ATN.INVALID_ALT_NUMBER && prediction !== this.conflictingAltResolvedBySLL) {
        // Even though this is an ambiguity we are reporting, we can
        // still detect some context sensitivities.  Both SLL and LL
        // are showing a conflict, hence an ambiguity, but if they resolve
        // to different minimum alternatives we have also identified a
        // context sensitivity.
        this.decisions[this.currentDecision].contextSensitivities.push(new ContextSensitivityInfo_1.ContextSensitivityInfo(this.currentDecision, this.currentState, this._input, startIndex, stopIndex));
      }
      this.decisions[this.currentDecision].ambiguities.push(new AmbiguityInfo_1.AmbiguityInfo(this.currentDecision, this.currentState, ambigAlts, this._input, startIndex, stopIndex));
      (0, _get2.default)((0, _getPrototypeOf2.default)(ProfilingATNSimulator.prototype), "reportAmbiguity", this).call(this, dfa, D, startIndex, stopIndex, exact, ambigAlts, configs);
    }
    // ---------------------------------------------------------------------
  }, {
    key: "getDecisionInfo",
    value: function getDecisionInfo() {
      return this.decisions;
    }
  }, {
    key: "getCurrentState",
    value: function getCurrentState() {
      return this.currentState;
    }
  }]);
  return ProfilingATNSimulator;
}(ParserATNSimulator_1.ParserATNSimulator);
__decorate([Decorators_1.Override, __param(0, Decorators_1.NotNull)], ProfilingATNSimulator.prototype, "adaptivePredict", null);
__decorate([Decorators_1.Override], ProfilingATNSimulator.prototype, "getStartState", null);
__decorate([Decorators_1.Override], ProfilingATNSimulator.prototype, "computeStartState", null);
__decorate([Decorators_1.Override], ProfilingATNSimulator.prototype, "computeReachSet", null);
__decorate([Decorators_1.Override], ProfilingATNSimulator.prototype, "getExistingTargetState", null);
__decorate([Decorators_1.Override], ProfilingATNSimulator.prototype, "computeTargetState", null);
__decorate([Decorators_1.Override], ProfilingATNSimulator.prototype, "evalSemanticContextImpl", null);
__decorate([Decorators_1.Override], ProfilingATNSimulator.prototype, "reportContextSensitivity", null);
__decorate([Decorators_1.Override], ProfilingATNSimulator.prototype, "reportAttemptingFullContext", null);
__decorate([Decorators_1.Override, __param(0, Decorators_1.NotNull), __param(5, Decorators_1.NotNull), __param(6, Decorators_1.NotNull)], ProfilingATNSimulator.prototype, "reportAmbiguity", null);
exports.ProfilingATNSimulator = ProfilingATNSimulator;

}).call(this)}).call(this,require('_process'))

},{"../Decorators":272,"./ATN":299,"./ATNSimulator":304,"./AmbiguityInfo":309,"./ContextSensitivityInfo":316,"./DecisionInfo":318,"./ErrorInfo":321,"./LookaheadEventInfo":335,"./ParserATNSimulator":340,"./PredicateEvalInfo":344,"./SemanticContext":354,"./SimulatorState":356,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/get":234,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"_process":732,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],350:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.string.from-code-point.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var IntervalSet_1 = require("../misc/IntervalSet");
var Decorators_1 = require("../Decorators");
var Transition_1 = require("./Transition");
var RangeTransition = /*#__PURE__*/function (_Transition_1$Transit) {
  (0, _inherits2.default)(RangeTransition, _Transition_1$Transit);
  var _super = _createSuper(RangeTransition);
  function RangeTransition(target, from, to) {
    var _this;
    (0, _classCallCheck2.default)(this, RangeTransition);
    _this = _super.call(this, target);
    _this.from = from;
    _this.to = to;
    return _this;
  }
  (0, _createClass2.default)(RangeTransition, [{
    key: "serializationType",
    get: function get() {
      return 2 /* RANGE */;
    }
  }, {
    key: "label",
    get: function get() {
      return IntervalSet_1.IntervalSet.of(this.from, this.to);
    }
  }, {
    key: "matches",
    value: function matches(symbol, minVocabSymbol, maxVocabSymbol) {
      return symbol >= this.from && symbol <= this.to;
    }
  }, {
    key: "toString",
    value: function toString() {
      return "'" + String.fromCodePoint(this.from) + "'..'" + String.fromCodePoint(this.to) + "'";
    }
  }]);
  return RangeTransition;
}(Transition_1.Transition);
__decorate([Decorators_1.Override], RangeTransition.prototype, "serializationType", null);
__decorate([Decorators_1.Override, Decorators_1.NotNull], RangeTransition.prototype, "label", null);
__decorate([Decorators_1.Override], RangeTransition.prototype, "matches", null);
__decorate([Decorators_1.Override, Decorators_1.NotNull], RangeTransition.prototype, "toString", null);
RangeTransition = __decorate([__param(0, Decorators_1.NotNull)], RangeTransition);
exports.RangeTransition = RangeTransition;

},{"../Decorators":272,"../misc/IntervalSet":379,"./Transition":361,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.string.from-code-point.js":624}],351:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:36.6806851-07:00
var ATNState_1 = require("./ATNState");
var ATNStateType_1 = require("./ATNStateType");
var Decorators_1 = require("../Decorators");
var RuleStartState = /*#__PURE__*/function (_ATNState_1$ATNState) {
  (0, _inherits2.default)(RuleStartState, _ATNState_1$ATNState);
  var _super = _createSuper(RuleStartState);
  function RuleStartState() {
    var _this;
    (0, _classCallCheck2.default)(this, RuleStartState);
    _this = _super.apply(this, arguments);
    _this.isPrecedenceRule = false;
    _this.leftFactored = false;
    return _this;
  }
  (0, _createClass2.default)(RuleStartState, [{
    key: "stateType",
    get: function get() {
      return ATNStateType_1.ATNStateType.RULE_START;
    }
  }]);
  return RuleStartState;
}(ATNState_1.ATNState);
__decorate([Decorators_1.Override], RuleStartState.prototype, "stateType", null);
exports.RuleStartState = RuleStartState;

},{"../Decorators":272,"./ATNState":305,"./ATNStateType":306,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],352:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:36.7513856-07:00
var ATNState_1 = require("./ATNState");
var ATNStateType_1 = require("./ATNStateType");
var Decorators_1 = require("../Decorators");
/** The last node in the ATN for a rule, unless that rule is the start symbol.
 *  In that case, there is one transition to EOF. Later, we might encode
 *  references to all calls to this rule to compute FOLLOW sets for
 *  error handling.
 */
var RuleStopState = /*#__PURE__*/function (_ATNState_1$ATNState) {
  (0, _inherits2.default)(RuleStopState, _ATNState_1$ATNState);
  var _super = _createSuper(RuleStopState);
  function RuleStopState() {
    (0, _classCallCheck2.default)(this, RuleStopState);
    return _super.apply(this, arguments);
  }
  (0, _createClass2.default)(RuleStopState, [{
    key: "nonStopStateNumber",
    get: function get() {
      return -1;
    }
  }, {
    key: "stateType",
    get: function get() {
      return ATNStateType_1.ATNStateType.RULE_STOP;
    }
  }]);
  return RuleStopState;
}(ATNState_1.ATNState);
__decorate([Decorators_1.Override], RuleStopState.prototype, "nonStopStateNumber", null);
__decorate([Decorators_1.Override], RuleStopState.prototype, "stateType", null);
exports.RuleStopState = RuleStopState;

},{"../Decorators":272,"./ATNState":305,"./ATNStateType":306,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],353:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var Decorators_1 = require("../Decorators");
var Transition_1 = require("./Transition");
/** */
var RuleTransition = /*#__PURE__*/function (_Transition_1$Transit) {
  (0, _inherits2.default)(RuleTransition, _Transition_1$Transit);
  var _super = _createSuper(RuleTransition);
  function RuleTransition(ruleStart, ruleIndex, precedence, followState) {
    var _this;
    (0, _classCallCheck2.default)(this, RuleTransition);
    _this = _super.call(this, ruleStart);
    _this.tailCall = false;
    _this.optimizedTailCall = false;
    _this.ruleIndex = ruleIndex;
    _this.precedence = precedence;
    _this.followState = followState;
    return _this;
  }
  (0, _createClass2.default)(RuleTransition, [{
    key: "serializationType",
    get: function get() {
      return 3 /* RULE */;
    }
  }, {
    key: "isEpsilon",
    get: function get() {
      return true;
    }
  }, {
    key: "matches",
    value: function matches(symbol, minVocabSymbol, maxVocabSymbol) {
      return false;
    }
  }]);
  return RuleTransition;
}(Transition_1.Transition);
__decorate([Decorators_1.NotNull], RuleTransition.prototype, "followState", void 0);
__decorate([Decorators_1.Override], RuleTransition.prototype, "serializationType", null);
__decorate([Decorators_1.Override], RuleTransition.prototype, "isEpsilon", null);
__decorate([Decorators_1.Override], RuleTransition.prototype, "matches", null);
RuleTransition = __decorate([__param(0, Decorators_1.NotNull), __param(3, Decorators_1.NotNull)], RuleTransition);
exports.RuleTransition = RuleTransition;

},{"../Decorators":272,"./Transition":361,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],354:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.array.splice.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.array.join.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:36.9521478-07:00
var Array2DHashSet_1 = require("../misc/Array2DHashSet");
var ArrayEqualityComparator_1 = require("../misc/ArrayEqualityComparator");
var MurmurHash_1 = require("../misc/MurmurHash");
var Decorators_1 = require("../Decorators");
var ObjectEqualityComparator_1 = require("../misc/ObjectEqualityComparator");
var Utils = require("../misc/Utils");
function max(items) {
  var result;
  var _iterator = _createForOfIteratorHelper(items),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var current = _step.value;
      if (result === undefined) {
        result = current;
        continue;
      }
      var comparison = result.compareTo(current);
      if (comparison < 0) {
        result = current;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return result;
}
function min(items) {
  var result;
  var _iterator2 = _createForOfIteratorHelper(items),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var current = _step2.value;
      if (result === undefined) {
        result = current;
        continue;
      }
      var comparison = result.compareTo(current);
      if (comparison > 0) {
        result = current;
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return result;
}
/** A tree structure used to record the semantic context in which
 *  an ATN configuration is valid.  It's either a single predicate,
 *  a conjunction `p1&&p2`, or a sum of products `p1||p2`.
 *
 *  I have scoped the {@link AND}, {@link OR}, and {@link Predicate} subclasses of
 *  {@link SemanticContext} within the scope of this outer class.
 */
var SemanticContext = /*#__PURE__*/function () {
  function SemanticContext() {
    (0, _classCallCheck2.default)(this, SemanticContext);
  }
  (0, _createClass2.default)(SemanticContext, [{
    key: "evalPrecedence",
    value:
    /**
     * Evaluate the precedence predicates for the context and reduce the result.
     *
     * @param parser The parser instance.
     * @param parserCallStack
     * @returns The simplified semantic context after precedence predicates are
     * evaluated, which will be one of the following values.
     *
     * * {@link #NONE}: if the predicate simplifies to `true` after
     *   precedence predicates are evaluated.
     * * `undefined`: if the predicate simplifies to `false` after
     *   precedence predicates are evaluated.
     * * `this`: if the semantic context is not changed as a result of
     *   precedence predicate evaluation.
     * * A non-`undefined` {@link SemanticContext}: the new simplified
     *   semantic context after precedence predicates are evaluated.
     */
    function evalPrecedence(parser, parserCallStack) {
      return this;
    }
  }], [{
    key: "NONE",
    get:
    /**
     * The default {@link SemanticContext}, which is semantically equivalent to
     * a predicate of the form `{true}?`.
     */
    function get() {
      if (SemanticContext._NONE === undefined) {
        SemanticContext._NONE = new SemanticContext.Predicate();
      }
      return SemanticContext._NONE;
    }
  }, {
    key: "and",
    value: function and(a, b) {
      if (!a || a === SemanticContext.NONE) {
        return b;
      }
      if (b === SemanticContext.NONE) {
        return a;
      }
      var result = new SemanticContext.AND(a, b);
      if (result.opnds.length === 1) {
        return result.opnds[0];
      }
      return result;
    }
    /**
     *
     *  @see ParserATNSimulator#getPredsForAmbigAlts
     */
  }, {
    key: "or",
    value: function or(a, b) {
      if (!a) {
        return b;
      }
      if (a === SemanticContext.NONE || b === SemanticContext.NONE) {
        return SemanticContext.NONE;
      }
      var result = new SemanticContext.OR(a, b);
      if (result.opnds.length === 1) {
        return result.opnds[0];
      }
      return result;
    }
  }]);
  return SemanticContext;
}();
exports.SemanticContext = SemanticContext;
(function (SemanticContext) {
  /**
   * This random 30-bit prime represents the value of `AND.class.hashCode()`.
   */
  var AND_HASHCODE = 40363613;
  /**
   * This random 30-bit prime represents the value of `OR.class.hashCode()`.
   */
  var OR_HASHCODE = 486279973;
  function filterPrecedencePredicates(collection) {
    var result = [];
    for (var i = 0; i < collection.length; i++) {
      var context = collection[i];
      if (context instanceof SemanticContext.PrecedencePredicate) {
        result.push(context);
        // Remove the item from 'collection' and move i back so we look at the same index again
        collection.splice(i, 1);
        i--;
      }
    }
    return result;
  }
  var Predicate = /*#__PURE__*/function (_SemanticContext) {
    (0, _inherits2.default)(Predicate, _SemanticContext);
    var _super = _createSuper(Predicate);
    function Predicate() {
      var _this;
      var ruleIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
      var predIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
      var isCtxDependent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      (0, _classCallCheck2.default)(this, Predicate);
      _this = _super.call(this);
      _this.ruleIndex = ruleIndex;
      _this.predIndex = predIndex;
      _this.isCtxDependent = isCtxDependent;
      return _this;
    }
    (0, _createClass2.default)(Predicate, [{
      key: "eval",
      value: function _eval(parser, parserCallStack) {
        var localctx = this.isCtxDependent ? parserCallStack : undefined;
        return parser.sempred(localctx, this.ruleIndex, this.predIndex);
      }
    }, {
      key: "hashCode",
      value: function hashCode() {
        var hashCode = MurmurHash_1.MurmurHash.initialize();
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.ruleIndex);
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.predIndex);
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.isCtxDependent ? 1 : 0);
        hashCode = MurmurHash_1.MurmurHash.finish(hashCode, 3);
        return hashCode;
      }
    }, {
      key: "equals",
      value: function equals(obj) {
        if (!(obj instanceof Predicate)) {
          return false;
        }
        if (this === obj) {
          return true;
        }
        return this.ruleIndex === obj.ruleIndex && this.predIndex === obj.predIndex && this.isCtxDependent === obj.isCtxDependent;
      }
    }, {
      key: "toString",
      value: function toString() {
        return "{" + this.ruleIndex + ":" + this.predIndex + "}?";
      }
    }]);
    return Predicate;
  }(SemanticContext);
  __decorate([Decorators_1.Override], Predicate.prototype, "eval", null);
  __decorate([Decorators_1.Override], Predicate.prototype, "hashCode", null);
  __decorate([Decorators_1.Override], Predicate.prototype, "equals", null);
  __decorate([Decorators_1.Override], Predicate.prototype, "toString", null);
  SemanticContext.Predicate = Predicate;
  var PrecedencePredicate = /*#__PURE__*/function (_SemanticContext2) {
    (0, _inherits2.default)(PrecedencePredicate, _SemanticContext2);
    var _super2 = _createSuper(PrecedencePredicate);
    function PrecedencePredicate(precedence) {
      var _this2;
      (0, _classCallCheck2.default)(this, PrecedencePredicate);
      _this2 = _super2.call(this);
      _this2.precedence = precedence;
      return _this2;
    }
    (0, _createClass2.default)(PrecedencePredicate, [{
      key: "eval",
      value: function _eval(parser, parserCallStack) {
        return parser.precpred(parserCallStack, this.precedence);
      }
    }, {
      key: "evalPrecedence",
      value: function evalPrecedence(parser, parserCallStack) {
        if (parser.precpred(parserCallStack, this.precedence)) {
          return SemanticContext.NONE;
        } else {
          return undefined;
        }
      }
    }, {
      key: "compareTo",
      value: function compareTo(o) {
        return this.precedence - o.precedence;
      }
    }, {
      key: "hashCode",
      value: function hashCode() {
        var hashCode = 1;
        hashCode = 31 * hashCode + this.precedence;
        return hashCode;
      }
    }, {
      key: "equals",
      value: function equals(obj) {
        if (!(obj instanceof PrecedencePredicate)) {
          return false;
        }
        if (this === obj) {
          return true;
        }
        return this.precedence === obj.precedence;
      }
    }, {
      key: "toString",
      value: function toString() {
        return "{" + this.precedence + ">=prec}?";
      }
    }]);
    return PrecedencePredicate;
  }(SemanticContext);
  __decorate([Decorators_1.Override], PrecedencePredicate.prototype, "eval", null);
  __decorate([Decorators_1.Override], PrecedencePredicate.prototype, "evalPrecedence", null);
  __decorate([Decorators_1.Override], PrecedencePredicate.prototype, "compareTo", null);
  __decorate([Decorators_1.Override], PrecedencePredicate.prototype, "hashCode", null);
  __decorate([Decorators_1.Override], PrecedencePredicate.prototype, "equals", null);
  __decorate([Decorators_1.Override
  // precedence >= _precedenceStack.peek()
  ], PrecedencePredicate.prototype, "toString", null);
  SemanticContext.PrecedencePredicate = PrecedencePredicate;
  /**
   * This is the base class for semantic context "operators", which operate on
   * a collection of semantic context "operands".
   *
   * @since 4.3
   */
  var Operator = /*#__PURE__*/function (_SemanticContext3) {
    (0, _inherits2.default)(Operator, _SemanticContext3);
    var _super3 = _createSuper(Operator);
    function Operator() {
      (0, _classCallCheck2.default)(this, Operator);
      return _super3.apply(this, arguments);
    }
    return (0, _createClass2.default)(Operator);
  }(SemanticContext);
  SemanticContext.Operator = Operator;
  /**
   * A semantic context which is true whenever none of the contained contexts
   * is false.
   */
  var AND = /*#__PURE__*/function (_Operator) {
    (0, _inherits2.default)(AND, _Operator);
    var _super4 = _createSuper(AND);
    function AND(a, b) {
      var _this3;
      (0, _classCallCheck2.default)(this, AND);
      _this3 = _super4.call(this);
      var operands = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
      if (a instanceof AND) {
        operands.addAll(a.opnds);
      } else {
        operands.add(a);
      }
      if (b instanceof AND) {
        operands.addAll(b.opnds);
      } else {
        operands.add(b);
      }
      _this3.opnds = operands.toArray();
      var precedencePredicates = filterPrecedencePredicates(_this3.opnds);
      // interested in the transition with the lowest precedence
      var reduced = min(precedencePredicates);
      if (reduced) {
        _this3.opnds.push(reduced);
      }
      return _this3;
    }
    (0, _createClass2.default)(AND, [{
      key: "operands",
      get: function get() {
        return this.opnds;
      }
    }, {
      key: "equals",
      value: function equals(obj) {
        if (this === obj) {
          return true;
        }
        if (!(obj instanceof AND)) {
          return false;
        }
        return ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this.opnds, obj.opnds);
      }
    }, {
      key: "hashCode",
      value: function hashCode() {
        return MurmurHash_1.MurmurHash.hashCode(this.opnds, AND_HASHCODE);
      }
      /**
       * {@inheritDoc}
       *
       * The evaluation of predicates by this context is short-circuiting, but
       * unordered.
       */
    }, {
      key: "eval",
      value: function _eval(parser, parserCallStack) {
        var _iterator3 = _createForOfIteratorHelper(this.opnds),
          _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var opnd = _step3.value;
            if (!opnd.eval(parser, parserCallStack)) {
              return false;
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        return true;
      }
    }, {
      key: "evalPrecedence",
      value: function evalPrecedence(parser, parserCallStack) {
        var differs = false;
        var operands = [];
        var _iterator4 = _createForOfIteratorHelper(this.opnds),
          _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var context = _step4.value;
            var evaluated = context.evalPrecedence(parser, parserCallStack);
            differs = differs || evaluated !== context;
            if (evaluated == null) {
              // The AND context is false if any element is false
              return undefined;
            } else if (evaluated !== SemanticContext.NONE) {
              // Reduce the result by skipping true elements
              operands.push(evaluated);
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
        if (!differs) {
          return this;
        }
        if (operands.length === 0) {
          // all elements were true, so the AND context is true
          return SemanticContext.NONE;
        }
        var result = operands[0];
        for (var i = 1; i < operands.length; i++) {
          result = SemanticContext.and(result, operands[i]);
        }
        return result;
      }
    }, {
      key: "toString",
      value: function toString() {
        return Utils.join(this.opnds, "&&");
      }
    }]);
    return AND;
  }(Operator);
  __decorate([Decorators_1.Override], AND.prototype, "operands", null);
  __decorate([Decorators_1.Override], AND.prototype, "equals", null);
  __decorate([Decorators_1.Override], AND.prototype, "hashCode", null);
  __decorate([Decorators_1.Override], AND.prototype, "eval", null);
  __decorate([Decorators_1.Override], AND.prototype, "evalPrecedence", null);
  __decorate([Decorators_1.Override], AND.prototype, "toString", null);
  AND = __decorate([__param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)], AND);
  SemanticContext.AND = AND;
  /**
   * A semantic context which is true whenever at least one of the contained
   * contexts is true.
   */
  var OR = /*#__PURE__*/function (_Operator2) {
    (0, _inherits2.default)(OR, _Operator2);
    var _super5 = _createSuper(OR);
    function OR(a, b) {
      var _this4;
      (0, _classCallCheck2.default)(this, OR);
      _this4 = _super5.call(this);
      var operands = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
      if (a instanceof OR) {
        operands.addAll(a.opnds);
      } else {
        operands.add(a);
      }
      if (b instanceof OR) {
        operands.addAll(b.opnds);
      } else {
        operands.add(b);
      }
      _this4.opnds = operands.toArray();
      var precedencePredicates = filterPrecedencePredicates(_this4.opnds);
      // interested in the transition with the highest precedence
      var reduced = max(precedencePredicates);
      if (reduced) {
        _this4.opnds.push(reduced);
      }
      return _this4;
    }
    (0, _createClass2.default)(OR, [{
      key: "operands",
      get: function get() {
        return this.opnds;
      }
    }, {
      key: "equals",
      value: function equals(obj) {
        if (this === obj) {
          return true;
        }
        if (!(obj instanceof OR)) {
          return false;
        }
        return ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this.opnds, obj.opnds);
      }
    }, {
      key: "hashCode",
      value: function hashCode() {
        return MurmurHash_1.MurmurHash.hashCode(this.opnds, OR_HASHCODE);
      }
      /**
       * {@inheritDoc}
       *
       * The evaluation of predicates by this context is short-circuiting, but
       * unordered.
       */
    }, {
      key: "eval",
      value: function _eval(parser, parserCallStack) {
        var _iterator5 = _createForOfIteratorHelper(this.opnds),
          _step5;
        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var opnd = _step5.value;
            if (opnd.eval(parser, parserCallStack)) {
              return true;
            }
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
        return false;
      }
    }, {
      key: "evalPrecedence",
      value: function evalPrecedence(parser, parserCallStack) {
        var differs = false;
        var operands = [];
        var _iterator6 = _createForOfIteratorHelper(this.opnds),
          _step6;
        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var context = _step6.value;
            var evaluated = context.evalPrecedence(parser, parserCallStack);
            differs = differs || evaluated !== context;
            if (evaluated === SemanticContext.NONE) {
              // The OR context is true if any element is true
              return SemanticContext.NONE;
            } else if (evaluated) {
              // Reduce the result by skipping false elements
              operands.push(evaluated);
            }
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }
        if (!differs) {
          return this;
        }
        if (operands.length === 0) {
          // all elements were false, so the OR context is false
          return undefined;
        }
        var result = operands[0];
        for (var i = 1; i < operands.length; i++) {
          result = SemanticContext.or(result, operands[i]);
        }
        return result;
      }
    }, {
      key: "toString",
      value: function toString() {
        return Utils.join(this.opnds, "||");
      }
    }]);
    return OR;
  }(Operator);
  __decorate([Decorators_1.Override], OR.prototype, "operands", null);
  __decorate([Decorators_1.Override], OR.prototype, "equals", null);
  __decorate([Decorators_1.Override], OR.prototype, "hashCode", null);
  __decorate([Decorators_1.Override], OR.prototype, "eval", null);
  __decorate([Decorators_1.Override], OR.prototype, "evalPrecedence", null);
  __decorate([Decorators_1.Override], OR.prototype, "toString", null);
  OR = __decorate([__param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)], OR);
  SemanticContext.OR = OR;
})(SemanticContext = exports.SemanticContext || (exports.SemanticContext = {}));

},{"../Decorators":272,"../misc/Array2DHashSet":370,"../misc/ArrayEqualityComparator":371,"../misc/MurmurHash":381,"../misc/ObjectEqualityComparator":382,"../misc/Utils":385,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.join.js":578,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.array.splice.js":582,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.promise.js":614,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],355:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var IntervalSet_1 = require("../misc/IntervalSet");
var Decorators_1 = require("../Decorators");
var Token_1 = require("../Token");
var Transition_1 = require("./Transition");
/** A transition containing a set of values. */
var SetTransition = /*#__PURE__*/function (_Transition_1$Transit) {
  (0, _inherits2.default)(SetTransition, _Transition_1$Transit);
  var _super = _createSuper(SetTransition);
  // TODO (sam): should we really allow undefined here?
  function SetTransition(target, set) {
    var _this;
    (0, _classCallCheck2.default)(this, SetTransition);
    _this = _super.call(this, target);
    if (set == null) {
      set = IntervalSet_1.IntervalSet.of(Token_1.Token.INVALID_TYPE);
    }
    _this.set = set;
    return _this;
  }
  (0, _createClass2.default)(SetTransition, [{
    key: "serializationType",
    get: function get() {
      return 7 /* SET */;
    }
  }, {
    key: "label",
    get: function get() {
      return this.set;
    }
  }, {
    key: "matches",
    value: function matches(symbol, minVocabSymbol, maxVocabSymbol) {
      return this.set.contains(symbol);
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.set.toString();
    }
  }]);
  return SetTransition;
}(Transition_1.Transition);
__decorate([Decorators_1.NotNull], SetTransition.prototype, "set", void 0);
__decorate([Decorators_1.Override], SetTransition.prototype, "serializationType", null);
__decorate([Decorators_1.Override, Decorators_1.NotNull], SetTransition.prototype, "label", null);
__decorate([Decorators_1.Override], SetTransition.prototype, "matches", null);
__decorate([Decorators_1.Override, Decorators_1.NotNull], SetTransition.prototype, "toString", null);
SetTransition = __decorate([__param(0, Decorators_1.NotNull), __param(1, Decorators_1.Nullable)], SetTransition);
exports.SetTransition = SetTransition;

},{"../Decorators":272,"../Token":296,"../misc/IntervalSet":379,"./Transition":361,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.to-string.js":620}],356:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var Decorators_1 = require("../Decorators");
var ParserRuleContext_1 = require("../ParserRuleContext");
/**
 *
 * @author Sam Harwell
 */
var SimulatorState = /*#__PURE__*/(0, _createClass2.default)(function SimulatorState(outerContext, s0, useContext, remainingOuterContext) {
  (0, _classCallCheck2.default)(this, SimulatorState);
  this.outerContext = outerContext != null ? outerContext : ParserRuleContext_1.ParserRuleContext.emptyContext();
  this.s0 = s0;
  this.useContext = useContext;
  this.remainingOuterContext = remainingOuterContext;
});
SimulatorState = __decorate([__param(1, Decorators_1.NotNull)], SimulatorState);
exports.SimulatorState = SimulatorState;

},{"../Decorators":272,"../ParserRuleContext":287,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612}],357:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var ATNStateType_1 = require("./ATNStateType");
var BlockStartState_1 = require("./BlockStartState");
var Decorators_1 = require("../Decorators");
/** The block that begins a closure loop. */
var StarBlockStartState = /*#__PURE__*/function (_BlockStartState_1$Bl) {
  (0, _inherits2.default)(StarBlockStartState, _BlockStartState_1$Bl);
  var _super = _createSuper(StarBlockStartState);
  function StarBlockStartState() {
    (0, _classCallCheck2.default)(this, StarBlockStartState);
    return _super.apply(this, arguments);
  }
  (0, _createClass2.default)(StarBlockStartState, [{
    key: "stateType",
    get: function get() {
      return ATNStateType_1.ATNStateType.STAR_BLOCK_START;
    }
  }]);
  return StarBlockStartState;
}(BlockStartState_1.BlockStartState);
__decorate([Decorators_1.Override], StarBlockStartState.prototype, "stateType", null);
exports.StarBlockStartState = StarBlockStartState;

},{"../Decorators":272,"./ATNStateType":306,"./BlockStartState":314,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],358:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:37.7099201-07:00
var ATNStateType_1 = require("./ATNStateType");
var BitSet_1 = require("../misc/BitSet");
var DecisionState_1 = require("./DecisionState");
var Decorators_1 = require("../Decorators");
var StarLoopEntryState = /*#__PURE__*/function (_DecisionState_1$Deci) {
  (0, _inherits2.default)(StarLoopEntryState, _DecisionState_1$Deci);
  var _super = _createSuper(StarLoopEntryState);
  function StarLoopEntryState() {
    var _this;
    (0, _classCallCheck2.default)(this, StarLoopEntryState);
    _this = _super.apply(this, arguments);
    /**
     * Indicates whether this state can benefit from a precedence DFA during SLL
     * decision making.
     *
     * This is a computed property that is calculated during ATN deserialization
     * and stored for use in {@link ParserATNSimulator} and
     * {@link ParserInterpreter}.
     *
     * @see `DFA.isPrecedenceDfa`
     */
    _this.precedenceRuleDecision = false;
    /**
     * For precedence decisions, this set marks states *S* which have all
     * of the following characteristics:
     *
     * * One or more invocation sites of the current rule returns to
     *   *S*.
     * * The closure from *S* includes the current decision without
     *   passing through any rule invocations or stepping out of the current
     *   rule.
     *
     * This field is not used when {@link #precedenceRuleDecision} is
     * `false`.
     */
    _this.precedenceLoopbackStates = new BitSet_1.BitSet();
    return _this;
  }
  (0, _createClass2.default)(StarLoopEntryState, [{
    key: "stateType",
    get: function get() {
      return ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY;
    }
  }]);
  return StarLoopEntryState;
}(DecisionState_1.DecisionState);
__decorate([Decorators_1.Override], StarLoopEntryState.prototype, "stateType", null);
exports.StarLoopEntryState = StarLoopEntryState;

},{"../Decorators":272,"../misc/BitSet":373,"./ATNStateType":306,"./DecisionState":319,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],359:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:37.6368726-07:00
var ATNState_1 = require("./ATNState");
var ATNStateType_1 = require("./ATNStateType");
var Decorators_1 = require("../Decorators");
var StarLoopbackState = /*#__PURE__*/function (_ATNState_1$ATNState) {
  (0, _inherits2.default)(StarLoopbackState, _ATNState_1$ATNState);
  var _super = _createSuper(StarLoopbackState);
  function StarLoopbackState() {
    (0, _classCallCheck2.default)(this, StarLoopbackState);
    return _super.apply(this, arguments);
  }
  (0, _createClass2.default)(StarLoopbackState, [{
    key: "loopEntryState",
    get: function get() {
      return this.transition(0).target;
    }
  }, {
    key: "stateType",
    get: function get() {
      return ATNStateType_1.ATNStateType.STAR_LOOP_BACK;
    }
  }]);
  return StarLoopbackState;
}(ATNState_1.ATNState);
__decorate([Decorators_1.Override], StarLoopbackState.prototype, "stateType", null);
exports.StarLoopbackState = StarLoopbackState;

},{"../Decorators":272,"./ATNState":305,"./ATNStateType":306,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],360:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:37.7814046-07:00
var ATNStateType_1 = require("./ATNStateType");
var DecisionState_1 = require("./DecisionState");
var Decorators_1 = require("../Decorators");
/** The Tokens rule start state linking to each lexer rule start state */
var TokensStartState = /*#__PURE__*/function (_DecisionState_1$Deci) {
  (0, _inherits2.default)(TokensStartState, _DecisionState_1$Deci);
  var _super = _createSuper(TokensStartState);
  function TokensStartState() {
    (0, _classCallCheck2.default)(this, TokensStartState);
    return _super.apply(this, arguments);
  }
  (0, _createClass2.default)(TokensStartState, [{
    key: "stateType",
    get: function get() {
      return ATNStateType_1.ATNStateType.TOKEN_START;
    }
  }]);
  return TokensStartState;
}(DecisionState_1.DecisionState);
__decorate([Decorators_1.Override], TokensStartState.prototype, "stateType", null);
exports.TokensStartState = TokensStartState;

},{"../Decorators":272,"./ATNStateType":306,"./DecisionState":319,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],361:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var Decorators_1 = require("../Decorators");
/** An ATN transition between any two ATN states.  Subclasses define
 *  atom, set, epsilon, action, predicate, rule transitions.
 *
 *  This is a one way link.  It emanates from a state (usually via a list of
 *  transitions) and has a target state.
 *
 *  Since we never have to change the ATN transitions once we construct it,
 *  we can fix these transitions as specific classes. The DFA transitions
 *  on the other hand need to update the labels as it adds transitions to
 *  the states. We'll use the term Edge for the DFA to distinguish them from
 *  ATN transitions.
 */
var Transition = /*#__PURE__*/function () {
  function Transition(target) {
    (0, _classCallCheck2.default)(this, Transition);
    if (target == null) {
      throw new Error("target cannot be null.");
    }
    this.target = target;
  }
  /**
   * Determines if the transition is an "epsilon" transition.
   *
   * The default implementation returns `false`.
   *
   * @returns `true` if traversing this transition in the ATN does not
   * consume an input symbol; otherwise, `false` if traversing this
   * transition consumes (matches) an input symbol.
   */
  (0, _createClass2.default)(Transition, [{
    key: "isEpsilon",
    get: function get() {
      return false;
    }
  }, {
    key: "label",
    get: function get() {
      return undefined;
    }
  }]);
  return Transition;
}();
Transition.serializationNames = ["INVALID", "EPSILON", "RANGE", "RULE", "PREDICATE", "ATOM", "ACTION", "SET", "NOT_SET", "WILDCARD", "PRECEDENCE"];
__decorate([Decorators_1.NotNull], Transition.prototype, "target", void 0);
Transition = __decorate([__param(0, Decorators_1.NotNull)], Transition);
exports.Transition = Transition;

},{"../Decorators":272,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612}],362:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var Decorators_1 = require("../Decorators");
var Transition_1 = require("./Transition");
var WildcardTransition = /*#__PURE__*/function (_Transition_1$Transit) {
  (0, _inherits2.default)(WildcardTransition, _Transition_1$Transit);
  var _super = _createSuper(WildcardTransition);
  function WildcardTransition(target) {
    (0, _classCallCheck2.default)(this, WildcardTransition);
    return _super.call(this, target);
  }
  (0, _createClass2.default)(WildcardTransition, [{
    key: "serializationType",
    get: function get() {
      return 9 /* WILDCARD */;
    }
  }, {
    key: "matches",
    value: function matches(symbol, minVocabSymbol, maxVocabSymbol) {
      return symbol >= minVocabSymbol && symbol <= maxVocabSymbol;
    }
  }, {
    key: "toString",
    value: function toString() {
      return ".";
    }
  }]);
  return WildcardTransition;
}(Transition_1.Transition);
__decorate([Decorators_1.Override], WildcardTransition.prototype, "serializationType", null);
__decorate([Decorators_1.Override], WildcardTransition.prototype, "matches", null);
__decorate([Decorators_1.Override, Decorators_1.NotNull], WildcardTransition.prototype, "toString", null);
WildcardTransition = __decorate([__param(0, Decorators_1.NotNull)], WildcardTransition);
exports.WildcardTransition = WildcardTransition;

},{"../Decorators":272,"./Transition":361,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],363:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Stores information about a {@link DFAState} which is an accept state under
 * some condition. Certain settings, such as
 * {@link ParserATNSimulator#getPredictionMode()}, may be used in addition to
 * this information to determine whether or not a particular state is an accept
 * state.
 *
 * @author Sam Harwell
 */
var AcceptStateInfo = /*#__PURE__*/function () {
  function AcceptStateInfo(prediction, lexerActionExecutor) {
    (0, _classCallCheck2.default)(this, AcceptStateInfo);
    this._prediction = prediction;
    this._lexerActionExecutor = lexerActionExecutor;
  }
  /**
   * Gets the prediction made by this accept state. Note that this value
   * assumes the predicates, if any, in the {@link DFAState} evaluate to
   * `true`. If predicate evaluation is enabled, the final prediction of
   * the accept state will be determined by the result of predicate
   * evaluation.
   */
  (0, _createClass2.default)(AcceptStateInfo, [{
    key: "prediction",
    get: function get() {
      return this._prediction;
    }
    /**
     * Gets the {@link LexerActionExecutor} which can be used to execute actions
     * and/or commands after the lexer matches a token.
     */
  }, {
    key: "lexerActionExecutor",
    get: function get() {
      return this._lexerActionExecutor;
    }
  }]);
  return AcceptStateInfo;
}();
exports.AcceptStateInfo = AcceptStateInfo;

},{"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237}],364:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:38.3567094-07:00
var Array2DHashSet_1 = require("../misc/Array2DHashSet");
var ATNConfigSet_1 = require("../atn/ATNConfigSet");
var DFASerializer_1 = require("./DFASerializer");
var DFAState_1 = require("./DFAState");
var LexerDFASerializer_1 = require("./LexerDFASerializer");
var Decorators_1 = require("../Decorators");
var ObjectEqualityComparator_1 = require("../misc/ObjectEqualityComparator");
var StarLoopEntryState_1 = require("../atn/StarLoopEntryState");
var VocabularyImpl_1 = require("../VocabularyImpl");
var DFA = /*#__PURE__*/function () {
  function DFA(atnStartState) {
    var decision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    (0, _classCallCheck2.default)(this, DFA);
    /**
     * A set of all states in the `DFA`.
     *
     * Note that this collection of states holds the DFA states for both SLL and LL prediction. Only the start state
     * needs to be differentiated for these cases, which is tracked by the `s0` and `s0full` fields.
     */
    this.states = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
    this.nextStateNumber = 0;
    if (!atnStartState.atn) {
      throw new Error("The ATNState must be associated with an ATN");
    }
    this.atnStartState = atnStartState;
    this.atn = atnStartState.atn;
    this.decision = decision;
    // Precedence DFAs are associated with the special precedence decision created for left-recursive rules which
    // evaluate their alternatives using a precedence hierarchy. When such a decision is encountered, we mark this
    // DFA instance as a precedence DFA and initialize the initial states s0 and s0full to special DFAState
    // instances which use outgoing edges to link to the actual start state used for each precedence level.
    var isPrecedenceDfa = false;
    if (atnStartState instanceof StarLoopEntryState_1.StarLoopEntryState) {
      if (atnStartState.precedenceRuleDecision) {
        isPrecedenceDfa = true;
        this.s0 = new DFAState_1.DFAState(new ATNConfigSet_1.ATNConfigSet());
        this.s0full = new DFAState_1.DFAState(new ATNConfigSet_1.ATNConfigSet());
      }
    }
    this.precedenceDfa = isPrecedenceDfa;
  }
  /**
   * Gets whether this DFA is a precedence DFA. Precedence DFAs use a special
   * start state {@link #s0} which is not stored in {@link #states}. The
   * {@link DFAState#edges} array for this start state contains outgoing edges
   * supplying individual start states corresponding to specific precedence
   * values.
   *
   * @returns `true` if this is a precedence DFA; otherwise,
   * `false`.
   * @see Parser.precedence
   */
  (0, _createClass2.default)(DFA, [{
    key: "isPrecedenceDfa",
    get: function get() {
      return this.precedenceDfa;
    }
    /**
     * Get the start state for a specific precedence value.
     *
     * @param precedence The current precedence.
     * @returns The start state corresponding to the specified precedence, or
     * `undefined` if no start state exists for the specified precedence.
     *
     * @ if this is not a precedence DFA.
     * @see `isPrecedenceDfa`
     */
  }, {
    key: "getPrecedenceStartState",
    value: function getPrecedenceStartState(precedence, fullContext) {
      if (!this.isPrecedenceDfa) {
        throw new Error("Only precedence DFAs may contain a precedence start state.");
      }
      // s0 and s0full are never null for a precedence DFA
      if (fullContext) {
        return this.s0full.getTarget(precedence);
      } else {
        return this.s0.getTarget(precedence);
      }
    }
    /**
     * Set the start state for a specific precedence value.
     *
     * @param precedence The current precedence.
     * @param startState The start state corresponding to the specified
     * precedence.
     *
     * @ if this is not a precedence DFA.
     * @see `isPrecedenceDfa`
     */
  }, {
    key: "setPrecedenceStartState",
    value: function setPrecedenceStartState(precedence, fullContext, startState) {
      if (!this.isPrecedenceDfa) {
        throw new Error("Only precedence DFAs may contain a precedence start state.");
      }
      if (precedence < 0) {
        return;
      }
      if (fullContext) {
        // s0full is never null for a precedence DFA
        this.s0full.setTarget(precedence, startState);
      } else {
        // s0 is never null for a precedence DFA
        this.s0.setTarget(precedence, startState);
      }
    }
  }, {
    key: "isEmpty",
    get: function get() {
      if (this.isPrecedenceDfa) {
        // s0 and s0full are never null for a precedence DFA
        return this.s0.getEdgeMap().size === 0 && this.s0full.getEdgeMap().size === 0;
      }
      return this.s0 == null && this.s0full == null;
    }
  }, {
    key: "isContextSensitive",
    get: function get() {
      if (this.isPrecedenceDfa) {
        // s0full is never null for a precedence DFA
        return this.s0full.getEdgeMap().size > 0;
      }
      return this.s0full != null;
    }
  }, {
    key: "addState",
    value: function addState(state) {
      state.stateNumber = this.nextStateNumber++;
      return this.states.getOrAdd(state);
    }
  }, {
    key: "toString",
    value: function toString(vocabulary, ruleNames) {
      if (!vocabulary) {
        vocabulary = VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY;
      }
      if (!this.s0) {
        return "";
      }
      var serializer;
      if (ruleNames) {
        serializer = new DFASerializer_1.DFASerializer(this, vocabulary, ruleNames, this.atnStartState.atn);
      } else {
        serializer = new DFASerializer_1.DFASerializer(this, vocabulary);
      }
      return serializer.toString();
    }
  }, {
    key: "toLexerString",
    value: function toLexerString() {
      if (!this.s0) {
        return "";
      }
      var serializer = new LexerDFASerializer_1.LexerDFASerializer(this);
      return serializer.toString();
    }
  }]);
  return DFA;
}();
__decorate([Decorators_1.NotNull], DFA.prototype, "states", void 0);
__decorate([Decorators_1.NotNull], DFA.prototype, "atnStartState", void 0);
__decorate([Decorators_1.NotNull], DFA.prototype, "atn", void 0);
DFA = __decorate([__param(0, Decorators_1.NotNull)], DFA);
exports.DFA = DFA;

},{"../Decorators":272,"../VocabularyImpl":298,"../atn/ATNConfigSet":301,"../atn/StarLoopEntryState":358,"../misc/Array2DHashSet":370,"../misc/ObjectEqualityComparator":382,"./DFASerializer":365,"./DFAState":366,"./LexerDFASerializer":367,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.to-string.js":620}],365:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _construct2 = _interopRequireDefault(require("@babel/runtime/helpers/construct"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.array.sort.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var ATNSimulator_1 = require("../atn/ATNSimulator");
var Decorators_1 = require("../Decorators");
var PredictionContext_1 = require("../atn/PredictionContext");
var Recognizer_1 = require("../Recognizer");
var VocabularyImpl_1 = require("../VocabularyImpl");
/** A DFA walker that knows how to dump them to serialized strings. */
var DFASerializer = /*#__PURE__*/function () {
  function DFASerializer(dfa, vocabulary, ruleNames, atn) {
    (0, _classCallCheck2.default)(this, DFASerializer);
    if (vocabulary instanceof Recognizer_1.Recognizer) {
      ruleNames = vocabulary.ruleNames;
      atn = vocabulary.atn;
      vocabulary = vocabulary.vocabulary;
    } else if (!vocabulary) {
      vocabulary = VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY;
    }
    this.dfa = dfa;
    this.vocabulary = vocabulary;
    this.ruleNames = ruleNames;
    this.atn = atn;
  }
  (0, _createClass2.default)(DFASerializer, [{
    key: "toString",
    value: function toString() {
      if (!this.dfa.s0) {
        return "";
      }
      var buf = "";
      if (this.dfa.states) {
        var states = (0, _construct2.default)(Array, (0, _toConsumableArray2.default)(this.dfa.states.toArray()));
        states.sort(function (o1, o2) {
          return o1.stateNumber - o2.stateNumber;
        });
        var _iterator = _createForOfIteratorHelper(states),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var s = _step.value;
            var edges = s.getEdgeMap();
            var edgeKeys = (0, _toConsumableArray2.default)(edges.keys()).sort(function (a, b) {
              return a - b;
            });
            var contextEdges = s.getContextEdgeMap();
            var contextEdgeKeys = (0, _toConsumableArray2.default)(contextEdges.keys()).sort(function (a, b) {
              return a - b;
            });
            var _iterator2 = _createForOfIteratorHelper(edgeKeys),
              _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var _entry = _step2.value;
                var value = edges.get(_entry);
                if ((value == null || value === ATNSimulator_1.ATNSimulator.ERROR) && !s.isContextSymbol(_entry)) {
                  continue;
                }
                var contextSymbol = false;
                buf += this.getStateString(s) + "-" + this.getEdgeLabel(_entry) + "->";
                if (s.isContextSymbol(_entry)) {
                  buf += "!";
                  contextSymbol = true;
                }
                var t = value;
                if (t && t.stateNumber !== ATNSimulator_1.ATNSimulator.ERROR.stateNumber) {
                  buf += this.getStateString(t) + "\n";
                } else if (contextSymbol) {
                  buf += "ctx\n";
                }
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
            if (s.isContextSensitive) {
              var _iterator3 = _createForOfIteratorHelper(contextEdgeKeys),
                _step3;
              try {
                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                  var entry = _step3.value;
                  buf += this.getStateString(s) + "-" + this.getContextLabel(entry) + "->" + this.getStateString(contextEdges.get(entry)) + "\n";
                }
              } catch (err) {
                _iterator3.e(err);
              } finally {
                _iterator3.f();
              }
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
      var output = buf;
      if (output.length === 0) {
        return "";
      }
      //return Utils.sortLinesInString(output);
      return output;
    }
  }, {
    key: "getContextLabel",
    value: function getContextLabel(i) {
      if (i === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
        return "ctx:EMPTY_FULL";
      } else if (i === PredictionContext_1.PredictionContext.EMPTY_LOCAL_STATE_KEY) {
        return "ctx:EMPTY_LOCAL";
      }
      if (this.atn && i > 0 && i <= this.atn.states.length) {
        var state = this.atn.states[i];
        var ruleIndex = state.ruleIndex;
        if (this.ruleNames && ruleIndex >= 0 && ruleIndex < this.ruleNames.length) {
          return "ctx:" + String(i) + "(" + this.ruleNames[ruleIndex] + ")";
        }
      }
      return "ctx:" + String(i);
    }
  }, {
    key: "getEdgeLabel",
    value: function getEdgeLabel(i) {
      return this.vocabulary.getDisplayName(i);
    }
  }, {
    key: "getStateString",
    value: function getStateString(s) {
      if (s === ATNSimulator_1.ATNSimulator.ERROR) {
        return "ERROR";
      }
      var n = s.stateNumber;
      var stateStr = "s" + n;
      if (s.isAcceptState) {
        if (s.predicates) {
          stateStr = ":s" + n + "=>" + s.predicates;
        } else {
          stateStr = ":s" + n + "=>" + s.prediction;
        }
      }
      if (s.isContextSensitive) {
        stateStr += "*";
        var _iterator4 = _createForOfIteratorHelper(s.configs),
          _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var config = _step4.value;
            if (config.reachesIntoOuterContext) {
              stateStr += "*";
              break;
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
      }
      return stateStr;
    }
  }]);
  return DFASerializer;
}();
__decorate([Decorators_1.NotNull], DFASerializer.prototype, "dfa", void 0);
__decorate([Decorators_1.NotNull], DFASerializer.prototype, "vocabulary", void 0);
__decorate([Decorators_1.Override], DFASerializer.prototype, "toString", null);
exports.DFASerializer = DFASerializer;

},{"../Decorators":272,"../Recognizer":291,"../VocabularyImpl":298,"../atn/ATNSimulator":304,"../atn/PredictionContext":346,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/construct":231,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/toConsumableArray":249,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.array.sort.js":581,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.promise.js":614,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],366:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.map.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.regexp.to-string.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var ATN_1 = require("../atn/ATN");
var BitSet_1 = require("../misc/BitSet");
var MurmurHash_1 = require("../misc/MurmurHash");
var Decorators_1 = require("../Decorators");
var PredictionContext_1 = require("../atn/PredictionContext");
var assert = require("assert");
/** A DFA state represents a set of possible ATN configurations.
 *  As Aho, Sethi, Ullman p. 117 says "The DFA uses its state
 *  to keep track of all possible states the ATN can be in after
 *  reading each input symbol.  That is to say, after reading
 *  input a1a2..an, the DFA is in a state that represents the
 *  subset T of the states of the ATN that are reachable from the
 *  ATN's start state along some path labeled a1a2..an."
 *  In conventional NFA&rarr;DFA conversion, therefore, the subset T
 *  would be a bitset representing the set of states the
 *  ATN could be in.  We need to track the alt predicted by each
 *  state as well, however.  More importantly, we need to maintain
 *  a stack of states, tracking the closure operations as they
 *  jump from rule to rule, emulating rule invocations (method calls).
 *  I have to add a stack to simulate the proper lookahead sequences for
 *  the underlying LL grammar from which the ATN was derived.
 *
 *  I use a set of ATNConfig objects not simple states.  An ATNConfig
 *  is both a state (ala normal conversion) and a RuleContext describing
 *  the chain of rules (if any) followed to arrive at that state.
 *
 *  A DFA state may have multiple references to a particular state,
 *  but with different ATN contexts (with same or different alts)
 *  meaning that state was reached via a different set of rule invocations.
 */
var DFAState = /*#__PURE__*/function () {
  /**
   * Constructs a new `DFAState`.
   *
   * @param configs The set of ATN configurations defining this state.
   */
  function DFAState(configs) {
    (0, _classCallCheck2.default)(this, DFAState);
    this.stateNumber = -1;
    this.configs = configs;
    this.edges = new Map();
    this.contextEdges = new Map();
  }
  (0, _createClass2.default)(DFAState, [{
    key: "isContextSensitive",
    get: function get() {
      return !!this.contextSymbols;
    }
  }, {
    key: "isContextSymbol",
    value: function isContextSymbol(symbol) {
      if (!this.isContextSensitive) {
        return false;
      }
      return this.contextSymbols.get(symbol);
    }
  }, {
    key: "setContextSymbol",
    value: function setContextSymbol(symbol) {
      assert(this.isContextSensitive);
      this.contextSymbols.set(symbol);
    }
  }, {
    key: "setContextSensitive",
    value: function setContextSensitive(atn) {
      assert(!this.configs.isOutermostConfigSet);
      if (this.isContextSensitive) {
        return;
      }
      if (!this.contextSymbols) {
        this.contextSymbols = new BitSet_1.BitSet();
      }
    }
  }, {
    key: "acceptStateInfo",
    get: function get() {
      return this._acceptStateInfo;
    },
    set: function set(acceptStateInfo) {
      this._acceptStateInfo = acceptStateInfo;
    }
  }, {
    key: "isAcceptState",
    get: function get() {
      return !!this._acceptStateInfo;
    }
  }, {
    key: "prediction",
    get: function get() {
      if (!this._acceptStateInfo) {
        return ATN_1.ATN.INVALID_ALT_NUMBER;
      }
      return this._acceptStateInfo.prediction;
    }
  }, {
    key: "lexerActionExecutor",
    get: function get() {
      if (!this._acceptStateInfo) {
        return undefined;
      }
      return this._acceptStateInfo.lexerActionExecutor;
    }
  }, {
    key: "getTarget",
    value: function getTarget(symbol) {
      return this.edges.get(symbol);
    }
  }, {
    key: "setTarget",
    value: function setTarget(symbol, target) {
      this.edges.set(symbol, target);
    }
  }, {
    key: "getEdgeMap",
    value: function getEdgeMap() {
      return this.edges;
    }
  }, {
    key: "getContextTarget",
    value: function getContextTarget(invokingState) {
      if (invokingState === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
        invokingState = -1;
      }
      return this.contextEdges.get(invokingState);
    }
  }, {
    key: "setContextTarget",
    value: function setContextTarget(invokingState, target) {
      if (!this.isContextSensitive) {
        throw new Error("The state is not context sensitive.");
      }
      if (invokingState === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
        invokingState = -1;
      }
      this.contextEdges.set(invokingState, target);
    }
  }, {
    key: "getContextEdgeMap",
    value: function getContextEdgeMap() {
      var map = new Map(this.contextEdges);
      var existing = map.get(-1);
      if (existing !== undefined) {
        if (map.size === 1) {
          var result = new Map();
          result.set(PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY, existing);
          return result;
        } else {
          map.delete(-1);
          map.set(PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY, existing);
        }
      }
      return map;
    }
  }, {
    key: "hashCode",
    value: function hashCode() {
      var hash = MurmurHash_1.MurmurHash.initialize(7);
      hash = MurmurHash_1.MurmurHash.update(hash, this.configs.hashCode());
      hash = MurmurHash_1.MurmurHash.finish(hash, 1);
      return hash;
    }
    /**
     * Two {@link DFAState} instances are equal if their ATN configuration sets
     * are the same. This method is used to see if a state already exists.
     *
     * Because the number of alternatives and number of ATN configurations are
     * finite, there is a finite number of DFA states that can be processed.
     * This is necessary to show that the algorithm terminates.
     *
     * Cannot test the DFA state numbers here because in
     * {@link ParserATNSimulator#addDFAState} we need to know if any other state
     * exists that has this exact set of ATN configurations. The
     * {@link #stateNumber} is irrelevant.
     */
  }, {
    key: "equals",
    value: function equals(o) {
      // compare set of ATN configurations in this set with other
      if (this === o) {
        return true;
      }
      if (!(o instanceof DFAState)) {
        return false;
      }
      var other = o;
      var sameSet = this.configs.equals(other.configs);
      //		System.out.println("DFAState.equals: "+configs+(sameSet?"==":"!=")+other.configs);
      return sameSet;
    }
  }, {
    key: "toString",
    value: function toString() {
      var buf = "";
      buf += this.stateNumber + ":" + this.configs;
      if (this.isAcceptState) {
        buf += "=>";
        if (this.predicates) {
          buf += this.predicates;
        } else {
          buf += this.prediction;
        }
      }
      return buf.toString();
    }
  }]);
  return DFAState;
}();
__decorate([Decorators_1.NotNull], DFAState.prototype, "configs", void 0);
__decorate([Decorators_1.NotNull], DFAState.prototype, "edges", void 0);
__decorate([Decorators_1.NotNull], DFAState.prototype, "contextEdges", void 0);
__decorate([Decorators_1.Override], DFAState.prototype, "hashCode", null);
__decorate([Decorators_1.Override], DFAState.prototype, "equals", null);
__decorate([Decorators_1.Override], DFAState.prototype, "toString", null);
exports.DFAState = DFAState;
(function (DFAState) {
  /** Map a predicate to a predicted alternative. */
  var PredPrediction = /*#__PURE__*/function () {
    function PredPrediction(pred, alt) {
      (0, _classCallCheck2.default)(this, PredPrediction);
      this.alt = alt;
      this.pred = pred;
    }
    (0, _createClass2.default)(PredPrediction, [{
      key: "toString",
      value: function toString() {
        return "(" + this.pred + ", " + this.alt + ")";
      }
    }]);
    return PredPrediction;
  }();
  __decorate([Decorators_1.NotNull], PredPrediction.prototype, "pred", void 0);
  __decorate([Decorators_1.Override], PredPrediction.prototype, "toString", null);
  PredPrediction = __decorate([__param(0, Decorators_1.NotNull)], PredPrediction);
  DFAState.PredPrediction = PredPrediction;
})(DFAState = exports.DFAState || (exports.DFAState = {}));

},{"../Decorators":272,"../atn/ATN":299,"../atn/PredictionContext":346,"../misc/BitSet":373,"../misc/MurmurHash":381,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"assert":413,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.map.js":587,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/web.dom-collections.iterator.js":677}],367:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.string.from-code-point.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var DFASerializer_1 = require("./DFASerializer");
var Decorators_1 = require("../Decorators");
var VocabularyImpl_1 = require("../VocabularyImpl");
var LexerDFASerializer = /*#__PURE__*/function (_DFASerializer_1$DFAS) {
  (0, _inherits2.default)(LexerDFASerializer, _DFASerializer_1$DFAS);
  var _super = _createSuper(LexerDFASerializer);
  function LexerDFASerializer(dfa) {
    (0, _classCallCheck2.default)(this, LexerDFASerializer);
    return _super.call(this, dfa, VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY);
  }
  (0, _createClass2.default)(LexerDFASerializer, [{
    key: "getEdgeLabel",
    value: function getEdgeLabel(i) {
      return "'" + String.fromCodePoint(i) + "'";
    }
  }]);
  return LexerDFASerializer;
}(DFASerializer_1.DFASerializer);
__decorate([Decorators_1.Override, Decorators_1.NotNull], LexerDFASerializer.prototype, "getEdgeLabel", null);
LexerDFASerializer = __decorate([__param(0, Decorators_1.NotNull)], LexerDFASerializer);
exports.LexerDFASerializer = LexerDFASerializer;

},{"../Decorators":272,"../VocabularyImpl":298,"./DFASerializer":365,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.string.from-code-point.js":624}],368:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
function __export(m) {
  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", {
  value: true
});
// export * from "./ANTLRFileStream";
__export(require("./ANTLRInputStream"));
__export(require("./BailErrorStrategy"));
__export(require("./BufferedTokenStream"));
__export(require("./CharStreams"));
__export(require("./CodePointBuffer"));
__export(require("./CodePointCharStream"));
__export(require("./CommonToken"));
__export(require("./CommonTokenFactory"));
__export(require("./CommonTokenStream"));
__export(require("./ConsoleErrorListener"));
__export(require("./DefaultErrorStrategy"));
__export(require("./Dependents"));
__export(require("./DiagnosticErrorListener"));
__export(require("./FailedPredicateException"));
__export(require("./InputMismatchException"));
__export(require("./InterpreterRuleContext"));
__export(require("./IntStream"));
__export(require("./Lexer"));
__export(require("./LexerInterpreter"));
__export(require("./LexerNoViableAltException"));
__export(require("./ListTokenSource"));
__export(require("./NoViableAltException"));
__export(require("./Parser"));
__export(require("./ParserInterpreter"));
__export(require("./ParserRuleContext"));
__export(require("./ProxyErrorListener"));
__export(require("./ProxyParserErrorListener"));
__export(require("./RecognitionException"));
__export(require("./Recognizer"));
__export(require("./RuleContext"));
__export(require("./RuleContextWithAltNum"));
__export(require("./RuleDependency"));
__export(require("./RuleVersion"));
__export(require("./Token"));
__export(require("./TokenStreamRewriter"));
__export(require("./VocabularyImpl"));

},{"./ANTLRInputStream":262,"./BailErrorStrategy":263,"./BufferedTokenStream":264,"./CharStreams":265,"./CodePointBuffer":266,"./CodePointCharStream":267,"./CommonToken":268,"./CommonTokenFactory":269,"./CommonTokenStream":270,"./ConsoleErrorListener":271,"./DefaultErrorStrategy":273,"./Dependents":274,"./DiagnosticErrorListener":275,"./FailedPredicateException":276,"./InputMismatchException":277,"./IntStream":278,"./InterpreterRuleContext":279,"./Lexer":280,"./LexerInterpreter":281,"./LexerNoViableAltException":282,"./ListTokenSource":283,"./NoViableAltException":284,"./Parser":285,"./ParserInterpreter":286,"./ParserRuleContext":287,"./ProxyErrorListener":288,"./ProxyParserErrorListener":289,"./RecognitionException":290,"./Recognizer":291,"./RuleContext":292,"./RuleContextWithAltNum":293,"./RuleDependency":294,"./RuleVersion":295,"./Token":296,"./TokenStreamRewriter":297,"./VocabularyImpl":298}],369:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
Object.defineProperty(exports, "__esModule", {
  value: true
});
var Array2DHashSet_1 = require("./Array2DHashSet");
var MapKeyEqualityComparator = /*#__PURE__*/function () {
  function MapKeyEqualityComparator(keyComparator) {
    (0, _classCallCheck2.default)(this, MapKeyEqualityComparator);
    this.keyComparator = keyComparator;
  }
  (0, _createClass2.default)(MapKeyEqualityComparator, [{
    key: "hashCode",
    value: function hashCode(obj) {
      return this.keyComparator.hashCode(obj.key);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return this.keyComparator.equals(a.key, b.key);
    }
  }]);
  return MapKeyEqualityComparator;
}();
var Array2DHashMap = /*#__PURE__*/function () {
  function Array2DHashMap(keyComparer) {
    (0, _classCallCheck2.default)(this, Array2DHashMap);
    if (keyComparer instanceof Array2DHashMap) {
      this.backingStore = new Array2DHashSet_1.Array2DHashSet(keyComparer.backingStore);
    } else {
      this.backingStore = new Array2DHashSet_1.Array2DHashSet(new MapKeyEqualityComparator(keyComparer));
    }
  }
  (0, _createClass2.default)(Array2DHashMap, [{
    key: "clear",
    value: function clear() {
      this.backingStore.clear();
    }
  }, {
    key: "containsKey",
    value: function containsKey(key) {
      return this.backingStore.contains({
        key: key
      });
    }
  }, {
    key: "get",
    value: function get(key) {
      var bucket = this.backingStore.get({
        key: key
      });
      if (!bucket) {
        return undefined;
      }
      return bucket.value;
    }
  }, {
    key: "isEmpty",
    get: function get() {
      return this.backingStore.isEmpty;
    }
  }, {
    key: "put",
    value: function put(key, value) {
      var element = this.backingStore.get({
        key: key,
        value: value
      });
      var result;
      if (!element) {
        this.backingStore.add({
          key: key,
          value: value
        });
      } else {
        result = element.value;
        element.value = value;
      }
      return result;
    }
  }, {
    key: "putIfAbsent",
    value: function putIfAbsent(key, value) {
      var element = this.backingStore.get({
        key: key,
        value: value
      });
      var result;
      if (!element) {
        this.backingStore.add({
          key: key,
          value: value
        });
      } else {
        result = element.value;
      }
      return result;
    }
  }, {
    key: "size",
    get: function get() {
      return this.backingStore.size;
    }
  }, {
    key: "hashCode",
    value: function hashCode() {
      return this.backingStore.hashCode();
    }
  }, {
    key: "equals",
    value: function equals(o) {
      if (!(o instanceof Array2DHashMap)) {
        return false;
      }
      return this.backingStore.equals(o.backingStore);
    }
  }]);
  return Array2DHashMap;
}();
exports.Array2DHashMap = Array2DHashMap;

},{"./Array2DHashSet":370,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237}],370:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.regexp.exec.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.to-string.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-03T02:09:41.7434086-07:00
var assert = require("assert");
var DefaultEqualityComparator_1 = require("./DefaultEqualityComparator");
var Decorators_1 = require("../Decorators");
var MurmurHash_1 = require("./MurmurHash");
/** {@link Set} implementation with closed hashing (open addressing). */
// NOTE:  JavaScript's Set interface has on significant different diffrence from Java's:
// 		  e.g. the return type of add() differs!
//        For this reason I've commented tweaked the implements clause
var INITAL_CAPACITY = 16; // must be power of 2
var LOAD_FACTOR = 0.75;
var Array2DHashSet = /*#__PURE__*/function () {
  function Array2DHashSet(comparatorOrSet) {
    var initialCapacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : INITAL_CAPACITY;
    (0, _classCallCheck2.default)(this, Array2DHashSet);
    /** How many elements in set */
    this.n = 0;
    this.threshold = Math.floor(INITAL_CAPACITY * LOAD_FACTOR); // when to expand
    if (comparatorOrSet instanceof Array2DHashSet) {
      this.comparator = comparatorOrSet.comparator;
      this.buckets = comparatorOrSet.buckets.slice(0);
      for (var i = 0; i < this.buckets.length; i++) {
        var bucket = this.buckets[i];
        if (bucket) {
          this.buckets[i] = bucket.slice(0);
        }
      }
      this.n = comparatorOrSet.n;
      this.threshold = comparatorOrSet.threshold;
    } else {
      this.comparator = comparatorOrSet || DefaultEqualityComparator_1.DefaultEqualityComparator.INSTANCE;
      this.buckets = this.createBuckets(initialCapacity);
    }
  }
  /**
   * Add `o` to set if not there; return existing value if already
   * there. This method performs the same operation as {@link #add} aside from
   * the return value.
   */
  (0, _createClass2.default)(Array2DHashSet, [{
    key: "getOrAdd",
    value: function getOrAdd(o) {
      if (this.n > this.threshold) {
        this.expand();
      }
      return this.getOrAddImpl(o);
    }
  }, {
    key: "getOrAddImpl",
    value: function getOrAddImpl(o) {
      var b = this.getBucket(o);
      var bucket = this.buckets[b];
      // NEW BUCKET
      if (!bucket) {
        bucket = [o];
        this.buckets[b] = bucket;
        this.n++;
        return o;
      }
      // LOOK FOR IT IN BUCKET
      var _iterator = _createForOfIteratorHelper(bucket),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var existing = _step.value;
          if (this.comparator.equals(existing, o)) {
            return existing; // found existing, quit
          }
        }
        // FULL BUCKET, expand and add to end
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      bucket.push(o);
      this.n++;
      return o;
    }
  }, {
    key: "get",
    value: function get(o) {
      if (o == null) {
        return o;
      }
      var b = this.getBucket(o);
      var bucket = this.buckets[b];
      if (!bucket) {
        // no bucket
        return undefined;
      }
      var _iterator2 = _createForOfIteratorHelper(bucket),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var e = _step2.value;
          if (this.comparator.equals(e, o)) {
            return e;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return undefined;
    }
  }, {
    key: "getBucket",
    value: function getBucket(o) {
      var hash = this.comparator.hashCode(o);
      var b = hash & this.buckets.length - 1; // assumes len is power of 2
      return b;
    }
  }, {
    key: "hashCode",
    value: function hashCode() {
      var hash = MurmurHash_1.MurmurHash.initialize();
      var _iterator3 = _createForOfIteratorHelper(this.buckets),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var bucket = _step3.value;
          if (bucket == null) {
            continue;
          }
          var _iterator4 = _createForOfIteratorHelper(bucket),
            _step4;
          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var o = _step4.value;
              if (o == null) {
                break;
              }
              hash = MurmurHash_1.MurmurHash.update(hash, this.comparator.hashCode(o));
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      hash = MurmurHash_1.MurmurHash.finish(hash, this.size);
      return hash;
    }
  }, {
    key: "equals",
    value: function equals(o) {
      if (o === this) {
        return true;
      }
      if (!(o instanceof Array2DHashSet)) {
        return false;
      }
      if (o.size !== this.size) {
        return false;
      }
      var same = this.containsAll(o);
      return same;
    }
  }, {
    key: "expand",
    value: function expand() {
      var old = this.buckets;
      var newCapacity = this.buckets.length * 2;
      var newTable = this.createBuckets(newCapacity);
      this.buckets = newTable;
      this.threshold = Math.floor(newCapacity * LOAD_FACTOR);
      //		System.out.println("new size="+newCapacity+", thres="+threshold);
      // rehash all existing entries
      var oldSize = this.size;
      var _iterator5 = _createForOfIteratorHelper(old),
        _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var bucket = _step5.value;
          if (!bucket) {
            continue;
          }
          var _iterator6 = _createForOfIteratorHelper(bucket),
            _step6;
          try {
            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
              var o = _step6.value;
              var b = this.getBucket(o);
              var newBucket = this.buckets[b];
              if (!newBucket) {
                newBucket = [];
                this.buckets[b] = newBucket;
              }
              newBucket.push(o);
            }
          } catch (err) {
            _iterator6.e(err);
          } finally {
            _iterator6.f();
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
      assert(this.n === oldSize);
    }
  }, {
    key: "add",
    value: function add(t) {
      var existing = this.getOrAdd(t);
      return existing === t;
    }
  }, {
    key: "size",
    get: function get() {
      return this.n;
    }
  }, {
    key: "isEmpty",
    get: function get() {
      return this.n === 0;
    }
  }, {
    key: "contains",
    value: function contains(o) {
      return this.containsFast(this.asElementType(o));
    }
  }, {
    key: "containsFast",
    value: function containsFast(obj) {
      if (obj == null) {
        return false;
      }
      return this.get(obj) != null;
    }
  }, {
    key: Symbol.iterator,
    value: /*#__PURE__*/_regenerator.default.mark(function value() {
      return _regenerator.default.wrap(function value$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            return _context.delegateYield(this.toArray(), "t0", 1);
          case 1:
          case "end":
            return _context.stop();
        }
      }, value, this);
    })
  }, {
    key: "toArray",
    value: function toArray() {
      var a = new Array(this.size);
      // Copy elements from the nested arrays into the destination array
      var i = 0; // Position within destination array
      var _iterator7 = _createForOfIteratorHelper(this.buckets),
        _step7;
      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var bucket = _step7.value;
          if (bucket == null) {
            continue;
          }
          var _iterator8 = _createForOfIteratorHelper(bucket),
            _step8;
          try {
            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
              var o = _step8.value;
              if (o == null) {
                break;
              }
              a[i++] = o;
            }
          } catch (err) {
            _iterator8.e(err);
          } finally {
            _iterator8.f();
          }
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }
      return a;
    }
  }, {
    key: "containsAll",
    value: function containsAll(collection) {
      if (collection instanceof Array2DHashSet) {
        var s = collection;
        var _iterator9 = _createForOfIteratorHelper(s.buckets),
          _step9;
        try {
          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
            var bucket = _step9.value;
            if (bucket == null) {
              continue;
            }
            var _iterator10 = _createForOfIteratorHelper(bucket),
              _step10;
            try {
              for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
                var o = _step10.value;
                if (o == null) {
                  break;
                }
                if (!this.containsFast(this.asElementType(o))) {
                  return false;
                }
              }
            } catch (err) {
              _iterator10.e(err);
            } finally {
              _iterator10.f();
            }
          }
        } catch (err) {
          _iterator9.e(err);
        } finally {
          _iterator9.f();
        }
      } else {
        var _iterator11 = _createForOfIteratorHelper(collection),
          _step11;
        try {
          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
            var _o = _step11.value;
            if (!this.containsFast(this.asElementType(_o))) {
              return false;
            }
          }
        } catch (err) {
          _iterator11.e(err);
        } finally {
          _iterator11.f();
        }
      }
      return true;
    }
  }, {
    key: "addAll",
    value: function addAll(c) {
      var changed = false;
      var _iterator12 = _createForOfIteratorHelper(c),
        _step12;
      try {
        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
          var o = _step12.value;
          var existing = this.getOrAdd(o);
          if (existing !== o) {
            changed = true;
          }
        }
      } catch (err) {
        _iterator12.e(err);
      } finally {
        _iterator12.f();
      }
      return changed;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.buckets = this.createBuckets(INITAL_CAPACITY);
      this.n = 0;
      this.threshold = Math.floor(INITAL_CAPACITY * LOAD_FACTOR);
    }
  }, {
    key: "toString",
    value: function toString() {
      if (this.size === 0) {
        return "{}";
      }
      var buf = "{";
      var first = true;
      var _iterator13 = _createForOfIteratorHelper(this.buckets),
        _step13;
      try {
        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
          var bucket = _step13.value;
          if (bucket == null) {
            continue;
          }
          var _iterator14 = _createForOfIteratorHelper(bucket),
            _step14;
          try {
            for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
              var o = _step14.value;
              if (o == null) {
                break;
              }
              if (first) {
                first = false;
              } else {
                buf += ", ";
              }
              buf += o.toString();
            }
          } catch (err) {
            _iterator14.e(err);
          } finally {
            _iterator14.f();
          }
        }
      } catch (err) {
        _iterator13.e(err);
      } finally {
        _iterator13.f();
      }
      buf += "}";
      return buf;
    }
  }, {
    key: "toTableString",
    value: function toTableString() {
      var buf = "";
      var _iterator15 = _createForOfIteratorHelper(this.buckets),
        _step15;
      try {
        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
          var bucket = _step15.value;
          if (bucket == null) {
            buf += "null\n";
            continue;
          }
          buf += "[";
          var first = true;
          var _iterator16 = _createForOfIteratorHelper(bucket),
            _step16;
          try {
            for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
              var o = _step16.value;
              if (first) {
                first = false;
              } else {
                buf += " ";
              }
              if (o == null) {
                buf += "_";
              } else {
                buf += o.toString();
              }
            }
          } catch (err) {
            _iterator16.e(err);
          } finally {
            _iterator16.f();
          }
          buf += "]\n";
        }
      } catch (err) {
        _iterator15.e(err);
      } finally {
        _iterator15.f();
      }
      return buf;
    }
    /**
     * Return `o` as an instance of the element type `T`. If
     * `o` is non-undefined but known to not be an instance of `T`, this
     * method returns `undefined`. The base implementation does not perform any
     * type checks; override this method to provide strong type checks for the
     * {@link #contains} and {@link #remove} methods to ensure the arguments to
     * the {@link EqualityComparator} for the set always have the expected
     * types.
     *
     * @param o the object to try and cast to the element type of the set
     * @returns `o` if it could be an instance of `T`, otherwise
     * `undefined`.
     */
  }, {
    key: "asElementType",
    value: function asElementType(o) {
      return o;
    }
    /**
     * Return an array of `T[]` with length `capacity`.
     *
     * @param capacity the length of the array to return
     * @returns the newly constructed array
     */
  }, {
    key: "createBuckets",
    value: function createBuckets(capacity) {
      return new Array(capacity);
    }
  }]);
  return Array2DHashSet;
}();
__decorate([Decorators_1.NotNull], Array2DHashSet.prototype, "comparator", void 0);
__decorate([Decorators_1.Override], Array2DHashSet.prototype, "hashCode", null);
__decorate([Decorators_1.Override], Array2DHashSet.prototype, "equals", null);
__decorate([Decorators_1.Override], Array2DHashSet.prototype, "add", null);
__decorate([Decorators_1.Override], Array2DHashSet.prototype, "size", null);
__decorate([Decorators_1.Override], Array2DHashSet.prototype, "isEmpty", null);
__decorate([Decorators_1.Override], Array2DHashSet.prototype, "contains", null);
__decorate([__param(0, Decorators_1.Nullable)], Array2DHashSet.prototype, "containsFast", null);
__decorate([Decorators_1.Override], Array2DHashSet.prototype, Symbol.iterator, null);
__decorate([Decorators_1.Override], Array2DHashSet.prototype, "toArray", null);
__decorate([Decorators_1.Override], Array2DHashSet.prototype, "containsAll", null);
__decorate([Decorators_1.Override], Array2DHashSet.prototype, "addAll", null);
__decorate([Decorators_1.Override], Array2DHashSet.prototype, "clear", null);
__decorate([Decorators_1.Override], Array2DHashSet.prototype, "toString", null);
__decorate([Decorators_1.SuppressWarnings("unchecked")], Array2DHashSet.prototype, "asElementType", null);
__decorate([Decorators_1.SuppressWarnings("unchecked")], Array2DHashSet.prototype, "createBuckets", null);
exports.Array2DHashSet = Array2DHashSet;

},{"../Decorators":272,"./DefaultEqualityComparator":375,"./MurmurHash":381,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"@babel/runtime/regenerator":255,"assert":413,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.promise.js":614,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],371:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var Decorators_1 = require("../Decorators");
var MurmurHash_1 = require("./MurmurHash");
var ObjectEqualityComparator_1 = require("./ObjectEqualityComparator");
/**
 * This default implementation of {@link EqualityComparator} uses object equality
 * for comparisons by calling {@link Object#hashCode} and {@link Object#equals}.
 *
 * @author Sam Harwell
 */
var ArrayEqualityComparator = /*#__PURE__*/function () {
  function ArrayEqualityComparator() {
    (0, _classCallCheck2.default)(this, ArrayEqualityComparator);
  }
  (0, _createClass2.default)(ArrayEqualityComparator, [{
    key: "hashCode",
    value:
    /**
     * {@inheritDoc}
     *
     * This implementation returns
     * `obj.`{@link Object#hashCode hashCode()}.
     */
    function hashCode(obj) {
      if (obj == null) {
        return 0;
      }
      return MurmurHash_1.MurmurHash.hashCode(obj, 0);
    }
    /**
     * {@inheritDoc}
     *
     * This implementation relies on object equality. If both objects are
     * `undefined`, this method returns `true`. Otherwise if only
     * `a` is `undefined`, this method returns `false`. Otherwise,
     * this method returns the result of
     * `a.`{@link Object#equals equals}`(b)`.
     */
  }, {
    key: "equals",
    value: function equals(a, b) {
      if (a == null) {
        return b == null;
      } else if (b == null) {
        return false;
      }
      if (a.length !== b.length) {
        return false;
      }
      for (var i = 0; i < a.length; i++) {
        if (!ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.equals(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
  }]);
  return ArrayEqualityComparator;
}();
ArrayEqualityComparator.INSTANCE = new ArrayEqualityComparator();
__decorate([Decorators_1.Override], ArrayEqualityComparator.prototype, "hashCode", null);
__decorate([Decorators_1.Override], ArrayEqualityComparator.prototype, "equals", null);
exports.ArrayEqualityComparator = ArrayEqualityComparator;

},{"../Decorators":272,"./MurmurHash":381,"./ObjectEqualityComparator":382,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612}],372:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var Arrays;
(function (Arrays) {
  /**
   * Searches the specified array of numbers for the specified value using the binary search algorithm. The array must
   * be sorted prior to making this call. If it is not sorted, the results are unspecified. If the array contains
   * multiple elements with the specified value, there is no guarantee which one will be found.
   *
   * @returns index of the search key, if it is contained in the array; otherwise, (-(insertion point) - 1). The
   * insertion point is defined as the point at which the key would be inserted into the array: the index of the first
   * element greater than the key, or array.length if all elements in the array are less than the specified key. Note
   * that this guarantees that the return value will be >= 0 if and only if the key is found.
   */
  function binarySearch(array, key, fromIndex, toIndex) {
    return binarySearch0(array, fromIndex !== undefined ? fromIndex : 0, toIndex !== undefined ? toIndex : array.length, key);
  }
  Arrays.binarySearch = binarySearch;
  function binarySearch0(array, fromIndex, toIndex, key) {
    var low = fromIndex;
    var high = toIndex - 1;
    while (low <= high) {
      var mid = low + high >>> 1;
      var midVal = array[mid];
      if (midVal < key) {
        low = mid + 1;
      } else if (midVal > key) {
        high = mid - 1;
      } else {
        // key found
        return mid;
      }
    }
    // key not found.
    return -(low + 1);
  }
  function toString(array) {
    var result = "[";
    var first = true;
    var _iterator = _createForOfIteratorHelper(array),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var element = _step.value;
        if (first) {
          first = false;
        } else {
          result += ", ";
        }
        if (element === null) {
          result += "null";
        } else if (element === undefined) {
          result += "undefined";
        } else {
          result += element;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    result += "]";
    return result;
  }
  Arrays.toString = toString;
})(Arrays = exports.Arrays || (exports.Arrays = {}));

},{"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],373:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.regexp.exec.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array-buffer.slice.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.typed-array.uint16-array.js");
require("core-js/modules/es.typed-array.copy-within.js");
require("core-js/modules/es.typed-array.every.js");
require("core-js/modules/es.typed-array.fill.js");
require("core-js/modules/es.typed-array.filter.js");
require("core-js/modules/es.typed-array.find.js");
require("core-js/modules/es.typed-array.find-index.js");
require("core-js/modules/es.typed-array.for-each.js");
require("core-js/modules/es.typed-array.includes.js");
require("core-js/modules/es.typed-array.index-of.js");
require("core-js/modules/es.typed-array.iterator.js");
require("core-js/modules/es.typed-array.join.js");
require("core-js/modules/es.typed-array.last-index-of.js");
require("core-js/modules/es.typed-array.map.js");
require("core-js/modules/es.typed-array.reduce.js");
require("core-js/modules/es.typed-array.reduce-right.js");
require("core-js/modules/es.typed-array.reverse.js");
require("core-js/modules/es.typed-array.set.js");
require("core-js/modules/es.typed-array.slice.js");
require("core-js/modules/es.typed-array.some.js");
require("core-js/modules/es.typed-array.sort.js");
require("core-js/modules/es.typed-array.subarray.js");
require("core-js/modules/es.typed-array.to-locale-string.js");
require("core-js/modules/es.typed-array.to-string.js");
require("core-js/modules/es.typed-array.uint8-array.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.array.fill.js");
require("core-js/modules/web.dom-collections.for-each.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.regexp.to-string.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var util = require("util");
var MurmurHash_1 = require("./MurmurHash");
/**
 * Private empty array used to construct empty BitSets
 */
var EMPTY_DATA = new Uint16Array(0);
/**
 * Gets the word index of the `UInt16` element in `BitSet.data` containing the bit with the specified index.
 */
function getIndex(bitNumber) {
  return bitNumber >>> 4;
}
/**
 * Convert a word index into the bit index of the LSB of that word
 */
function unIndex(n) {
  return n * 16;
}
/**
 * Get's the bit number of the least signficant bit set LSB which is set in a word non-zero word;
 * Bit numbers run from LSB to MSB starting with 0.
 */
function findLSBSet(word) {
  var bit = 1;
  for (var i = 0; i < 16; i++) {
    if ((word & bit) !== 0) {
      return i;
    }
    bit = bit << 1 >>> 0;
  }
  throw new RangeError("No specified bit found");
}
function findMSBSet(word) {
  var bit = 1 << 15 >>> 0;
  for (var i = 15; i >= 0; i--) {
    if ((word & bit) !== 0) {
      return i;
    }
    bit = bit >>> 1;
  }
  throw new RangeError("No specified bit found");
}
/**
 * Gets a 16-bit mask with bit numbers fromBit to toBit (inclusive) set.
 * Bit numbers run from LSB to MSB starting with 0.
 */
function bitsFor(fromBit, toBit) {
  fromBit &= 0xF;
  toBit &= 0xF;
  if (fromBit === toBit) {
    return 1 << fromBit >>> 0;
  }
  return 0xFFFF >>> 15 - toBit ^ 0xFFFF >>> 16 - fromBit;
}
/**
 * A lookup table for number of set bits in a 16-bit integer.   This is used to quickly count the cardinality (number of unique elements) of a BitSet.
 */
var POP_CNT = new Uint8Array(65536);
for (var i = 0; i < 16; i++) {
  var stride = 1 << i >>> 0;
  var index = 0;
  while (index < POP_CNT.length) {
    // skip the numbers where the bit isn't set
    index += stride;
    // increment the ones where the bit is set
    for (var j = 0; j < stride; j++) {
      POP_CNT[index]++;
      index++;
    }
  }
}
var BitSet = /*#__PURE__*/function (_util$inspect$custom) {
  /*
  ** constructor implementation
  */
  function BitSet(arg) {
    (0, _classCallCheck2.default)(this, BitSet);
    if (!arg) {
      // covering the case of unspecified and nbits===0
      this.data = EMPTY_DATA;
    } else if (typeof arg === "number") {
      if (arg < 0) {
        throw new RangeError("nbits cannot be negative");
      } else {
        this.data = new Uint16Array(getIndex(arg - 1) + 1);
      }
    } else {
      if (arg instanceof BitSet) {
        this.data = arg.data.slice(0); // Clone the data
      } else {
        var max = -1;
        var _iterator = _createForOfIteratorHelper(arg),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var v = _step.value;
            if (max < v) {
              max = v;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        this.data = new Uint16Array(getIndex(max - 1) + 1);
        var _iterator2 = _createForOfIteratorHelper(arg),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _v = _step2.value;
            this.set(_v);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    }
  }
  /**
   * Performs a logical **AND** of this target bit set with the argument bit set. This bit set is modified so that
   * each bit in it has the value `true` if and only if it both initially had the value `true` and the corresponding
   * bit in the bit set argument also had the value `true`.
   */
  (0, _createClass2.default)(BitSet, [{
    key: "and",
    value: function and(set) {
      var data = this.data;
      var other = set.data;
      var words = Math.min(data.length, other.length);
      var lastWord = -1; // Keep track of index of last non-zero word
      for (var _i = 0; _i < words; _i++) {
        var value = data[_i] &= other[_i];
        if (value !== 0) {
          lastWord = _i;
        }
      }
      if (lastWord === -1) {
        this.data = EMPTY_DATA;
      }
      if (lastWord < data.length - 1) {
        this.data = data.slice(0, lastWord + 1);
      }
    }
    /**
     * Clears all of the bits in this `BitSet` whose corresponding bit is set in the specified `BitSet`.
     */
  }, {
    key: "andNot",
    value: function andNot(set) {
      var data = this.data;
      var other = set.data;
      var words = Math.min(data.length, other.length);
      var lastWord = -1; // Keep track of index of last non-zero word
      for (var _i2 = 0; _i2 < words; _i2++) {
        var value = data[_i2] &= other[_i2] ^ 0xFFFF;
        if (value !== 0) {
          lastWord = _i2;
        }
      }
      if (lastWord === -1) {
        this.data = EMPTY_DATA;
      }
      if (lastWord < data.length - 1) {
        this.data = data.slice(0, lastWord + 1);
      }
    }
    /**
     * Returns the number of bits set to `true` in this `BitSet`.
     */
  }, {
    key: "cardinality",
    value: function cardinality() {
      if (this.isEmpty) {
        return 0;
      }
      var data = this.data;
      var length = data.length;
      var result = 0;
      for (var _i3 = 0; _i3 < length; _i3++) {
        result += POP_CNT[data[_i3]];
      }
      return result;
    }
  }, {
    key: "clear",
    value: function clear(fromIndex, toIndex) {
      if (fromIndex == null) {
        this.data.fill(0);
      } else if (toIndex == null) {
        this.set(fromIndex, false);
      } else {
        this.set(fromIndex, toIndex, false);
      }
    }
  }, {
    key: "flip",
    value: function flip(fromIndex, toIndex) {
      if (toIndex == null) {
        toIndex = fromIndex;
      }
      if (fromIndex < 0 || toIndex < fromIndex) {
        throw new RangeError();
      }
      var word = getIndex(fromIndex);
      var lastWord = getIndex(toIndex);
      if (word === lastWord) {
        this.data[word] ^= bitsFor(fromIndex, toIndex);
      } else {
        this.data[word++] ^= bitsFor(fromIndex, 15);
        while (word < lastWord) {
          this.data[word++] ^= 0xFFFF;
        }
        this.data[word++] ^= bitsFor(0, toIndex);
      }
    }
  }, {
    key: "get",
    value: function get(fromIndex, toIndex) {
      if (toIndex === undefined) {
        return !!(this.data[getIndex(fromIndex)] & bitsFor(fromIndex, fromIndex));
      } else {
        // return a BitSet
        var result = new BitSet(toIndex + 1);
        for (var _i4 = fromIndex; _i4 <= toIndex; _i4++) {
          result.set(_i4, this.get(_i4));
        }
        return result;
      }
    }
    /**
     * Returns true if the specified `BitSet` has any bits set to `true` that are also set to `true` in this `BitSet`.
     *
     * @param set `BitSet` to intersect with
     */
  }, {
    key: "intersects",
    value: function intersects(set) {
      var smallerLength = Math.min(this.length(), set.length());
      if (smallerLength === 0) {
        return false;
      }
      var bound = getIndex(smallerLength - 1);
      for (var _i5 = 0; _i5 <= bound; _i5++) {
        if ((this.data[_i5] & set.data[_i5]) !== 0) {
          return true;
        }
      }
      return false;
    }
    /**
     * Returns true if this `BitSet` contains no bits that are set to `true`.
     */
  }, {
    key: "isEmpty",
    get: function get() {
      return this.length() === 0;
    }
    /**
     * Returns the "logical size" of this `BitSet`: the index of the highest set bit in the `BitSet` plus one. Returns
     * zero if the `BitSet` contains no set bits.
     */
  }, {
    key: "length",
    value: function length() {
      if (!this.data.length) {
        return 0;
      }
      return this.previousSetBit(unIndex(this.data.length) - 1) + 1;
    }
    /**
     * Returns the index of the first bit that is set to `false` that occurs on or after the specified starting index,
     * If no such bit exists then `-1` is returned.
     *
     * @param fromIndex the index to start checking from (inclusive)
     *
     * @throws RangeError if the specified index is negative
     */
  }, {
    key: "nextClearBit",
    value: function nextClearBit(fromIndex) {
      if (fromIndex < 0) {
        throw new RangeError("fromIndex cannot be negative");
      }
      var data = this.data;
      var length = data.length;
      var word = getIndex(fromIndex);
      if (word > length) {
        return -1;
      }
      var ignore = 0xFFFF ^ bitsFor(fromIndex, 15);
      if ((data[word] | ignore) === 0xFFFF) {
        word++;
        ignore = 0;
        for (; word < length; word++) {
          if (data[word] !== 0xFFFF) {
            break;
          }
        }
        if (word === length) {
          // Hit the end
          return -1;
        }
      }
      return unIndex(word) + findLSBSet((data[word] | ignore) ^ 0xFFFF);
    }
    /**
     * Returns the index of the first bit that is set to `true` that occurs on or after the specified starting index.
     * If no such bit exists then `-1` is returned.
     *
     * To iterate over the `true` bits in a `BitSet`, use the following loop:
     *
     * ```
     * for (let i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i + 1)) {
     *   // operate on index i here
     * }
     * ```
     *
     * @param fromIndex the index to start checking from (inclusive)
     *
     * @throws RangeError if the specified index is negative
     */
  }, {
    key: "nextSetBit",
    value: function nextSetBit(fromIndex) {
      if (fromIndex < 0) {
        throw new RangeError("fromIndex cannot be negative");
      }
      var data = this.data;
      var length = data.length;
      var word = getIndex(fromIndex);
      if (word > length) {
        return -1;
      }
      var mask = bitsFor(fromIndex, 15);
      if ((data[word] & mask) === 0) {
        word++;
        mask = 0xFFFF;
        for (; word < length; word++) {
          if (data[word] !== 0) {
            break;
          }
        }
        if (word >= length) {
          return -1;
        }
      }
      return unIndex(word) + findLSBSet(data[word] & mask);
    }
    /**
     * Performs a logical **OR** of this bit set with the bit set argument. This bit set is modified so that a bit in it
     * has the value `true` if and only if it either already had the value `true` or the corresponding bit in the bit
     * set argument has the value `true`.
     */
  }, {
    key: "or",
    value: function or(set) {
      var data = this.data;
      var other = set.data;
      var minWords = Math.min(data.length, other.length);
      var words = Math.max(data.length, other.length);
      var dest = data.length === words ? data : new Uint16Array(words);
      var lastWord = -1;
      // Or those words both sets have in common
      for (var _i6 = 0; _i6 < minWords; _i6++) {
        var value = dest[_i6] = data[_i6] | other[_i6];
        if (value !== 0) {
          lastWord = _i6;
        }
      }
      // Copy words from larger set (if there is one)
      var longer = data.length > other.length ? data : other;
      for (var _i7 = minWords; _i7 < words; _i7++) {
        var _value = dest[_i7] = longer[_i7];
        if (_value !== 0) {
          lastWord = _i7;
        }
      }
      if (lastWord === -1) {
        this.data = EMPTY_DATA;
      } else if (dest.length === lastWord + 1) {
        this.data = dest;
      } else {
        this.data = dest.slice(0, lastWord);
      }
    }
    /**
     * Returns the index of the nearest bit that is set to `false` that occurs on or before the specified starting
     * index. If no such bit exists, or if `-1` is given as the starting index, then `-1` is returned.
     *
     * @param fromIndex the index to start checking from (inclusive)
     *
     * @throws RangeError if the specified index is less than `-1`
     */
  }, {
    key: "previousClearBit",
    value: function previousClearBit(fromIndex) {
      if (fromIndex < 0) {
        throw new RangeError("fromIndex cannot be negative");
      }
      var data = this.data;
      var length = data.length;
      var word = getIndex(fromIndex);
      if (word >= length) {
        word = length - 1;
      }
      var ignore = 0xFFFF ^ bitsFor(0, fromIndex);
      if ((data[word] | ignore) === 0xFFFF) {
        ignore = 0;
        word--;
        for (; word >= 0; word--) {
          if (data[word] !== 0xFFFF) {
            break;
          }
        }
        if (word < 0) {
          // Hit the end
          return -1;
        }
      }
      return unIndex(word) + findMSBSet((data[word] | ignore) ^ 0xFFFF);
    }
    /**
     * Returns the index of the nearest bit that is set to `true` that occurs on or before the specified starting index.
     * If no such bit exists, or if `-1` is given as the starting index, then `-1` is returned.
     *
     * To iterate over the `true` bits in a `BitSet`, use the following loop:
     *
     * ```
     * for (let i = bs.length(); (i = bs.previousSetBit(i-1)) >= 0; ) {
     *   // operate on index i here
     * }
     * ```
     *
     * @param fromIndex the index to start checking from (inclusive)
     *
     * @throws RangeError if the specified index is less than `-1`
     */
  }, {
    key: "previousSetBit",
    value: function previousSetBit(fromIndex) {
      if (fromIndex < 0) {
        throw new RangeError("fromIndex cannot be negative");
      }
      var data = this.data;
      var length = data.length;
      var word = getIndex(fromIndex);
      if (word >= length) {
        word = length - 1;
      }
      var mask = bitsFor(0, fromIndex);
      if ((data[word] & mask) === 0) {
        word--;
        mask = 0xFFFF;
        for (; word >= 0; word--) {
          if (data[word] !== 0) {
            break;
          }
        }
        if (word < 0) {
          return -1;
        }
      }
      return unIndex(word) + findMSBSet(data[word] & mask);
    }
  }, {
    key: "set",
    value: function set(fromIndex, toIndex, value) {
      if (toIndex === undefined) {
        toIndex = fromIndex;
        value = true;
      } else if (typeof toIndex === "boolean") {
        value = toIndex;
        toIndex = fromIndex;
      }
      if (value === undefined) {
        value = true;
      }
      if (fromIndex < 0 || fromIndex > toIndex) {
        throw new RangeError();
      }
      var word = getIndex(fromIndex);
      var lastWord = getIndex(toIndex);
      if (value && lastWord >= this.data.length) {
        // Grow array "just enough" for bits we need to set
        var temp = new Uint16Array(lastWord + 1);
        this.data.forEach(function (value, index) {
          return temp[index] = value;
        });
        this.data = temp;
      } else if (!value) {
        // But there is no need to grow array to clear bits.
        if (word >= this.data.length) {
          // Early exit
          return;
        }
        if (lastWord >= this.data.length) {
          // Adjust work to fit array
          lastWord = this.data.length - 1;
          toIndex = this.data.length * 16 - 1;
        }
      }
      if (word === lastWord) {
        this._setBits(word, value, bitsFor(fromIndex, toIndex));
      } else {
        this._setBits(word++, value, bitsFor(fromIndex, 15));
        while (word < lastWord) {
          this.data[word++] = value ? 0xFFFF : 0;
        }
        this._setBits(word, value, bitsFor(0, toIndex));
      }
    }
  }, {
    key: "_setBits",
    value: function _setBits(word, value, mask) {
      if (value) {
        this.data[word] |= mask;
      } else {
        this.data[word] &= 0xFFFF ^ mask;
      }
    }
    /**
     * Returns the number of bits of space actually in use by this `BitSet` to represent bit values. The maximum element
     * in the set is the size - 1st element.
     */
  }, {
    key: "size",
    get: function get() {
      return this.data.byteLength * 8;
    }
    /**
     * Returns a new byte array containing all the bits in this bit set.
     *
     * More precisely, if
     * `let bytes = s.toByteArray();`
     * then `bytes.length === (s.length()+7)/8` and `s.get(n) === ((bytes[n/8] & (1<<(n%8))) != 0)` for all
     * `n < 8 * bytes.length`.
     */
    // toByteArray(): Int8Array {
    // 	throw new Error("NOT IMPLEMENTED");
    // }
    /**
     * Returns a new integer array containing all the bits in this bit set.
     *
     * More precisely, if
     * `let integers = s.toIntegerArray();`
     * then `integers.length === (s.length()+31)/32` and `s.get(n) === ((integers[n/32] & (1<<(n%32))) != 0)` for all
     * `n < 32 * integers.length`.
     */
    // toIntegerArray(): Int32Array {
    // 	throw new Error("NOT IMPLEMENTED");
    // }
  }, {
    key: "hashCode",
    value: function hashCode() {
      return MurmurHash_1.MurmurHash.hashCode(this.data, 22);
    }
    /**
     * Compares this object against the specified object. The result is `true` if and only if the argument is not
     * `undefined` and is a `Bitset` object that has exactly the same set of bits set to `true` as this bit set. That
     * is, for every nonnegative index `k`,
     *
     * ```
     * ((BitSet)obj).get(k) == this.get(k)
     * ```
     *
     * must be true. The current sizes of the two bit sets are not compared.
     */
  }, {
    key: "equals",
    value: function equals(obj) {
      if (obj === this) {
        return true;
      } else if (!(obj instanceof BitSet)) {
        return false;
      }
      var len = this.length();
      if (len !== obj.length()) {
        return false;
      }
      if (len === 0) {
        return true;
      }
      var bound = getIndex(len - 1);
      for (var _i8 = 0; _i8 <= bound; _i8++) {
        if (this.data[_i8] !== obj.data[_i8]) {
          return false;
        }
      }
      return true;
    }
    /**
     * Returns a string representation of this bit set. For every index for which this `BitSet` contains a bit in the
     * set state, the decimal representation of that index is included in the result. Such indices are listed in order
     * from lowest to highest, separated by ", " (a comma and a space) and surrounded by braces, resulting in the usual
     * mathematical notation for a set of integers.
     *
     * Example:
     *
     *     BitSet drPepper = new BitSet();
     *
     * Now `drPepper.toString()` returns `"{}"`.
     *
     *     drPepper.set(2);
     *
     * Now `drPepper.toString()` returns `"{2}"`.
     *
     *     drPepper.set(4);
     *     drPepper.set(10);
     *
     * Now `drPepper.toString()` returns `"{2, 4, 10}"`.
     */
  }, {
    key: "toString",
    value: function toString() {
      var result = "{";
      var first = true;
      for (var _i9 = this.nextSetBit(0); _i9 >= 0; _i9 = this.nextSetBit(_i9 + 1)) {
        if (first) {
          first = false;
        } else {
          result += ", ";
        }
        result += _i9;
      }
      result += "}";
      return result;
    }
    // static valueOf(bytes: Int8Array): BitSet;
    // static valueOf(buffer: ArrayBuffer): BitSet;
    // static valueOf(integers: Int32Array): BitSet;
    // static valueOf(data: Int8Array | Int32Array | ArrayBuffer): BitSet {
    // 	throw new Error("NOT IMPLEMENTED");
    // }
    /**
     * Performs a logical **XOR** of this bit set with the bit set argument. This bit set is modified so that a bit in
     * it has the value `true` if and only if one of the following statements holds:
     *
     * * The bit initially has the value `true`, and the corresponding bit in the argument has the value `false`.
     * * The bit initially has the value `false`, and the corresponding bit in the argument has the value `true`.
     */
  }, {
    key: "xor",
    value: function xor(set) {
      var data = this.data;
      var other = set.data;
      var minWords = Math.min(data.length, other.length);
      var words = Math.max(data.length, other.length);
      var dest = data.length === words ? data : new Uint16Array(words);
      var lastWord = -1;
      // Xor those words both sets have in common
      for (var _i10 = 0; _i10 < minWords; _i10++) {
        var value = dest[_i10] = data[_i10] ^ other[_i10];
        if (value !== 0) {
          lastWord = _i10;
        }
      }
      // Copy words from larger set (if there is one)
      var longer = data.length > other.length ? data : other;
      for (var _i11 = minWords; _i11 < words; _i11++) {
        var _value2 = dest[_i11] = longer[_i11];
        if (_value2 !== 0) {
          lastWord = _i11;
        }
      }
      if (lastWord === -1) {
        this.data = EMPTY_DATA;
      } else if (dest.length === lastWord + 1) {
        this.data = dest;
      } else {
        this.data = dest.slice(0, lastWord + 1);
      }
    }
  }, {
    key: "clone",
    value: function clone() {
      return new BitSet(this);
    }
  }, {
    key: Symbol.iterator,
    value: function value() {
      return new BitSetIterator(this.data);
    }
    // Overrides formatting for nodejs assert etc.
  }, {
    key: _util$inspect$custom,
    value: function value() {
      return "BitSet " + this.toString();
    }
  }]);
  return BitSet;
}(util.inspect.custom);
exports.BitSet = BitSet;
var BitSetIterator = /*#__PURE__*/function () {
  function BitSetIterator(data) {
    (0, _classCallCheck2.default)(this, BitSetIterator);
    this.data = data;
    this.index = 0;
    this.mask = 0xFFFF;
  }
  (0, _createClass2.default)(BitSetIterator, [{
    key: "next",
    value: function next() {
      while (this.index < this.data.length) {
        var bits = this.data[this.index] & this.mask;
        if (bits !== 0) {
          var bitNumber = unIndex(this.index) + findLSBSet(bits);
          this.mask = bitsFor(bitNumber + 1, 15);
          return {
            done: false,
            value: bitNumber
          };
        }
        this.index++;
        this.mask = 0xFFFF;
      }
      return {
        done: true,
        value: -1
      };
    }
  }, {
    key: Symbol.iterator,
    value: function value() {
      return this;
    }
  }]);
  return BitSetIterator;
}();

},{"./MurmurHash":381,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"core-js/modules/es.array-buffer.slice.js":568,"core-js/modules/es.array.fill.js":571,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/es.typed-array.copy-within.js":641,"core-js/modules/es.typed-array.every.js":642,"core-js/modules/es.typed-array.fill.js":643,"core-js/modules/es.typed-array.filter.js":644,"core-js/modules/es.typed-array.find-index.js":645,"core-js/modules/es.typed-array.find.js":646,"core-js/modules/es.typed-array.for-each.js":649,"core-js/modules/es.typed-array.includes.js":650,"core-js/modules/es.typed-array.index-of.js":651,"core-js/modules/es.typed-array.iterator.js":655,"core-js/modules/es.typed-array.join.js":656,"core-js/modules/es.typed-array.last-index-of.js":657,"core-js/modules/es.typed-array.map.js":658,"core-js/modules/es.typed-array.reduce-right.js":659,"core-js/modules/es.typed-array.reduce.js":660,"core-js/modules/es.typed-array.reverse.js":661,"core-js/modules/es.typed-array.set.js":662,"core-js/modules/es.typed-array.slice.js":663,"core-js/modules/es.typed-array.some.js":664,"core-js/modules/es.typed-array.sort.js":665,"core-js/modules/es.typed-array.subarray.js":666,"core-js/modules/es.typed-array.to-locale-string.js":667,"core-js/modules/es.typed-array.to-string.js":668,"core-js/modules/es.typed-array.uint16-array.js":669,"core-js/modules/es.typed-array.uint8-array.js":671,"core-js/modules/web.dom-collections.for-each.js":676,"core-js/modules/web.dom-collections.iterator.js":677,"util":736}],374:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
function isHighSurrogate(ch) {
  return ch >= 0xD800 && ch <= 0xDBFF;
}
exports.isHighSurrogate = isHighSurrogate;
function isLowSurrogate(ch) {
  return ch >= 0xDC00 && ch <= 0xDFFF;
}
exports.isLowSurrogate = isLowSurrogate;
function isSupplementaryCodePoint(ch) {
  return ch >= 0x10000;
}
exports.isSupplementaryCodePoint = isSupplementaryCodePoint;

},{}],375:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var Decorators_1 = require("../Decorators");
var MurmurHash_1 = require("./MurmurHash");
var ObjectEqualityComparator_1 = require("./ObjectEqualityComparator");
/**
 * This default implementation of {@link EqualityComparator} uses object equality
 * for comparisons by calling {@link Object#hashCode} and {@link Object#equals}.
 *
 * @author Sam Harwell
 */
var DefaultEqualityComparator = /*#__PURE__*/function () {
  function DefaultEqualityComparator() {
    (0, _classCallCheck2.default)(this, DefaultEqualityComparator);
  }
  (0, _createClass2.default)(DefaultEqualityComparator, [{
    key: "hashCode",
    value:
    /**
     * {@inheritDoc}
     *
     * This implementation returns
     * `obj.`{@link Object#hashCode hashCode()}.
     */
    function hashCode(obj) {
      if (obj == null) {
        return 0;
      } else if (typeof obj === "string" || typeof obj === "number") {
        return MurmurHash_1.MurmurHash.hashCode([obj]);
      } else {
        return ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.hashCode(obj);
      }
    }
    /**
     * {@inheritDoc}
     *
     * This implementation relies on object equality. If both objects are
     * `undefined` or `null`, this method returns `true`. Otherwise if only
     * `a` is `undefined` or `null`, this method returns `false`. Otherwise,
     * this method returns the result of
     * `a.`{@link Object#equals equals}`(b)`.
     */
  }, {
    key: "equals",
    value: function equals(a, b) {
      if (a == null) {
        return b == null;
      } else if (typeof a === "string" || typeof a === "number") {
        return a === b;
      } else {
        return ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.equals(a, b);
      }
    }
  }]);
  return DefaultEqualityComparator;
}();
DefaultEqualityComparator.INSTANCE = new DefaultEqualityComparator();
__decorate([Decorators_1.Override], DefaultEqualityComparator.prototype, "hashCode", null);
__decorate([Decorators_1.Override], DefaultEqualityComparator.prototype, "equals", null);
exports.DefaultEqualityComparator = DefaultEqualityComparator;

},{"../Decorators":272,"./MurmurHash":381,"./ObjectEqualityComparator":382,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612}],376:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array-buffer.slice.js");
require("core-js/modules/es.typed-array.int32-array.js");
require("core-js/modules/es.typed-array.copy-within.js");
require("core-js/modules/es.typed-array.every.js");
require("core-js/modules/es.typed-array.fill.js");
require("core-js/modules/es.typed-array.filter.js");
require("core-js/modules/es.typed-array.find.js");
require("core-js/modules/es.typed-array.find-index.js");
require("core-js/modules/es.typed-array.for-each.js");
require("core-js/modules/es.typed-array.includes.js");
require("core-js/modules/es.typed-array.index-of.js");
require("core-js/modules/es.typed-array.iterator.js");
require("core-js/modules/es.typed-array.join.js");
require("core-js/modules/es.typed-array.last-index-of.js");
require("core-js/modules/es.typed-array.map.js");
require("core-js/modules/es.typed-array.reduce.js");
require("core-js/modules/es.typed-array.reduce-right.js");
require("core-js/modules/es.typed-array.reverse.js");
require("core-js/modules/es.typed-array.set.js");
require("core-js/modules/es.typed-array.slice.js");
require("core-js/modules/es.typed-array.some.js");
require("core-js/modules/es.typed-array.sort.js");
require("core-js/modules/es.typed-array.subarray.js");
require("core-js/modules/es.typed-array.to-locale-string.js");
require("core-js/modules/es.typed-array.to-string.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.array.copy-within.js");
require("core-js/modules/es.array.fill.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.array.sort.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.typed-array.uint16-array.js");
require("core-js/modules/es.string.from-code-point.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:40.5099429-07:00
var Arrays_1 = require("./Arrays");
var Decorators_1 = require("../Decorators");
var EMPTY_DATA = new Int32Array(0);
var INITIAL_SIZE = 4;
var MAX_ARRAY_SIZE = (1 << 31 >>> 0) - 1 - 8;
/**
 *
 * @author Sam Harwell
 */
var IntegerList = /*#__PURE__*/function () {
  function IntegerList(arg) {
    (0, _classCallCheck2.default)(this, IntegerList);
    if (!arg) {
      this._data = EMPTY_DATA;
      this._size = 0;
    } else if (arg instanceof IntegerList) {
      this._data = arg._data.slice(0);
      this._size = arg._size;
    } else if (typeof arg === "number") {
      if (arg === 0) {
        this._data = EMPTY_DATA;
        this._size = 0;
      } else {
        this._data = new Int32Array(arg);
        this._size = 0;
      }
    } else {
      // arg is Iterable<number>
      this._data = EMPTY_DATA;
      this._size = 0;
      var _iterator = _createForOfIteratorHelper(arg),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var value = _step.value;
          this.add(value);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }
  (0, _createClass2.default)(IntegerList, [{
    key: "add",
    value: function add(value) {
      if (this._data.length === this._size) {
        this.ensureCapacity(this._size + 1);
      }
      this._data[this._size] = value;
      this._size++;
    }
  }, {
    key: "addAll",
    value: function addAll(list) {
      if (Array.isArray(list)) {
        this.ensureCapacity(this._size + list.length);
        this._data.subarray(this._size, this._size + list.length).set(list);
        this._size += list.length;
      } else if (list instanceof IntegerList) {
        this.ensureCapacity(this._size + list._size);
        this._data.subarray(this._size, this._size + list.size).set(list._data);
        this._size += list._size;
      } else {
        // list is JavaCollection<number>
        this.ensureCapacity(this._size + list.size);
        var current = 0;
        var _iterator2 = _createForOfIteratorHelper(list),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var xi = _step2.value;
            this._data[this._size + current] = xi;
            current++;
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        this._size += list.size;
      }
    }
  }, {
    key: "get",
    value: function get(index) {
      if (index < 0 || index >= this._size) {
        throw RangeError();
      }
      return this._data[index];
    }
  }, {
    key: "contains",
    value: function contains(value) {
      for (var i = 0; i < this._size; i++) {
        if (this._data[i] === value) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: "set",
    value: function set(index, value) {
      if (index < 0 || index >= this._size) {
        throw RangeError();
      }
      var previous = this._data[index];
      this._data[index] = value;
      return previous;
    }
  }, {
    key: "removeAt",
    value: function removeAt(index) {
      var value = this.get(index);
      this._data.copyWithin(index, index + 1, this._size);
      this._data[this._size - 1] = 0;
      this._size--;
      return value;
    }
  }, {
    key: "removeRange",
    value: function removeRange(fromIndex, toIndex) {
      if (fromIndex < 0 || toIndex < 0 || fromIndex > this._size || toIndex > this._size) {
        throw RangeError();
      }
      if (fromIndex > toIndex) {
        throw RangeError();
      }
      this._data.copyWithin(toIndex, fromIndex, this._size);
      this._data.fill(0, this._size - (toIndex - fromIndex), this._size);
      this._size -= toIndex - fromIndex;
    }
  }, {
    key: "isEmpty",
    get: function get() {
      return this._size === 0;
    }
  }, {
    key: "size",
    get: function get() {
      return this._size;
    }
  }, {
    key: "trimToSize",
    value: function trimToSize() {
      if (this._data.length === this._size) {
        return;
      }
      this._data = this._data.slice(0, this._size);
    }
  }, {
    key: "clear",
    value: function clear() {
      this._data.fill(0, 0, this._size);
      this._size = 0;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      if (this._size === 0) {
        return [];
      }
      return Array.from(this._data.subarray(0, this._size));
    }
  }, {
    key: "sort",
    value: function sort() {
      this._data.subarray(0, this._size).sort();
    }
    /**
     * Compares the specified object with this list for equality.  Returns
     * `true` if and only if the specified object is also an {@link IntegerList},
     * both lists have the same size, and all corresponding pairs of elements in
     * the two lists are equal.  In other words, two lists are defined to be
     * equal if they contain the same elements in the same order.
     *
     * This implementation first checks if the specified object is this
     * list. If so, it returns `true`; if not, it checks if the
     * specified object is an {@link IntegerList}. If not, it returns `false`;
     * if so, it checks the size of both lists. If the lists are not the same size,
     * it returns `false`; otherwise it iterates over both lists, comparing
     * corresponding pairs of elements.  If any comparison returns `false`,
     * this method returns `false`.
     *
     * @param o the object to be compared for equality with this list
     * @returns `true` if the specified object is equal to this list
     */
  }, {
    key: "equals",
    value: function equals(o) {
      if (o === this) {
        return true;
      }
      if (!(o instanceof IntegerList)) {
        return false;
      }
      if (this._size !== o._size) {
        return false;
      }
      for (var i = 0; i < this._size; i++) {
        if (this._data[i] !== o._data[i]) {
          return false;
        }
      }
      return true;
    }
    /**
     * Returns the hash code value for this list.
     *
     * This implementation uses exactly the code that is used to define the
     * list hash function in the documentation for the {@link List#hashCode}
     * method.
     *
     * @returns the hash code value for this list
     */
  }, {
    key: "hashCode",
    value: function hashCode() {
      var hashCode = 1;
      for (var i = 0; i < this._size; i++) {
        hashCode = 31 * hashCode + this._data[i];
      }
      return hashCode;
    }
    /**
     * Returns a string representation of this list.
     */
  }, {
    key: "toString",
    value: function toString() {
      return this._data.toString();
    }
  }, {
    key: "binarySearch",
    value: function binarySearch(key, fromIndex, toIndex) {
      if (fromIndex === undefined) {
        fromIndex = 0;
      }
      if (toIndex === undefined) {
        toIndex = this._size;
      }
      if (fromIndex < 0 || toIndex < 0 || fromIndex > this._size || toIndex > this._size) {
        throw new RangeError();
      }
      if (fromIndex > toIndex) {
        throw new RangeError();
      }
      return Arrays_1.Arrays.binarySearch(this._data, key, fromIndex, toIndex);
    }
  }, {
    key: "ensureCapacity",
    value: function ensureCapacity(capacity) {
      if (capacity < 0 || capacity > MAX_ARRAY_SIZE) {
        throw new RangeError();
      }
      var newLength;
      if (this._data.length === 0) {
        newLength = INITIAL_SIZE;
      } else {
        newLength = this._data.length;
      }
      while (newLength < capacity) {
        newLength = newLength * 2;
        if (newLength < 0 || newLength > MAX_ARRAY_SIZE) {
          newLength = MAX_ARRAY_SIZE;
        }
      }
      var tmp = new Int32Array(newLength);
      tmp.set(this._data);
      this._data = tmp;
    }
    /** Convert the list to a UTF-16 encoded char array. If all values are less
     *  than the 0xFFFF 16-bit code point limit then this is just a char array
     *  of 16-bit char as usual. For values in the supplementary range, encode
     * them as two UTF-16 code units.
     */
  }, {
    key: "toCharArray",
    value: function toCharArray() {
      // Optimize for the common case (all data values are < 0xFFFF) to avoid an extra scan
      var resultArray = new Uint16Array(this._size);
      var resultIdx = 0;
      var calculatedPreciseResultSize = false;
      for (var i = 0; i < this._size; i++) {
        var codePoint = this._data[i];
        if (codePoint >= 0 && codePoint < 0x10000) {
          resultArray[resultIdx] = codePoint;
          resultIdx++;
          continue;
        }
        // Calculate the precise result size if we encounter a code point > 0xFFFF
        if (!calculatedPreciseResultSize) {
          var newResultArray = new Uint16Array(this.charArraySize());
          newResultArray.set(resultArray, 0);
          resultArray = newResultArray;
          calculatedPreciseResultSize = true;
        }
        // This will throw RangeError if the code point is not a valid Unicode code point
        var pair = String.fromCodePoint(codePoint);
        resultArray[resultIdx] = pair.charCodeAt(0);
        resultArray[resultIdx + 1] = pair.charCodeAt(1);
        resultIdx += 2;
      }
      return resultArray;
    }
  }, {
    key: "charArraySize",
    value: function charArraySize() {
      var result = 0;
      for (var i = 0; i < this._size; i++) {
        result += this._data[i] >= 0x10000 ? 2 : 1;
      }
      return result;
    }
  }]);
  return IntegerList;
}();
__decorate([Decorators_1.NotNull], IntegerList.prototype, "_data", void 0);
__decorate([Decorators_1.Override], IntegerList.prototype, "equals", null);
__decorate([Decorators_1.Override], IntegerList.prototype, "hashCode", null);
__decorate([Decorators_1.Override], IntegerList.prototype, "toString", null);
exports.IntegerList = IntegerList;

},{"../Decorators":272,"./Arrays":372,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array-buffer.slice.js":568,"core-js/modules/es.array.copy-within.js":570,"core-js/modules/es.array.fill.js":571,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.array.sort.js":581,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.from-code-point.js":624,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/es.typed-array.copy-within.js":641,"core-js/modules/es.typed-array.every.js":642,"core-js/modules/es.typed-array.fill.js":643,"core-js/modules/es.typed-array.filter.js":644,"core-js/modules/es.typed-array.find-index.js":645,"core-js/modules/es.typed-array.find.js":646,"core-js/modules/es.typed-array.for-each.js":649,"core-js/modules/es.typed-array.includes.js":650,"core-js/modules/es.typed-array.index-of.js":651,"core-js/modules/es.typed-array.int32-array.js":653,"core-js/modules/es.typed-array.iterator.js":655,"core-js/modules/es.typed-array.join.js":656,"core-js/modules/es.typed-array.last-index-of.js":657,"core-js/modules/es.typed-array.map.js":658,"core-js/modules/es.typed-array.reduce-right.js":659,"core-js/modules/es.typed-array.reduce.js":660,"core-js/modules/es.typed-array.reverse.js":661,"core-js/modules/es.typed-array.set.js":662,"core-js/modules/es.typed-array.slice.js":663,"core-js/modules/es.typed-array.some.js":664,"core-js/modules/es.typed-array.sort.js":665,"core-js/modules/es.typed-array.subarray.js":666,"core-js/modules/es.typed-array.to-locale-string.js":667,"core-js/modules/es.typed-array.to-string.js":668,"core-js/modules/es.typed-array.uint16-array.js":669,"core-js/modules/web.dom-collections.iterator.js":677}],377:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:40.6647101-07:00
var IntegerList_1 = require("./IntegerList");
/**
 *
 * @author Sam Harwell
 */
var IntegerStack = /*#__PURE__*/function (_IntegerList_1$Intege) {
  (0, _inherits2.default)(IntegerStack, _IntegerList_1$Intege);
  var _super = _createSuper(IntegerStack);
  function IntegerStack(arg) {
    (0, _classCallCheck2.default)(this, IntegerStack);
    return _super.call(this, arg);
  }
  (0, _createClass2.default)(IntegerStack, [{
    key: "push",
    value: function push(value) {
      this.add(value);
    }
  }, {
    key: "pop",
    value: function pop() {
      return this.removeAt(this.size - 1);
    }
  }, {
    key: "peek",
    value: function peek() {
      return this.get(this.size - 1);
    }
  }]);
  return IntegerStack;
}(IntegerList_1.IntegerList);
exports.IntegerStack = IntegerStack;

},{"./IntegerList":376,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],378:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:40.7402214-07:00
var Decorators_1 = require("../Decorators");
var INTERVAL_POOL_MAX_VALUE = 1000;
/** An immutable inclusive interval a..b */
var Interval = /*#__PURE__*/function () {
  /**
   * @param a The start of the interval
   * @param b The end of the interval (inclusive)
   */
  function Interval(a, b) {
    (0, _classCallCheck2.default)(this, Interval);
    this.a = a;
    this.b = b;
  }
  (0, _createClass2.default)(Interval, [{
    key: "length",
    get:
    /** return number of elements between a and b inclusively. x..x is length 1.
     *  if b &lt; a, then length is 0.  9..10 has length 2.
     */
    function get() {
      if (this.b < this.a) {
        return 0;
      }
      return this.b - this.a + 1;
    }
  }, {
    key: "equals",
    value: function equals(o) {
      if (o === this) {
        return true;
      } else if (!(o instanceof Interval)) {
        return false;
      }
      return this.a === o.a && this.b === o.b;
    }
  }, {
    key: "hashCode",
    value: function hashCode() {
      var hash = 23;
      hash = hash * 31 + this.a;
      hash = hash * 31 + this.b;
      return hash;
    }
    /** Does this start completely before other? Disjoint */
  }, {
    key: "startsBeforeDisjoint",
    value: function startsBeforeDisjoint(other) {
      return this.a < other.a && this.b < other.a;
    }
    /** Does this start at or before other? Nondisjoint */
  }, {
    key: "startsBeforeNonDisjoint",
    value: function startsBeforeNonDisjoint(other) {
      return this.a <= other.a && this.b >= other.a;
    }
    /** Does this.a start after other.b? May or may not be disjoint */
  }, {
    key: "startsAfter",
    value: function startsAfter(other) {
      return this.a > other.a;
    }
    /** Does this start completely after other? Disjoint */
  }, {
    key: "startsAfterDisjoint",
    value: function startsAfterDisjoint(other) {
      return this.a > other.b;
    }
    /** Does this start after other? NonDisjoint */
  }, {
    key: "startsAfterNonDisjoint",
    value: function startsAfterNonDisjoint(other) {
      return this.a > other.a && this.a <= other.b; // this.b>=other.b implied
    }
    /** Are both ranges disjoint? I.e., no overlap? */
  }, {
    key: "disjoint",
    value: function disjoint(other) {
      return this.startsBeforeDisjoint(other) || this.startsAfterDisjoint(other);
    }
    /** Are two intervals adjacent such as 0..41 and 42..42? */
  }, {
    key: "adjacent",
    value: function adjacent(other) {
      return this.a === other.b + 1 || this.b === other.a - 1;
    }
  }, {
    key: "properlyContains",
    value: function properlyContains(other) {
      return other.a >= this.a && other.b <= this.b;
    }
    /** Return the interval computed from combining this and other */
  }, {
    key: "union",
    value: function union(other) {
      return Interval.of(Math.min(this.a, other.a), Math.max(this.b, other.b));
    }
    /** Return the interval in common between this and o */
  }, {
    key: "intersection",
    value: function intersection(other) {
      return Interval.of(Math.max(this.a, other.a), Math.min(this.b, other.b));
    }
    /** Return the interval with elements from `this` not in `other`;
     *  `other` must not be totally enclosed (properly contained)
     *  within `this`, which would result in two disjoint intervals
     *  instead of the single one returned by this method.
     */
  }, {
    key: "differenceNotProperlyContained",
    value: function differenceNotProperlyContained(other) {
      var diff;
      if (other.startsBeforeNonDisjoint(this)) {
        // other.a to left of this.a (or same)
        diff = Interval.of(Math.max(this.a, other.b + 1), this.b);
      } else if (other.startsAfterNonDisjoint(this)) {
        // other.a to right of this.a
        diff = Interval.of(this.a, other.a - 1);
      }
      return diff;
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.a + ".." + this.b;
    }
  }], [{
    key: "INVALID",
    get: function get() {
      return Interval._INVALID;
    }
    /** Interval objects are used readonly so share all with the
     *  same single value a==b up to some max size.  Use an array as a perfect hash.
     *  Return shared object for 0..INTERVAL_POOL_MAX_VALUE or a new
     *  Interval object with a..a in it.  On Java.g4, 218623 IntervalSets
     *  have a..a (set with 1 element).
     */
  }, {
    key: "of",
    value: function of(a, b) {
      // cache just a..a
      if (a !== b || a < 0 || a > INTERVAL_POOL_MAX_VALUE) {
        return new Interval(a, b);
      }
      if (Interval.cache[a] == null) {
        Interval.cache[a] = new Interval(a, a);
      }
      return Interval.cache[a];
    }
  }]);
  return Interval;
}();
Interval._INVALID = new Interval(-1, -2);
Interval.cache = new Array(INTERVAL_POOL_MAX_VALUE + 1);
__decorate([Decorators_1.Override], Interval.prototype, "equals", null);
__decorate([Decorators_1.Override], Interval.prototype, "hashCode", null);
__decorate([Decorators_1.Override], Interval.prototype, "toString", null);
exports.Interval = Interval;

},{"../Decorators":272,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612}],379:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.array.splice.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.string.from-code-point.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.set.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:40.8683480-07:00
var ArrayEqualityComparator_1 = require("./ArrayEqualityComparator");
var IntegerList_1 = require("./IntegerList");
var Interval_1 = require("./Interval");
var Lexer_1 = require("../Lexer");
var MurmurHash_1 = require("./MurmurHash");
var Decorators_1 = require("../Decorators");
var Token_1 = require("../Token");
/**
 * This class implements the {@link IntSet} backed by a sorted array of
 * non-overlapping intervals. It is particularly efficient for representing
 * large collections of numbers, where the majority of elements appear as part
 * of a sequential range of numbers that are all part of the set. For example,
 * the set { 1, 2, 3, 4, 7, 8 } may be represented as { [1, 4], [7, 8] }.
 *
 * This class is able to represent sets containing any combination of values in
 * the range {@link Integer#MIN_VALUE} to {@link Integer#MAX_VALUE}
 * (inclusive).
 */
var IntervalSet = /*#__PURE__*/function () {
  function IntervalSet(intervals) {
    (0, _classCallCheck2.default)(this, IntervalSet);
    this.readonly = false;
    if (intervals != null) {
      this._intervals = intervals.slice(0);
    } else {
      this._intervals = [];
    }
  }
  (0, _createClass2.default)(IntervalSet, [{
    key: "clear",
    value: function clear() {
      if (this.readonly) {
        throw new Error("can't alter readonly IntervalSet");
      }
      this._intervals.length = 0;
    }
    /** Add interval; i.e., add all integers from a to b to set.
     *  If b&lt;a, do nothing.
     *  Keep list in sorted order (by left range value).
     *  If overlap, combine ranges.  For example,
     *  If this is {1..5, 10..20}, adding 6..7 yields
     *  {1..5, 6..7, 10..20}.  Adding 4..8 yields {1..8, 10..20}.
     */
  }, {
    key: "add",
    value: function add(a) {
      var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : a;
      this.addRange(Interval_1.Interval.of(a, b));
    }
    // copy on write so we can cache a..a intervals and sets of that
  }, {
    key: "addRange",
    value: function addRange(addition) {
      if (this.readonly) {
        throw new Error("can't alter readonly IntervalSet");
      }
      //System.out.println("add "+addition+" to "+intervals.toString());
      if (addition.b < addition.a) {
        return;
      }
      // find position in list
      // Use iterators as we modify list in place
      for (var i = 0; i < this._intervals.length; i++) {
        var r = this._intervals[i];
        if (addition.equals(r)) {
          return;
        }
        if (addition.adjacent(r) || !addition.disjoint(r)) {
          // next to each other, make a single larger interval
          var bigger = addition.union(r);
          this._intervals[i] = bigger;
          // make sure we didn't just create an interval that
          // should be merged with next interval in list
          while (i < this._intervals.length - 1) {
            i++;
            var next = this._intervals[i];
            if (!bigger.adjacent(next) && bigger.disjoint(next)) {
              break;
            }
            // if we bump up against or overlap next, merge
            // remove this one
            this._intervals.splice(i, 1);
            i--;
            // move backwards to what we just set
            this._intervals[i] = bigger.union(next);
            // set to 3 merged ones
          }
          // first call to next after previous duplicates the result
          return;
        }
        if (addition.startsBeforeDisjoint(r)) {
          // insert before r
          this._intervals.splice(i, 0, addition);
          return;
        }
        // if disjoint and after r, a future iteration will handle it
      }
      // ok, must be after last interval (and disjoint from last interval)
      // just add it
      this._intervals.push(addition);
    }
    /** combine all sets in the array returned the or'd value */
  }, {
    key: "addAll",
    value: function addAll(set) {
      if (set == null) {
        return this;
      }
      if (set instanceof IntervalSet) {
        var other = set;
        // walk set and add each interval
        var n = other._intervals.length;
        for (var i = 0; i < n; i++) {
          var I = other._intervals[i];
          this.add(I.a, I.b);
        }
      } else {
        var _iterator = _createForOfIteratorHelper(set.toArray()),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var value = _step.value;
            this.add(value);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
      return this;
    }
  }, {
    key: "complementRange",
    value: function complementRange(minElement, maxElement) {
      return this.complement(IntervalSet.of(minElement, maxElement));
    }
    /** {@inheritDoc} */
  }, {
    key: "complement",
    value: function complement(vocabulary) {
      if (vocabulary.isNil) {
        // nothing in common with null set
        return IntervalSet.EMPTY_SET;
      }
      var vocabularyIS;
      if (vocabulary instanceof IntervalSet) {
        vocabularyIS = vocabulary;
      } else {
        vocabularyIS = new IntervalSet();
        vocabularyIS.addAll(vocabulary);
      }
      return vocabularyIS.subtract(this);
    }
  }, {
    key: "subtract",
    value: function subtract(a) {
      if (a == null || a.isNil) {
        return new IntervalSet(this._intervals);
      }
      if (a instanceof IntervalSet) {
        return IntervalSet.subtract(this, a);
      }
      var other = new IntervalSet();
      other.addAll(a);
      return IntervalSet.subtract(this, other);
    }
    /**
     * Compute the set difference between two interval sets. The specific
     * operation is `left - right`.
     */
  }, {
    key: "or",
    value: function or(a) {
      var o = new IntervalSet();
      o.addAll(this);
      o.addAll(a);
      return o;
    }
    /** {@inheritDoc} */
  }, {
    key: "and",
    value: function and(other) {
      if (other.isNil) {
        //|| !(other instanceof IntervalSet) ) {
        // nothing in common with null set
        return new IntervalSet();
      }
      var myIntervals = this._intervals;
      var theirIntervals = other._intervals;
      var intersection;
      var mySize = myIntervals.length;
      var theirSize = theirIntervals.length;
      var i = 0;
      var j = 0;
      // iterate down both interval lists looking for nondisjoint intervals
      while (i < mySize && j < theirSize) {
        var mine = myIntervals[i];
        var theirs = theirIntervals[j];
        //System.out.println("mine="+mine+" and theirs="+theirs);
        if (mine.startsBeforeDisjoint(theirs)) {
          // move this iterator looking for interval that might overlap
          i++;
        } else if (theirs.startsBeforeDisjoint(mine)) {
          // move other iterator looking for interval that might overlap
          j++;
        } else if (mine.properlyContains(theirs)) {
          // overlap, add intersection, get next theirs
          if (!intersection) {
            intersection = new IntervalSet();
          }
          intersection.addRange(mine.intersection(theirs));
          j++;
        } else if (theirs.properlyContains(mine)) {
          // overlap, add intersection, get next mine
          if (!intersection) {
            intersection = new IntervalSet();
          }
          intersection.addRange(mine.intersection(theirs));
          i++;
        } else if (!mine.disjoint(theirs)) {
          // overlap, add intersection
          if (!intersection) {
            intersection = new IntervalSet();
          }
          intersection.addRange(mine.intersection(theirs));
          // Move the iterator of lower range [a..b], but not
          // the upper range as it may contain elements that will collide
          // with the next iterator. So, if mine=[0..115] and
          // theirs=[115..200], then intersection is 115 and move mine
          // but not theirs as theirs may collide with the next range
          // in thisIter.
          // move both iterators to next ranges
          if (mine.startsAfterNonDisjoint(theirs)) {
            j++;
          } else if (theirs.startsAfterNonDisjoint(mine)) {
            i++;
          }
        }
      }
      if (!intersection) {
        return new IntervalSet();
      }
      return intersection;
    }
    /** {@inheritDoc} */
  }, {
    key: "contains",
    value: function contains(el) {
      var n = this._intervals.length;
      var l = 0;
      var r = n - 1;
      // Binary search for the element in the (sorted, disjoint) array of intervals.
      while (l <= r) {
        var m = l + r >> 1;
        var I = this._intervals[m];
        var a = I.a;
        var b = I.b;
        if (b < el) {
          l = m + 1;
        } else if (a > el) {
          r = m - 1;
        } else {
          // el >= a && el <= b
          return true;
        }
      }
      return false;
    }
    /** {@inheritDoc} */
  }, {
    key: "isNil",
    get: function get() {
      return this._intervals == null || this._intervals.length === 0;
    }
    /**
     * Returns the maximum value contained in the set if not isNil.
     *
     * @return the maximum value contained in the set.
     * @throws RangeError if set is empty
     */
  }, {
    key: "maxElement",
    get: function get() {
      if (this.isNil) {
        throw new RangeError("set is empty");
      }
      var last = this._intervals[this._intervals.length - 1];
      return last.b;
    }
    /**
     * Returns the minimum value contained in the set if not isNil.
     *
     * @return the minimum value contained in the set.
     * @throws RangeError if set is empty
     */
  }, {
    key: "minElement",
    get: function get() {
      if (this.isNil) {
        throw new RangeError("set is empty");
      }
      return this._intervals[0].a;
    }
    /** Return a list of Interval objects. */
  }, {
    key: "intervals",
    get: function get() {
      return this._intervals;
    }
  }, {
    key: "hashCode",
    value: function hashCode() {
      var hash = MurmurHash_1.MurmurHash.initialize();
      var _iterator2 = _createForOfIteratorHelper(this._intervals),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var I = _step2.value;
          hash = MurmurHash_1.MurmurHash.update(hash, I.a);
          hash = MurmurHash_1.MurmurHash.update(hash, I.b);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      hash = MurmurHash_1.MurmurHash.finish(hash, this._intervals.length * 2);
      return hash;
    }
    /** Are two IntervalSets equal?  Because all intervals are sorted
     *  and disjoint, equals is a simple linear walk over both lists
     *  to make sure they are the same.  Interval.equals() is used
     *  by the List.equals() method to check the ranges.
     */
  }, {
    key: "equals",
    value: function equals(o) {
      if (o == null || !(o instanceof IntervalSet)) {
        return false;
      }
      return ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this._intervals, o._intervals);
    }
  }, {
    key: "toString",
    value: function toString() {
      var elemAreChar = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var buf = "";
      if (this._intervals == null || this._intervals.length === 0) {
        return "{}";
      }
      if (this.size > 1) {
        buf += "{";
      }
      var first = true;
      var _iterator3 = _createForOfIteratorHelper(this._intervals),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var I = _step3.value;
          if (first) {
            first = false;
          } else {
            buf += ", ";
          }
          var a = I.a;
          var b = I.b;
          if (a === b) {
            if (a === Token_1.Token.EOF) {
              buf += "<EOF>";
            } else if (elemAreChar) {
              buf += "'" + String.fromCodePoint(a) + "'";
            } else {
              buf += a;
            }
          } else {
            if (elemAreChar) {
              buf += "'" + String.fromCodePoint(a) + "'..'" + String.fromCodePoint(b) + "'";
            } else {
              buf += a + ".." + b;
            }
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      if (this.size > 1) {
        buf += "}";
      }
      return buf;
    }
  }, {
    key: "toStringVocabulary",
    value: function toStringVocabulary(vocabulary) {
      if (this._intervals == null || this._intervals.length === 0) {
        return "{}";
      }
      var buf = "";
      if (this.size > 1) {
        buf += "{";
      }
      var first = true;
      var _iterator4 = _createForOfIteratorHelper(this._intervals),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var I = _step4.value;
          if (first) {
            first = false;
          } else {
            buf += ", ";
          }
          var a = I.a;
          var b = I.b;
          if (a === b) {
            buf += this.elementName(vocabulary, a);
          } else {
            for (var i = a; i <= b; i++) {
              if (i > a) {
                buf += ", ";
              }
              buf += this.elementName(vocabulary, i);
            }
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      if (this.size > 1) {
        buf += "}";
      }
      return buf;
    }
  }, {
    key: "elementName",
    value: function elementName(vocabulary, a) {
      if (a === Token_1.Token.EOF) {
        return "<EOF>";
      } else if (a === Token_1.Token.EPSILON) {
        return "<EPSILON>";
      } else {
        return vocabulary.getDisplayName(a);
      }
    }
  }, {
    key: "size",
    get: function get() {
      var n = 0;
      var numIntervals = this._intervals.length;
      if (numIntervals === 1) {
        var firstInterval = this._intervals[0];
        return firstInterval.b - firstInterval.a + 1;
      }
      for (var i = 0; i < numIntervals; i++) {
        var I = this._intervals[i];
        n += I.b - I.a + 1;
      }
      return n;
    }
  }, {
    key: "toIntegerList",
    value: function toIntegerList() {
      var values = new IntegerList_1.IntegerList(this.size);
      var n = this._intervals.length;
      for (var i = 0; i < n; i++) {
        var I = this._intervals[i];
        var a = I.a;
        var b = I.b;
        for (var v = a; v <= b; v++) {
          values.add(v);
        }
      }
      return values;
    }
  }, {
    key: "toSet",
    value: function toSet() {
      var s = new Set();
      var _iterator5 = _createForOfIteratorHelper(this._intervals),
        _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var I = _step5.value;
          var a = I.a;
          var b = I.b;
          for (var v = a; v <= b; v++) {
            s.add(v);
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
      return s;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var values = new Array();
      var n = this._intervals.length;
      for (var i = 0; i < n; i++) {
        var I = this._intervals[i];
        var a = I.a;
        var b = I.b;
        for (var v = a; v <= b; v++) {
          values.push(v);
        }
      }
      return values;
    }
  }, {
    key: "remove",
    value: function remove(el) {
      if (this.readonly) {
        throw new Error("can't alter readonly IntervalSet");
      }
      var n = this._intervals.length;
      for (var i = 0; i < n; i++) {
        var I = this._intervals[i];
        var a = I.a;
        var b = I.b;
        if (el < a) {
          break; // list is sorted and el is before this interval; not here
        }
        // if whole interval x..x, rm
        if (el === a && el === b) {
          this._intervals.splice(i, 1);
          break;
        }
        // if on left edge x..b, adjust left
        if (el === a) {
          this._intervals[i] = Interval_1.Interval.of(I.a + 1, I.b);
          break;
        }
        // if on right edge a..x, adjust right
        if (el === b) {
          this._intervals[i] = Interval_1.Interval.of(I.a, I.b - 1);
          break;
        }
        // if in middle a..x..b, split interval
        if (el > a && el < b) {
          // found in this interval
          var oldb = I.b;
          this._intervals[i] = Interval_1.Interval.of(I.a, el - 1); // [a..x-1]
          this.add(el + 1, oldb); // add [x+1..b]
        }
      }
    }
  }, {
    key: "isReadonly",
    get: function get() {
      return this.readonly;
    }
  }, {
    key: "setReadonly",
    value: function setReadonly(readonly) {
      if (this.readonly && !readonly) {
        throw new Error("can't alter readonly IntervalSet");
      }
      this.readonly = readonly;
    }
  }], [{
    key: "COMPLETE_CHAR_SET",
    get: function get() {
      if (IntervalSet._COMPLETE_CHAR_SET === undefined) {
        IntervalSet._COMPLETE_CHAR_SET = IntervalSet.of(Lexer_1.Lexer.MIN_CHAR_VALUE, Lexer_1.Lexer.MAX_CHAR_VALUE);
        IntervalSet._COMPLETE_CHAR_SET.setReadonly(true);
      }
      return IntervalSet._COMPLETE_CHAR_SET;
    }
  }, {
    key: "EMPTY_SET",
    get: function get() {
      if (IntervalSet._EMPTY_SET == null) {
        IntervalSet._EMPTY_SET = new IntervalSet();
        IntervalSet._EMPTY_SET.setReadonly(true);
      }
      return IntervalSet._EMPTY_SET;
    }
    /**
     * Create a set with all ints within range [a..b] (inclusive). If b is omitted, the set contains the single element
     * a.
     */
  }, {
    key: "of",
    value: function of(a) {
      var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : a;
      var s = new IntervalSet();
      s.add(a, b);
      return s;
    }
  }, {
    key: "or",
    value: function or(sets) {
      var r = new IntervalSet();
      var _iterator6 = _createForOfIteratorHelper(sets),
        _step6;
      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var s = _step6.value;
          r.addAll(s);
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
      return r;
    }
  }, {
    key: "subtract",
    value: function subtract(left, right) {
      if (left.isNil) {
        return new IntervalSet();
      }
      var result = new IntervalSet(left._intervals);
      if (right.isNil) {
        // right set has no elements; just return the copy of the current set
        return result;
      }
      var resultI = 0;
      var rightI = 0;
      while (resultI < result._intervals.length && rightI < right._intervals.length) {
        var resultInterval = result._intervals[resultI];
        var rightInterval = right._intervals[rightI];
        // operation: (resultInterval - rightInterval) and update indexes
        if (rightInterval.b < resultInterval.a) {
          rightI++;
          continue;
        }
        if (rightInterval.a > resultInterval.b) {
          resultI++;
          continue;
        }
        var beforeCurrent = void 0;
        var afterCurrent = void 0;
        if (rightInterval.a > resultInterval.a) {
          beforeCurrent = new Interval_1.Interval(resultInterval.a, rightInterval.a - 1);
        }
        if (rightInterval.b < resultInterval.b) {
          afterCurrent = new Interval_1.Interval(rightInterval.b + 1, resultInterval.b);
        }
        if (beforeCurrent) {
          if (afterCurrent) {
            // split the current interval into two
            result._intervals[resultI] = beforeCurrent;
            result._intervals.splice(resultI + 1, 0, afterCurrent);
            resultI++;
            rightI++;
            continue;
          } else {
            // replace the current interval
            result._intervals[resultI] = beforeCurrent;
            resultI++;
            continue;
          }
        } else {
          if (afterCurrent) {
            // replace the current interval
            result._intervals[resultI] = afterCurrent;
            rightI++;
            continue;
          } else {
            // remove the current interval (thus no need to increment resultI)
            result._intervals.splice(resultI, 1);
            continue;
          }
        }
      }
      // If rightI reached right.intervals.size, no more intervals to subtract from result.
      // If resultI reached result.intervals.size, we would be subtracting from an empty set.
      // Either way, we are done.
      return result;
    }
  }]);
  return IntervalSet;
}();
__decorate([Decorators_1.Override], IntervalSet.prototype, "addAll", null);
__decorate([Decorators_1.Override], IntervalSet.prototype, "complement", null);
__decorate([Decorators_1.Override], IntervalSet.prototype, "subtract", null);
__decorate([Decorators_1.Override], IntervalSet.prototype, "or", null);
__decorate([Decorators_1.Override], IntervalSet.prototype, "and", null);
__decorate([Decorators_1.Override], IntervalSet.prototype, "contains", null);
__decorate([Decorators_1.Override], IntervalSet.prototype, "isNil", null);
__decorate([Decorators_1.Override], IntervalSet.prototype, "hashCode", null);
__decorate([Decorators_1.Override], IntervalSet.prototype, "equals", null);
__decorate([__param(0, Decorators_1.NotNull)], IntervalSet.prototype, "toStringVocabulary", null);
__decorate([Decorators_1.NotNull, __param(0, Decorators_1.NotNull)], IntervalSet.prototype, "elementName", null);
__decorate([Decorators_1.Override], IntervalSet.prototype, "size", null);
__decorate([Decorators_1.Override], IntervalSet.prototype, "remove", null);
__decorate([Decorators_1.NotNull], IntervalSet, "of", null);
__decorate([Decorators_1.NotNull], IntervalSet, "subtract", null);
exports.IntervalSet = IntervalSet;

},{"../Decorators":272,"../Lexer":280,"../Token":296,"./ArrayEqualityComparator":371,"./IntegerList":376,"./Interval":378,"./MurmurHash":381,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.array.splice.js":582,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.promise.js":614,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.set.js":621,"core-js/modules/es.string.from-code-point.js":624,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],380:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/web.dom-collections.for-each.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.map.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapNativeSuper"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:42.1346951-07:00
var MultiMap = /*#__PURE__*/function (_Map) {
  (0, _inherits2.default)(MultiMap, _Map);
  var _super = _createSuper(MultiMap);
  function MultiMap() {
    (0, _classCallCheck2.default)(this, MultiMap);
    return _super.call(this);
  }
  (0, _createClass2.default)(MultiMap, [{
    key: "map",
    value: function map(key, value) {
      var elementsForKey = (0, _get2.default)((0, _getPrototypeOf2.default)(MultiMap.prototype), "get", this).call(this, key);
      if (!elementsForKey) {
        elementsForKey = [];
        (0, _get2.default)((0, _getPrototypeOf2.default)(MultiMap.prototype), "set", this).call(this, key, elementsForKey);
      }
      elementsForKey.push(value);
    }
  }, {
    key: "getPairs",
    value: function getPairs() {
      var pairs = [];
      this.forEach(function (values, key) {
        values.forEach(function (v) {
          pairs.push([key, v]);
        });
      });
      return pairs;
    }
  }]);
  return MultiMap;
}( /*#__PURE__*/(0, _wrapNativeSuper2.default)(Map));
exports.MultiMap = MultiMap;

},{"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/get":234,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/wrapNativeSuper":254,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.map.js":587,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.string.iterator.js":626,"core-js/modules/web.dom-collections.for-each.js":676,"core-js/modules/web.dom-collections.iterator.js":677}],381:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.math.imul.js");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 *
 * @author Sam Harwell
 */
var MurmurHash;
(function (MurmurHash) {
  var DEFAULT_SEED = 0;
  /**
   * Initialize the hash using the specified `seed`.
   *
   * @param seed the seed (optional)
   * @returns the intermediate hash value
   */
  function initialize() {
    var seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_SEED;
    return seed;
  }
  MurmurHash.initialize = initialize;
  /**
   * Update the intermediate hash value for the next input `value`.
   *
   * @param hash the intermediate hash value
   * @param value the value to add to the current hash
   * @returns the updated intermediate hash value
   */
  function update(hash, value) {
    var c1 = 0xCC9E2D51;
    var c2 = 0x1B873593;
    var r1 = 15;
    var r2 = 13;
    var m = 5;
    var n = 0xE6546B64;
    if (value == null) {
      value = 0;
    } else if (typeof value === "string") {
      value = hashString(value);
    } else if ((0, _typeof2.default)(value) === "object") {
      value = value.hashCode();
    }
    var k = value;
    k = Math.imul(k, c1);
    k = k << r1 | k >>> 32 - r1;
    k = Math.imul(k, c2);
    hash = hash ^ k;
    hash = hash << r2 | hash >>> 32 - r2;
    hash = Math.imul(hash, m) + n;
    return hash & 0xFFFFFFFF;
  }
  MurmurHash.update = update;
  /**
   * Apply the final computation steps to the intermediate value `hash`
   * to form the final result of the MurmurHash 3 hash function.
   *
   * @param hash the intermediate hash value
   * @param numberOfWords the number of integer values added to the hash
   * @returns the final hash result
   */
  function finish(hash, numberOfWords) {
    hash = hash ^ numberOfWords * 4;
    hash = hash ^ hash >>> 16;
    hash = Math.imul(hash, 0x85EBCA6B);
    hash = hash ^ hash >>> 13;
    hash = Math.imul(hash, 0xC2B2AE35);
    hash = hash ^ hash >>> 16;
    return hash;
  }
  MurmurHash.finish = finish;
  /**
   * Utility function to compute the hash code of an array using the
   * MurmurHash algorithm.
   *
   * @param <T> the array element type
   * @param data the array data
   * @param seed the seed for the MurmurHash algorithm
   * @returns the hash code of the data
   */
  function hashCode(data) {
    var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_SEED;
    var hash = initialize(seed);
    var length = 0;
    var _iterator = _createForOfIteratorHelper(data),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var value = _step.value;
        hash = update(hash, value);
        length++;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    hash = finish(hash, length);
    return hash;
  }
  MurmurHash.hashCode = hashCode;
  /**
   * Function to hash a string. Based on the implementation found here:
   * http://stackoverflow.com/a/7616484
   */
  function hashString(str) {
    var len = str.length;
    if (len === 0) {
      return 0;
    }
    var hash = 0;
    for (var i = 0; i < len; i++) {
      var c = str.charCodeAt(i);
      hash = (hash << 5 >>> 0) - hash + c;
      hash |= 0;
    }
    return hash;
  }
})(MurmurHash = exports.MurmurHash || (exports.MurmurHash = {}));

},{"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.math.imul.js":589,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],382:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var Decorators_1 = require("../Decorators");
/**
 * This default implementation of {@link EqualityComparator} uses object equality
 * for comparisons by calling {@link Object#hashCode} and {@link Object#equals}.
 *
 * @author Sam Harwell
 */
var ObjectEqualityComparator = /*#__PURE__*/function () {
  function ObjectEqualityComparator() {
    (0, _classCallCheck2.default)(this, ObjectEqualityComparator);
  }
  (0, _createClass2.default)(ObjectEqualityComparator, [{
    key: "hashCode",
    value:
    /**
     * {@inheritDoc}
     *
     * This implementation returns
     * `obj.`{@link Object#hashCode hashCode()}.
     */
    function hashCode(obj) {
      if (obj == null) {
        return 0;
      }
      return obj.hashCode();
    }
    /**
     * {@inheritDoc}
     *
     * This implementation relies on object equality. If both objects are
     * `undefined` or `null`, this method returns `true`. Otherwise if only
     * `a` is `undefined` or `null`, this method returns `false`. Otherwise,
     * this method returns the result of
     * `a.`{@link Object#equals equals}`(b)`.
     */
  }, {
    key: "equals",
    value: function equals(a, b) {
      if (a == null) {
        return b == null;
      }
      return a.equals(b);
    }
  }]);
  return ObjectEqualityComparator;
}();
ObjectEqualityComparator.INSTANCE = new ObjectEqualityComparator();
__decorate([Decorators_1.Override], ObjectEqualityComparator.prototype, "hashCode", null);
__decorate([Decorators_1.Override], ObjectEqualityComparator.prototype, "equals", null);
exports.ObjectEqualityComparator = ObjectEqualityComparator;

},{"../Decorators":272,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612}],383:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapNativeSuper"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:42.5447085-07:00
/**
 * This exception is thrown to cancel a parsing operation. This exception does
 * not extend {@link RecognitionException}, allowing it to bypass the standard
 * error recovery mechanisms. {@link BailErrorStrategy} throws this exception in
 * response to a parse error.
 *
 * @author Sam Harwell
 */
var ParseCancellationException = /*#__PURE__*/function (_Error) {
  (0, _inherits2.default)(ParseCancellationException, _Error);
  var _super = _createSuper(ParseCancellationException);
  function ParseCancellationException(cause) {
    var _this;
    (0, _classCallCheck2.default)(this, ParseCancellationException);
    _this = _super.call(this, cause.message);
    _this.cause = cause;
    _this.stack = cause.stack;
    return _this;
  }
  (0, _createClass2.default)(ParseCancellationException, [{
    key: "getCause",
    value: function getCause() {
      return this.cause;
    }
  }]);
  return ParseCancellationException;
}( /*#__PURE__*/(0, _wrapNativeSuper2.default)(Error));
exports.ParseCancellationException = ParseCancellationException;

},{"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/wrapNativeSuper":254,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],384:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array-buffer.slice.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.typed-array.uint32-array.js");
require("core-js/modules/es.typed-array.copy-within.js");
require("core-js/modules/es.typed-array.every.js");
require("core-js/modules/es.typed-array.fill.js");
require("core-js/modules/es.typed-array.filter.js");
require("core-js/modules/es.typed-array.find.js");
require("core-js/modules/es.typed-array.find-index.js");
require("core-js/modules/es.typed-array.for-each.js");
require("core-js/modules/es.typed-array.includes.js");
require("core-js/modules/es.typed-array.index-of.js");
require("core-js/modules/es.typed-array.iterator.js");
require("core-js/modules/es.typed-array.join.js");
require("core-js/modules/es.typed-array.last-index-of.js");
require("core-js/modules/es.typed-array.map.js");
require("core-js/modules/es.typed-array.reduce.js");
require("core-js/modules/es.typed-array.reduce-right.js");
require("core-js/modules/es.typed-array.reverse.js");
require("core-js/modules/es.typed-array.set.js");
require("core-js/modules/es.typed-array.slice.js");
require("core-js/modules/es.typed-array.some.js");
require("core-js/modules/es.typed-array.sort.js");
require("core-js/modules/es.typed-array.subarray.js");
require("core-js/modules/es.typed-array.to-locale-string.js");
require("core-js/modules/es.typed-array.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.regexp.exec.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
Object.defineProperty(exports, "__esModule", {
  value: true
});
var MurmurHash_1 = require("./MurmurHash");
var UUID = /*#__PURE__*/function () {
  function UUID(mostSigBits, moreSigBits, lessSigBits, leastSigBits) {
    (0, _classCallCheck2.default)(this, UUID);
    this.data = new Uint32Array(4);
    this.data[0] = mostSigBits;
    this.data[1] = moreSigBits;
    this.data[2] = lessSigBits;
    this.data[3] = leastSigBits;
  }
  (0, _createClass2.default)(UUID, [{
    key: "hashCode",
    value: function hashCode() {
      return MurmurHash_1.MurmurHash.hashCode([this.data[0], this.data[1], this.data[2], this.data[3]]);
    }
  }, {
    key: "equals",
    value: function equals(obj) {
      if (obj === this) {
        return true;
      } else if (!(obj instanceof UUID)) {
        return false;
      }
      return this.data[0] === obj.data[0] && this.data[1] === obj.data[1] && this.data[2] === obj.data[2] && this.data[3] === obj.data[3];
    }
  }, {
    key: "toString",
    value: function toString() {
      return ("00000000" + this.data[0].toString(16)).substr(-8) + "-" + ("0000" + (this.data[1] >>> 16).toString(16)).substr(-4) + "-" + ("0000" + this.data[1].toString(16)).substr(-4) + "-" + ("0000" + (this.data[2] >>> 16).toString(16)).substr(-4) + "-" + ("0000" + this.data[2].toString(16)).substr(-4) + ("00000000" + this.data[3].toString(16)).substr(-8);
    }
  }], [{
    key: "fromString",
    value: function fromString(data) {
      if (!/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.test(data)) {
        throw new Error("Incorrectly formatted UUID");
      }
      var segments = data.split("-");
      var mostSigBits = parseInt(segments[0], 16);
      var moreSigBits = (parseInt(segments[1], 16) << 16 >>> 0) + parseInt(segments[2], 16);
      var lessSigBits = (parseInt(segments[3], 16) << 16 >>> 0) + parseInt(segments[4].substr(0, 4), 16);
      var leastSigBits = parseInt(segments[4].substr(-8), 16);
      return new UUID(mostSigBits, moreSigBits, lessSigBits, leastSigBits);
    }
  }]);
  return UUID;
}();
exports.UUID = UUID;

},{"./MurmurHash":381,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"core-js/modules/es.array-buffer.slice.js":568,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.typed-array.copy-within.js":641,"core-js/modules/es.typed-array.every.js":642,"core-js/modules/es.typed-array.fill.js":643,"core-js/modules/es.typed-array.filter.js":644,"core-js/modules/es.typed-array.find-index.js":645,"core-js/modules/es.typed-array.find.js":646,"core-js/modules/es.typed-array.for-each.js":649,"core-js/modules/es.typed-array.includes.js":650,"core-js/modules/es.typed-array.index-of.js":651,"core-js/modules/es.typed-array.iterator.js":655,"core-js/modules/es.typed-array.join.js":656,"core-js/modules/es.typed-array.last-index-of.js":657,"core-js/modules/es.typed-array.map.js":658,"core-js/modules/es.typed-array.reduce-right.js":659,"core-js/modules/es.typed-array.reduce.js":660,"core-js/modules/es.typed-array.reverse.js":661,"core-js/modules/es.typed-array.set.js":662,"core-js/modules/es.typed-array.slice.js":663,"core-js/modules/es.typed-array.some.js":664,"core-js/modules/es.typed-array.sort.js":665,"core-js/modules/es.typed-array.subarray.js":666,"core-js/modules/es.typed-array.to-locale-string.js":667,"core-js/modules/es.typed-array.to-string.js":668,"core-js/modules/es.typed-array.uint32-array.js":670}],385:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.array.join.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.map.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.array-buffer.slice.js");
require("core-js/modules/es.typed-array.uint16-array.js");
require("core-js/modules/es.typed-array.copy-within.js");
require("core-js/modules/es.typed-array.every.js");
require("core-js/modules/es.typed-array.fill.js");
require("core-js/modules/es.typed-array.filter.js");
require("core-js/modules/es.typed-array.find.js");
require("core-js/modules/es.typed-array.find-index.js");
require("core-js/modules/es.typed-array.for-each.js");
require("core-js/modules/es.typed-array.includes.js");
require("core-js/modules/es.typed-array.index-of.js");
require("core-js/modules/es.typed-array.iterator.js");
require("core-js/modules/es.typed-array.join.js");
require("core-js/modules/es.typed-array.last-index-of.js");
require("core-js/modules/es.typed-array.map.js");
require("core-js/modules/es.typed-array.reduce.js");
require("core-js/modules/es.typed-array.reduce-right.js");
require("core-js/modules/es.typed-array.reverse.js");
require("core-js/modules/es.typed-array.set.js");
require("core-js/modules/es.typed-array.slice.js");
require("core-js/modules/es.typed-array.some.js");
require("core-js/modules/es.typed-array.sort.js");
require("core-js/modules/es.typed-array.subarray.js");
require("core-js/modules/es.typed-array.to-locale-string.js");
require("core-js/modules/es.typed-array.to-string.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
function escapeWhitespace(s, escapeSpaces) {
  return escapeSpaces ? s.replace(/ /, "\xB7") : s.replace(/\t/, "\\t").replace(/\n/, "\\n").replace(/\r/, "\\r");
}
exports.escapeWhitespace = escapeWhitespace;
// Seriously: why isn't this built in to java? ugh!
function join(collection, separator) {
  var buf = "";
  var first = true;
  var _iterator = _createForOfIteratorHelper(collection),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var current = _step.value;
      if (first) {
        first = false;
      } else {
        buf += separator;
      }
      buf += current;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return buf;
}
exports.join = join;
function equals(x, y) {
  if (x === y) {
    return true;
  }
  if (x === undefined || y === undefined) {
    return false;
  }
  return x.equals(y);
}
exports.equals = equals;
// export function numNonnull(data: any[]): number {
// 	let n: number =  0;
// 	if ( data == null ) return n;
// 	for (let o of data) {
// 		if ( o!=null ) n++;
// 	}
// 	return n;
// }
// export function removeAllElements<T>(data: Collection<T>, value: T): void {
// 	if ( data==null ) return;
// 	while ( data.contains(value) ) data.remove(value);
// }
// export function writeFile(@NotNull file: File, @NotNull content: Uint8Array): void {
// 	let fos: FileOutputStream = new FileOutputStream(file);
// 	try {
// 		fos.write(content);
// 	} finally {
// 		fos.close();
// 	}
// }
// export function writeFile(@NotNull fileName: string, @NotNull content: string): void {
// 	writeFile(fileName, content, null);
// }
// export function writeFile(@NotNull fileName: string, @NotNull content: string, @Nullable encoding: string): void {
// 	let f: File =  new File(fileName);
// 	let fos: FileOutputStream =  new FileOutputStream(f);
// 	let osw: OutputStreamWriter;
// 	if (encoding != null) {
// 		osw = new OutputStreamWriter(fos, encoding);
// 	}
// 	else {
// 		osw = new OutputStreamWriter(fos);
// 	}
// 	try {
// 		osw.write(content);
// 	}
// 	finally {
// 		osw.close();
// 	}
// }
// @NotNull
// export function readFile(@NotNull fileName: string): char[] {
// 	return readFile(fileName, null);
// }
// @NotNull
// export function readFile(@NotNull fileName: string, @Nullable encoding: string): char[] {
// 	let f: File =  new File(fileName);
// 	let size: number =  (int)f.length();
// 	let isr: InputStreamReader;
// 	let fis: FileInputStream =  new FileInputStream(fileName);
// 	if ( encoding!=null ) {
// 		isr = new InputStreamReader(fis, encoding);
// 	}
// 	else {
// 		isr = new InputStreamReader(fis);
// 	}
// 	let data: char[] =  null;
// 	try {
// 		data = new char[size];
// 		let n: number =  isr.read(data);
// 		if (n < data.length) {
// 			data = Arrays.copyOf(data, n);
// 		}
// 	}
// 	finally {
// 		isr.close();
// 	}
// 	return data;
// }
// export function removeAll<T>(@NotNull predicate: List<T> list,@NotNull Predicate<? super T>): void {
// 	let j: number =  0;
// 	for (let i = 0; i < list.size; i++) {
// 		let item: T =  list.get(i);
// 		if (!predicate.eval(item)) {
// 			if (j != i) {
// 				list.set(j, item);
// 			}
// 			j++;
// 		}
// 	}
// 	if (j < list.size) {
// 		list.subList(j, list.size).clear();
// 	}
// }
// export function removeAll<T>(@NotNull predicate: Iterable<T> iterable,@NotNull Predicate<? super T>): void {
// 	if (iterable instanceof List<?>) {
// 		removeAll((List<T>)iterable, predicate);
// 		return;
// 	}
// 	for (Iterator<T> iterator = iterable.iterator(); iterator.hasNext(); ) {
// 		let item: T =  iterator.next();
// 		if (predicate.eval(item)) {
// 			iterator.remove();
// 		}
// 	}
// }
/** Convert array of strings to string&rarr;index map. Useful for
 *  converting rulenames to name&rarr;ruleindex map.
 */
function toMap(keys) {
  var m = new Map();
  for (var i = 0; i < keys.length; i++) {
    m.set(keys[i], i);
  }
  return m;
}
exports.toMap = toMap;
function toCharArray(str) {
  if (typeof str === "string") {
    var result = new Uint16Array(str.length);
    for (var i = 0; i < str.length; i++) {
      result[i] = str.charCodeAt(i);
    }
    return result;
  } else {
    return str.toCharArray();
  }
}
exports.toCharArray = toCharArray;
// /**
// 	* @since 4.5
// 	*/
// @NotNull
// export function toSet(@NotNull bits: BitSet): IntervalSet {
// 	let s: IntervalSet =  new IntervalSet();
// 	let i: number =  bits.nextSetBit(0);
// 	while ( i >= 0 ) {
// 		s.add(i);
// 		i = bits.nextSetBit(i+1);
// 	}
// 	return s;
// }

},{"core-js/modules/es.array-buffer.slice.js":568,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.join.js":578,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.map.js":587,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.string.replace.js":629,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/es.typed-array.copy-within.js":641,"core-js/modules/es.typed-array.every.js":642,"core-js/modules/es.typed-array.fill.js":643,"core-js/modules/es.typed-array.filter.js":644,"core-js/modules/es.typed-array.find-index.js":645,"core-js/modules/es.typed-array.find.js":646,"core-js/modules/es.typed-array.for-each.js":649,"core-js/modules/es.typed-array.includes.js":650,"core-js/modules/es.typed-array.index-of.js":651,"core-js/modules/es.typed-array.iterator.js":655,"core-js/modules/es.typed-array.join.js":656,"core-js/modules/es.typed-array.last-index-of.js":657,"core-js/modules/es.typed-array.map.js":658,"core-js/modules/es.typed-array.reduce-right.js":659,"core-js/modules/es.typed-array.reduce.js":660,"core-js/modules/es.typed-array.reverse.js":661,"core-js/modules/es.typed-array.set.js":662,"core-js/modules/es.typed-array.slice.js":663,"core-js/modules/es.typed-array.some.js":664,"core-js/modules/es.typed-array.sort.js":665,"core-js/modules/es.typed-array.subarray.js":666,"core-js/modules/es.typed-array.to-locale-string.js":667,"core-js/modules/es.typed-array.to-string.js":668,"core-js/modules/es.typed-array.uint16-array.js":669,"core-js/modules/web.dom-collections.iterator.js":677}],386:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var Decorators_1 = require("../Decorators");
var AbstractParseTreeVisitor = /*#__PURE__*/function () {
  function AbstractParseTreeVisitor() {
    (0, _classCallCheck2.default)(this, AbstractParseTreeVisitor);
  }
  (0, _createClass2.default)(AbstractParseTreeVisitor, [{
    key: "visit",
    value:
    /**
     * {@inheritDoc}
     *
     * The default implementation calls {@link ParseTree#accept} on the
     * specified tree.
     */
    function visit(tree) {
      return tree.accept(this);
    }
    /**
     * {@inheritDoc}
     *
     * The default implementation initializes the aggregate result to
     * {@link #defaultResult defaultResult()}. Before visiting each child, it
     * calls {@link #shouldVisitNextChild shouldVisitNextChild}; if the result
     * is `false` no more children are visited and the current aggregate
     * result is returned. After visiting a child, the aggregate result is
     * updated by calling {@link #aggregateResult aggregateResult} with the
     * previous aggregate result and the result of visiting the child.
     *
     * The default implementation is not safe for use in visitors that modify
     * the tree structure. Visitors that modify the tree should override this
     * method to behave properly in respect to the specific algorithm in use.
     */
  }, {
    key: "visitChildren",
    value: function visitChildren(node) {
      var result = this.defaultResult();
      var n = node.childCount;
      for (var i = 0; i < n; i++) {
        if (!this.shouldVisitNextChild(node, result)) {
          break;
        }
        var c = node.getChild(i);
        var childResult = c.accept(this);
        result = this.aggregateResult(result, childResult);
      }
      return result;
    }
    /**
     * {@inheritDoc}
     *
     * The default implementation returns the result of
     * {@link #defaultResult defaultResult}.
     */
  }, {
    key: "visitTerminal",
    value: function visitTerminal(node) {
      return this.defaultResult();
    }
    /**
     * {@inheritDoc}
     *
     * The default implementation returns the result of
     * {@link #defaultResult defaultResult}.
     */
  }, {
    key: "visitErrorNode",
    value: function visitErrorNode(node) {
      return this.defaultResult();
    }
    /**
     * Aggregates the results of visiting multiple children of a node. After
     * either all children are visited or {@link #shouldVisitNextChild} returns
     * `false`, the aggregate value is returned as the result of
     * {@link #visitChildren}.
     *
     * The default implementation returns `nextResult`, meaning
     * {@link #visitChildren} will return the result of the last child visited
     * (or return the initial value if the node has no children).
     *
     * @param aggregate The previous aggregate value. In the default
     * implementation, the aggregate value is initialized to
     * {@link #defaultResult}, which is passed as the `aggregate` argument
     * to this method after the first child node is visited.
     * @param nextResult The result of the immediately preceeding call to visit
     * a child node.
     *
     * @returns The updated aggregate result.
     */
  }, {
    key: "aggregateResult",
    value: function aggregateResult(aggregate, nextResult) {
      return nextResult;
    }
    /**
     * This method is called after visiting each child in
     * {@link #visitChildren}. This method is first called before the first
     * child is visited; at that point `currentResult` will be the initial
     * value (in the default implementation, the initial value is returned by a
     * call to {@link #defaultResult}. This method is not called after the last
     * child is visited.
     *
     * The default implementation always returns `true`, indicating that
     * `visitChildren` should only return after all children are visited.
     * One reason to override this method is to provide a "short circuit"
     * evaluation option for situations where the result of visiting a single
     * child has the potential to determine the result of the visit operation as
     * a whole.
     *
     * @param node The {@link RuleNode} whose children are currently being
     * visited.
     * @param currentResult The current aggregate result of the children visited
     * to the current point.
     *
     * @returns `true` to continue visiting children. Otherwise return
     * `false` to stop visiting children and immediately return the
     * current aggregate result from {@link #visitChildren}.
     */
  }, {
    key: "shouldVisitNextChild",
    value: function shouldVisitNextChild(node, currentResult) {
      return true;
    }
  }]);
  return AbstractParseTreeVisitor;
}();
__decorate([Decorators_1.Override, __param(0, Decorators_1.NotNull)], AbstractParseTreeVisitor.prototype, "visit", null);
__decorate([Decorators_1.Override, __param(0, Decorators_1.NotNull)], AbstractParseTreeVisitor.prototype, "visitChildren", null);
__decorate([Decorators_1.Override, __param(0, Decorators_1.NotNull)], AbstractParseTreeVisitor.prototype, "visitTerminal", null);
__decorate([Decorators_1.Override, __param(0, Decorators_1.NotNull)], AbstractParseTreeVisitor.prototype, "visitErrorNode", null);
__decorate([__param(0, Decorators_1.NotNull)], AbstractParseTreeVisitor.prototype, "shouldVisitNextChild", null);
exports.AbstractParseTreeVisitor = AbstractParseTreeVisitor;

},{"../Decorators":272,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612}],387:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:47.4646355-07:00
var Decorators_1 = require("../Decorators");
var TerminalNode_1 = require("./TerminalNode");
/** Represents a token that was consumed during resynchronization
 *  rather than during a valid match operation. For example,
 *  we will create this kind of a node during single token insertion
 *  and deletion as well as during "consume until error recovery set"
 *  upon no viable alternative exceptions.
 */
var ErrorNode = /*#__PURE__*/function (_TerminalNode_1$Termi) {
  (0, _inherits2.default)(ErrorNode, _TerminalNode_1$Termi);
  var _super = _createSuper(ErrorNode);
  function ErrorNode(token) {
    (0, _classCallCheck2.default)(this, ErrorNode);
    return _super.call(this, token);
  }
  (0, _createClass2.default)(ErrorNode, [{
    key: "accept",
    value: function accept(visitor) {
      return visitor.visitErrorNode(this);
    }
  }]);
  return ErrorNode;
}(TerminalNode_1.TerminalNode);
__decorate([Decorators_1.Override], ErrorNode.prototype, "accept", null);
exports.ErrorNode = ErrorNode;

},{"../Decorators":272,"./TerminalNode":391,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],388:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.object.to-string.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Associate a property with a parse tree node. Useful with parse tree listeners
 * that need to associate values with particular tree nodes, kind of like
 * specifying a return value for the listener event method that visited a
 * particular node. Example:
 *
 * ```
 * ParseTreeProperty<Integer> values = new ParseTreeProperty<Integer>();
 * values.put(tree, 36);
 * int x = values.get(tree);
 * values.removeFrom(tree);
 * ```
 *
 * You would make one decl (values here) in the listener and use lots of times
 * in your event methods.
 */
var ParseTreeProperty = /*#__PURE__*/function () {
  function ParseTreeProperty() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "ParseTreeProperty";
    (0, _classCallCheck2.default)(this, ParseTreeProperty);
    this._symbol = Symbol(name);
  }
  (0, _createClass2.default)(ParseTreeProperty, [{
    key: "get",
    value: function get(node) {
      return node[this._symbol];
    }
  }, {
    key: "set",
    value: function set(node, value) {
      node[this._symbol] = value;
    }
  }, {
    key: "removeFrom",
    value: function removeFrom(node) {
      var result = node[this._symbol];
      delete node[this._symbol];
      return result;
    }
  }]);
  return ParseTreeProperty;
}();
exports.ParseTreeProperty = ParseTreeProperty;

},{"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.js":638}],389:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
Object.defineProperty(exports, "__esModule", {
  value: true
});
var ErrorNode_1 = require("./ErrorNode");
var TerminalNode_1 = require("./TerminalNode");
var RuleNode_1 = require("./RuleNode");
var ParseTreeWalker = /*#__PURE__*/function () {
  function ParseTreeWalker() {
    (0, _classCallCheck2.default)(this, ParseTreeWalker);
  }
  (0, _createClass2.default)(ParseTreeWalker, [{
    key: "walk",
    value: function walk(listener, t) {
      var nodeStack = [];
      var indexStack = [];
      var currentNode = t;
      var currentIndex = 0;
      while (currentNode) {
        // pre-order visit
        if (currentNode instanceof ErrorNode_1.ErrorNode) {
          if (listener.visitErrorNode) {
            listener.visitErrorNode(currentNode);
          }
        } else if (currentNode instanceof TerminalNode_1.TerminalNode) {
          if (listener.visitTerminal) {
            listener.visitTerminal(currentNode);
          }
        } else {
          this.enterRule(listener, currentNode);
        }
        // Move down to first child, if exists
        if (currentNode.childCount > 0) {
          nodeStack.push(currentNode);
          indexStack.push(currentIndex);
          currentIndex = 0;
          currentNode = currentNode.getChild(0);
          continue;
        }
        // No child nodes, so walk tree
        do {
          // post-order visit
          if (currentNode instanceof RuleNode_1.RuleNode) {
            this.exitRule(listener, currentNode);
          }
          // No parent, so no siblings
          if (nodeStack.length === 0) {
            currentNode = undefined;
            currentIndex = 0;
            break;
          }
          // Move to next sibling if possible
          var last = nodeStack[nodeStack.length - 1];
          currentIndex++;
          currentNode = currentIndex < last.childCount ? last.getChild(currentIndex) : undefined;
          if (currentNode) {
            break;
          }
          // No next sibling, so move up
          currentNode = nodeStack.pop();
          currentIndex = indexStack.pop();
        } while (currentNode);
      }
    }
    /**
     * The discovery of a rule node, involves sending two events: the generic
     * {@link ParseTreeListener#enterEveryRule} and a
     * {@link RuleContext}-specific event. First we trigger the generic and then
     * the rule specific. We to them in reverse order upon finishing the node.
     */
  }, {
    key: "enterRule",
    value: function enterRule(listener, r) {
      var ctx = r.ruleContext;
      if (listener.enterEveryRule) {
        listener.enterEveryRule(ctx);
      }
      ctx.enterRule(listener);
    }
  }, {
    key: "exitRule",
    value: function exitRule(listener, r) {
      var ctx = r.ruleContext;
      ctx.exitRule(listener);
      if (listener.exitEveryRule) {
        listener.exitEveryRule(ctx);
      }
    }
  }]);
  return ParseTreeWalker;
}();
exports.ParseTreeWalker = ParseTreeWalker;
(function (ParseTreeWalker) {
  ParseTreeWalker.DEFAULT = new ParseTreeWalker();
})(ParseTreeWalker = exports.ParseTreeWalker || (exports.ParseTreeWalker = {}));

},{"./ErrorNode":387,"./RuleNode":390,"./TerminalNode":391,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237}],390:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
Object.defineProperty(exports, "__esModule", {
  value: true
});
var RuleNode = /*#__PURE__*/(0, _createClass2.default)(function RuleNode() {
  (0, _classCallCheck2.default)(this, RuleNode);
});
exports.RuleNode = RuleNode;

},{"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237}],391:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:48.1433686-07:00
var Interval_1 = require("../misc/Interval");
var Decorators_1 = require("../Decorators");
var Token_1 = require("../Token");
var TerminalNode = /*#__PURE__*/function () {
  function TerminalNode(symbol) {
    (0, _classCallCheck2.default)(this, TerminalNode);
    this._symbol = symbol;
  }
  (0, _createClass2.default)(TerminalNode, [{
    key: "getChild",
    value: function getChild(i) {
      throw new RangeError("Terminal Node has no children.");
    }
  }, {
    key: "symbol",
    get: function get() {
      return this._symbol;
    }
  }, {
    key: "parent",
    get: function get() {
      return this._parent;
    }
  }, {
    key: "setParent",
    value: function setParent(parent) {
      this._parent = parent;
    }
  }, {
    key: "payload",
    get: function get() {
      return this._symbol;
    }
  }, {
    key: "sourceInterval",
    get: function get() {
      var tokenIndex = this._symbol.tokenIndex;
      return new Interval_1.Interval(tokenIndex, tokenIndex);
    }
  }, {
    key: "childCount",
    get: function get() {
      return 0;
    }
  }, {
    key: "accept",
    value: function accept(visitor) {
      return visitor.visitTerminal(this);
    }
  }, {
    key: "text",
    get: function get() {
      return this._symbol.text || "";
    }
  }, {
    key: "toStringTree",
    value: function toStringTree(parser) {
      return this.toString();
    }
  }, {
    key: "toString",
    value: function toString() {
      if (this._symbol.type === Token_1.Token.EOF) {
        return "<EOF>";
      }
      return this._symbol.text || "";
    }
  }]);
  return TerminalNode;
}();
__decorate([Decorators_1.Override], TerminalNode.prototype, "getChild", null);
__decorate([Decorators_1.Override], TerminalNode.prototype, "parent", null);
__decorate([Decorators_1.Override], TerminalNode.prototype, "setParent", null);
__decorate([Decorators_1.Override], TerminalNode.prototype, "payload", null);
__decorate([Decorators_1.Override], TerminalNode.prototype, "sourceInterval", null);
__decorate([Decorators_1.Override], TerminalNode.prototype, "childCount", null);
__decorate([Decorators_1.Override], TerminalNode.prototype, "accept", null);
__decorate([Decorators_1.Override], TerminalNode.prototype, "text", null);
__decorate([Decorators_1.Override], TerminalNode.prototype, "toStringTree", null);
__decorate([Decorators_1.Override], TerminalNode.prototype, "toString", null);
exports.TerminalNode = TerminalNode;

},{"../Decorators":272,"../Token":296,"../misc/Interval":378,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.to-string.js":620}],392:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var ATN_1 = require("../atn/ATN");
var CommonToken_1 = require("../CommonToken");
var ErrorNode_1 = require("./ErrorNode");
var Decorators_1 = require("../Decorators");
var Parser_1 = require("../Parser");
var ParserRuleContext_1 = require("../ParserRuleContext");
var RuleNode_1 = require("./RuleNode");
var TerminalNode_1 = require("./TerminalNode");
var Token_1 = require("../Token");
var Utils = require("../misc/Utils");
/** A set of utility routines useful for all kinds of ANTLR trees. */
var Trees = /*#__PURE__*/function () {
  function Trees() {
    (0, _classCallCheck2.default)(this, Trees);
  }
  (0, _createClass2.default)(Trees, null, [{
    key: "toStringTree",
    value: function toStringTree(t, arg2) {
      var ruleNames;
      if (arg2 instanceof Parser_1.Parser) {
        ruleNames = arg2.ruleNames;
      } else {
        ruleNames = arg2;
      }
      var s = Utils.escapeWhitespace(this.getNodeText(t, ruleNames), false);
      if (t.childCount === 0) {
        return s;
      }
      var buf = "";
      buf += "(";
      s = Utils.escapeWhitespace(this.getNodeText(t, ruleNames), false);
      buf += s;
      buf += " ";
      for (var i = 0; i < t.childCount; i++) {
        if (i > 0) {
          buf += " ";
        }
        buf += this.toStringTree(t.getChild(i), ruleNames);
      }
      buf += ")";
      return buf;
    }
  }, {
    key: "getNodeText",
    value: function getNodeText(t, arg2) {
      var ruleNames;
      if (arg2 instanceof Parser_1.Parser) {
        ruleNames = arg2.ruleNames;
      } else if (arg2) {
        ruleNames = arg2;
      } else {
        // no recog or rule names
        var payload = t.payload;
        if (typeof payload.text === "string") {
          return payload.text;
        }
        return t.payload.toString();
      }
      if (t instanceof RuleNode_1.RuleNode) {
        var ruleContext = t.ruleContext;
        var ruleIndex = ruleContext.ruleIndex;
        var ruleName = ruleNames[ruleIndex];
        var altNumber = ruleContext.altNumber;
        if (altNumber !== ATN_1.ATN.INVALID_ALT_NUMBER) {
          return ruleName + ":" + altNumber;
        }
        return ruleName;
      } else if (t instanceof ErrorNode_1.ErrorNode) {
        return t.toString();
      } else if (t instanceof TerminalNode_1.TerminalNode) {
        var symbol = t.symbol;
        return symbol.text || "";
      }
      throw new TypeError("Unexpected node type");
    }
  }, {
    key: "getChildren",
    value: function getChildren(t) {
      var kids = [];
      for (var i = 0; i < t.childCount; i++) {
        kids.push(t.getChild(i));
      }
      return kids;
    }
  }, {
    key: "getAncestors",
    value: function getAncestors(t) {
      var ancestors = [];
      var p = t.parent;
      while (p) {
        ancestors.unshift(p); // insert at start
        p = p.parent;
      }
      return ancestors;
    }
    /** Return true if t is u's parent or a node on path to root from u.
     *  Use === not equals().
     *
     *  @since 4.5.1
     */
  }, {
    key: "isAncestorOf",
    value: function isAncestorOf(t, u) {
      if (!t || !u || !t.parent) {
        return false;
      }
      var p = u.parent;
      while (p) {
        if (t === p) {
          return true;
        }
        p = p.parent;
      }
      return false;
    }
  }, {
    key: "findAllTokenNodes",
    value: function findAllTokenNodes(t, ttype) {
      return Trees.findAllNodes(t, ttype, true);
    }
  }, {
    key: "findAllRuleNodes",
    value: function findAllRuleNodes(t, ruleIndex) {
      return Trees.findAllNodes(t, ruleIndex, false);
    }
  }, {
    key: "findAllNodes",
    value: function findAllNodes(t, index, findTokens) {
      var nodes = [];
      Trees._findAllNodes(t, index, findTokens, nodes);
      return nodes;
    }
  }, {
    key: "_findAllNodes",
    value: function _findAllNodes(t, index, findTokens, nodes) {
      // check this node (the root) first
      if (findTokens && t instanceof TerminalNode_1.TerminalNode) {
        if (t.symbol.type === index) {
          nodes.push(t);
        }
      } else if (!findTokens && t instanceof ParserRuleContext_1.ParserRuleContext) {
        if (t.ruleIndex === index) {
          nodes.push(t);
        }
      }
      // check children
      for (var i = 0; i < t.childCount; i++) {
        Trees._findAllNodes(t.getChild(i), index, findTokens, nodes);
      }
    }
    /** Get all descendents; includes t itself.
     *
     * @since 4.5.1
     */
  }, {
    key: "getDescendants",
    value: function getDescendants(t) {
      var nodes = [];
      function recurse(e) {
        nodes.push(e);
        var n = e.childCount;
        for (var i = 0; i < n; i++) {
          recurse(e.getChild(i));
        }
      }
      recurse(t);
      return nodes;
    }
    /** Find smallest subtree of t enclosing range startTokenIndex..stopTokenIndex
     *  inclusively using postorder traversal.  Recursive depth-first-search.
     *
     *  @since 4.5
     */
  }, {
    key: "getRootOfSubtreeEnclosingRegion",
    value: function getRootOfSubtreeEnclosingRegion(t, startTokenIndex,
    // inclusive
    stopTokenIndex) {
      var n = t.childCount;
      for (var i = 0; i < n; i++) {
        var child = t.getChild(i);
        var r = Trees.getRootOfSubtreeEnclosingRegion(child, startTokenIndex, stopTokenIndex);
        if (r) {
          return r;
        }
      }
      if (t instanceof ParserRuleContext_1.ParserRuleContext) {
        var stopToken = t.stop;
        if (startTokenIndex >= t.start.tokenIndex && (
        // is range fully contained in t?
        stopToken == null || stopTokenIndex <= stopToken.tokenIndex)) {
          // note: r.stop==null likely implies that we bailed out of parser and there's nothing to the right
          return t;
        }
      }
      return undefined;
    }
    /** Replace any subtree siblings of root that are completely to left
     *  or right of lookahead range with a CommonToken(Token.INVALID_TYPE,"...")
     *  node. The source interval for t is not altered to suit smaller range!
     *
     *  WARNING: destructive to t.
     *
     *  @since 4.5.1
     */
  }, {
    key: "stripChildrenOutOfRange",
    value: function stripChildrenOutOfRange(t, root, startIndex, stopIndex) {
      if (!t) {
        return;
      }
      var count = t.childCount;
      for (var i = 0; i < count; i++) {
        var child = t.getChild(i);
        var range = child.sourceInterval;
        if (child instanceof ParserRuleContext_1.ParserRuleContext && (range.b < startIndex || range.a > stopIndex)) {
          if (Trees.isAncestorOf(child, root)) {
            // replace only if subtree doesn't have displayed root
            var abbrev = new CommonToken_1.CommonToken(Token_1.Token.INVALID_TYPE, "...");
            t.children[i] = new TerminalNode_1.TerminalNode(abbrev); // HACK access to private
          }
        }
      }
    }
  }, {
    key: "findNodeSuchThat",
    value: function findNodeSuchThat(t, pred) {
      // No type check needed as long as users only use one of the available overloads
      if (pred(t)) {
        return t;
      }
      var n = t.childCount;
      for (var i = 0; i < n; i++) {
        var u = Trees.findNodeSuchThat(t.getChild(i), pred);
        if (u !== undefined) {
          return u;
        }
      }
      return undefined;
    }
  }]);
  return Trees;
}();
__decorate([__param(0, Decorators_1.NotNull)], Trees, "toStringTree", null);
__decorate([Decorators_1.NotNull, __param(0, Decorators_1.NotNull)], Trees, "getAncestors", null);
__decorate([__param(0, Decorators_1.NotNull)], Trees, "getRootOfSubtreeEnclosingRegion", null);
exports.Trees = Trees;

},{"../CommonToken":268,"../Decorators":272,"../Parser":285,"../ParserRuleContext":287,"../Token":296,"../atn/ATN":299,"../misc/Utils":385,"./ErrorNode":387,"./RuleNode":390,"./TerminalNode":391,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.to-string.js":620}],393:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
function __export(m) {
  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", {
  value: true
});
__export(require("./AbstractParseTreeVisitor"));
__export(require("./ErrorNode"));
__export(require("./ParseTreeProperty"));
__export(require("./ParseTreeWalker"));
__export(require("./RuleNode"));
__export(require("./TerminalNode"));
__export(require("./Trees"));

},{"./AbstractParseTreeVisitor":386,"./ErrorNode":387,"./ParseTreeProperty":388,"./ParseTreeWalker":389,"./RuleNode":390,"./TerminalNode":391,"./Trees":392}],394:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:45.2799060-07:00
/**
 * A chunk is either a token tag, a rule tag, or a span of literal text within a
 * tree pattern.
 *
 * The method {@link ParseTreePatternMatcher#split(String)} returns a list of
 * chunks in preparation for creating a token stream by
 * {@link ParseTreePatternMatcher#tokenize(String)}. From there, we get a parse
 * tree from with {@link ParseTreePatternMatcher#compile(String, int)}. These
 * chunks are converted to {@link RuleTagToken}, {@link TokenTagToken}, or the
 * regular tokens of the text surrounding the tags.
 */
var Chunk = /*#__PURE__*/(0, _createClass2.default)(function Chunk() {
  (0, _classCallCheck2.default)(this, Chunk);
});
exports.Chunk = Chunk;

},{"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237}],395:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.array.concat.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var Decorators_1 = require("../../Decorators");
/**
 * Represents the result of matching a {@link ParseTree} against a tree pattern.
 */
var ParseTreeMatch = /*#__PURE__*/function () {
  /**
   * Constructs a new instance of {@link ParseTreeMatch} from the specified
   * parse tree and pattern.
   *
   * @param tree The parse tree to match against the pattern.
   * @param pattern The parse tree pattern.
   * @param labels A mapping from label names to collections of
   * {@link ParseTree} objects located by the tree pattern matching process.
   * @param mismatchedNode The first node which failed to match the tree
   * pattern during the matching process.
   *
   * @throws {@link Error} if `tree` is not defined
   * @throws {@link Error} if `pattern` is not defined
   * @throws {@link Error} if `labels` is not defined
   */
  function ParseTreeMatch(tree, pattern, labels, mismatchedNode) {
    (0, _classCallCheck2.default)(this, ParseTreeMatch);
    if (!tree) {
      throw new Error("tree cannot be null");
    }
    if (!pattern) {
      throw new Error("pattern cannot be null");
    }
    if (!labels) {
      throw new Error("labels cannot be null");
    }
    this._tree = tree;
    this._pattern = pattern;
    this._labels = labels;
    this._mismatchedNode = mismatchedNode;
  }
  /**
   * Get the last node associated with a specific `label`.
   *
   * For example, for pattern `<id:ID>`, `get("id")` returns the
   * node matched for that `ID`. If more than one node
   * matched the specified label, only the last is returned. If there is
   * no node associated with the label, this returns `undefined`.
   *
   * Pattern tags like `<ID>` and `<expr>` without labels are
   * considered to be labeled with `ID` and `expr`, respectively.
   *
   * @param label The label to check.
   *
   * @returns The last {@link ParseTree} to match a tag with the specified
   * label, or `undefined` if no parse tree matched a tag with the label.
   */
  (0, _createClass2.default)(ParseTreeMatch, [{
    key: "get",
    value: function get(label) {
      var parseTrees = this._labels.get(label);
      if (!parseTrees || parseTrees.length === 0) {
        return undefined;
      }
      return parseTrees[parseTrees.length - 1]; // return last if multiple
    }
    /**
     * Return all nodes matching a rule or token tag with the specified label.
     *
     * If the `label` is the name of a parser rule or token in the
     * grammar, the resulting list will contain both the parse trees matching
     * rule or tags explicitly labeled with the label and the complete set of
     * parse trees matching the labeled and unlabeled tags in the pattern for
     * the parser rule or token. For example, if `label` is `"foo"`,
     * the result will contain *all* of the following.
     *
     * * Parse tree nodes matching tags of the form `<foo:anyRuleName>` and
     *   `<foo:AnyTokenName>`.
     * * Parse tree nodes matching tags of the form `<anyLabel:foo>`.
     * * Parse tree nodes matching tags of the form `<foo>`.
     *
     * @param label The label.
     *
     * @returns A collection of all {@link ParseTree} nodes matching tags with
     * the specified `label`. If no nodes matched the label, an empty list
     * is returned.
     */
  }, {
    key: "getAll",
    value: function getAll(label) {
      var nodes = this._labels.get(label);
      if (!nodes) {
        return [];
      }
      return nodes;
    }
    /**
     * Return a mapping from label &rarr; [list of nodes].
     *
     * The map includes special entries corresponding to the names of rules and
     * tokens referenced in tags in the original pattern. For additional
     * information, see the description of {@link #getAll(String)}.
     *
     * @returns A mapping from labels to parse tree nodes. If the parse tree
     * pattern did not contain any rule or token tags, this map will be empty.
     */
  }, {
    key: "labels",
    get: function get() {
      return this._labels;
    }
    /**
     * Get the node at which we first detected a mismatch.
     *
     * @returns the node at which we first detected a mismatch, or `undefined`
     * if the match was successful.
     */
  }, {
    key: "mismatchedNode",
    get: function get() {
      return this._mismatchedNode;
    }
    /**
     * Gets a value indicating whether the match operation succeeded.
     *
     * @returns `true` if the match operation succeeded; otherwise,
     * `false`.
     */
  }, {
    key: "succeeded",
    get: function get() {
      return !this._mismatchedNode;
    }
    /**
     * Get the tree pattern we are matching against.
     *
     * @returns The tree pattern we are matching against.
     */
  }, {
    key: "pattern",
    get: function get() {
      return this._pattern;
    }
    /**
     * Get the parse tree we are trying to match to a pattern.
     *
     * @returns The {@link ParseTree} we are trying to match to a pattern.
     */
  }, {
    key: "tree",
    get: function get() {
      return this._tree;
    }
    /**
     * {@inheritDoc}
     */
  }, {
    key: "toString",
    value: function toString() {
      return "Match ".concat(this.succeeded ? "succeeded" : "failed", "; found ").concat(this.labels.size, " labels");
    }
  }]);
  return ParseTreeMatch;
}();
__decorate([Decorators_1.NotNull, __param(0, Decorators_1.NotNull)], ParseTreeMatch.prototype, "getAll", null);
__decorate([Decorators_1.NotNull], ParseTreeMatch.prototype, "labels", null);
__decorate([Decorators_1.NotNull], ParseTreeMatch.prototype, "pattern", null);
__decorate([Decorators_1.NotNull], ParseTreeMatch.prototype, "tree", null);
__decorate([Decorators_1.Override], ParseTreeMatch.prototype, "toString", null);
ParseTreeMatch = __decorate([__param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull), __param(2, Decorators_1.NotNull)], ParseTreeMatch);
exports.ParseTreeMatch = ParseTreeMatch;

},{"../../Decorators":272,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612}],396:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.match.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// CONVERSTION complete, Burt Harris 10/14/2016
var Decorators_1 = require("../../Decorators");
var XPath_1 = require("../xpath/XPath");
/**
 * A pattern like `<ID> = <expr>;` converted to a {@link ParseTree} by
 * {@link ParseTreePatternMatcher#compile(String, int)}.
 */
var ParseTreePattern = /*#__PURE__*/function () {
  /**
   * Construct a new instance of the {@link ParseTreePattern} class.
   *
   * @param matcher The {@link ParseTreePatternMatcher} which created this
   * tree pattern.
   * @param pattern The tree pattern in concrete syntax form.
   * @param patternRuleIndex The parser rule which serves as the root of the
   * tree pattern.
   * @param patternTree The tree pattern in {@link ParseTree} form.
   */
  function ParseTreePattern(matcher, pattern, patternRuleIndex, patternTree) {
    (0, _classCallCheck2.default)(this, ParseTreePattern);
    this._matcher = matcher;
    this._patternRuleIndex = patternRuleIndex;
    this._pattern = pattern;
    this._patternTree = patternTree;
  }
  /**
   * Match a specific parse tree against this tree pattern.
   *
   * @param tree The parse tree to match against this tree pattern.
   * @returns A {@link ParseTreeMatch} object describing the result of the
   * match operation. The `ParseTreeMatch.succeeded` method can be
   * used to determine whether or not the match was successful.
   */
  (0, _createClass2.default)(ParseTreePattern, [{
    key: "match",
    value: function match(tree) {
      return this._matcher.match(tree, this);
    }
    /**
     * Determine whether or not a parse tree matches this tree pattern.
     *
     * @param tree The parse tree to match against this tree pattern.
     * @returns `true` if `tree` is a match for the current tree
     * pattern; otherwise, `false`.
     */
  }, {
    key: "matches",
    value: function matches(tree) {
      return this._matcher.match(tree, this).succeeded;
    }
    /**
     * Find all nodes using XPath and then try to match those subtrees against
     * this tree pattern.
     *
     * @param tree The {@link ParseTree} to match against this pattern.
     * @param xpath An expression matching the nodes
     *
     * @returns A collection of {@link ParseTreeMatch} objects describing the
     * successful matches. Unsuccessful matches are omitted from the result,
     * regardless of the reason for the failure.
     */
  }, {
    key: "findAll",
    value: function findAll(tree, xpath) {
      var subtrees = XPath_1.XPath.findAll(tree, xpath, this._matcher.parser);
      var matches = [];
      var _iterator = _createForOfIteratorHelper(subtrees),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var t = _step.value;
          var match = this.match(t);
          if (match.succeeded) {
            matches.push(match);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return matches;
    }
    /**
     * Get the {@link ParseTreePatternMatcher} which created this tree pattern.
     *
     * @returns The {@link ParseTreePatternMatcher} which created this tree
     * pattern.
     */
  }, {
    key: "matcher",
    get: function get() {
      return this._matcher;
    }
    /**
     * Get the tree pattern in concrete syntax form.
     *
     * @returns The tree pattern in concrete syntax form.
     */
  }, {
    key: "pattern",
    get: function get() {
      return this._pattern;
    }
    /**
     * Get the parser rule which serves as the outermost rule for the tree
     * pattern.
     *
     * @returns The parser rule which serves as the outermost rule for the tree
     * pattern.
     */
  }, {
    key: "patternRuleIndex",
    get: function get() {
      return this._patternRuleIndex;
    }
    /**
     * Get the tree pattern as a {@link ParseTree}. The rule and token tags from
     * the pattern are present in the parse tree as terminal nodes with a symbol
     * of type {@link RuleTagToken} or {@link TokenTagToken}.
     *
     * @returns The tree pattern as a {@link ParseTree}.
     */
  }, {
    key: "patternTree",
    get: function get() {
      return this._patternTree;
    }
  }]);
  return ParseTreePattern;
}();
__decorate([Decorators_1.NotNull], ParseTreePattern.prototype, "_pattern", void 0);
__decorate([Decorators_1.NotNull], ParseTreePattern.prototype, "_patternTree", void 0);
__decorate([Decorators_1.NotNull], ParseTreePattern.prototype, "_matcher", void 0);
__decorate([Decorators_1.NotNull, __param(0, Decorators_1.NotNull)], ParseTreePattern.prototype, "match", null);
__decorate([__param(0, Decorators_1.NotNull)], ParseTreePattern.prototype, "matches", null);
__decorate([Decorators_1.NotNull, __param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)], ParseTreePattern.prototype, "findAll", null);
__decorate([Decorators_1.NotNull], ParseTreePattern.prototype, "matcher", null);
__decorate([Decorators_1.NotNull], ParseTreePattern.prototype, "pattern", null);
__decorate([Decorators_1.NotNull], ParseTreePattern.prototype, "patternTree", null);
ParseTreePattern = __decorate([__param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull), __param(3, Decorators_1.NotNull)], ParseTreePattern);
exports.ParseTreePattern = ParseTreePattern;

},{"../../Decorators":272,"../xpath/XPath":402,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.string.match.js":627,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],397:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapNativeSuper"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.constructor.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.string.match.js");
require("core-js/modules/es.array.map.js");
require("core-js/modules/es.string.split.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// CONVERSTION complete, Burt Harris 10/14/2016
var BailErrorStrategy_1 = require("../../BailErrorStrategy");
var CharStreams_1 = require("../../CharStreams");
var CommonTokenStream_1 = require("../../CommonTokenStream");
var ListTokenSource_1 = require("../../ListTokenSource");
var MultiMap_1 = require("../../misc/MultiMap");
var Decorators_1 = require("../../Decorators");
var ParseCancellationException_1 = require("../../misc/ParseCancellationException");
var ParserInterpreter_1 = require("../../ParserInterpreter");
var ParserRuleContext_1 = require("../../ParserRuleContext");
var ParseTreeMatch_1 = require("./ParseTreeMatch");
var ParseTreePattern_1 = require("./ParseTreePattern");
var RecognitionException_1 = require("../../RecognitionException");
var RuleNode_1 = require("../RuleNode");
var RuleTagToken_1 = require("./RuleTagToken");
var TagChunk_1 = require("./TagChunk");
var TerminalNode_1 = require("../TerminalNode");
var TextChunk_1 = require("./TextChunk");
var Token_1 = require("../../Token");
var TokenTagToken_1 = require("./TokenTagToken");
/**
 * A tree pattern matching mechanism for ANTLR {@link ParseTree}s.
 *
 * Patterns are strings of source input text with special tags representing
 * token or rule references such as:
 *
 * ```
 * <ID> = <expr>;
 * ```
 *
 * Given a pattern start rule such as `statement`, this object constructs
 * a {@link ParseTree} with placeholders for the `ID` and `expr`
 * subtree. Then the {@link #match} routines can compare an actual
 * {@link ParseTree} from a parse with this pattern. Tag `<ID>` matches
 * any `ID` token and tag `<expr>` references the result of the
 * `expr` rule (generally an instance of `ExprContext`.
 *
 * Pattern `x = 0;` is a similar pattern that matches the same pattern
 * except that it requires the identifier to be `x` and the expression to
 * be `0`.
 *
 * The {@link #matches} routines return `true` or `false` based
 * upon a match for the tree rooted at the parameter sent in. The
 * {@link #match} routines return a {@link ParseTreeMatch} object that
 * contains the parse tree, the parse tree pattern, and a map from tag name to
 * matched nodes (more below). A subtree that fails to match, returns with
 * {@link ParseTreeMatch#mismatchedNode} set to the first tree node that did not
 * match.
 *
 * For efficiency, you can compile a tree pattern in string form to a
 * {@link ParseTreePattern} object.
 *
 * See `TestParseTreeMatcher` for lots of examples.
 * {@link ParseTreePattern} has two static helper methods:
 * {@link ParseTreePattern#findAll} and {@link ParseTreePattern#match} that
 * are easy to use but not super efficient because they create new
 * {@link ParseTreePatternMatcher} objects each time and have to compile the
 * pattern in string form before using it.
 *
 * The lexer and parser that you pass into the {@link ParseTreePatternMatcher}
 * constructor are used to parse the pattern in string form. The lexer converts
 * the `<ID> = <expr>;` into a sequence of four tokens (assuming lexer
 * throws out whitespace or puts it on a hidden channel). Be aware that the
 * input stream is reset for the lexer (but not the parser; a
 * {@link ParserInterpreter} is created to parse the input.). Any user-defined
 * fields you have put into the lexer might get changed when this mechanism asks
 * it to scan the pattern string.
 *
 * Normally a parser does not accept token `<expr>` as a valid
 * `expr` but, from the parser passed in, we create a special version of
 * the underlying grammar representation (an {@link ATN}) that allows imaginary
 * tokens representing rules (`<expr>`) to match entire rules. We call
 * these *bypass alternatives*.
 *
 * Delimiters are `<`} and `>`}, with `\` as the escape string
 * by default, but you can set them to whatever you want using
 * {@link #setDelimiters}. You must escape both start and stop strings
 * `\<` and `\>`.
 */
var ParseTreePatternMatcher = /*#__PURE__*/function () {
  /**
   * Constructs a {@link ParseTreePatternMatcher} or from a {@link Lexer} and
   * {@link Parser} object. The lexer input stream is altered for tokenizing
   * the tree patterns. The parser is used as a convenient mechanism to get
   * the grammar name, plus token, rule names.
   */
  function ParseTreePatternMatcher(lexer, parser) {
    (0, _classCallCheck2.default)(this, ParseTreePatternMatcher);
    this.start = "<";
    this.stop = ">";
    this.escape = "\\"; // e.g., \< and \> must escape BOTH!
    /**
     * Regular expression corresponding to escape, for global replace
     */
    this.escapeRE = /\\/g;
    this._lexer = lexer;
    this._parser = parser;
  }
  /**
   * Set the delimiters used for marking rule and token tags within concrete
   * syntax used by the tree pattern parser.
   *
   * @param start The start delimiter.
   * @param stop The stop delimiter.
   * @param escapeLeft The escape sequence to use for escaping a start or stop delimiter.
   *
   * @throws {@link Error} if `start` is not defined or empty.
   * @throws {@link Error} if `stop` is not defined or empty.
   */
  (0, _createClass2.default)(ParseTreePatternMatcher, [{
    key: "setDelimiters",
    value: function setDelimiters(start, stop, escapeLeft) {
      if (!start) {
        throw new Error("start cannot be null or empty");
      }
      if (!stop) {
        throw new Error("stop cannot be null or empty");
      }
      this.start = start;
      this.stop = stop;
      this.escape = escapeLeft;
      this.escapeRE = new RegExp(escapeLeft.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g");
    }
  }, {
    key: "matches",
    value: function matches(tree, pattern) {
      var patternRuleIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      if (typeof pattern === "string") {
        var p = this.compile(pattern, patternRuleIndex);
        return this.matches(tree, p);
      } else {
        var labels = new MultiMap_1.MultiMap();
        var mismatchedNode = this.matchImpl(tree, pattern.patternTree, labels);
        return !mismatchedNode;
      }
    }
    // Implementation of match
  }, {
    key: "match",
    value: function match(tree, pattern) {
      var patternRuleIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      if (typeof pattern === "string") {
        var p = this.compile(pattern, patternRuleIndex);
        return this.match(tree, p);
      } else {
        var labels = new MultiMap_1.MultiMap();
        var mismatchedNode = this.matchImpl(tree, pattern.patternTree, labels);
        return new ParseTreeMatch_1.ParseTreeMatch(tree, pattern, labels, mismatchedNode);
      }
    }
    /**
     * For repeated use of a tree pattern, compile it to a
     * {@link ParseTreePattern} using this method.
     */
  }, {
    key: "compile",
    value: function compile(pattern, patternRuleIndex) {
      var tokenList = this.tokenize(pattern);
      var tokenSrc = new ListTokenSource_1.ListTokenSource(tokenList);
      var tokens = new CommonTokenStream_1.CommonTokenStream(tokenSrc);
      var parser = this._parser;
      var parserInterp = new ParserInterpreter_1.ParserInterpreter(parser.grammarFileName, parser.vocabulary, parser.ruleNames, parser.getATNWithBypassAlts(), tokens);
      var tree;
      try {
        parserInterp.errorHandler = new BailErrorStrategy_1.BailErrorStrategy();
        tree = parserInterp.parse(patternRuleIndex);
        //			System.out.println("pattern tree = "+tree.toStringTree(parserInterp));
      } catch (e) {
        if (e instanceof ParseCancellationException_1.ParseCancellationException) {
          throw e.getCause();
        } else if (e instanceof RecognitionException_1.RecognitionException) {
          throw e;
        } else if (e instanceof Error) {
          throw new ParseTreePatternMatcher.CannotInvokeStartRule(e);
        } else {
          throw e;
        }
      }
      // Make sure tree pattern compilation checks for a complete parse
      if (tokens.LA(1) !== Token_1.Token.EOF) {
        throw new ParseTreePatternMatcher.StartRuleDoesNotConsumeFullPattern();
      }
      return new ParseTreePattern_1.ParseTreePattern(this, pattern, patternRuleIndex, tree);
    }
    /**
     * Used to convert the tree pattern string into a series of tokens. The
     * input stream is reset.
     */
  }, {
    key: "lexer",
    get: function get() {
      return this._lexer;
    }
    /**
     * Used to collect to the grammar file name, token names, rule names for
     * used to parse the pattern into a parse tree.
     */
  }, {
    key: "parser",
    get: function get() {
      return this._parser;
    }
    // ---- SUPPORT CODE ----
    /**
     * Recursively walk `tree` against `patternTree`, filling
     * `match.`{@link ParseTreeMatch#labels labels}.
     *
     * @returns the first node encountered in `tree` which does not match
     * a corresponding node in `patternTree`, or `undefined` if the match
     * was successful. The specific node returned depends on the matching
     * algorithm used by the implementation, and may be overridden.
     */
  }, {
    key: "matchImpl",
    value: function matchImpl(tree, patternTree, labels) {
      if (!tree) {
        throw new TypeError("tree cannot be null");
      }
      if (!patternTree) {
        throw new TypeError("patternTree cannot be null");
      }
      // x and <ID>, x and y, or x and x; or could be mismatched types
      if (tree instanceof TerminalNode_1.TerminalNode && patternTree instanceof TerminalNode_1.TerminalNode) {
        var mismatchedNode;
        // both are tokens and they have same type
        if (tree.symbol.type === patternTree.symbol.type) {
          if (patternTree.symbol instanceof TokenTagToken_1.TokenTagToken) {
            // x and <ID>
            var tokenTagToken = patternTree.symbol;
            // track label->list-of-nodes for both token name and label (if any)
            labels.map(tokenTagToken.tokenName, tree);
            var l = tokenTagToken.label;
            if (l) {
              labels.map(l, tree);
            }
          } else if (tree.text === patternTree.text) {
            // x and x
          } else {
            // x and y
            if (!mismatchedNode) {
              mismatchedNode = tree;
            }
          }
        } else {
          if (!mismatchedNode) {
            mismatchedNode = tree;
          }
        }
        return mismatchedNode;
      }
      if (tree instanceof ParserRuleContext_1.ParserRuleContext && patternTree instanceof ParserRuleContext_1.ParserRuleContext) {
        var _mismatchedNode;
        // (expr ...) and <expr>
        var ruleTagToken = this.getRuleTagToken(patternTree);
        if (ruleTagToken) {
          var m;
          if (tree.ruleContext.ruleIndex === patternTree.ruleContext.ruleIndex) {
            // track label->list-of-nodes for both rule name and label (if any)
            labels.map(ruleTagToken.ruleName, tree);
            var _l = ruleTagToken.label;
            if (_l) {
              labels.map(_l, tree);
            }
          } else {
            if (!_mismatchedNode) {
              _mismatchedNode = tree;
            }
          }
          return _mismatchedNode;
        }
        // (expr ...) and (expr ...)
        if (tree.childCount !== patternTree.childCount) {
          if (!_mismatchedNode) {
            _mismatchedNode = tree;
          }
          return _mismatchedNode;
        }
        var n = tree.childCount;
        for (var i = 0; i < n; i++) {
          var childMatch = this.matchImpl(tree.getChild(i), patternTree.getChild(i), labels);
          if (childMatch) {
            return childMatch;
          }
        }
        return _mismatchedNode;
      }
      // if nodes aren't both tokens or both rule nodes, can't match
      return tree;
    }
    /** Is `t` `(expr <expr>)` subtree? */
  }, {
    key: "getRuleTagToken",
    value: function getRuleTagToken(t) {
      if (t instanceof RuleNode_1.RuleNode) {
        if (t.childCount === 1 && t.getChild(0) instanceof TerminalNode_1.TerminalNode) {
          var c = t.getChild(0);
          if (c.symbol instanceof RuleTagToken_1.RuleTagToken) {
            //					System.out.println("rule tag subtree "+t.toStringTree(parser));
            return c.symbol;
          }
        }
      }
      return undefined;
    }
  }, {
    key: "tokenize",
    value: function tokenize(pattern) {
      // split pattern into chunks: sea (raw input) and islands (<ID>, <expr>)
      var chunks = this.split(pattern);
      // create token stream from text and tags
      var tokens = [];
      var _iterator = _createForOfIteratorHelper(chunks),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var chunk = _step.value;
          if (chunk instanceof TagChunk_1.TagChunk) {
            var tagChunk = chunk;
            var firstChar = tagChunk.tag.substr(0, 1);
            // add special rule token or conjure up new token from name
            if (firstChar === firstChar.toUpperCase()) {
              var ttype = this._parser.getTokenType(tagChunk.tag);
              if (ttype === Token_1.Token.INVALID_TYPE) {
                throw new Error("Unknown token " + tagChunk.tag + " in pattern: " + pattern);
              }
              var t = new TokenTagToken_1.TokenTagToken(tagChunk.tag, ttype, tagChunk.label);
              tokens.push(t);
            } else if (firstChar === firstChar.toLowerCase()) {
              var ruleIndex = this._parser.getRuleIndex(tagChunk.tag);
              if (ruleIndex === -1) {
                throw new Error("Unknown rule " + tagChunk.tag + " in pattern: " + pattern);
              }
              var ruleImaginaryTokenType = this._parser.getATNWithBypassAlts().ruleToTokenType[ruleIndex];
              tokens.push(new RuleTagToken_1.RuleTagToken(tagChunk.tag, ruleImaginaryTokenType, tagChunk.label));
            } else {
              throw new Error("invalid tag: " + tagChunk.tag + " in pattern: " + pattern);
            }
          } else {
            var textChunk = chunk;
            this._lexer.inputStream = CharStreams_1.CharStreams.fromString(textChunk.text);
            var _t = this._lexer.nextToken();
            while (_t.type !== Token_1.Token.EOF) {
              tokens.push(_t);
              _t = this._lexer.nextToken();
            }
          }
        }
        //		System.out.println("tokens="+tokens);
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return tokens;
    }
    /** Split `<ID> = <e:expr> ;` into 4 chunks for tokenizing by {@link #tokenize}. */
  }, {
    key: "split",
    value: function split(pattern) {
      var p = 0;
      var n = pattern.length;
      var chunks = [];
      var buf;
      // find all start and stop indexes first, then collect
      var starts = [];
      var stops = [];
      while (p < n) {
        if (p === pattern.indexOf(this.escape + this.start, p)) {
          p += this.escape.length + this.start.length;
        } else if (p === pattern.indexOf(this.escape + this.stop, p)) {
          p += this.escape.length + this.stop.length;
        } else if (p === pattern.indexOf(this.start, p)) {
          starts.push(p);
          p += this.start.length;
        } else if (p === pattern.indexOf(this.stop, p)) {
          stops.push(p);
          p += this.stop.length;
        } else {
          p++;
        }
      }
      //		System.out.println("");
      //		System.out.println(starts);
      //		System.out.println(stops);
      if (starts.length > stops.length) {
        throw new Error("unterminated tag in pattern: " + pattern);
      }
      if (starts.length < stops.length) {
        throw new Error("missing start tag in pattern: " + pattern);
      }
      var ntags = starts.length;
      for (var i = 0; i < ntags; i++) {
        if (starts[i] >= stops[i]) {
          throw new Error("tag delimiters out of order in pattern: " + pattern);
        }
      }
      // collect into chunks now
      if (ntags === 0) {
        var text = pattern.substring(0, n);
        chunks.push(new TextChunk_1.TextChunk(text));
      }
      if (ntags > 0 && starts[0] > 0) {
        // copy text up to first tag into chunks
        var _text = pattern.substring(0, starts[0]);
        chunks.push(new TextChunk_1.TextChunk(_text));
      }
      for (var _i = 0; _i < ntags; _i++) {
        // copy inside of <tag>
        var tag = pattern.substring(starts[_i] + this.start.length, stops[_i]);
        var ruleOrToken = tag;
        var label = void 0;
        var colon = tag.indexOf(":");
        if (colon >= 0) {
          label = tag.substring(0, colon);
          ruleOrToken = tag.substring(colon + 1, tag.length);
        }
        chunks.push(new TagChunk_1.TagChunk(ruleOrToken, label));
        if (_i + 1 < ntags) {
          // copy from end of <tag> to start of next
          var _text2 = pattern.substring(stops[_i] + this.stop.length, starts[_i + 1]);
          chunks.push(new TextChunk_1.TextChunk(_text2));
        }
      }
      if (ntags > 0) {
        var afterLastTag = stops[ntags - 1] + this.stop.length;
        if (afterLastTag < n) {
          // copy text from end of last tag to end
          var _text3 = pattern.substring(afterLastTag, n);
          chunks.push(new TextChunk_1.TextChunk(_text3));
        }
      }
      // strip out the escape sequences from text chunks but not tags
      for (var _i2 = 0; _i2 < chunks.length; _i2++) {
        var c = chunks[_i2];
        if (c instanceof TextChunk_1.TextChunk) {
          var unescaped = c.text.replace(this.escapeRE, "");
          if (unescaped.length < c.text.length) {
            chunks[_i2] = new TextChunk_1.TextChunk(unescaped);
          }
        }
      }
      return chunks;
    }
  }]);
  return ParseTreePatternMatcher;
}();
__decorate([Decorators_1.NotNull, __param(1, Decorators_1.NotNull)], ParseTreePatternMatcher.prototype, "match", null);
__decorate([Decorators_1.NotNull], ParseTreePatternMatcher.prototype, "lexer", null);
__decorate([Decorators_1.NotNull], ParseTreePatternMatcher.prototype, "parser", null);
__decorate([__param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull), __param(2, Decorators_1.NotNull)], ParseTreePatternMatcher.prototype, "matchImpl", null);
exports.ParseTreePatternMatcher = ParseTreePatternMatcher;
(function (ParseTreePatternMatcher) {
  var CannotInvokeStartRule = /*#__PURE__*/function (_Error) {
    (0, _inherits2.default)(CannotInvokeStartRule, _Error);
    var _super = _createSuper(CannotInvokeStartRule);
    function CannotInvokeStartRule(error) {
      var _this;
      (0, _classCallCheck2.default)(this, CannotInvokeStartRule);
      _this = _super.call(this, "CannotInvokeStartRule: ".concat(error));
      _this.error = error;
      return _this;
    }
    return (0, _createClass2.default)(CannotInvokeStartRule);
  }( /*#__PURE__*/(0, _wrapNativeSuper2.default)(Error));
  ParseTreePatternMatcher.CannotInvokeStartRule = CannotInvokeStartRule;
  // Fixes https://github.com/antlr/antlr4/issues/413
  // "Tree pattern compilation doesn't check for a complete parse"
  var StartRuleDoesNotConsumeFullPattern = /*#__PURE__*/function (_Error2) {
    (0, _inherits2.default)(StartRuleDoesNotConsumeFullPattern, _Error2);
    var _super2 = _createSuper(StartRuleDoesNotConsumeFullPattern);
    function StartRuleDoesNotConsumeFullPattern() {
      (0, _classCallCheck2.default)(this, StartRuleDoesNotConsumeFullPattern);
      return _super2.call(this, "StartRuleDoesNotConsumeFullPattern");
    }
    return (0, _createClass2.default)(StartRuleDoesNotConsumeFullPattern);
  }( /*#__PURE__*/(0, _wrapNativeSuper2.default)(Error));
  ParseTreePatternMatcher.StartRuleDoesNotConsumeFullPattern = StartRuleDoesNotConsumeFullPattern;
})(ParseTreePatternMatcher = exports.ParseTreePatternMatcher || (exports.ParseTreePatternMatcher = {}));

},{"../../BailErrorStrategy":263,"../../CharStreams":265,"../../CommonTokenStream":270,"../../Decorators":272,"../../ListTokenSource":283,"../../ParserInterpreter":286,"../../ParserRuleContext":287,"../../RecognitionException":290,"../../Token":296,"../../misc/MultiMap":380,"../../misc/ParseCancellationException":383,"../RuleNode":390,"../TerminalNode":391,"./ParseTreeMatch":395,"./ParseTreePattern":396,"./RuleTagToken":398,"./TagChunk":399,"./TextChunk":400,"./TokenTagToken":401,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"@babel/runtime/helpers/wrapNativeSuper":254,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.map.js":579,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.constructor.js":617,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.string.match.js":627,"core-js/modules/es.string.replace.js":629,"core-js/modules/es.string.split.js":631,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],398:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var Decorators_1 = require("../../Decorators");
var Token_1 = require("../../Token");
/**
 * A {@link Token} object representing an entire subtree matched by a parser
 * rule; e.g., `<expr>`. These tokens are created for {@link TagChunk}
 * chunks where the tag corresponds to a parser rule.
 */
var RuleTagToken = /*#__PURE__*/function () {
  /**
   * Constructs a new instance of {@link RuleTagToken} with the specified rule
   * name, bypass token type, and label.
   *
   * @param ruleName The name of the parser rule this rule tag matches.
   * @param bypassTokenType The bypass token type assigned to the parser rule.
   * @param label The label associated with the rule tag, or `undefined` if
   * the rule tag is unlabeled.
   *
   * @exception IllegalArgumentException if `ruleName` is not defined
   * or empty.
   */
  function RuleTagToken(ruleName, bypassTokenType, label) {
    (0, _classCallCheck2.default)(this, RuleTagToken);
    if (ruleName == null || ruleName.length === 0) {
      throw new Error("ruleName cannot be null or empty.");
    }
    this._ruleName = ruleName;
    this.bypassTokenType = bypassTokenType;
    this._label = label;
  }
  /**
   * Gets the name of the rule associated with this rule tag.
   *
   * @returns The name of the parser rule associated with this rule tag.
   */
  (0, _createClass2.default)(RuleTagToken, [{
    key: "ruleName",
    get: function get() {
      return this._ruleName;
    }
    /**
     * Gets the label associated with the rule tag.
     *
     * @returns The name of the label associated with the rule tag, or
     * `undefined` if this is an unlabeled rule tag.
     */
  }, {
    key: "label",
    get: function get() {
      return this._label;
    }
    /**
     * {@inheritDoc}
     *
     * Rule tag tokens are always placed on the {@link #DEFAULT_CHANNEL}.
     */
  }, {
    key: "channel",
    get: function get() {
      return Token_1.Token.DEFAULT_CHANNEL;
    }
    /**
     * {@inheritDoc}
     *
     * This method returns the rule tag formatted with `<` and `>`
     * delimiters.
     */
  }, {
    key: "text",
    get: function get() {
      if (this._label != null) {
        return "<" + this._label + ":" + this._ruleName + ">";
      }
      return "<" + this._ruleName + ">";
    }
    /**
     * {@inheritDoc}
     *
     * Rule tag tokens have types assigned according to the rule bypass
     * transitions created during ATN deserialization.
     */
  }, {
    key: "type",
    get: function get() {
      return this.bypassTokenType;
    }
    /**
     * {@inheritDoc}
     *
     * The implementation for {@link RuleTagToken} always returns 0.
     */
  }, {
    key: "line",
    get: function get() {
      return 0;
    }
    /**
     * {@inheritDoc}
     *
     * The implementation for {@link RuleTagToken} always returns -1.
     */
  }, {
    key: "charPositionInLine",
    get: function get() {
      return -1;
    }
    /**
     * {@inheritDoc}
     *
     * The implementation for {@link RuleTagToken} always returns -1.
     */
  }, {
    key: "tokenIndex",
    get: function get() {
      return -1;
    }
    /**
     * {@inheritDoc}
     *
     * The implementation for {@link RuleTagToken} always returns -1.
     */
  }, {
    key: "startIndex",
    get: function get() {
      return -1;
    }
    /**
     * {@inheritDoc}
     *
     * The implementation for {@link RuleTagToken} always returns -1.
     */
  }, {
    key: "stopIndex",
    get: function get() {
      return -1;
    }
    /**
     * {@inheritDoc}
     *
     * The implementation for {@link RuleTagToken} always returns `undefined`.
     */
  }, {
    key: "tokenSource",
    get: function get() {
      return undefined;
    }
    /**
     * {@inheritDoc}
     *
     * The implementation for {@link RuleTagToken} always returns `undefined`.
     */
  }, {
    key: "inputStream",
    get: function get() {
      return undefined;
    }
    /**
     * {@inheritDoc}
     *
     * The implementation for {@link RuleTagToken} returns a string of the form
     * `ruleName:bypassTokenType`.
     */
  }, {
    key: "toString",
    value: function toString() {
      return this._ruleName + ":" + this.bypassTokenType;
    }
  }]);
  return RuleTagToken;
}();
__decorate([Decorators_1.NotNull], RuleTagToken.prototype, "ruleName", null);
__decorate([Decorators_1.Override], RuleTagToken.prototype, "channel", null);
__decorate([Decorators_1.Override], RuleTagToken.prototype, "text", null);
__decorate([Decorators_1.Override], RuleTagToken.prototype, "type", null);
__decorate([Decorators_1.Override], RuleTagToken.prototype, "line", null);
__decorate([Decorators_1.Override], RuleTagToken.prototype, "charPositionInLine", null);
__decorate([Decorators_1.Override], RuleTagToken.prototype, "tokenIndex", null);
__decorate([Decorators_1.Override], RuleTagToken.prototype, "startIndex", null);
__decorate([Decorators_1.Override], RuleTagToken.prototype, "stopIndex", null);
__decorate([Decorators_1.Override], RuleTagToken.prototype, "tokenSource", null);
__decorate([Decorators_1.Override], RuleTagToken.prototype, "inputStream", null);
__decorate([Decorators_1.Override], RuleTagToken.prototype, "toString", null);
RuleTagToken = __decorate([__param(0, Decorators_1.NotNull)], RuleTagToken);
exports.RuleTagToken = RuleTagToken;

},{"../../Decorators":272,"../../Token":296,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612}],399:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:46.1670669-07:00
var Chunk_1 = require("./Chunk");
var Decorators_1 = require("../../Decorators");
/**
 * Represents a placeholder tag in a tree pattern. A tag can have any of the
 * following forms.
 *
 * * `expr`: An unlabeled placeholder for a parser rule `expr`.
 * * `ID`: An unlabeled placeholder for a token of type `ID`.
 * * `e:expr`: A labeled placeholder for a parser rule `expr`.
 * * `id:ID`: A labeled placeholder for a token of type `ID`.
 *
 * This class does not perform any validation on the tag or label names aside
 * from ensuring that the tag is a defined, non-empty string.
 */
var TagChunk = /*#__PURE__*/function (_Chunk_1$Chunk) {
  (0, _inherits2.default)(TagChunk, _Chunk_1$Chunk);
  var _super = _createSuper(TagChunk);
  /**
   * Construct a new instance of {@link TagChunk} using the specified label
   * and tag.
   *
   * @param label The label for the tag. If this is `undefined`, the
   * {@link TagChunk} represents an unlabeled tag.
   * @param tag The tag, which should be the name of a parser rule or token
   * type.
   *
   * @exception IllegalArgumentException if `tag` is not defined or
   * empty.
   */
  function TagChunk(tag, label) {
    var _this;
    (0, _classCallCheck2.default)(this, TagChunk);
    _this = _super.call(this);
    if (tag == null || tag.length === 0) {
      throw new Error("tag cannot be null or empty");
    }
    _this._tag = tag;
    _this._label = label;
    return _this;
  }
  /**
   * Get the tag for this chunk.
   *
   * @returns The tag for the chunk.
   */
  (0, _createClass2.default)(TagChunk, [{
    key: "tag",
    get: function get() {
      return this._tag;
    }
    /**
     * Get the label, if any, assigned to this chunk.
     *
     * @returns The label assigned to this chunk, or `undefined` if no label is
     * assigned to the chunk.
     */
  }, {
    key: "label",
    get: function get() {
      return this._label;
    }
    /**
     * This method returns a text representation of the tag chunk. Labeled tags
     * are returned in the form `label:tag`, and unlabeled tags are
     * returned as just the tag name.
     */
  }, {
    key: "toString",
    value: function toString() {
      if (this._label != null) {
        return this._label + ":" + this._tag;
      }
      return this._tag;
    }
  }]);
  return TagChunk;
}(Chunk_1.Chunk);
__decorate([Decorators_1.NotNull], TagChunk.prototype, "tag", null);
__decorate([Decorators_1.Override], TagChunk.prototype, "toString", null);
exports.TagChunk = TagChunk;

},{"../../Decorators":272,"./Chunk":394,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],400:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:46.2521448-07:00
var Chunk_1 = require("./Chunk");
var Decorators_1 = require("../../Decorators");
/**
 * Represents a span of raw text (concrete syntax) between tags in a tree
 * pattern string.
 */
var TextChunk = /*#__PURE__*/function (_Chunk_1$Chunk) {
  (0, _inherits2.default)(TextChunk, _Chunk_1$Chunk);
  var _super = _createSuper(TextChunk);
  /**
   * Constructs a new instance of {@link TextChunk} with the specified text.
   *
   * @param text The text of this chunk.
   * @exception IllegalArgumentException if `text` is not defined.
   */
  function TextChunk(text) {
    var _this;
    (0, _classCallCheck2.default)(this, TextChunk);
    _this = _super.call(this);
    if (text == null) {
      throw new Error("text cannot be null");
    }
    _this._text = text;
    return _this;
  }
  /**
   * Gets the raw text of this chunk.
   *
   * @returns The text of the chunk.
   */
  (0, _createClass2.default)(TextChunk, [{
    key: "text",
    get: function get() {
      return this._text;
    }
    /**
     * {@inheritDoc}
     *
     * The implementation for {@link TextChunk} returns the result of
     * `text` in single quotes.
     */
  }, {
    key: "toString",
    value: function toString() {
      return "'" + this._text + "'";
    }
  }]);
  return TextChunk;
}(Chunk_1.Chunk);
__decorate([Decorators_1.NotNull], TextChunk.prototype, "_text", void 0);
__decorate([Decorators_1.NotNull], TextChunk.prototype, "text", null);
__decorate([Decorators_1.Override], TextChunk.prototype, "toString", null);
TextChunk = __decorate([__param(0, Decorators_1.NotNull)], TextChunk);
exports.TextChunk = TextChunk;

},{"../../Decorators":272,"./Chunk":394,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],401:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:46.3281988-07:00
var CommonToken_1 = require("../../CommonToken");
var Decorators_1 = require("../../Decorators");
/**
 * A {@link Token} object representing a token of a particular type; e.g.,
 * `<ID>`. These tokens are created for {@link TagChunk} chunks where the
 * tag corresponds to a lexer rule or token type.
 */
var TokenTagToken = /*#__PURE__*/function (_CommonToken_1$Common) {
  (0, _inherits2.default)(TokenTagToken, _CommonToken_1$Common);
  var _super = _createSuper(TokenTagToken);
  /**
   * Constructs a new instance of {@link TokenTagToken} with the specified
   * token name, type, and label.
   *
   * @param tokenName The token name.
   * @param type The token type.
   * @param label The label associated with the token tag, or `undefined` if
   * the token tag is unlabeled.
   */
  function TokenTagToken(tokenName, type, label) {
    var _this;
    (0, _classCallCheck2.default)(this, TokenTagToken);
    _this = _super.call(this, type);
    _this._tokenName = tokenName;
    _this._label = label;
    return _this;
  }
  /**
   * Gets the token name.
   * @returns The token name.
   */
  (0, _createClass2.default)(TokenTagToken, [{
    key: "tokenName",
    get: function get() {
      return this._tokenName;
    }
    /**
     * Gets the label associated with the rule tag.
     *
     * @returns The name of the label associated with the rule tag, or
     * `undefined` if this is an unlabeled rule tag.
     */
  }, {
    key: "label",
    get: function get() {
      return this._label;
    }
    /**
     * {@inheritDoc}
     *
     * The implementation for {@link TokenTagToken} returns the token tag
     * formatted with `<` and `>` delimiters.
     */
  }, {
    key: "text",
    get: function get() {
      if (this._label != null) {
        return "<" + this._label + ":" + this._tokenName + ">";
      }
      return "<" + this._tokenName + ">";
    }
    /**
     * {@inheritDoc}
     *
     * The implementation for {@link TokenTagToken} returns a string of the form
     * `tokenName:type`.
     */
  }, {
    key: "toString",
    value: function toString() {
      return this._tokenName + ":" + this.type;
    }
  }]);
  return TokenTagToken;
}(CommonToken_1.CommonToken);
__decorate([Decorators_1.NotNull], TokenTagToken.prototype, "_tokenName", void 0);
__decorate([Decorators_1.NotNull], TokenTagToken.prototype, "tokenName", null);
__decorate([Decorators_1.Override], TokenTagToken.prototype, "text", null);
__decorate([Decorators_1.Override], TokenTagToken.prototype, "toString", null);
TokenTagToken = __decorate([__param(0, Decorators_1.NotNull)], TokenTagToken);
exports.TokenTagToken = TokenTagToken;

},{"../../CommonToken":268,"../../Decorators":272,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],402:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.split.js");
require("core-js/modules/es.array.fill.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.set.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/web.dom-collections.for-each.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
// ConvertTo-TS run at 2016-10-04T11:26:46.4373888-07:00
var CharStreams_1 = require("../../CharStreams");
var CommonTokenStream_1 = require("../../CommonTokenStream");
var LexerNoViableAltException_1 = require("../../LexerNoViableAltException");
var ParserRuleContext_1 = require("../../ParserRuleContext");
var Token_1 = require("../../Token");
var XPathLexer_1 = require("./XPathLexer");
var XPathLexerErrorListener_1 = require("./XPathLexerErrorListener");
var XPathRuleAnywhereElement_1 = require("./XPathRuleAnywhereElement");
var XPathRuleElement_1 = require("./XPathRuleElement");
var XPathTokenAnywhereElement_1 = require("./XPathTokenAnywhereElement");
var XPathTokenElement_1 = require("./XPathTokenElement");
var XPathWildcardAnywhereElement_1 = require("./XPathWildcardAnywhereElement");
var XPathWildcardElement_1 = require("./XPathWildcardElement");
/**
 * Represent a subset of XPath XML path syntax for use in identifying nodes in
 * parse trees.
 *
 * Split path into words and separators `/` and `//` via ANTLR
 * itself then walk path elements from left to right. At each separator-word
 * pair, find set of nodes. Next stage uses those as work list.
 *
 * The basic interface is
 * {@link XPath#findAll ParseTree.findAll}`(tree, pathString, parser)`.
 * But that is just shorthand for:
 *
 * ```
 * let p = new XPath(parser, pathString);
 * return p.evaluate(tree);
 * ```
 *
 * See `TestXPath` for descriptions. In short, this
 * allows operators:
 *
 * | | |
 * | --- | --- |
 * | `/` | root |
 * | `//` | anywhere |
 * | `!` | invert; this much appear directly after root or anywhere operator |
 *
 * and path elements:
 *
 * | | |
 * | --- | --- |
 * | `ID` | token name |
 * | `'string'` | any string literal token from the grammar |
 * | `expr` | rule name |
 * | `*` | wildcard matching any node |
 *
 * Whitespace is not allowed.
 */
var XPath = /*#__PURE__*/function () {
  function XPath(parser, path) {
    (0, _classCallCheck2.default)(this, XPath);
    this.parser = parser;
    this.path = path;
    this.elements = this.split(path);
    // console.log(this.elements.toString());
  }
  // TODO: check for invalid token/rule names, bad syntax
  (0, _createClass2.default)(XPath, [{
    key: "split",
    value: function split(path) {
      var lexer = new XPathLexer_1.XPathLexer(CharStreams_1.CharStreams.fromString(path));
      lexer.recover = function (e) {
        throw e;
      };
      lexer.removeErrorListeners();
      lexer.addErrorListener(new XPathLexerErrorListener_1.XPathLexerErrorListener());
      var tokenStream = new CommonTokenStream_1.CommonTokenStream(lexer);
      try {
        tokenStream.fill();
      } catch (e) {
        if (e instanceof LexerNoViableAltException_1.LexerNoViableAltException) {
          var pos = lexer.charPositionInLine;
          var msg = "Invalid tokens or characters at index " + pos + " in path '" + path + "' -- " + e.message;
          throw new RangeError(msg);
        }
        throw e;
      }
      var tokens = tokenStream.getTokens();
      // console.log("path=" + path + "=>" + tokens);
      var elements = [];
      var n = tokens.length;
      var i = 0;
      loop: while (i < n) {
        var el = tokens[i];
        var next = void 0;
        switch (el.type) {
          case XPathLexer_1.XPathLexer.ROOT:
          case XPathLexer_1.XPathLexer.ANYWHERE:
            var anywhere = el.type === XPathLexer_1.XPathLexer.ANYWHERE;
            i++;
            next = tokens[i];
            var invert = next.type === XPathLexer_1.XPathLexer.BANG;
            if (invert) {
              i++;
              next = tokens[i];
            }
            var pathElement = this.getXPathElement(next, anywhere);
            pathElement.invert = invert;
            elements.push(pathElement);
            i++;
            break;
          case XPathLexer_1.XPathLexer.TOKEN_REF:
          case XPathLexer_1.XPathLexer.RULE_REF:
          case XPathLexer_1.XPathLexer.WILDCARD:
            elements.push(this.getXPathElement(el, false));
            i++;
            break;
          case Token_1.Token.EOF:
            break loop;
          default:
            throw new Error("Unknowth path element " + el);
        }
      }
      return elements;
    }
    /**
     * Convert word like `*` or `ID` or `expr` to a path
     * element. `anywhere` is `true` if `//` precedes the
     * word.
     */
  }, {
    key: "getXPathElement",
    value: function getXPathElement(wordToken, anywhere) {
      if (wordToken.type === Token_1.Token.EOF) {
        throw new Error("Missing path element at end of path");
      }
      var word = wordToken.text;
      if (word == null) {
        throw new Error("Expected wordToken to have text content.");
      }
      var ttype = this.parser.getTokenType(word);
      var ruleIndex = this.parser.getRuleIndex(word);
      switch (wordToken.type) {
        case XPathLexer_1.XPathLexer.WILDCARD:
          return anywhere ? new XPathWildcardAnywhereElement_1.XPathWildcardAnywhereElement() : new XPathWildcardElement_1.XPathWildcardElement();
        case XPathLexer_1.XPathLexer.TOKEN_REF:
        case XPathLexer_1.XPathLexer.STRING:
          if (ttype === Token_1.Token.INVALID_TYPE) {
            throw new Error(word + " at index " + wordToken.startIndex + " isn't a valid token name");
          }
          return anywhere ? new XPathTokenAnywhereElement_1.XPathTokenAnywhereElement(word, ttype) : new XPathTokenElement_1.XPathTokenElement(word, ttype);
        default:
          if (ruleIndex === -1) {
            throw new Error(word + " at index " + wordToken.startIndex + " isn't a valid rule name");
          }
          return anywhere ? new XPathRuleAnywhereElement_1.XPathRuleAnywhereElement(word, ruleIndex) : new XPathRuleElement_1.XPathRuleElement(word, ruleIndex);
      }
    }
  }, {
    key: "evaluate",
    value:
    /**
     * Return a list of all nodes starting at `t` as root that satisfy the
     * path. The root `/` is relative to the node passed to {@link evaluate}.
     */
    function evaluate(t) {
      var dummyRoot = new ParserRuleContext_1.ParserRuleContext();
      dummyRoot.addChild(t);
      var work = new Set([dummyRoot]);
      var i = 0;
      while (i < this.elements.length) {
        var next = new Set();
        var _iterator = _createForOfIteratorHelper(work),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var node = _step.value;
            if (node.childCount > 0) {
              // only try to match next element if it has children
              // e.g., //func/*/stat might have a token node for which
              // we can't go looking for stat nodes.
              var matching = this.elements[i].evaluate(node);
              matching.forEach(next.add, next);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        i++;
        work = next;
      }
      return work;
    }
  }], [{
    key: "findAll",
    value: function findAll(tree, xpath, parser) {
      var p = new XPath(parser, xpath);
      return p.evaluate(tree);
    }
  }]);
  return XPath;
}();
XPath.WILDCARD = "*"; // word not operator/separator
XPath.NOT = "!"; // word for invert operator
exports.XPath = XPath;

},{"../../CharStreams":265,"../../CommonTokenStream":270,"../../LexerNoViableAltException":282,"../../ParserRuleContext":287,"../../Token":296,"./XPathLexer":404,"./XPathLexerErrorListener":405,"./XPathRuleAnywhereElement":406,"./XPathRuleElement":407,"./XPathTokenAnywhereElement":408,"./XPathTokenElement":409,"./XPathWildcardAnywhereElement":410,"./XPathWildcardElement":411,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"core-js/modules/es.array.fill.js":571,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.set.js":621,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.string.split.js":631,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.for-each.js":676,"core-js/modules/web.dom-collections.iterator.js":677}],403:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.function.name.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// CONVERSTION complete, Burt Harris 10/14/2016
var Decorators_1 = require("../../Decorators");
var XPathElement = /*#__PURE__*/function () {
  /** Construct element like `/ID` or `ID` or `/*` etc...
   *  op is null if just node
   */
  function XPathElement(nodeName) {
    (0, _classCallCheck2.default)(this, XPathElement);
    this.nodeName = nodeName;
    this.invert = false;
  }
  (0, _createClass2.default)(XPathElement, [{
    key: "toString",
    value: function toString() {
      var inv = this.invert ? "!" : "";
      var className = Object.constructor.name;
      return className + "[" + inv + this.nodeName + "]";
    }
  }]);
  return XPathElement;
}();
__decorate([Decorators_1.Override], XPathElement.prototype, "toString", null);
exports.XPathElement = XPathElement;

},{"../../Decorators":272,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612}],404:[function(require,module,exports){
"use strict";

// Generated from XPathLexer.g4 by ANTLR 4.7.3-SNAPSHOT
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.join.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var ATNDeserializer_1 = require("../../atn/ATNDeserializer");
var Lexer_1 = require("../../Lexer");
var LexerATNSimulator_1 = require("../../atn/LexerATNSimulator");
var VocabularyImpl_1 = require("../../VocabularyImpl");
var Utils = require("../../misc/Utils");
var XPathLexer = /*#__PURE__*/function (_Lexer_1$Lexer) {
  (0, _inherits2.default)(XPathLexer, _Lexer_1$Lexer);
  var _super = _createSuper(XPathLexer);
  // tslint:enable:no-trailing-whitespace
  function XPathLexer(input) {
    var _this;
    (0, _classCallCheck2.default)(this, XPathLexer);
    _this = _super.call(this, input);
    _this._interp = new LexerATNSimulator_1.LexerATNSimulator(XPathLexer._ATN, (0, _assertThisInitialized2.default)(_this));
    return _this;
  }
  // @Override
  // @NotNull
  (0, _createClass2.default)(XPathLexer, [{
    key: "vocabulary",
    get: function get() {
      return XPathLexer.VOCABULARY;
    }
    // @Override
  }, {
    key: "grammarFileName",
    get: function get() {
      return "XPathLexer.g4";
    }
    // @Override
  }, {
    key: "ruleNames",
    get: function get() {
      return XPathLexer.ruleNames;
    }
    // @Override
  }, {
    key: "serializedATN",
    get: function get() {
      return XPathLexer._serializedATN;
    }
    // @Override
  }, {
    key: "channelNames",
    get: function get() {
      return XPathLexer.channelNames;
    }
    // @Override
  }, {
    key: "modeNames",
    get: function get() {
      return XPathLexer.modeNames;
    }
    // @Override
  }, {
    key: "action",
    value: function action(_localctx, ruleIndex, actionIndex) {
      switch (ruleIndex) {
        case 4:
          this.ID_action(_localctx, actionIndex);
          break;
      }
    }
  }, {
    key: "ID_action",
    value: function ID_action(_localctx, actionIndex) {
      switch (actionIndex) {
        case 0:
          var text = this.text;
          if (text.charAt(0) === text.charAt(0).toUpperCase()) {
            this.type = XPathLexer.TOKEN_REF;
          } else {
            this.type = XPathLexer.RULE_REF;
          }
          break;
      }
    }
  }], [{
    key: "_ATN",
    get: function get() {
      if (!XPathLexer.__ATN) {
        XPathLexer.__ATN = new ATNDeserializer_1.ATNDeserializer().deserialize(Utils.toCharArray(XPathLexer._serializedATN));
      }
      return XPathLexer.__ATN;
    }
  }]);
  return XPathLexer;
}(Lexer_1.Lexer);
XPathLexer.TOKEN_REF = 1;
XPathLexer.RULE_REF = 2;
XPathLexer.ANYWHERE = 3;
XPathLexer.ROOT = 4;
XPathLexer.WILDCARD = 5;
XPathLexer.BANG = 6;
XPathLexer.ID = 7;
XPathLexer.STRING = 8;
// tslint:disable:no-trailing-whitespace
XPathLexer.channelNames = ["DEFAULT_TOKEN_CHANNEL", "HIDDEN"];
// tslint:disable:no-trailing-whitespace
XPathLexer.modeNames = ["DEFAULT_MODE"];
XPathLexer.ruleNames = ["ANYWHERE", "ROOT", "WILDCARD", "BANG", "ID", "NameChar", "NameStartChar", "STRING"];
XPathLexer._LITERAL_NAMES = [undefined, undefined, undefined, "'//'", "'/'", "'*'", "'!'"];
XPathLexer._SYMBOLIC_NAMES = [undefined, "TOKEN_REF", "RULE_REF", "ANYWHERE", "ROOT", "WILDCARD", "BANG", "ID", "STRING"];
XPathLexer.VOCABULARY = new VocabularyImpl_1.VocabularyImpl(XPathLexer._LITERAL_NAMES, XPathLexer._SYMBOLIC_NAMES, []);
XPathLexer._serializedATNSegments = 2;
XPathLexer._serializedATNSegment0 = "\x03\uC91D\uCABA\u058D\uAFBA\u4F53\u0607\uEA8B\uC241\x02\n2\b\x01\x04" + "\x02\t\x02\x04\x03\t\x03\x04\x04\t\x04\x04\x05\t\x05\x04\x06\t\x06\x04" + "\x07\t\x07\x04\b\t\b\x04\t\t\t\x03\x02\x03\x02\x03\x02\x03\x03\x03\x03" + "\x03\x04\x03\x04\x03\x05\x03\x05\x03\x06\x03\x06\x07\x06\x1F\n\x06\f\x06" + "\x0E\x06\"\v\x06\x03\x06\x03\x06\x03\x07\x03\x07\x03\b\x03\b\x03\t\x03" + "\t\x07\t,\n\t\f\t\x0E\t/\v\t\x03\t\x03\t\x03-\x02\x02\n\x03\x02\x05\x05" + "\x02\x06\x07\x02\x07\t\x02\b\v\x02\t\r\x02\x02\x0F\x02\x02\x11\x02\n\x03" + "\x02\x02\x04\u02B6\x02\x02\x02\n\x02\x10\x02\x1D\x022\x02;\x02C\x02\\" + "\x02a\x02a\x02c\x02|\x02\x81\x02\xA1\x02\xAC\x02\xAC\x02\xAF\x02\xAF\x02" + "\xB7\x02\xB7\x02\xBC\x02\xBC\x02\xC2\x02\xD8\x02\xDA\x02\xF8\x02\xFA\x02" + "\u02C3\x02\u02C8\x02\u02D3\x02\u02E2\x02\u02E6\x02\u02EE\x02\u02EE\x02" + "\u02F0\x02\u02F0\x02\u0302\x02\u0376\x02\u0378\x02\u0379\x02\u037C\x02" + "\u037F\x02\u0381\x02\u0381\x02\u0388\x02\u0388\x02\u038A\x02\u038C\x02" + "\u038E\x02\u038E\x02\u0390\x02\u03A3\x02\u03A5\x02\u03F7\x02\u03F9\x02" + "\u0483\x02\u0485\x02\u0489\x02\u048C\x02\u0531\x02\u0533\x02\u0558\x02" + "\u055B\x02\u055B\x02\u0563\x02\u0589\x02\u0593\x02\u05BF\x02\u05C1\x02" + "\u05C1\x02\u05C3\x02\u05C4\x02\u05C6\x02\u05C7\x02\u05C9\x02\u05C9\x02" + "\u05D2\x02\u05EC\x02\u05F2\x02\u05F4\x02\u0602\x02\u0607\x02\u0612\x02" + "\u061C\x02\u061E\x02\u061E\x02\u0622\x02\u066B\x02\u0670\x02\u06D5\x02" + "\u06D7\x02\u06DF\x02\u06E1\x02\u06EA\x02\u06EC\x02\u06FE\x02\u0701\x02" + "\u0701\x02\u0711\x02\u074C\x02\u074F\x02\u07B3\x02\u07C2\x02\u07F7\x02" + "\u07FC\x02\u07FC\x02\u0802\x02\u082F\x02\u0842\x02\u085D\x02\u08A2\x02" + "\u08B6\x02\u08B8\x02\u08BF\x02\u08D6\x02\u0965\x02\u0968\x02\u0971\x02" + "\u0973\x02\u0985\x02\u0987\x02\u098E\x02\u0991\x02\u0992\x02\u0995\x02" + "\u09AA\x02\u09AC\x02\u09B2\x02\u09B4\x02\u09B4\x02\u09B8\x02\u09BB\x02" + "\u09BE\x02\u09C6\x02\u09C9\x02\u09CA\x02\u09CD\x02\u09D0\x02\u09D9\x02" + "\u09D9\x02\u09DE\x02\u09DF\x02\u09E1\x02\u09E5\x02\u09E8\x02\u09F3\x02" + "\u0A03\x02\u0A05\x02\u0A07\x02\u0A0C\x02\u0A11\x02\u0A12\x02\u0A15\x02" + "\u0A2A\x02\u0A2C\x02\u0A32\x02\u0A34\x02\u0A35\x02\u0A37\x02\u0A38\x02" + "\u0A3A\x02\u0A3B\x02\u0A3E\x02\u0A3E\x02\u0A40\x02\u0A44\x02\u0A49\x02" + "\u0A4A\x02\u0A4D\x02\u0A4F\x02\u0A53\x02\u0A53\x02\u0A5B\x02\u0A5E\x02" + "\u0A60\x02\u0A60\x02\u0A68\x02\u0A77\x02\u0A83\x02\u0A85\x02\u0A87\x02" + "\u0A8F\x02\u0A91\x02\u0A93\x02\u0A95\x02\u0AAA\x02\u0AAC\x02\u0AB2\x02" + "\u0AB4\x02\u0AB5\x02\u0AB7\x02\u0ABB\x02\u0ABE\x02\u0AC7\x02\u0AC9\x02" + "\u0ACB\x02\u0ACD\x02\u0ACF\x02\u0AD2\x02\u0AD2\x02\u0AE2\x02\u0AE5\x02" + "\u0AE8\x02\u0AF1\x02\u0AFB\x02\u0AFB\x02\u0B03\x02\u0B05\x02\u0B07\x02" + "\u0B0E\x02\u0B11\x02\u0B12\x02\u0B15\x02\u0B2A\x02\u0B2C\x02\u0B32\x02" + "\u0B34\x02\u0B35\x02\u0B37\x02\u0B3B\x02\u0B3E\x02\u0B46\x02\u0B49\x02" + "\u0B4A\x02\u0B4D\x02\u0B4F\x02\u0B58\x02\u0B59\x02\u0B5E\x02\u0B5F\x02" + "\u0B61\x02\u0B65\x02\u0B68\x02\u0B71\x02\u0B73\x02\u0B73\x02\u0B84\x02" + "\u0B85\x02\u0B87\x02\u0B8C\x02\u0B90\x02\u0B92\x02\u0B94\x02\u0B97\x02" + "\u0B9B\x02\u0B9C\x02\u0B9E\x02\u0B9E\x02\u0BA0\x02\u0BA1\x02\u0BA5\x02" + "\u0BA6\x02\u0BAA\x02\u0BAC\x02\u0BB0\x02\u0BBB\x02\u0BC0\x02\u0BC4\x02" + "\u0BC8\x02\u0BCA\x02\u0BCC\x02\u0BCF\x02\u0BD2\x02\u0BD2\x02\u0BD9\x02" + "\u0BD9\x02\u0BE8\x02\u0BF1\x02\u0C02\x02\u0C05\x02\u0C07\x02\u0C0E\x02" + "\u0C10\x02\u0C12\x02\u0C14\x02\u0C2A\x02\u0C2C\x02\u0C3B\x02\u0C3F\x02" + "\u0C46\x02\u0C48\x02\u0C4A\x02\u0C4C\x02\u0C4F\x02\u0C57\x02\u0C58\x02" + "\u0C5A\x02\u0C5C\x02\u0C62\x02\u0C65\x02\u0C68\x02\u0C71\x02\u0C82\x02" + "\u0C85\x02\u0C87\x02\u0C8E\x02\u0C90\x02\u0C92\x02\u0C94\x02\u0CAA\x02" + "\u0CAC\x02\u0CB5\x02\u0CB7\x02\u0CBB\x02\u0CBE\x02\u0CC6\x02\u0CC8\x02" + "\u0CCA\x02\u0CCC\x02\u0CCF\x02\u0CD7\x02\u0CD8\x02\u0CE0\x02\u0CE0\x02" + "\u0CE2\x02\u0CE5\x02\u0CE8\x02\u0CF1\x02\u0CF3\x02\u0CF4\x02\u0D03\x02" + "\u0D05\x02\u0D07\x02\u0D0E\x02\u0D10\x02\u0D12\x02\u0D14\x02\u0D3C\x02" + "\u0D3F\x02\u0D46\x02\u0D48\x02\u0D4A\x02\u0D4C\x02\u0D50\x02\u0D56\x02" + "\u0D59\x02\u0D61\x02\u0D65\x02\u0D68\x02\u0D71\x02\u0D7C\x02\u0D81\x02" + "\u0D84\x02\u0D85\x02\u0D87\x02\u0D98\x02\u0D9C\x02\u0DB3\x02\u0DB5\x02" + "\u0DBD\x02\u0DBF\x02\u0DBF\x02\u0DC2\x02\u0DC8\x02\u0DCC\x02\u0DCC\x02" + "\u0DD1\x02\u0DD6\x02\u0DD8\x02\u0DD8\x02\u0DDA\x02\u0DE1\x02\u0DE8\x02" + "\u0DF1\x02\u0DF4\x02\u0DF5\x02\u0E03\x02\u0E3C\x02\u0E42\x02\u0E50\x02" + "\u0E52\x02\u0E5B\x02\u0E83\x02\u0E84\x02\u0E86\x02\u0E86\x02\u0E89\x02" + "\u0E8A\x02\u0E8C\x02\u0E8C\x02\u0E8F\x02\u0E8F\x02\u0E96\x02\u0E99\x02" + "\u0E9B\x02\u0EA1\x02\u0EA3\x02\u0EA5\x02\u0EA7\x02\u0EA7\x02\u0EA9\x02" + "\u0EA9\x02\u0EAC\x02\u0EAD\x02\u0EAF\x02\u0EBB\x02\u0EBD\x02\u0EBF\x02" + "\u0EC2\x02\u0EC6\x02\u0EC8\x02\u0EC8\x02\u0ECA\x02\u0ECF\x02\u0ED2\x02" + "\u0EDB\x02\u0EDE\x02\u0EE1\x02\u0F02\x02\u0F02\x02\u0F1A\x02\u0F1B\x02" + "\u0F22\x02\u0F2B\x02\u0F37\x02\u0F37\x02\u0F39\x02\u0F39\x02\u0F3B\x02" + "\u0F3B\x02\u0F40\x02\u0F49\x02\u0F4B\x02\u0F6E\x02\u0F73\x02\u0F86\x02" + "\u0F88\x02\u0F99\x02\u0F9B\x02\u0FBE\x02\u0FC8\x02\u0FC8\x02\u1002\x02" + "\u104B\x02\u1052\x02\u109F\x02\u10A2\x02\u10C7\x02\u10C9\x02\u10C9\x02" + "\u10CF\x02\u10CF\x02\u10D2\x02\u10FC\x02\u10FE\x02\u124A\x02\u124C\x02" + "\u124F\x02\u1252\x02\u1258\x02\u125A\x02\u125A\x02\u125C\x02\u125F\x02" + "\u1262\x02\u128A\x02\u128C\x02\u128F\x02\u1292\x02\u12B2\x02\u12B4\x02" + "\u12B7\x02\u12BA\x02\u12C0\x02\u12C2\x02\u12C2\x02\u12C4\x02\u12C7\x02" + "\u12CA\x02\u12D8\x02\u12DA\x02\u1312\x02\u1314\x02\u1317\x02\u131A\x02" + "\u135C\x02\u135F\x02\u1361\x02\u1382\x02\u1391\x02\u13A2\x02\u13F7\x02" + "\u13FA\x02\u13FF\x02\u1403\x02\u166E\x02\u1671\x02\u1681\x02\u1683\x02" + "\u169C\x02\u16A2\x02\u16EC\x02\u16F0\x02\u16FA\x02\u1702\x02\u170E\x02" + "\u1710\x02\u1716\x02\u1722\x02\u1736\x02\u1742\x02\u1755\x02\u1762\x02" + "\u176E\x02\u1770\x02\u1772\x02\u1774\x02\u1775\x02\u1782\x02\u17D5\x02" + "\u17D9\x02\u17D9\x02\u17DE\x02\u17DF\x02\u17E2\x02\u17EB\x02\u180D\x02" + "\u1810\x02\u1812\x02\u181B\x02\u1822\x02\u1879\x02\u1882\x02\u18AC\x02" + "\u18B2\x02\u18F7\x02\u1902\x02\u1920\x02\u1922\x02\u192D\x02\u1932\x02" + "\u193D\x02\u1948\x02\u196F\x02\u1972\x02\u1976\x02\u1982\x02\u19AD\x02" + "\u19B2\x02\u19CB\x02\u19D2\x02\u19DB\x02\u1A02\x02\u1A1D\x02\u1A22\x02" + "\u1A60\x02\u1A62\x02\u1A7E\x02\u1A81\x02\u1A8B\x02\u1A92\x02\u1A9B\x02" + "\u1AA9\x02\u1AA9\x02\u1AB2\x02\u1ABF\x02\u1B02\x02\u1B4D\x02\u1B52\x02" + "\u1B5B\x02\u1B6D\x02\u1B75\x02\u1B82\x02\u1BF5\x02\u1C02\x02\u1C39\x02" + "\u1C42\x02\u1C4B\x02\u1C4F\x02\u1C7F\x02\u1C82\x02\u1C8A\x02\u1CD2\x02" + "\u1CD4\x02\u1CD6\x02\u1CF8\x02\u1CFA\x02\u1CFB\x02\u1D02\x02\u1DF7\x02" + "\u1DFD\x02\u1F17\x02\u1F1A\x02\u1F1F\x02\u1F22\x02\u1F47\x02\u1F4A\x02" + "\u1F4F\x02\u1F52\x02\u1F59\x02\u1F5B\x02\u1F5B\x02\u1F5D\x02\u1F5D\x02" + "\u1F5F\x02\u1F5F\x02\u1F61\x02\u1F7F\x02\u1F82\x02\u1FB6\x02\u1FB8\x02" + "\u1FBE\x02\u1FC0\x02\u1FC0\x02\u1FC4\x02\u1FC6\x02\u1FC8\x02\u1FCE\x02" + "\u1FD2\x02\u1FD5\x02\u1FD8\x02\u1FDD\x02\u1FE2\x02\u1FEE\x02\u1FF4\x02" + "\u1FF6\x02\u1FF8\x02\u1FFE\x02\u200D\x02\u2011\x02\u202C\x02\u2030\x02" + "\u2041\x02\u2042\x02\u2056\x02\u2056\x02\u2062\x02\u2066\x02\u2068\x02" + "\u2071\x02\u2073\x02\u2073\x02\u2081\x02\u2081\x02\u2092\x02\u209E\x02" + "\u20D2\x02\u20DE\x02\u20E3\x02\u20E3\x02\u20E7\x02\u20F2\x02\u2104\x02" + "\u2104\x02\u2109\x02\u2109\x02\u210C\x02\u2115\x02\u2117\x02\u2117\x02" + "\u211B\x02\u211F\x02\u2126\x02\u2126\x02\u2128\x02\u2128\x02\u212A\x02" + "\u212A\x02\u212C\x02\u212F\x02\u2131\x02\u213B\x02\u213E\x02\u2141\x02" + "\u2147\x02\u214B\x02\u2150\x02\u2150\x02\u2162\x02\u218A\x02\u2C02\x02" + "\u2C30\x02\u2C32\x02\u2C60\x02\u2C62\x02\u2CE6\x02\u2CED\x02\u2CF5\x02" + "\u2D02\x02\u2D27\x02\u2D29\x02\u2D29\x02\u2D2F\x02\u2D2F\x02\u2D32\x02" + "\u2D69\x02\u2D71\x02\u2D71\x02\u2D81\x02\u2D98\x02\u2DA2\x02\u2DA8\x02" + "\u2DAA\x02\u2DB0\x02\u2DB2\x02\u2DB8\x02\u2DBA\x02\u2DC0\x02\u2DC2\x02" + "\u2DC8\x02\u2DCA\x02\u2DD0\x02\u2DD2\x02\u2DD8\x02\u2DDA\x02\u2DE0\x02" + "\u2DE2\x02\u2E01\x02\u2E31\x02\u2E31\x02\u3007\x02\u3009\x02\u3023\x02" + "\u3031\x02\u3033\x02\u3037\x02\u303A\x02\u303E\x02\u3043\x02\u3098\x02" + "\u309B\x02\u309C\x02\u309F\x02\u30A1\x02\u30A3\x02\u30FC\x02\u30FE\x02" + "\u3101\x02\u3107\x02\u312F\x02\u3133\x02\u3190\x02\u31A2\x02\u31BC\x02" + "\u31F2\x02\u3201\x02\u3402\x02\u4DB7\x02\u4E02\x02\u9FD7\x02\uA002\x02" + "\uA48E\x02\uA4D2\x02\uA4FF\x02\uA502\x02\uA60E\x02\uA612\x02\uA62D\x02" + "\uA642\x02\uA671\x02\uA676\x02\uA67F\x02\uA681\x02\uA6F3\x02\uA719\x02" + "\uA721\x02\uA724\x02\uA78A\x02\uA78D\x02\uA7B0\x02\uA7B2\x02\uA7B9\x02" + "\uA7F9\x02\uA829\x02\uA842\x02\uA875\x02\uA882\x02\uA8C7\x02\uA8D2\x02" + "\uA8DB\x02\uA8E2\x02\uA8F9\x02\uA8FD\x02\uA8FD\x02\uA8FF\x02\uA8FF\x02" + "\uA902\x02\uA92F\x02\uA932\x02\uA955\x02\uA962\x02\uA97E\x02\uA982\x02" + "\uA9C2\x02\uA9D1\x02\uA9DB\x02\uA9E2\x02\uAA00\x02\uAA02\x02\uAA38\x02" + "\uAA42\x02\uAA4F\x02\uAA52\x02\uAA5B\x02\uAA62\x02\uAA78\x02\uAA7C\x02" + "\uAAC4\x02\uAADD\x02\uAADF\x02\uAAE2\x02\uAAF1\x02\uAAF4\x02\uAAF8\x02" + "\uAB03\x02\uAB08\x02\uAB0B\x02\uAB10\x02\uAB13\x02\uAB18\x02\uAB22\x02" + "\uAB28\x02\uAB2A\x02\uAB30\x02\uAB32\x02\uAB5C\x02\uAB5E\x02\uAB67\x02" + "\uAB72\x02\uABEC\x02\uABEE\x02\uABEF\x02\uABF2\x02\uABFB\x02\uAC02\x02" + "\uD7A5\x02\uD7B2\x02\uD7C8\x02\uD7CD\x02\uD7FD\x02\uF902\x02\uFA6F\x02" + "\uFA72\x02\uFADB\x02\uFB02\x02\uFB08\x02\uFB15\x02\uFB19\x02\uFB1F\x02" + "\uFB2A\x02\uFB2C\x02\uFB38\x02\uFB3A\x02\uFB3E\x02\uFB40\x02\uFB40\x02" + "\uFB42\x02\uFB43\x02\uFB45\x02\uFB46\x02\uFB48\x02\uFBB3\x02\uFBD5\x02" + "\uFD3F\x02\uFD52\x02\uFD91\x02\uFD94\x02\uFDC9\x02\uFDF2\x02\uFDFD\x02" + "\uFE02\x02\uFE11\x02\uFE22\x02\uFE31\x02\uFE35\x02\uFE36\x02\uFE4F\x02" + "\uFE51\x02\uFE72\x02\uFE76\x02\uFE78\x02\uFEFE\x02\uFF01\x02\uFF01\x02" + "\uFF12\x02\uFF1B\x02\uFF23\x02\uFF3C\x02\uFF41\x02\uFF41\x02\uFF43\x02" + "\uFF5C\x02\uFF68\x02\uFFC0\x02\uFFC4\x02\uFFC9\x02\uFFCC\x02\uFFD1\x02" + "\uFFD4\x02\uFFD9\x02\uFFDC\x02\uFFDE\x02\uFFFB\x02\uFFFD\x02\x02\x03\r" + "\x03\x0F\x03(\x03*\x03<\x03>\x03?\x03A\x03O\x03R\x03_\x03\x82\x03\xFC" + "\x03\u0142\x03\u0176\x03\u01FF\x03\u01FF\x03\u0282\x03\u029E\x03\u02A2" + "\x03\u02D2\x03\u02E2\x03\u02E2\x03\u0302\x03\u0321\x03\u0332\x03\u034C" + "\x03\u0352\x03\u037C\x03\u0382\x03\u039F\x03\u03A2\x03\u03C5\x03\u03CA" + "\x03\u03D1\x03\u03D3\x03\u03D7\x03\u0402\x03\u049F\x03\u04A2\x03\u04AB" + "\x03\u04B2\x03\u04D5\x03\u04DA\x03\u04FD\x03\u0502\x03\u0529\x03\u0532" + "\x03\u0565\x03\u0602\x03\u0738\x03\u0742\x03\u0757\x03\u0762\x03\u0769" + "\x03\u0802\x03\u0807\x03\u080A\x03\u080A\x03\u080C\x03\u0837\x03\u0839" + "\x03\u083A\x03\u083E\x03\u083E\x03\u0841\x03\u0857\x03\u0862\x03\u0878" + "\x03\u0882\x03\u08A0\x03\u08E2\x03\u08F4\x03\u08F6\x03\u08F7\x03\u0902" + "\x03\u0917\x03\u0922\x03\u093B\x03\u0982\x03\u09B9\x03\u09C0\x03\u09C1" + "\x03\u0A02\x03\u0A05\x03\u0A07\x03\u0A08\x03\u0A0E\x03\u0A15\x03\u0A17" + "\x03\u0A19\x03\u0A1B\x03\u0A35\x03\u0A3A\x03\u0A3C\x03\u0A41\x03\u0A41" + "\x03\u0A62\x03\u0A7E\x03\u0A82\x03\u0A9E\x03\u0AC2\x03\u0AC9\x03\u0ACB" + "\x03\u0AE8\x03\u0B02\x03\u0B37\x03\u0B42\x03\u0B57\x03\u0B62\x03\u0B74" + "\x03\u0B82\x03\u0B93\x03\u0C02\x03\u0C4A\x03\u0C82\x03\u0CB4\x03\u0CC2" + "\x03\u0CF4\x03\u1002\x03\u1048\x03\u1068\x03\u1071\x03\u1081\x03\u10BC" + "\x03\u10BF\x03\u10BF\x03\u10D2\x03\u10EA\x03\u10F2\x03\u10FB\x03\u1102" + "\x03\u1136\x03\u1138\x03\u1141\x03\u1152\x03\u1175\x03\u1178\x03\u1178" + "\x03\u1182\x03\u11C6\x03\u11CC\x03\u11CE\x03\u11D2\x03\u11DC\x03\u11DE" + "\x03\u11DE\x03\u1202\x03\u1213\x03\u1215\x03\u1239\x03\u1240\x03\u1240" + "\x03\u1282\x03\u1288\x03\u128A\x03\u128A\x03\u128C\x03\u128F\x03\u1291" + "\x03\u129F\x03\u12A1\x03\u12AA\x03\u12B2\x03\u12EC\x03\u12F2\x03\u12FB" + "\x03\u1302\x03\u1305\x03\u1307\x03\u130E\x03\u1311\x03\u1312\x03\u1315" + "\x03\u132A\x03\u132C\x03\u1332\x03\u1334\x03\u1335\x03\u1337\x03\u133B" + "\x03\u133E\x03\u1346\x03\u1349\x03\u134A\x03\u134D\x03\u134F\x03\u1352" + "\x03\u1352\x03\u1359\x03\u1359\x03\u135F\x03\u1365\x03\u1368\x03\u136E" + "\x03\u1372\x03\u1376\x03\u1402\x03\u144C\x03\u1452\x03\u145B\x03\u1482" + "\x03\u14C7\x03\u14C9\x03\u14C9\x03\u14D2\x03\u14DB\x03\u1582\x03\u15B7" + "\x03\u15BA\x03\u15C2\x03\u15DA\x03\u15DF\x03\u1602\x03\u1642\x03\u1646" + "\x03\u1646\x03\u1652\x03\u165B\x03\u1682\x03\u16B9\x03\u16C2\x03\u16CB" + "\x03\u1702\x03\u171B\x03\u171F\x03\u172D\x03\u1732\x03\u173B\x03\u18A2" + "\x03\u18EB\x03\u1901\x03\u1901\x03\u1AC2\x03\u1AFA\x03\u1C02\x03\u1C0A" + "\x03\u1C0C\x03\u1C38\x03\u1C3A\x03\u1C42\x03\u1C52\x03\u1C5B\x03\u1C74" + "\x03\u1C91\x03\u1C94\x03\u1CA9\x03\u1CAB\x03\u1CB8\x03\u2002\x03\u239B" + "\x03\u2402\x03\u2470\x03\u2482\x03\u2545\x03\u3002\x03\u3430\x03\u4402" + "\x03\u4648\x03\u6802\x03\u6A3A\x03\u6A42\x03\u6A60\x03\u6A62\x03\u6A6B" + "\x03\u6AD2\x03\u6AEF\x03\u6AF2\x03\u6AF6\x03\u6B02\x03\u6B38\x03\u6B42" + "\x03\u6B45\x03\u6B52\x03\u6B5B\x03\u6B65\x03\u6B79\x03\u6B7F\x03\u6B91" + "\x03\u6F02\x03\u6F46\x03\u6F52\x03\u6F80\x03\u6F91\x03\u6FA1\x03\u6FE2" + "\x03\u6FE2\x03\u7002\x03\u87EE\x03\u8802\x03\u8AF4\x03\uB002\x03\uB003" + "\x03\uBC02\x03\uBC6C\x03\uBC72\x03\uBC7E\x03\uBC82\x03\uBC8A\x03\uBC92" + "\x03\uBC9B\x03\uBC9F\x03\uBCA0\x03\uBCA2\x03\uBCA5\x03\uD167\x03\uD16B" + "\x03\uD16F\x03\uD184\x03\uD187\x03\uD18D\x03\uD1AC\x03\uD1AF\x03\uD244" + "\x03\uD246\x03\uD402\x03\uD456\x03\uD458\x03\uD49E\x03\uD4A0\x03\uD4A1" + "\x03\uD4A4\x03\uD4A4\x03\uD4A7\x03\uD4A8\x03\uD4AB\x03\uD4AE\x03\uD4B0" + "\x03\uD4BB\x03\uD4BD\x03\uD4BD\x03\uD4BF\x03\uD4C5\x03\uD4C7\x03\uD507" + "\x03\uD509\x03\uD50C\x03\uD50F\x03\uD516\x03\uD518\x03\uD51E\x03\uD520" + "\x03\uD53B\x03\uD53D\x03\uD540\x03\uD542\x03\uD546\x03\uD548\x03\uD548" + "\x03\uD54C\x03\uD552\x03\uD554\x03\uD6A7\x03\uD6AA\x03\uD6C2\x03\uD6C4" + "\x03\uD6DC\x03\uD6DE\x03\uD6FC\x03\uD6FE\x03\uD716\x03\uD718\x03\uD736" + "\x03\uD738\x03\uD750\x03\uD752\x03\uD770\x03\uD772\x03\uD78A\x03\uD78C" + "\x03\uD7AA\x03\uD7AC\x03\uD7C4\x03\uD7C6\x03\uD7CD\x03\uD7D0\x03\uD801" + "\x03\uDA02\x03\uDA38\x03\uDA3D\x03\uDA6E\x03\uDA77\x03\uDA77\x03\uDA86" + "\x03\uDA86\x03\uDA9D\x03\uDAA1\x03\uDAA3\x03\uDAB1\x03\uE002\x03\uE008" + "\x03\uE00A\x03\uE01A\x03\uE01D\x03\uE023\x03\uE025\x03\uE026\x03\uE028" + "\x03\uE02C\x03\uE802\x03\uE8C6\x03\uE8D2\x03\uE8D8\x03\uE902\x03\uE94C" + "\x03\uE952\x03\uE95B\x03\uEE02\x03\uEE05\x03\uEE07\x03\uEE21\x03\uEE23" + "\x03\uEE24\x03\uEE26\x03\uEE26\x03\uEE29\x03\uEE29\x03\uEE2B\x03\uEE34" + "\x03\uEE36\x03\uEE39\x03\uEE3B\x03\uEE3B\x03\uEE3D\x03\uEE3D\x03\uEE44" + "\x03\uEE44\x03\uEE49\x03\uEE49\x03\uEE4B\x03\uEE4B\x03\uEE4D\x03\uEE4D" + "\x03\uEE4F\x03\uEE51\x03\uEE53\x03\uEE54\x03\uEE56\x03\uEE56\x03\uEE59" + "\x03\uEE59\x03\uEE5B\x03\uEE5B\x03\uEE5D\x03\uEE5D\x03\uEE5F\x03\uEE5F" + "\x03\uEE61\x03\uEE61\x03\uEE63\x03\uEE64\x03\uEE66\x03\uEE66\x03\uEE69" + "\x03\uEE6C\x03\uEE6E\x03\uEE74\x03\uEE76\x03\uEE79\x03\uEE7B\x03\uEE7E" + "\x03\uEE80\x03\uEE80\x03\uEE82\x03\uEE8B\x03\uEE8D\x03\uEE9D\x03\uEEA3" + "\x03\uEEA5\x03\uEEA7\x03\uEEAB\x03\uEEAD\x03\uEEBD\x03\x02\x04\uA6D8\x04" + "\uA702\x04\uB736\x04\uB742\x04\uB81F\x04\uB822\x04\uCEA3\x04\uF802\x04" + "\uFA1F\x04\x03\x10\x03\x10\"\x10\x81\x10\u0102\x10\u01F1\x10\u0240\x02" + "C\x02\\\x02c\x02|\x02\xAC\x02\xAC\x02\xB7\x02\xB7\x02\xBC\x02\xBC\x02" + "\xC2\x02\xD8\x02\xDA\x02\xF8\x02\xFA\x02\u02C3\x02\u02C8\x02\u02D3\x02" + "\u02E2\x02\u02E6\x02\u02EE\x02\u02EE\x02\u02F0\x02\u02F0\x02\u0372\x02" + "\u0376\x02\u0378\x02\u0379\x02\u037C\x02\u037F\x02\u0381\x02\u0381\x02" + "\u0388\x02\u0388\x02\u038A\x02\u038C\x02\u038E\x02\u038E\x02\u0390\x02" + "\u03A3\x02\u03A5\x02\u03F7\x02\u03F9\x02\u0483\x02\u048C\x02\u0531\x02" + "\u0533\x02\u0558\x02\u055B\x02\u055B\x02\u0563\x02\u0589\x02\u05D2\x02" + "\u05EC\x02\u05F2\x02\u05F4\x02\u0622\x02\u064C\x02\u0670\x02\u0671\x02" + "\u0673\x02\u06D5\x02\u06D7\x02\u06D7\x02\u06E7\x02\u06E8\x02\u06F0\x02" + "\u06F1\x02\u06FC\x02\u06FE\x02\u0701\x02\u0701\x02\u0712\x02\u0712\x02" + "\u0714\x02\u0731\x02\u074F\x02\u07A7\x02\u07B3\x02\u07B3\x02\u07CC\x02" + "\u07EC\x02\u07F6\x02\u07F7\x02\u07FC\x02\u07FC\x02\u0802\x02\u0817\x02" + "\u081C\x02\u081C\x02\u0826\x02\u0826\x02\u082A\x02\u082A\x02\u0842\x02" + "\u085A\x02\u08A2\x02\u08B6\x02\u08B8\x02\u08BF\x02\u0906\x02\u093B\x02" + "\u093F\x02\u093F\x02\u0952\x02\u0952\x02\u095A\x02\u0963\x02\u0973\x02" + "\u0982\x02\u0987\x02\u098E\x02\u0991\x02\u0992\x02\u0995\x02\u09AA\x02" + "\u09AC\x02\u09B2\x02\u09B4\x02\u09B4\x02\u09B8\x02\u09BB\x02\u09BF\x02" + "\u09BF\x02\u09D0\x02\u09D0\x02\u09DE\x02\u09DF\x02\u09E1\x02\u09E3\x02" + "\u09F2\x02\u09F3\x02\u0A07\x02\u0A0C\x02\u0A11\x02\u0A12\x02\u0A15\x02" + "\u0A2A\x02\u0A2C\x02\u0A32\x02\u0A34\x02\u0A35\x02\u0A37\x02\u0A38\x02" + "\u0A3A\x02\u0A3B\x02\u0A5B\x02\u0A5E\x02\u0A60\x02\u0A60\x02\u0A74\x02" + "\u0A76\x02\u0A87\x02\u0A8F\x02\u0A91\x02\u0A93\x02\u0A95\x02\u0AAA\x02" + "\u0AAC\x02\u0AB2\x02\u0AB4\x02\u0AB5\x02\u0AB7\x02\u0ABB\x02\u0ABF\x02" + "\u0ABF\x02\u0AD2\x02\u0AD2\x02\u0AE2\x02\u0AE3\x02\u0AFB\x02\u0AFB\x02" + "\u0B07\x02\u0B0E\x02\u0B11\x02\u0B12\x02\u0B15\x02\u0B2A\x02\u0B2C\x02" + "\u0B32\x02\u0B34\x02\u0B35\x02\u0B37\x02\u0B3B\x02\u0B3F\x02\u0B3F\x02" + "\u0B5E\x02\u0B5F\x02\u0B61\x02\u0B63\x02\u0B73\x02\u0B73\x02\u0B85\x02" + "\u0B85\x02\u0B87\x02\u0B8C\x02\u0B90\x02\u0B92\x02\u0B94\x02\u0B97\x02" + "\u0B9B\x02\u0B9C\x02\u0B9E\x02\u0B9E\x02\u0BA0\x02\u0BA1\x02\u0BA5\x02" + "\u0BA6\x02\u0BAA\x02\u0BAC\x02\u0BB0\x02\u0BBB\x02\u0BD2\x02\u0BD2\x02" + "\u0C07\x02\u0C0E\x02\u0C10\x02\u0C12\x02\u0C14\x02\u0C2A\x02\u0C2C\x02" + "\u0C3B\x02\u0C3F\x02\u0C3F\x02\u0C5A\x02\u0C5C\x02\u0C62\x02\u0C63\x02" + "\u0C82\x02\u0C82\x02\u0C87\x02\u0C8E\x02\u0C90\x02\u0C92\x02\u0C94\x02" + "\u0CAA\x02\u0CAC\x02\u0CB5\x02\u0CB7\x02\u0CBB\x02\u0CBF\x02\u0CBF\x02" + "\u0CE0\x02\u0CE0\x02\u0CE2\x02\u0CE3\x02\u0CF3\x02\u0CF4\x02\u0D07\x02" + "\u0D0E\x02\u0D10\x02\u0D12\x02\u0D14\x02\u0D3C\x02\u0D3F\x02\u0D3F\x02" + "\u0D50\x02\u0D50\x02\u0D56\x02\u0D58\x02\u0D61\x02\u0D63\x02\u0D7C\x02" + "\u0D81\x02\u0D87\x02\u0D98\x02\u0D9C\x02\u0DB3\x02\u0DB5\x02\u0DBD\x02" + "\u0DBF\x02\u0DBF\x02\u0DC2\x02\u0DC8\x02\u0E03\x02\u0E32\x02\u0E34\x02" + "\u0E35\x02\u0E42\x02\u0E48\x02\u0E83\x02\u0E84\x02\u0E86\x02\u0E86\x02" + "\u0E89\x02\u0E8A\x02\u0E8C\x02\u0E8C\x02\u0E8F\x02\u0E8F\x02\u0E96\x02" + "\u0E99\x02\u0E9B\x02\u0EA1\x02\u0EA3\x02\u0EA5\x02\u0EA7\x02\u0EA7\x02" + "\u0EA9\x02\u0EA9\x02\u0EAC\x02\u0EAD\x02\u0EAF\x02\u0EB2\x02\u0EB4\x02" + "\u0EB5\x02\u0EBF\x02\u0EBF\x02\u0EC2\x02\u0EC6\x02\u0EC8\x02\u0EC8\x02" + "\u0EDE\x02\u0EE1\x02\u0F02\x02\u0F02\x02\u0F42\x02\u0F49\x02\u0F4B\x02" + "\u0F6E\x02\u0F8A\x02\u0F8E\x02\u1002\x02\u102C\x02\u1041\x02\u1041\x02" + "\u1052\x02\u1057\x02\u105C\x02\u105F\x02\u1063\x02\u1063\x02\u1067\x02" + "\u1068\x02\u1070\x02\u1072\x02\u1077\x02\u1083\x02\u1090\x02\u1090\x02" + "\u10A2\x02\u10C7\x02\u10C9\x02\u10C9\x02\u10CF\x02\u10CF\x02\u10D2\x02" + "\u10FC\x02\u10FE\x02\u124A\x02\u124C\x02\u124F\x02\u1252\x02\u1258\x02" + "\u125A\x02\u125A\x02\u125C\x02\u125F\x02\u1262\x02\u128A\x02\u128C\x02" + "\u128F\x02\u1292\x02\u12B2\x02\u12B4\x02\u12B7\x02\u12BA\x02\u12C0\x02" + "\u12C2\x02\u12C2\x02\u12C4\x02\u12C7\x02\u12CA\x02\u12D8\x02\u12DA\x02" + "\u1312\x02\u1314\x02\u1317\x02\u131A\x02\u135C\x02\u1382\x02\u1391\x02" + "\u13A2\x02\u13F7\x02\u13FA\x02\u13FF\x02\u1403\x02\u166E\x02\u1671\x02" + "\u1681\x02\u1683\x02\u169C\x02\u16A2\x02\u16EC\x02\u16F0\x02\u16FA\x02" + "\u1702\x02\u170E\x02\u1710\x02\u1713\x02\u1722\x02\u1733\x02\u1742\x02" + "\u1753\x02\u1762\x02\u176E\x02\u1770\x02\u1772\x02\u1782\x02\u17B5\x02" + "\u17D9\x02\u17D9\x02\u17DE\x02\u17DE\x02\u1822\x02\u1879\x02\u1882\x02" + "\u1886\x02\u1889\x02\u18AA\x02\u18AC\x02\u18AC\x02\u18B2\x02\u18F7\x02" + "\u1902\x02\u1920\x02\u1952\x02\u196F\x02\u1972\x02\u1976\x02\u1982\x02" + "\u19AD\x02\u19B2\x02\u19CB\x02\u1A02\x02\u1A18\x02\u1A22\x02\u1A56\x02" + "\u1AA9\x02\u1AA9\x02\u1B07\x02\u1B35\x02\u1B47\x02\u1B4D\x02\u1B85\x02" + "\u1BA2\x02\u1BB0\x02\u1BB1\x02\u1BBC\x02\u1BE7\x02\u1C02\x02\u1C25\x02" + "\u1C4F\x02\u1C51\x02\u1C5C\x02\u1C7F\x02\u1C82\x02\u1C8A\x02\u1CEB\x02" + "\u1CEE\x02\u1CF0\x02\u1CF3\x02\u1CF7\x02\u1CF8\x02\u1D02\x02\u1DC1\x02" + "\u1E02\x02\u1F17\x02\u1F1A\x02\u1F1F\x02\u1F22\x02\u1F47\x02\u1F4A\x02" + "\u1F4F\x02\u1F52\x02\u1F59\x02\u1F5B\x02\u1F5B\x02\u1F5D\x02\u1F5D\x02" + "\u1F5F\x02\u1F5F\x02\u1F61\x02\u1F7F\x02\u1F82\x02\u1FB6\x02\u1FB8\x02" + "\u1FBE\x02\u1FC0\x02\u1FC0\x02\u1FC4\x02\u1FC6\x02\u1FC8\x02\u1FCE\x02" + "\u1FD2\x02\u1FD5\x02\u1FD8\x02\u1FDD\x02\u1FE2\x02\u1FEE\x02\u1FF4\x02" + "\u1FF6\x02\u1FF8\x02\u1FFE\x02\u2073\x02\u2073\x02\u2081\x02\u2081\x02" + "\u2092\x02\u209E\x02\u2104\x02\u2104\x02\u2109\x02\u2109\x02\u210C\x02" + "\u2115\x02\u2117\x02\u2117\x02\u211B\x02\u211F\x02\u2126\x02\u2126\x02" + "\u2128\x02\u2128\x02\u212A\x02\u212A\x02\u212C\x02\u212F\x02\u2131\x02" + "\u213B\x02\u213E\x02\u2141\x02\u2147\x02\u214B\x02\u2150\x02\u2150\x02" + "\u2162\x02\u218A\x02\u2C02\x02\u2C30\x02\u2C32\x02\u2C60\x02\u2C62\x02" + "\u2CE6\x02\u2CED\x02\u2CF0\x02\u2CF4\x02\u2CF5\x02\u2D02\x02\u2D27\x02" + "\u2D29\x02\u2D29\x02\u2D2F\x02\u2D2F\x02\u2D32\x02\u2D69\x02\u2D71\x02" + "\u2D71\x02\u2D82\x02\u2D98\x02\u2DA2\x02\u2DA8\x02\u2DAA\x02\u2DB0\x02" + "\u2DB2\x02\u2DB8\x02\u2DBA\x02\u2DC0\x02\u2DC2\x02\u2DC8\x02\u2DCA\x02" + "\u2DD0\x02\u2DD2\x02\u2DD8\x02\u2DDA\x02\u2DE0\x02\u2E31\x02\u2E31\x02" + "\u3007\x02\u3009\x02\u3023\x02\u302B\x02\u3033\x02\u3037\x02\u303A\x02" + "\u303E\x02\u3043\x02\u3098\x02\u309F\x02\u30A1\x02\u30A3\x02\u30FC\x02" + "\u30FE\x02\u3101\x02\u3107\x02\u312F\x02\u3133\x02\u3190\x02\u31A2\x02" + "\u31BC\x02\u31F2\x02\u3201\x02\u3402\x02\u4DB7\x02\u4E02\x02\u9FD7\x02" + "\uA002\x02\uA48E\x02\uA4D2\x02\uA4FF\x02\uA502\x02\uA60E\x02\uA612\x02" + "\uA621\x02\uA62C\x02\uA62D\x02\uA642\x02\uA670\x02\uA681\x02\uA69F\x02" + "\uA6A2\x02\uA6F1\x02\uA719\x02\uA721\x02\uA724\x02\uA78A\x02\uA78D\x02" + "\uA7B0\x02\uA7B2\x02\uA7B9\x02\uA7F9\x02\uA803\x02\uA805\x02\uA807\x02" + "\uA809\x02\uA80C\x02\uA80E\x02\uA824\x02\uA842\x02\uA875\x02\uA884\x02" + "\uA8B5\x02\uA8F4\x02\uA8F9\x02\uA8FD\x02\uA8FD\x02\uA8FF\x02\uA8FF\x02" + "\uA90C\x02\uA927\x02\uA932\x02\uA948\x02\uA962\x02\uA97E\x02\uA986\x02" + "\uA9B4\x02\uA9D1\x02\uA9D1\x02\uA9E2\x02\uA9E6\x02\uA9E8\x02\uA9F1\x02" + "\uA9FC\x02\uAA00\x02\uAA02\x02\uAA2A\x02\uAA42\x02\uAA44\x02\uAA46\x02" + "\uAA4D\x02\uAA62\x02\uAA78\x02\uAA7C\x02\uAA7C\x02\uAA80\x02\uAAB1\x02" + "\uAAB3\x02\uAAB3\x02\uAAB7\x02\uAAB8\x02\uAABB\x02\uAABF\x02\uAAC2\x02" + "\uAAC2\x02\uAAC4\x02\uAAC4\x02\uAADD\x02\uAADF\x02\uAAE2\x02\uAAEC\x02" + "\uAAF4\x02\uAAF6\x02\uAB03\x02\uAB08\x02\uAB0B\x02\uAB10\x02\uAB13\x02" + "\uAB18\x02\uAB22\x02\uAB28\x02\uAB2A\x02\uAB30\x02\uAB32\x02\uAB5C\x02" + "\uAB5E\x02\uAB67\x02\uAB72\x02\uABE4\x02\uAC02\x02\uD7A5\x02\uD7B2\x02" + "\uD7C8\x02\uD7CD\x02\uD7FD\x02\uF902\x02\uFA6F\x02\uFA72\x02\uFADB\x02" + "\uFB02\x02\uFB08\x02\uFB15\x02\uFB19\x02\uFB1F\x02\uFB1F\x02\uFB21\x02" + "\uFB2A\x02\uFB2C\x02\uFB38\x02\uFB3A\x02\uFB3E\x02\uFB40\x02\uFB40\x02" + "\uFB42\x02\uFB43\x02\uFB45\x02\uFB46\x02\uFB48\x02\uFBB3\x02\uFBD5\x02" + "\uFD3F\x02\uFD52\x02\uFD91\x02\uFD94\x02\uFDC9\x02\uFDF2\x02\uFDFD\x02" + "\uFE72\x02\uFE76\x02\uFE78\x02\uFEFE\x02\uFF23\x02\uFF3C\x02\uFF43\x02" + "\uFF5C\x02\uFF68\x02\uFFC0\x02\uFFC4\x02\uFFC9\x02\uFFCC\x02\uFFD1\x02" + "\uFFD4\x02\uFFD9\x02\uFFDC\x02\uFFDE\x02\x02\x03\r\x03\x0F\x03(\x03*\x03" + "<\x03>\x03?\x03A\x03O\x03R\x03_\x03\x82\x03\xFC\x03\u0142\x03\u0176\x03" + "\u0282\x03\u029E\x03\u02A2\x03\u02D2\x03\u0302\x03\u0321\x03\u0332\x03" + "\u034C\x03\u0352\x03\u0377\x03\u0382\x03\u039F\x03\u03A2\x03\u03C5\x03" + "\u03CA\x03\u03D1\x03\u03D3\x03\u03D7\x03\u0402\x03\u049F\x03\u04B2\x03" + "\u04D5\x03\u04DA\x03\u04FD\x03\u0502\x03\u0529\x03\u0532\x03\u0565\x03" + "\u0602\x03\u0738\x03\u0742\x03\u0757\x03\u0762\x03\u0769\x03\u0802\x03" + "\u0807\x03\u080A\x03\u080A\x03\u080C\x03\u0837\x03\u0839\x03\u083A\x03" + "\u083E\x03\u083E\x03\u0841\x03\u0857\x03\u0862\x03\u0878\x03\u0882\x03" + "\u08A0\x03\u08E2\x03\u08F4\x03\u08F6\x03\u08F7\x03\u0902\x03\u0917\x03" + "\u0922\x03\u093B\x03\u0982\x03\u09B9\x03\u09C0\x03\u09C1\x03\u0A02\x03" + "\u0A02\x03\u0A12\x03\u0A15\x03\u0A17\x03\u0A19\x03\u0A1B\x03\u0A35\x03" + "\u0A62\x03\u0A7E\x03\u0A82\x03\u0A9E\x03\u0AC2\x03\u0AC9\x03\u0ACB\x03" + "\u0AE6\x03\u0B02\x03\u0B37\x03\u0B42\x03\u0B57\x03\u0B62\x03\u0B74\x03" + "\u0B82\x03\u0B93\x03\u0C02\x03\u0C4A\x03\u0C82\x03\u0CB4\x03\u0CC2\x03" + "\u0CF4\x03\u1005\x03\u1039\x03\u1085\x03\u10B1\x03\u10D2\x03\u10EA\x03" + "\u1105\x03\u1128\x03\u1152\x03\u1174\x03\u1178\x03\u1178\x03\u1185\x03" + "\u11B4\x03\u11C3\x03\u11C6\x03\u11DC\x03\u11DC\x03\u11DE\x03\u11DE\x03" + "\u1202\x03\u1213\x03\u1215\x03\u122D\x03\u1282\x03\u1288\x03\u128A\x03" + "\u128A\x03\u128C\x03\u128F\x03\u1291\x03\u129F\x03\u12A1\x03\u12AA\x03" + "\u12B2\x03\u12E0\x03\u1307\x03\u130E\x03\u1311\x03\u1312\x03\u1315\x03" + "\u132A\x03\u132C\x03\u1332\x03\u1334\x03\u1335\x03\u1337\x03\u133B\x03" + "\u133F\x03\u133F\x03\u1352\x03\u1352\x03\u135F\x03\u1363\x03\u1402\x03" + "\u1436\x03\u1449\x03\u144C\x03\u1482\x03\u14B1\x03\u14C6\x03\u14C7\x03" + "\u14C9\x03\u14C9\x03\u1582\x03\u15B0\x03\u15DA\x03\u15DD\x03\u1602\x03" + "\u1631\x03\u1646\x03\u1646\x03\u1682\x03\u16AC\x03\u1702\x03\u171B\x03" + "\u18A2\x03\u18E1\x03\u1901\x03\u1901\x03\u1AC2\x03\u1AFA\x03\u1C02\x03" + "\u1C0A\x03\u1C0C\x03\u1C30\x03\u1C42\x03\u1C42\x03\u1C74\x03\u1C91\x03" + "\u2002\x03\u239B\x03\u2402\x03\u2470\x03\u2482\x03\u2545\x03\u3002\x03" + "\u3430\x03\u4402\x03\u4648\x03\u6802\x03\u6A3A\x03\u6A42\x03\u6A60\x03" + "\u6AD2\x03\u6AEF\x03\u6B02\x03\u6B31\x03\u6B42\x03\u6B45\x03\u6B65\x03" + "\u6B79\x03\u6B7F\x03\u6B91\x03\u6F02\x03\u6F46\x03\u6F52\x03\u6F52\x03" + "\u6F95\x03\u6FA1\x03\u6FE2\x03\u6FE2\x03\u7002\x03\u87EE\x03\u8802\x03" + "\u8AF4\x03\uB002\x03\uB003\x03\uBC02\x03\uBC6C\x03\uBC72\x03\uBC7E\x03" + "\uBC82\x03\uBC8A\x03\uBC92\x03\uBC9B\x03\uD402\x03\uD456\x03\uD458\x03" + "\uD49E\x03\uD4A0\x03\uD4A1\x03\uD4A4\x03\uD4A4\x03\uD4A7\x03\uD4A8\x03" + "\uD4AB\x03\uD4AE\x03\uD4B0\x03\uD4BB\x03\uD4BD\x03\uD4BD\x03\uD4BF\x03" + "\uD4C5\x03\uD4C7\x03\uD507\x03\uD509\x03\uD50C\x03\uD50F\x03\uD516\x03" + "\uD518\x03\uD51E\x03\uD520\x03\uD53B\x03\uD53D\x03\uD540\x03\uD542\x03" + "\uD546\x03\uD548\x03\uD548";
XPathLexer._serializedATNSegment1 = "\x03\uD54C\x03\uD552\x03\uD554\x03\uD6A7\x03\uD6AA\x03\uD6C2\x03\uD6C4" + "\x03\uD6DC\x03\uD6DE\x03\uD6FC\x03\uD6FE\x03\uD716\x03\uD718\x03\uD736" + "\x03\uD738\x03\uD750\x03\uD752\x03\uD770\x03\uD772\x03\uD78A\x03\uD78C" + "\x03\uD7AA\x03\uD7AC\x03\uD7C4\x03\uD7C6\x03\uD7CD\x03\uE802\x03\uE8C6" + "\x03\uE902\x03\uE945\x03\uEE02\x03\uEE05\x03\uEE07\x03\uEE21\x03\uEE23" + "\x03\uEE24\x03\uEE26\x03\uEE26\x03\uEE29\x03\uEE29\x03\uEE2B\x03\uEE34" + "\x03\uEE36\x03\uEE39\x03\uEE3B\x03\uEE3B\x03\uEE3D\x03\uEE3D\x03\uEE44" + "\x03\uEE44\x03\uEE49\x03\uEE49\x03\uEE4B\x03\uEE4B\x03\uEE4D\x03\uEE4D" + "\x03\uEE4F\x03\uEE51\x03\uEE53\x03\uEE54\x03\uEE56\x03\uEE56\x03\uEE59" + "\x03\uEE59\x03\uEE5B\x03\uEE5B\x03\uEE5D\x03\uEE5D\x03\uEE5F\x03\uEE5F" + "\x03\uEE61\x03\uEE61\x03\uEE63\x03\uEE64\x03\uEE66\x03\uEE66\x03\uEE69" + "\x03\uEE6C\x03\uEE6E\x03\uEE74\x03\uEE76\x03\uEE79\x03\uEE7B\x03\uEE7E" + "\x03\uEE80\x03\uEE80\x03\uEE82\x03\uEE8B\x03\uEE8D\x03\uEE9D\x03\uEEA3" + "\x03\uEEA5\x03\uEEA7\x03\uEEAB\x03\uEEAD\x03\uEEBD\x03\x02\x04\uA6D8\x04" + "\uA702\x04\uB736\x04\uB742\x04\uB81F\x04\uB822\x04\uCEA3\x04\uF802\x04" + "\uFA1F\x041\x02\x03\x03\x02\x02\x02\x02\x05\x03\x02\x02\x02\x02\x07\x03" + "\x02\x02\x02\x02\t\x03\x02\x02\x02\x02\v\x03\x02\x02\x02\x02\x11\x03\x02" + "\x02\x02\x03\x13\x03\x02\x02\x02\x05\x16\x03\x02\x02\x02\x07\x18\x03\x02" + "\x02\x02\t\x1A\x03\x02\x02\x02\v\x1C\x03\x02\x02\x02\r%\x03\x02\x02\x02" + "\x0F\'\x03\x02\x02\x02\x11)\x03\x02\x02\x02\x13\x14\x071\x02\x02\x14\x15" + "\x071\x02\x02\x15\x04\x03\x02\x02\x02\x16\x17\x071\x02\x02\x17\x06\x03" + "\x02\x02\x02\x18\x19\x07,\x02\x02\x19\b\x03\x02\x02\x02\x1A\x1B\x07#\x02" + "\x02\x1B\n\x03\x02\x02\x02\x1C \x05\x0F\b\x02\x1D\x1F\x05\r\x07\x02\x1E" + "\x1D\x03\x02\x02\x02\x1F\"\x03\x02\x02\x02 \x1E\x03\x02\x02\x02 !\x03" + "\x02\x02\x02!#\x03\x02\x02\x02\" \x03\x02\x02\x02#$\b\x06\x02\x02$\f\x03" + "\x02\x02\x02%&\t\x02\x02\x02&\x0E\x03\x02\x02\x02\'(\t\x03\x02\x02(\x10" + "\x03\x02\x02\x02)-\x07)\x02\x02*,\v\x02\x02\x02+*\x03\x02\x02\x02,/\x03" + "\x02\x02\x02-.\x03\x02\x02\x02-+\x03\x02\x02\x02.0\x03\x02\x02\x02/-\x03" + "\x02\x02\x0201\x07)\x02\x021\x12\x03\x02\x02\x02\x05\x02 -\x03\x03\x06" + "\x02";
XPathLexer._serializedATN = Utils.join([XPathLexer._serializedATNSegment0, XPathLexer._serializedATNSegment1], "");
exports.XPathLexer = XPathLexer;

},{"../../Lexer":280,"../../VocabularyImpl":298,"../../atn/ATNDeserializer":303,"../../atn/LexerATNSimulator":324,"../../misc/Utils":385,"@babel/runtime/helpers/assertThisInitialized":229,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"core-js/modules/es.array.join.js":578,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],405:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var Decorators_1 = require("../../Decorators");
var XPathLexerErrorListener = /*#__PURE__*/function () {
  function XPathLexerErrorListener() {
    (0, _classCallCheck2.default)(this, XPathLexerErrorListener);
  }
  (0, _createClass2.default)(XPathLexerErrorListener, [{
    key: "syntaxError",
    value: function syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
      // intentionally empty
    }
  }]);
  return XPathLexerErrorListener;
}();
__decorate([Decorators_1.Override], XPathLexerErrorListener.prototype, "syntaxError", null);
exports.XPathLexerErrorListener = XPathLexerErrorListener;

},{"../../Decorators":272,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612}],406:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var Decorators_1 = require("../../Decorators");
var Trees_1 = require("../Trees");
var XPathElement_1 = require("./XPathElement");
/**
 * Either `ID` at start of path or `...//ID` in middle of path.
 */
var XPathRuleAnywhereElement = /*#__PURE__*/function (_XPathElement_1$XPath) {
  (0, _inherits2.default)(XPathRuleAnywhereElement, _XPathElement_1$XPath);
  var _super = _createSuper(XPathRuleAnywhereElement);
  function XPathRuleAnywhereElement(ruleName, ruleIndex) {
    var _this;
    (0, _classCallCheck2.default)(this, XPathRuleAnywhereElement);
    _this = _super.call(this, ruleName);
    _this.ruleIndex = ruleIndex;
    return _this;
  }
  (0, _createClass2.default)(XPathRuleAnywhereElement, [{
    key: "evaluate",
    value: function evaluate(t) {
      return Trees_1.Trees.findAllRuleNodes(t, this.ruleIndex);
    }
  }]);
  return XPathRuleAnywhereElement;
}(XPathElement_1.XPathElement);
__decorate([Decorators_1.Override], XPathRuleAnywhereElement.prototype, "evaluate", null);
exports.XPathRuleAnywhereElement = XPathRuleAnywhereElement;

},{"../../Decorators":272,"../Trees":392,"./XPathElement":403,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],407:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// CONVERSTION complete, Burt Harris 10/14/2016
var ParserRuleContext_1 = require("../../ParserRuleContext");
var Decorators_1 = require("../../Decorators");
var Trees_1 = require("../Trees");
var XPathElement_1 = require("./XPathElement");
var XPathRuleElement = /*#__PURE__*/function (_XPathElement_1$XPath) {
  (0, _inherits2.default)(XPathRuleElement, _XPathElement_1$XPath);
  var _super = _createSuper(XPathRuleElement);
  function XPathRuleElement(ruleName, ruleIndex) {
    var _this;
    (0, _classCallCheck2.default)(this, XPathRuleElement);
    _this = _super.call(this, ruleName);
    _this.ruleIndex = ruleIndex;
    return _this;
  }
  (0, _createClass2.default)(XPathRuleElement, [{
    key: "evaluate",
    value: function evaluate(t) {
      // return all children of t that match nodeName
      var nodes = [];
      var _iterator = _createForOfIteratorHelper(Trees_1.Trees.getChildren(t)),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var c = _step.value;
          if (c instanceof ParserRuleContext_1.ParserRuleContext) {
            if (c.ruleIndex === this.ruleIndex && !this.invert || c.ruleIndex !== this.ruleIndex && this.invert) {
              nodes.push(c);
            }
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return nodes;
    }
  }]);
  return XPathRuleElement;
}(XPathElement_1.XPathElement);
__decorate([Decorators_1.Override], XPathRuleElement.prototype, "evaluate", null);
exports.XPathRuleElement = XPathRuleElement;

},{"../../Decorators":272,"../../ParserRuleContext":287,"../Trees":392,"./XPathElement":403,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],408:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// CONVERSTION complete, Burt Harris 10/14/2016
var Decorators_1 = require("../../Decorators");
var Trees_1 = require("../Trees");
var XPathElement_1 = require("./XPathElement");
var XPathTokenAnywhereElement = /*#__PURE__*/function (_XPathElement_1$XPath) {
  (0, _inherits2.default)(XPathTokenAnywhereElement, _XPathElement_1$XPath);
  var _super = _createSuper(XPathTokenAnywhereElement);
  function XPathTokenAnywhereElement(tokenName, tokenType) {
    var _this;
    (0, _classCallCheck2.default)(this, XPathTokenAnywhereElement);
    _this = _super.call(this, tokenName);
    _this.tokenType = tokenType;
    return _this;
  }
  (0, _createClass2.default)(XPathTokenAnywhereElement, [{
    key: "evaluate",
    value: function evaluate(t) {
      return Trees_1.Trees.findAllTokenNodes(t, this.tokenType);
    }
  }]);
  return XPathTokenAnywhereElement;
}(XPathElement_1.XPathElement);
__decorate([Decorators_1.Override], XPathTokenAnywhereElement.prototype, "evaluate", null);
exports.XPathTokenAnywhereElement = XPathTokenAnywhereElement;

},{"../../Decorators":272,"../Trees":392,"./XPathElement":403,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],409:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// CONVERSTION complete, Burt Harris 10/14/2016
var Decorators_1 = require("../../Decorators");
var TerminalNode_1 = require("../TerminalNode");
var Trees_1 = require("../Trees");
var XPathElement_1 = require("./XPathElement");
var XPathTokenElement = /*#__PURE__*/function (_XPathElement_1$XPath) {
  (0, _inherits2.default)(XPathTokenElement, _XPathElement_1$XPath);
  var _super = _createSuper(XPathTokenElement);
  function XPathTokenElement(tokenName, tokenType) {
    var _this;
    (0, _classCallCheck2.default)(this, XPathTokenElement);
    _this = _super.call(this, tokenName);
    _this.tokenType = tokenType;
    return _this;
  }
  (0, _createClass2.default)(XPathTokenElement, [{
    key: "evaluate",
    value: function evaluate(t) {
      // return all children of t that match nodeName
      var nodes = [];
      var _iterator = _createForOfIteratorHelper(Trees_1.Trees.getChildren(t)),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var c = _step.value;
          if (c instanceof TerminalNode_1.TerminalNode) {
            if (c.symbol.type === this.tokenType && !this.invert || c.symbol.type !== this.tokenType && this.invert) {
              nodes.push(c);
            }
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return nodes;
    }
  }]);
  return XPathTokenElement;
}(XPathElement_1.XPathElement);
__decorate([Decorators_1.Override], XPathTokenElement.prototype, "evaluate", null);
exports.XPathTokenElement = XPathTokenElement;

},{"../../Decorators":272,"../TerminalNode":391,"../Trees":392,"./XPathElement":403,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],410:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// CONVERSTION complete, Burt Harris 10/14/2016
var Decorators_1 = require("../../Decorators");
var Trees_1 = require("../Trees");
var XPath_1 = require("./XPath");
var XPathElement_1 = require("./XPathElement");
var XPathWildcardAnywhereElement = /*#__PURE__*/function (_XPathElement_1$XPath) {
  (0, _inherits2.default)(XPathWildcardAnywhereElement, _XPathElement_1$XPath);
  var _super = _createSuper(XPathWildcardAnywhereElement);
  function XPathWildcardAnywhereElement() {
    (0, _classCallCheck2.default)(this, XPathWildcardAnywhereElement);
    return _super.call(this, XPath_1.XPath.WILDCARD);
  }
  (0, _createClass2.default)(XPathWildcardAnywhereElement, [{
    key: "evaluate",
    value: function evaluate(t) {
      if (this.invert) {
        // !* is weird but valid (empty)
        return [];
      }
      return Trees_1.Trees.getDescendants(t);
    }
  }]);
  return XPathWildcardAnywhereElement;
}(XPathElement_1.XPathElement);
__decorate([Decorators_1.Override], XPathWildcardAnywhereElement.prototype, "evaluate", null);
exports.XPathWildcardAnywhereElement = XPathWildcardAnywhereElement;

},{"../../Decorators":272,"../Trees":392,"./XPath":402,"./XPathElement":403,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615}],411:[function(require,module,exports){
"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
require("core-js/modules/es.reflect.construct.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.to-string.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// CONVERSTION complete, Burt Harris 10/14/2016
var Decorators_1 = require("../../Decorators");
var Trees_1 = require("../Trees");
var XPath_1 = require("./XPath");
var XPathElement_1 = require("./XPathElement");
var XPathWildcardElement = /*#__PURE__*/function (_XPathElement_1$XPath) {
  (0, _inherits2.default)(XPathWildcardElement, _XPathElement_1$XPath);
  var _super = _createSuper(XPathWildcardElement);
  function XPathWildcardElement() {
    (0, _classCallCheck2.default)(this, XPathWildcardElement);
    return _super.call(this, XPath_1.XPath.WILDCARD);
  }
  (0, _createClass2.default)(XPathWildcardElement, [{
    key: "evaluate",
    value: function evaluate(t) {
      var kids = [];
      if (this.invert) {
        // !* is weird but valid (empty)
        return kids;
      }
      var _iterator = _createForOfIteratorHelper(Trees_1.Trees.getChildren(t)),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var c = _step.value;
          kids.push(c);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return kids;
    }
  }]);
  return XPathWildcardElement;
}(XPathElement_1.XPathElement);
__decorate([Decorators_1.Override], XPathWildcardElement.prototype, "evaluate", null);
exports.XPathWildcardElement = XPathWildcardElement;

},{"../../Decorators":272,"../Trees":392,"./XPath":402,"./XPathElement":403,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/getPrototypeOf":235,"@babel/runtime/helpers/inherits":236,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/possibleConstructorReturn":244,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.from.js":575,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.reflect.construct.js":615,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],412:[function(require,module,exports){
"use strict";

require("core-js/modules/es.array.filter.js");
require("core-js/modules/es.object.to-string.js");
/**
 * Array#filter.
 *
 * @param {Array} arr
 * @param {Function} fn
 * @param {Object=} self
 * @return {Array}
 * @throw TypeError
 */

module.exports = function (arr, fn, self) {
  if (arr.filter) return arr.filter(fn, self);
  if (void 0 === arr || null === arr) throw new TypeError();
  if ('function' != typeof fn) throw new TypeError();
  var ret = [];
  for (var i = 0; i < arr.length; i++) {
    if (!hasOwn.call(arr, i)) continue;
    var val = arr[i];
    if (fn.call(self, val, i, arr)) ret.push(val);
  }
  return ret;
};
var hasOwn = Object.prototype.hasOwnProperty;

},{"core-js/modules/es.array.filter.js":572,"core-js/modules/es.object.to-string.js":612}],413:[function(require,module,exports){
(function (global){(function (){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.array-buffer.constructor.js");
require("core-js/modules/es.array-buffer.slice.js");
require("core-js/modules/es.array-buffer.is-view.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.match.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.typed-array.float32-array.js");
require("core-js/modules/es.typed-array.copy-within.js");
require("core-js/modules/es.typed-array.every.js");
require("core-js/modules/es.typed-array.fill.js");
require("core-js/modules/es.typed-array.filter.js");
require("core-js/modules/es.typed-array.find.js");
require("core-js/modules/es.typed-array.find-index.js");
require("core-js/modules/es.typed-array.for-each.js");
require("core-js/modules/es.typed-array.includes.js");
require("core-js/modules/es.typed-array.index-of.js");
require("core-js/modules/es.typed-array.iterator.js");
require("core-js/modules/es.typed-array.join.js");
require("core-js/modules/es.typed-array.last-index-of.js");
require("core-js/modules/es.typed-array.map.js");
require("core-js/modules/es.typed-array.reduce.js");
require("core-js/modules/es.typed-array.reduce-right.js");
require("core-js/modules/es.typed-array.reverse.js");
require("core-js/modules/es.typed-array.set.js");
require("core-js/modules/es.typed-array.slice.js");
require("core-js/modules/es.typed-array.some.js");
require("core-js/modules/es.typed-array.sort.js");
require("core-js/modules/es.typed-array.subarray.js");
require("core-js/modules/es.typed-array.to-locale-string.js");
require("core-js/modules/es.typed-array.to-string.js");
require("core-js/modules/es.typed-array.float64-array.js");
require("core-js/modules/es.typed-array.uint8-array.js");
require("core-js/modules/es.object.get-prototype-of.js");
require("core-js/modules/es.array.sort.js");
require("core-js/modules/es.object.keys.js");
var objectAssign = require('object-assign');

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }
  var x = a.length;
  var y = b.length;
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }
  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:
// NB: The URL to the CommonJS spec is kept just for tradition.
//     node-assert has evolved a lot since then, both in API and behavior.

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util/');
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = function () {
  return function foo() {}.name === 'foo';
}();
function pToString(obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }
      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);
function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' + name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' + self.operator + ' ' + truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};
assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};
function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

    // 7.2. If the expected value is a Date object, the actual value is
    // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

    // 7.3 If the expected value is a RegExp object, the actual value is
    // equivalent if it is also a RegExp object with the same source and
    // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;

    // 7.4. Other pairs that do not both pass typeof value == 'object',
    // equivalence is determined by ==.
  } else if ((actual === null || (0, _typeof2.default)(actual) !== 'object') && (expected === null || (0, _typeof2.default)(expected) !== 'object')) {
    return strict ? actual === expected : actual == expected;

    // If both values are instances of typed arrays, wrap their underlying
    // ArrayBuffers in a Buffer each to increase performance
    // This optimization requires the arrays to have the same type as checked by
    // Object.prototype.toString (aka pToString). Never perform binary
    // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
    // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer)) === 0;

    // 7.5 For all other Object pairs, including Array objects, equivalence is
    // determined by having the same number of owned properties (as verified
    // with Object.prototype.hasOwnProperty.call), the same set of keys
    // (although not necessarily the same order), equivalent values for every
    // corresponding key, and an identical 'prototype' property. Note: this
    // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {
      actual: [],
      expected: []
    };
    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }
    memos.actual.push(actual);
    memos.expected.push(expected);
    return objEquiv(actual, expected, strict, memos);
  }
}
function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}
function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined) return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b)) return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length) return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i]) return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects)) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};
assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};
function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }
  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }
  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }
  if (Error.isPrototypeOf(expected)) {
    return false;
  }
  return expected.call({}, actual) === true;
}
function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}
function _throws(shouldThrow, block, expected, message) {
  var actual;
  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }
  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }
  actual = _tryBlock(block);
  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.');
  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }
  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;
  if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }
  if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function (block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function (block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};
assert.ifError = function (err) {
  if (err) throw err;
};

// Expose a strict only variant of assert
function strict(value, message) {
  if (!value) fail(value, true, message, '==', strict);
}
assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array-buffer.constructor.js":566,"core-js/modules/es.array-buffer.is-view.js":567,"core-js/modules/es.array-buffer.slice.js":568,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.array.sort.js":581,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.get-prototype-of.js":606,"core-js/modules/es.object.keys.js":609,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.match.js":627,"core-js/modules/es.typed-array.copy-within.js":641,"core-js/modules/es.typed-array.every.js":642,"core-js/modules/es.typed-array.fill.js":643,"core-js/modules/es.typed-array.filter.js":644,"core-js/modules/es.typed-array.find-index.js":645,"core-js/modules/es.typed-array.find.js":646,"core-js/modules/es.typed-array.float32-array.js":647,"core-js/modules/es.typed-array.float64-array.js":648,"core-js/modules/es.typed-array.for-each.js":649,"core-js/modules/es.typed-array.includes.js":650,"core-js/modules/es.typed-array.index-of.js":651,"core-js/modules/es.typed-array.iterator.js":655,"core-js/modules/es.typed-array.join.js":656,"core-js/modules/es.typed-array.last-index-of.js":657,"core-js/modules/es.typed-array.map.js":658,"core-js/modules/es.typed-array.reduce-right.js":659,"core-js/modules/es.typed-array.reduce.js":660,"core-js/modules/es.typed-array.reverse.js":661,"core-js/modules/es.typed-array.set.js":662,"core-js/modules/es.typed-array.slice.js":663,"core-js/modules/es.typed-array.some.js":664,"core-js/modules/es.typed-array.sort.js":665,"core-js/modules/es.typed-array.subarray.js":666,"core-js/modules/es.typed-array.to-locale-string.js":667,"core-js/modules/es.typed-array.to-string.js":668,"core-js/modules/es.typed-array.uint8-array.js":671,"object-assign":730,"util/":416}],414:[function(require,module,exports){
"use strict";

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function TempCtor() {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}

},{}],415:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.fill.js");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
module.exports = function isBuffer(arg) {
  return arg && (0, _typeof2.default)(arg) === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
};

},{"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.fill.js":571}],416:[function(require,module,exports){
(function (process,global){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.array.join.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.number.constructor.js");
require("core-js/modules/es.regexp.constructor.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/web.dom-collections.for-each.js");
require("core-js/modules/es.object.keys.js");
require("core-js/modules/es.object.get-own-property-names.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.map.js");
require("core-js/modules/es.string.match.js");
require("core-js/modules/es.object.get-own-property-descriptor.js");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function (f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }
  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function (x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s':
        return String(args[i++]);
      case '%d':
        return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};

// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function (fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function () {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }
  if (process.noDeprecation === true) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
};
var debugs = {};
var debugEnviron;
exports.debuglog = function (set) {
  if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function () {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function () {};
    }
  }
  return debugs[set];
};

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;

// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold': [1, 22],
  'italic': [3, 23],
  'underline': [4, 24],
  'inverse': [7, 27],
  'white': [37, 39],
  'grey': [90, 39],
  'black': [30, 39],
  'blue': [34, 39],
  'cyan': [36, 39],
  'green': [32, 39],
  'magenta': [35, 39],
  'red': [31, 39],
  'yellow': [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};
function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];
  if (style) {
    return "\x1B[" + inspect.colors[style][0] + 'm' + str + "\x1B[" + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}
function stylizeNoColor(str, styleType) {
  return str;
}
function arrayToHash(array) {
  var hash = {};
  array.forEach(function (val, idx) {
    hash[val] = true;
  });
  return hash;
}
function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect && value && isFunction(value.inspect) &&
  // Filter out the util module, it's inspect function is special
  value.inspect !== exports.inspect &&
  // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);
  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }
  var base = '',
    array = false,
    braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }
  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }
  ctx.seen.push(value);
  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function (key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value) {
  if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value)) return ctx.stylize('' + value, 'number');
  if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value)) return ctx.stylize('null', 'null');
}
function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function (key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || {
    value: value[key]
  };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function (line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function (line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }
  return name + ': ' + str;
}
function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function (prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);
  if (length > 60) {
    return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
  }
  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;
function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;
function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;
function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;
function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;
function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;
function isSymbol(arg) {
  return (0, _typeof2.default)(arg) === 'symbol';
}
exports.isSymbol = isSymbol;
function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;
function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
function isObject(arg) {
  return (0, _typeof2.default)(arg) === 'object' && arg !== null;
}
exports.isObject = isObject;
function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
function isError(e) {
  return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;
function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;
function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || (0, _typeof2.default)(arg) === 'symbol' ||
  // ES6 symbol
  typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;
exports.isBuffer = require('./support/isBuffer');
function objectToString(o) {
  return Object.prototype.toString.call(o);
}
function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}
var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}

// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function () {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};

/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');
exports._extend = function (origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;
  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":415,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"_process":732,"core-js/modules/es.array.join.js":578,"core-js/modules/es.array.map.js":579,"core-js/modules/es.function.name.js":584,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.get-own-property-names.js":605,"core-js/modules/es.object.keys.js":609,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.constructor.js":617,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.match.js":627,"core-js/modules/es.string.replace.js":629,"core-js/modules/web.dom-collections.for-each.js":676,"inherits":414}],417:[function(require,module,exports){
"use strict";

module.exports = function _atob(str) {
  return atob(str);
};

},{}],418:[function(require,module,exports){
(function (global){(function (){
'use strict';

var filter = require('array-filter');
module.exports = function availableTypedArrays() {
  return filter(['BigInt64Array', 'BigUint64Array', 'Float32Array', 'Float64Array', 'Int16Array', 'Int32Array', 'Int8Array', 'Uint16Array', 'Uint32Array', 'Uint8Array', 'Uint8ClampedArray'], function (typedArray) {
    return typeof global[typedArray] === 'function';
  });
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"array-filter":412}],419:[function(require,module,exports){
"use strict";

require("core-js/modules/es.array.concat.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.array.map.js");
require("core-js/modules/es.number.constructor.js");
require("core-js/modules/es.array.join.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/web.url.to-json.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.split.js");
var bigInt = function (undefined) {
  "use strict";

  var BASE = 1e7,
    LOG_BASE = 7,
    MAX_INT = 9007199254740992,
    MAX_INT_ARR = smallToArray(MAX_INT),
    DEFAULT_ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";
  var supportsNativeBigInt = typeof BigInt === "function";
  function Integer(v, radix, alphabet, caseSensitive) {
    if (typeof v === "undefined") return Integer[0];
    if (typeof radix !== "undefined") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);
    return parseValue(v);
  }
  function BigInteger(value, sign) {
    this.value = value;
    this.sign = sign;
    this.isSmall = false;
  }
  BigInteger.prototype = Object.create(Integer.prototype);
  function SmallInteger(value) {
    this.value = value;
    this.sign = value < 0;
    this.isSmall = true;
  }
  SmallInteger.prototype = Object.create(Integer.prototype);
  function NativeBigInt(value) {
    this.value = value;
  }
  NativeBigInt.prototype = Object.create(Integer.prototype);
  function isPrecise(n) {
    return -MAX_INT < n && n < MAX_INT;
  }
  function smallToArray(n) {
    // For performance reasons doesn't reference BASE, need to change this function if BASE changes
    if (n < 1e7) return [n];
    if (n < 1e14) return [n % 1e7, Math.floor(n / 1e7)];
    return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];
  }
  function arrayToSmall(arr) {
    // If BASE changes this function may need to change
    trim(arr);
    var length = arr.length;
    if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {
      switch (length) {
        case 0:
          return 0;
        case 1:
          return arr[0];
        case 2:
          return arr[0] + arr[1] * BASE;
        default:
          return arr[0] + (arr[1] + arr[2] * BASE) * BASE;
      }
    }
    return arr;
  }
  function trim(v) {
    var i = v.length;
    while (v[--i] === 0);
    v.length = i + 1;
  }
  function createArray(length) {
    // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger
    var x = new Array(length);
    var i = -1;
    while (++i < length) {
      x[i] = 0;
    }
    return x;
  }
  function truncate(n) {
    if (n > 0) return Math.floor(n);
    return Math.ceil(n);
  }
  function add(a, b) {
    // assumes a and b are arrays with a.length >= b.length
    var l_a = a.length,
      l_b = b.length,
      r = new Array(l_a),
      carry = 0,
      base = BASE,
      sum,
      i;
    for (i = 0; i < l_b; i++) {
      sum = a[i] + b[i] + carry;
      carry = sum >= base ? 1 : 0;
      r[i] = sum - carry * base;
    }
    while (i < l_a) {
      sum = a[i] + carry;
      carry = sum === base ? 1 : 0;
      r[i++] = sum - carry * base;
    }
    if (carry > 0) r.push(carry);
    return r;
  }
  function addAny(a, b) {
    if (a.length >= b.length) return add(a, b);
    return add(b, a);
  }
  function addSmall(a, carry) {
    // assumes a is array, carry is number with 0 <= carry < MAX_INT
    var l = a.length,
      r = new Array(l),
      base = BASE,
      sum,
      i;
    for (i = 0; i < l; i++) {
      sum = a[i] - base + carry;
      carry = Math.floor(sum / base);
      r[i] = sum - carry * base;
      carry += 1;
    }
    while (carry > 0) {
      r[i++] = carry % base;
      carry = Math.floor(carry / base);
    }
    return r;
  }
  BigInteger.prototype.add = function (v) {
    var n = parseValue(v);
    if (this.sign !== n.sign) {
      return this.subtract(n.negate());
    }
    var a = this.value,
      b = n.value;
    if (n.isSmall) {
      return new BigInteger(addSmall(a, Math.abs(b)), this.sign);
    }
    return new BigInteger(addAny(a, b), this.sign);
  };
  BigInteger.prototype.plus = BigInteger.prototype.add;
  SmallInteger.prototype.add = function (v) {
    var n = parseValue(v);
    var a = this.value;
    if (a < 0 !== n.sign) {
      return this.subtract(n.negate());
    }
    var b = n.value;
    if (n.isSmall) {
      if (isPrecise(a + b)) return new SmallInteger(a + b);
      b = smallToArray(Math.abs(b));
    }
    return new BigInteger(addSmall(b, Math.abs(a)), a < 0);
  };
  SmallInteger.prototype.plus = SmallInteger.prototype.add;
  NativeBigInt.prototype.add = function (v) {
    return new NativeBigInt(this.value + parseValue(v).value);
  };
  NativeBigInt.prototype.plus = NativeBigInt.prototype.add;
  function subtract(a, b) {
    // assumes a and b are arrays with a >= b
    var a_l = a.length,
      b_l = b.length,
      r = new Array(a_l),
      borrow = 0,
      base = BASE,
      i,
      difference;
    for (i = 0; i < b_l; i++) {
      difference = a[i] - borrow - b[i];
      if (difference < 0) {
        difference += base;
        borrow = 1;
      } else borrow = 0;
      r[i] = difference;
    }
    for (i = b_l; i < a_l; i++) {
      difference = a[i] - borrow;
      if (difference < 0) difference += base;else {
        r[i++] = difference;
        break;
      }
      r[i] = difference;
    }
    for (; i < a_l; i++) {
      r[i] = a[i];
    }
    trim(r);
    return r;
  }
  function subtractAny(a, b, sign) {
    var value;
    if (compareAbs(a, b) >= 0) {
      value = subtract(a, b);
    } else {
      value = subtract(b, a);
      sign = !sign;
    }
    value = arrayToSmall(value);
    if (typeof value === "number") {
      if (sign) value = -value;
      return new SmallInteger(value);
    }
    return new BigInteger(value, sign);
  }
  function subtractSmall(a, b, sign) {
    // assumes a is array, b is number with 0 <= b < MAX_INT
    var l = a.length,
      r = new Array(l),
      carry = -b,
      base = BASE,
      i,
      difference;
    for (i = 0; i < l; i++) {
      difference = a[i] + carry;
      carry = Math.floor(difference / base);
      difference %= base;
      r[i] = difference < 0 ? difference + base : difference;
    }
    r = arrayToSmall(r);
    if (typeof r === "number") {
      if (sign) r = -r;
      return new SmallInteger(r);
    }
    return new BigInteger(r, sign);
  }
  BigInteger.prototype.subtract = function (v) {
    var n = parseValue(v);
    if (this.sign !== n.sign) {
      return this.add(n.negate());
    }
    var a = this.value,
      b = n.value;
    if (n.isSmall) return subtractSmall(a, Math.abs(b), this.sign);
    return subtractAny(a, b, this.sign);
  };
  BigInteger.prototype.minus = BigInteger.prototype.subtract;
  SmallInteger.prototype.subtract = function (v) {
    var n = parseValue(v);
    var a = this.value;
    if (a < 0 !== n.sign) {
      return this.add(n.negate());
    }
    var b = n.value;
    if (n.isSmall) {
      return new SmallInteger(a - b);
    }
    return subtractSmall(b, Math.abs(a), a >= 0);
  };
  SmallInteger.prototype.minus = SmallInteger.prototype.subtract;
  NativeBigInt.prototype.subtract = function (v) {
    return new NativeBigInt(this.value - parseValue(v).value);
  };
  NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;
  BigInteger.prototype.negate = function () {
    return new BigInteger(this.value, !this.sign);
  };
  SmallInteger.prototype.negate = function () {
    var sign = this.sign;
    var small = new SmallInteger(-this.value);
    small.sign = !sign;
    return small;
  };
  NativeBigInt.prototype.negate = function () {
    return new NativeBigInt(-this.value);
  };
  BigInteger.prototype.abs = function () {
    return new BigInteger(this.value, false);
  };
  SmallInteger.prototype.abs = function () {
    return new SmallInteger(Math.abs(this.value));
  };
  NativeBigInt.prototype.abs = function () {
    return new NativeBigInt(this.value >= 0 ? this.value : -this.value);
  };
  function multiplyLong(a, b) {
    var a_l = a.length,
      b_l = b.length,
      l = a_l + b_l,
      r = createArray(l),
      base = BASE,
      product,
      carry,
      i,
      a_i,
      b_j;
    for (i = 0; i < a_l; ++i) {
      a_i = a[i];
      for (var j = 0; j < b_l; ++j) {
        b_j = b[j];
        product = a_i * b_j + r[i + j];
        carry = Math.floor(product / base);
        r[i + j] = product - carry * base;
        r[i + j + 1] += carry;
      }
    }
    trim(r);
    return r;
  }
  function multiplySmall(a, b) {
    // assumes a is array, b is number with |b| < BASE
    var l = a.length,
      r = new Array(l),
      base = BASE,
      carry = 0,
      product,
      i;
    for (i = 0; i < l; i++) {
      product = a[i] * b + carry;
      carry = Math.floor(product / base);
      r[i] = product - carry * base;
    }
    while (carry > 0) {
      r[i++] = carry % base;
      carry = Math.floor(carry / base);
    }
    return r;
  }
  function shiftLeft(x, n) {
    var r = [];
    while (n-- > 0) r.push(0);
    return r.concat(x);
  }
  function multiplyKaratsuba(x, y) {
    var n = Math.max(x.length, y.length);
    if (n <= 30) return multiplyLong(x, y);
    n = Math.ceil(n / 2);
    var b = x.slice(n),
      a = x.slice(0, n),
      d = y.slice(n),
      c = y.slice(0, n);
    var ac = multiplyKaratsuba(a, c),
      bd = multiplyKaratsuba(b, d),
      abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));
    var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));
    trim(product);
    return product;
  }

  // The following function is derived from a surface fit of a graph plotting the performance difference
  // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.
  function useKaratsuba(l1, l2) {
    return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;
  }
  BigInteger.prototype.multiply = function (v) {
    var n = parseValue(v),
      a = this.value,
      b = n.value,
      sign = this.sign !== n.sign,
      abs;
    if (n.isSmall) {
      if (b === 0) return Integer[0];
      if (b === 1) return this;
      if (b === -1) return this.negate();
      abs = Math.abs(b);
      if (abs < BASE) {
        return new BigInteger(multiplySmall(a, abs), sign);
      }
      b = smallToArray(abs);
    }
    if (useKaratsuba(a.length, b.length))
      // Karatsuba is only faster for certain array sizes
      return new BigInteger(multiplyKaratsuba(a, b), sign);
    return new BigInteger(multiplyLong(a, b), sign);
  };
  BigInteger.prototype.times = BigInteger.prototype.multiply;
  function multiplySmallAndArray(a, b, sign) {
    // a >= 0
    if (a < BASE) {
      return new BigInteger(multiplySmall(b, a), sign);
    }
    return new BigInteger(multiplyLong(b, smallToArray(a)), sign);
  }
  SmallInteger.prototype._multiplyBySmall = function (a) {
    if (isPrecise(a.value * this.value)) {
      return new SmallInteger(a.value * this.value);
    }
    return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);
  };
  BigInteger.prototype._multiplyBySmall = function (a) {
    if (a.value === 0) return Integer[0];
    if (a.value === 1) return this;
    if (a.value === -1) return this.negate();
    return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);
  };
  SmallInteger.prototype.multiply = function (v) {
    return parseValue(v)._multiplyBySmall(this);
  };
  SmallInteger.prototype.times = SmallInteger.prototype.multiply;
  NativeBigInt.prototype.multiply = function (v) {
    return new NativeBigInt(this.value * parseValue(v).value);
  };
  NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;
  function square(a) {
    //console.assert(2 * BASE * BASE < MAX_INT);
    var l = a.length,
      r = createArray(l + l),
      base = BASE,
      product,
      carry,
      i,
      a_i,
      a_j;
    for (i = 0; i < l; i++) {
      a_i = a[i];
      carry = 0 - a_i * a_i;
      for (var j = i; j < l; j++) {
        a_j = a[j];
        product = 2 * (a_i * a_j) + r[i + j] + carry;
        carry = Math.floor(product / base);
        r[i + j] = product - carry * base;
      }
      r[i + l] = carry;
    }
    trim(r);
    return r;
  }
  BigInteger.prototype.square = function () {
    return new BigInteger(square(this.value), false);
  };
  SmallInteger.prototype.square = function () {
    var value = this.value * this.value;
    if (isPrecise(value)) return new SmallInteger(value);
    return new BigInteger(square(smallToArray(Math.abs(this.value))), false);
  };
  NativeBigInt.prototype.square = function (v) {
    return new NativeBigInt(this.value * this.value);
  };
  function divMod1(a, b) {
    // Left over from previous version. Performs faster than divMod2 on smaller input sizes.
    var a_l = a.length,
      b_l = b.length,
      base = BASE,
      result = createArray(b.length),
      divisorMostSignificantDigit = b[b_l - 1],
      // normalization
      lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),
      remainder = multiplySmall(a, lambda),
      divisor = multiplySmall(b, lambda),
      quotientDigit,
      shift,
      carry,
      borrow,
      i,
      l,
      q;
    if (remainder.length <= a_l) remainder.push(0);
    divisor.push(0);
    divisorMostSignificantDigit = divisor[b_l - 1];
    for (shift = a_l - b_l; shift >= 0; shift--) {
      quotientDigit = base - 1;
      if (remainder[shift + b_l] !== divisorMostSignificantDigit) {
        quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);
      }
      // quotientDigit <= base - 1
      carry = 0;
      borrow = 0;
      l = divisor.length;
      for (i = 0; i < l; i++) {
        carry += quotientDigit * divisor[i];
        q = Math.floor(carry / base);
        borrow += remainder[shift + i] - (carry - q * base);
        carry = q;
        if (borrow < 0) {
          remainder[shift + i] = borrow + base;
          borrow = -1;
        } else {
          remainder[shift + i] = borrow;
          borrow = 0;
        }
      }
      while (borrow !== 0) {
        quotientDigit -= 1;
        carry = 0;
        for (i = 0; i < l; i++) {
          carry += remainder[shift + i] - base + divisor[i];
          if (carry < 0) {
            remainder[shift + i] = carry + base;
            carry = 0;
          } else {
            remainder[shift + i] = carry;
            carry = 1;
          }
        }
        borrow += carry;
      }
      result[shift] = quotientDigit;
    }
    // denormalization
    remainder = divModSmall(remainder, lambda)[0];
    return [arrayToSmall(result), arrayToSmall(remainder)];
  }
  function divMod2(a, b) {
    // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/
    // Performs faster than divMod1 on larger input sizes.
    var a_l = a.length,
      b_l = b.length,
      result = [],
      part = [],
      base = BASE,
      guess,
      xlen,
      highx,
      highy,
      check;
    while (a_l) {
      part.unshift(a[--a_l]);
      trim(part);
      if (compareAbs(part, b) < 0) {
        result.push(0);
        continue;
      }
      xlen = part.length;
      highx = part[xlen - 1] * base + part[xlen - 2];
      highy = b[b_l - 1] * base + b[b_l - 2];
      if (xlen > b_l) {
        highx = (highx + 1) * base;
      }
      guess = Math.ceil(highx / highy);
      do {
        check = multiplySmall(b, guess);
        if (compareAbs(check, part) <= 0) break;
        guess--;
      } while (guess);
      result.push(guess);
      part = subtract(part, check);
    }
    result.reverse();
    return [arrayToSmall(result), arrayToSmall(part)];
  }
  function divModSmall(value, lambda) {
    var length = value.length,
      quotient = createArray(length),
      base = BASE,
      i,
      q,
      remainder,
      divisor;
    remainder = 0;
    for (i = length - 1; i >= 0; --i) {
      divisor = remainder * base + value[i];
      q = truncate(divisor / lambda);
      remainder = divisor - q * lambda;
      quotient[i] = q | 0;
    }
    return [quotient, remainder | 0];
  }
  function divModAny(self, v) {
    var value,
      n = parseValue(v);
    if (supportsNativeBigInt) {
      return [new NativeBigInt(self.value / n.value), new NativeBigInt(self.value % n.value)];
    }
    var a = self.value,
      b = n.value;
    var quotient;
    if (b === 0) throw new Error("Cannot divide by zero");
    if (self.isSmall) {
      if (n.isSmall) {
        return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];
      }
      return [Integer[0], self];
    }
    if (n.isSmall) {
      if (b === 1) return [self, Integer[0]];
      if (b == -1) return [self.negate(), Integer[0]];
      var abs = Math.abs(b);
      if (abs < BASE) {
        value = divModSmall(a, abs);
        quotient = arrayToSmall(value[0]);
        var remainder = value[1];
        if (self.sign) remainder = -remainder;
        if (typeof quotient === "number") {
          if (self.sign !== n.sign) quotient = -quotient;
          return [new SmallInteger(quotient), new SmallInteger(remainder)];
        }
        return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];
      }
      b = smallToArray(abs);
    }
    var comparison = compareAbs(a, b);
    if (comparison === -1) return [Integer[0], self];
    if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];

    // divMod1 is faster on smaller input sizes
    if (a.length + b.length <= 200) value = divMod1(a, b);else value = divMod2(a, b);
    quotient = value[0];
    var qSign = self.sign !== n.sign,
      mod = value[1],
      mSign = self.sign;
    if (typeof quotient === "number") {
      if (qSign) quotient = -quotient;
      quotient = new SmallInteger(quotient);
    } else quotient = new BigInteger(quotient, qSign);
    if (typeof mod === "number") {
      if (mSign) mod = -mod;
      mod = new SmallInteger(mod);
    } else mod = new BigInteger(mod, mSign);
    return [quotient, mod];
  }
  BigInteger.prototype.divmod = function (v) {
    var result = divModAny(this, v);
    return {
      quotient: result[0],
      remainder: result[1]
    };
  };
  NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;
  BigInteger.prototype.divide = function (v) {
    return divModAny(this, v)[0];
  };
  NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function (v) {
    return new NativeBigInt(this.value / parseValue(v).value);
  };
  SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;
  BigInteger.prototype.mod = function (v) {
    return divModAny(this, v)[1];
  };
  NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function (v) {
    return new NativeBigInt(this.value % parseValue(v).value);
  };
  SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;
  BigInteger.prototype.pow = function (v) {
    var n = parseValue(v),
      a = this.value,
      b = n.value,
      value,
      x,
      y;
    if (b === 0) return Integer[1];
    if (a === 0) return Integer[0];
    if (a === 1) return Integer[1];
    if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];
    if (n.sign) {
      return Integer[0];
    }
    if (!n.isSmall) throw new Error("The exponent " + n.toString() + " is too large.");
    if (this.isSmall) {
      if (isPrecise(value = Math.pow(a, b))) return new SmallInteger(truncate(value));
    }
    x = this;
    y = Integer[1];
    while (true) {
      if (b & 1 === 1) {
        y = y.times(x);
        --b;
      }
      if (b === 0) break;
      b /= 2;
      x = x.square();
    }
    return y;
  };
  SmallInteger.prototype.pow = BigInteger.prototype.pow;
  NativeBigInt.prototype.pow = function (v) {
    var n = parseValue(v);
    var a = this.value,
      b = n.value;
    var _0 = BigInt(0),
      _1 = BigInt(1),
      _2 = BigInt(2);
    if (b === _0) return Integer[1];
    if (a === _0) return Integer[0];
    if (a === _1) return Integer[1];
    if (a === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];
    if (n.isNegative()) return new NativeBigInt(_0);
    var x = this;
    var y = Integer[1];
    while (true) {
      if ((b & _1) === _1) {
        y = y.times(x);
        --b;
      }
      if (b === _0) break;
      b /= _2;
      x = x.square();
    }
    return y;
  };
  BigInteger.prototype.modPow = function (exp, mod) {
    exp = parseValue(exp);
    mod = parseValue(mod);
    if (mod.isZero()) throw new Error("Cannot take modPow with modulus 0");
    var r = Integer[1],
      base = this.mod(mod);
    if (exp.isNegative()) {
      exp = exp.multiply(Integer[-1]);
      base = base.modInv(mod);
    }
    while (exp.isPositive()) {
      if (base.isZero()) return Integer[0];
      if (exp.isOdd()) r = r.multiply(base).mod(mod);
      exp = exp.divide(2);
      base = base.square().mod(mod);
    }
    return r;
  };
  NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;
  function compareAbs(a, b) {
    if (a.length !== b.length) {
      return a.length > b.length ? 1 : -1;
    }
    for (var i = a.length - 1; i >= 0; i--) {
      if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;
    }
    return 0;
  }
  BigInteger.prototype.compareAbs = function (v) {
    var n = parseValue(v),
      a = this.value,
      b = n.value;
    if (n.isSmall) return 1;
    return compareAbs(a, b);
  };
  SmallInteger.prototype.compareAbs = function (v) {
    var n = parseValue(v),
      a = Math.abs(this.value),
      b = n.value;
    if (n.isSmall) {
      b = Math.abs(b);
      return a === b ? 0 : a > b ? 1 : -1;
    }
    return -1;
  };
  NativeBigInt.prototype.compareAbs = function (v) {
    var a = this.value;
    var b = parseValue(v).value;
    a = a >= 0 ? a : -a;
    b = b >= 0 ? b : -b;
    return a === b ? 0 : a > b ? 1 : -1;
  };
  BigInteger.prototype.compare = function (v) {
    // See discussion about comparison with Infinity:
    // https://github.com/peterolson/BigInteger.js/issues/61
    if (v === Infinity) {
      return -1;
    }
    if (v === -Infinity) {
      return 1;
    }
    var n = parseValue(v),
      a = this.value,
      b = n.value;
    if (this.sign !== n.sign) {
      return n.sign ? 1 : -1;
    }
    if (n.isSmall) {
      return this.sign ? -1 : 1;
    }
    return compareAbs(a, b) * (this.sign ? -1 : 1);
  };
  BigInteger.prototype.compareTo = BigInteger.prototype.compare;
  SmallInteger.prototype.compare = function (v) {
    if (v === Infinity) {
      return -1;
    }
    if (v === -Infinity) {
      return 1;
    }
    var n = parseValue(v),
      a = this.value,
      b = n.value;
    if (n.isSmall) {
      return a == b ? 0 : a > b ? 1 : -1;
    }
    if (a < 0 !== n.sign) {
      return a < 0 ? -1 : 1;
    }
    return a < 0 ? 1 : -1;
  };
  SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;
  NativeBigInt.prototype.compare = function (v) {
    if (v === Infinity) {
      return -1;
    }
    if (v === -Infinity) {
      return 1;
    }
    var a = this.value;
    var b = parseValue(v).value;
    return a === b ? 0 : a > b ? 1 : -1;
  };
  NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;
  BigInteger.prototype.equals = function (v) {
    return this.compare(v) === 0;
  };
  NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;
  BigInteger.prototype.notEquals = function (v) {
    return this.compare(v) !== 0;
  };
  NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;
  BigInteger.prototype.greater = function (v) {
    return this.compare(v) > 0;
  };
  NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;
  BigInteger.prototype.lesser = function (v) {
    return this.compare(v) < 0;
  };
  NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;
  BigInteger.prototype.greaterOrEquals = function (v) {
    return this.compare(v) >= 0;
  };
  NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;
  BigInteger.prototype.lesserOrEquals = function (v) {
    return this.compare(v) <= 0;
  };
  NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;
  BigInteger.prototype.isEven = function () {
    return (this.value[0] & 1) === 0;
  };
  SmallInteger.prototype.isEven = function () {
    return (this.value & 1) === 0;
  };
  NativeBigInt.prototype.isEven = function () {
    return (this.value & BigInt(1)) === BigInt(0);
  };
  BigInteger.prototype.isOdd = function () {
    return (this.value[0] & 1) === 1;
  };
  SmallInteger.prototype.isOdd = function () {
    return (this.value & 1) === 1;
  };
  NativeBigInt.prototype.isOdd = function () {
    return (this.value & BigInt(1)) === BigInt(1);
  };
  BigInteger.prototype.isPositive = function () {
    return !this.sign;
  };
  SmallInteger.prototype.isPositive = function () {
    return this.value > 0;
  };
  NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;
  BigInteger.prototype.isNegative = function () {
    return this.sign;
  };
  SmallInteger.prototype.isNegative = function () {
    return this.value < 0;
  };
  NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;
  BigInteger.prototype.isUnit = function () {
    return false;
  };
  SmallInteger.prototype.isUnit = function () {
    return Math.abs(this.value) === 1;
  };
  NativeBigInt.prototype.isUnit = function () {
    return this.abs().value === BigInt(1);
  };
  BigInteger.prototype.isZero = function () {
    return false;
  };
  SmallInteger.prototype.isZero = function () {
    return this.value === 0;
  };
  NativeBigInt.prototype.isZero = function () {
    return this.value === BigInt(0);
  };
  BigInteger.prototype.isDivisibleBy = function (v) {
    var n = parseValue(v);
    if (n.isZero()) return false;
    if (n.isUnit()) return true;
    if (n.compareAbs(2) === 0) return this.isEven();
    return this.mod(n).isZero();
  };
  NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;
  function isBasicPrime(v) {
    var n = v.abs();
    if (n.isUnit()) return false;
    if (n.equals(2) || n.equals(3) || n.equals(5)) return true;
    if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;
    if (n.lesser(49)) return true;
    // we don't know if it's prime: let the other functions figure it out
  }

  function millerRabinTest(n, a) {
    var nPrev = n.prev(),
      b = nPrev,
      r = 0,
      d,
      t,
      i,
      x;
    while (b.isEven()) b = b.divide(2), r++;
    next: for (i = 0; i < a.length; i++) {
      if (n.lesser(a[i])) continue;
      x = bigInt(a[i]).modPow(b, n);
      if (x.isUnit() || x.equals(nPrev)) continue;
      for (d = r - 1; d != 0; d--) {
        x = x.square().mod(n);
        if (x.isUnit()) return false;
        if (x.equals(nPrev)) continue next;
      }
      return false;
    }
    return true;
  }

  // Set "strict" to true to force GRH-supported lower bound of 2*log(N)^2
  BigInteger.prototype.isPrime = function (strict) {
    var isPrime = isBasicPrime(this);
    if (isPrime !== undefined) return isPrime;
    var n = this.abs();
    var bits = n.bitLength();
    if (bits <= 64) return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
    var logN = Math.log(2) * bits.toJSNumber();
    var t = Math.ceil(strict === true ? 2 * Math.pow(logN, 2) : logN);
    for (var a = [], i = 0; i < t; i++) {
      a.push(bigInt(i + 2));
    }
    return millerRabinTest(n, a);
  };
  NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;
  BigInteger.prototype.isProbablePrime = function (iterations, rng) {
    var isPrime = isBasicPrime(this);
    if (isPrime !== undefined) return isPrime;
    var n = this.abs();
    var t = iterations === undefined ? 5 : iterations;
    for (var a = [], i = 0; i < t; i++) {
      a.push(bigInt.randBetween(2, n.minus(2), rng));
    }
    return millerRabinTest(n, a);
  };
  NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;
  BigInteger.prototype.modInv = function (n) {
    var t = bigInt.zero,
      newT = bigInt.one,
      r = parseValue(n),
      newR = this.abs(),
      q,
      lastT,
      lastR;
    while (!newR.isZero()) {
      q = r.divide(newR);
      lastT = t;
      lastR = r;
      t = newT;
      r = newR;
      newT = lastT.subtract(q.multiply(newT));
      newR = lastR.subtract(q.multiply(newR));
    }
    if (!r.isUnit()) throw new Error(this.toString() + " and " + n.toString() + " are not co-prime");
    if (t.compare(0) === -1) {
      t = t.add(n);
    }
    if (this.isNegative()) {
      return t.negate();
    }
    return t;
  };
  NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;
  BigInteger.prototype.next = function () {
    var value = this.value;
    if (this.sign) {
      return subtractSmall(value, 1, this.sign);
    }
    return new BigInteger(addSmall(value, 1), this.sign);
  };
  SmallInteger.prototype.next = function () {
    var value = this.value;
    if (value + 1 < MAX_INT) return new SmallInteger(value + 1);
    return new BigInteger(MAX_INT_ARR, false);
  };
  NativeBigInt.prototype.next = function () {
    return new NativeBigInt(this.value + BigInt(1));
  };
  BigInteger.prototype.prev = function () {
    var value = this.value;
    if (this.sign) {
      return new BigInteger(addSmall(value, 1), true);
    }
    return subtractSmall(value, 1, this.sign);
  };
  SmallInteger.prototype.prev = function () {
    var value = this.value;
    if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);
    return new BigInteger(MAX_INT_ARR, true);
  };
  NativeBigInt.prototype.prev = function () {
    return new NativeBigInt(this.value - BigInt(1));
  };
  var powersOfTwo = [1];
  while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
  var powers2Length = powersOfTwo.length,
    highestPower2 = powersOfTwo[powers2Length - 1];
  function shift_isSmall(n) {
    return Math.abs(n) <= BASE;
  }
  BigInteger.prototype.shiftLeft = function (v) {
    var n = parseValue(v).toJSNumber();
    if (!shift_isSmall(n)) {
      throw new Error(String(n) + " is too large for shifting.");
    }
    if (n < 0) return this.shiftRight(-n);
    var result = this;
    if (result.isZero()) return result;
    while (n >= powers2Length) {
      result = result.multiply(highestPower2);
      n -= powers2Length - 1;
    }
    return result.multiply(powersOfTwo[n]);
  };
  NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;
  BigInteger.prototype.shiftRight = function (v) {
    var remQuo;
    var n = parseValue(v).toJSNumber();
    if (!shift_isSmall(n)) {
      throw new Error(String(n) + " is too large for shifting.");
    }
    if (n < 0) return this.shiftLeft(-n);
    var result = this;
    while (n >= powers2Length) {
      if (result.isZero() || result.isNegative() && result.isUnit()) return result;
      remQuo = divModAny(result, highestPower2);
      result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
      n -= powers2Length - 1;
    }
    remQuo = divModAny(result, powersOfTwo[n]);
    return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
  };
  NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;
  function bitwise(x, y, fn) {
    y = parseValue(y);
    var xSign = x.isNegative(),
      ySign = y.isNegative();
    var xRem = xSign ? x.not() : x,
      yRem = ySign ? y.not() : y;
    var xDigit = 0,
      yDigit = 0;
    var xDivMod = null,
      yDivMod = null;
    var result = [];
    while (!xRem.isZero() || !yRem.isZero()) {
      xDivMod = divModAny(xRem, highestPower2);
      xDigit = xDivMod[1].toJSNumber();
      if (xSign) {
        xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers
      }

      yDivMod = divModAny(yRem, highestPower2);
      yDigit = yDivMod[1].toJSNumber();
      if (ySign) {
        yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers
      }

      xRem = xDivMod[0];
      yRem = yDivMod[0];
      result.push(fn(xDigit, yDigit));
    }
    var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);
    for (var i = result.length - 1; i >= 0; i -= 1) {
      sum = sum.multiply(highestPower2).add(bigInt(result[i]));
    }
    return sum;
  }
  BigInteger.prototype.not = function () {
    return this.negate().prev();
  };
  NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;
  BigInteger.prototype.and = function (n) {
    return bitwise(this, n, function (a, b) {
      return a & b;
    });
  };
  NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;
  BigInteger.prototype.or = function (n) {
    return bitwise(this, n, function (a, b) {
      return a | b;
    });
  };
  NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;
  BigInteger.prototype.xor = function (n) {
    return bitwise(this, n, function (a, b) {
      return a ^ b;
    });
  };
  NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;
  var LOBMASK_I = 1 << 30,
    LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;
  function roughLOB(n) {
    // get lowestOneBit (rough)
    // SmallInteger: return Min(lowestOneBit(n), 1 << 30)
    // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]
    var v = n.value,
      x = typeof v === "number" ? v | LOBMASK_I : typeof v === "bigint" ? v | BigInt(LOBMASK_I) : v[0] + v[1] * BASE | LOBMASK_BI;
    return x & -x;
  }
  function integerLogarithm(value, base) {
    if (base.compareTo(value) <= 0) {
      var tmp = integerLogarithm(value, base.square(base));
      var p = tmp.p;
      var e = tmp.e;
      var t = p.multiply(base);
      return t.compareTo(value) <= 0 ? {
        p: t,
        e: e * 2 + 1
      } : {
        p: p,
        e: e * 2
      };
    }
    return {
      p: bigInt(1),
      e: 0
    };
  }
  BigInteger.prototype.bitLength = function () {
    var n = this;
    if (n.compareTo(bigInt(0)) < 0) {
      n = n.negate().subtract(bigInt(1));
    }
    if (n.compareTo(bigInt(0)) === 0) {
      return bigInt(0);
    }
    return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));
  };
  NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;
  function max(a, b) {
    a = parseValue(a);
    b = parseValue(b);
    return a.greater(b) ? a : b;
  }
  function min(a, b) {
    a = parseValue(a);
    b = parseValue(b);
    return a.lesser(b) ? a : b;
  }
  function gcd(a, b) {
    a = parseValue(a).abs();
    b = parseValue(b).abs();
    if (a.equals(b)) return a;
    if (a.isZero()) return b;
    if (b.isZero()) return a;
    var c = Integer[1],
      d,
      t;
    while (a.isEven() && b.isEven()) {
      d = min(roughLOB(a), roughLOB(b));
      a = a.divide(d);
      b = b.divide(d);
      c = c.multiply(d);
    }
    while (a.isEven()) {
      a = a.divide(roughLOB(a));
    }
    do {
      while (b.isEven()) {
        b = b.divide(roughLOB(b));
      }
      if (a.greater(b)) {
        t = b;
        b = a;
        a = t;
      }
      b = b.subtract(a);
    } while (!b.isZero());
    return c.isUnit() ? a : a.multiply(c);
  }
  function lcm(a, b) {
    a = parseValue(a).abs();
    b = parseValue(b).abs();
    return a.divide(gcd(a, b)).multiply(b);
  }
  function randBetween(a, b, rng) {
    a = parseValue(a);
    b = parseValue(b);
    var usedRNG = rng || Math.random;
    var low = min(a, b),
      high = max(a, b);
    var range = high.subtract(low).add(1);
    if (range.isSmall) return low.add(Math.floor(usedRNG() * range));
    var digits = toBase(range, BASE).value;
    var result = [],
      restricted = true;
    for (var i = 0; i < digits.length; i++) {
      var top = restricted ? digits[i] : BASE;
      var digit = truncate(usedRNG() * top);
      result.push(digit);
      if (digit < top) restricted = false;
    }
    return low.add(Integer.fromArray(result, BASE, false));
  }
  var parseBase = function parseBase(text, base, alphabet, caseSensitive) {
    alphabet = alphabet || DEFAULT_ALPHABET;
    text = String(text);
    if (!caseSensitive) {
      text = text.toLowerCase();
      alphabet = alphabet.toLowerCase();
    }
    var length = text.length;
    var i;
    var absBase = Math.abs(base);
    var alphabetValues = {};
    for (i = 0; i < alphabet.length; i++) {
      alphabetValues[alphabet[i]] = i;
    }
    for (i = 0; i < length; i++) {
      var c = text[i];
      if (c === "-") continue;
      if (c in alphabetValues) {
        if (alphabetValues[c] >= absBase) {
          if (c === "1" && absBase === 1) continue;
          throw new Error(c + " is not a valid digit in base " + base + ".");
        }
      }
    }
    base = parseValue(base);
    var digits = [];
    var isNegative = text[0] === "-";
    for (i = isNegative ? 1 : 0; i < text.length; i++) {
      var c = text[i];
      if (c in alphabetValues) digits.push(parseValue(alphabetValues[c]));else if (c === "<") {
        var start = i;
        do {
          i++;
        } while (text[i] !== ">" && i < text.length);
        digits.push(parseValue(text.slice(start + 1, i)));
      } else throw new Error(c + " is not a valid character");
    }
    return parseBaseFromArray(digits, base, isNegative);
  };
  function parseBaseFromArray(digits, base, isNegative) {
    var val = Integer[0],
      pow = Integer[1],
      i;
    for (i = digits.length - 1; i >= 0; i--) {
      val = val.add(digits[i].times(pow));
      pow = pow.times(base);
    }
    return isNegative ? val.negate() : val;
  }
  function stringify(digit, alphabet) {
    alphabet = alphabet || DEFAULT_ALPHABET;
    if (digit < alphabet.length) {
      return alphabet[digit];
    }
    return "<" + digit + ">";
  }
  function toBase(n, base) {
    base = bigInt(base);
    if (base.isZero()) {
      if (n.isZero()) return {
        value: [0],
        isNegative: false
      };
      throw new Error("Cannot convert nonzero numbers to base 0.");
    }
    if (base.equals(-1)) {
      if (n.isZero()) return {
        value: [0],
        isNegative: false
      };
      if (n.isNegative()) return {
        value: [].concat.apply([], Array.apply(null, Array(-n.toJSNumber())).map(Array.prototype.valueOf, [1, 0])),
        isNegative: false
      };
      var arr = Array.apply(null, Array(n.toJSNumber() - 1)).map(Array.prototype.valueOf, [0, 1]);
      arr.unshift([1]);
      return {
        value: [].concat.apply([], arr),
        isNegative: false
      };
    }
    var neg = false;
    if (n.isNegative() && base.isPositive()) {
      neg = true;
      n = n.abs();
    }
    if (base.isUnit()) {
      if (n.isZero()) return {
        value: [0],
        isNegative: false
      };
      return {
        value: Array.apply(null, Array(n.toJSNumber())).map(Number.prototype.valueOf, 1),
        isNegative: neg
      };
    }
    var out = [];
    var left = n,
      divmod;
    while (left.isNegative() || left.compareAbs(base) >= 0) {
      divmod = left.divmod(base);
      left = divmod.quotient;
      var digit = divmod.remainder;
      if (digit.isNegative()) {
        digit = base.minus(digit).abs();
        left = left.next();
      }
      out.push(digit.toJSNumber());
    }
    out.push(left.toJSNumber());
    return {
      value: out.reverse(),
      isNegative: neg
    };
  }
  function toBaseString(n, base, alphabet) {
    var arr = toBase(n, base);
    return (arr.isNegative ? "-" : "") + arr.value.map(function (x) {
      return stringify(x, alphabet);
    }).join('');
  }
  BigInteger.prototype.toArray = function (radix) {
    return toBase(this, radix);
  };
  SmallInteger.prototype.toArray = function (radix) {
    return toBase(this, radix);
  };
  NativeBigInt.prototype.toArray = function (radix) {
    return toBase(this, radix);
  };
  BigInteger.prototype.toString = function (radix, alphabet) {
    if (radix === undefined) radix = 10;
    if (radix !== 10) return toBaseString(this, radix, alphabet);
    var v = this.value,
      l = v.length,
      str = String(v[--l]),
      zeros = "0000000",
      digit;
    while (--l >= 0) {
      digit = String(v[l]);
      str += zeros.slice(digit.length) + digit;
    }
    var sign = this.sign ? "-" : "";
    return sign + str;
  };
  SmallInteger.prototype.toString = function (radix, alphabet) {
    if (radix === undefined) radix = 10;
    if (radix != 10) return toBaseString(this, radix, alphabet);
    return String(this.value);
  };
  NativeBigInt.prototype.toString = SmallInteger.prototype.toString;
  NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function () {
    return this.toString();
  };
  BigInteger.prototype.valueOf = function () {
    return parseInt(this.toString(), 10);
  };
  BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;
  SmallInteger.prototype.valueOf = function () {
    return this.value;
  };
  SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;
  NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function () {
    return parseInt(this.toString(), 10);
  };
  function parseStringValue(v) {
    if (isPrecise(+v)) {
      var x = +v;
      if (x === truncate(x)) return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);
      throw new Error("Invalid integer: " + v);
    }
    var sign = v[0] === "-";
    if (sign) v = v.slice(1);
    var split = v.split(/e/i);
    if (split.length > 2) throw new Error("Invalid integer: " + split.join("e"));
    if (split.length === 2) {
      var exp = split[1];
      if (exp[0] === "+") exp = exp.slice(1);
      exp = +exp;
      if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error("Invalid integer: " + exp + " is not a valid exponent.");
      var text = split[0];
      var decimalPlace = text.indexOf(".");
      if (decimalPlace >= 0) {
        exp -= text.length - decimalPlace - 1;
        text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);
      }
      if (exp < 0) throw new Error("Cannot include negative exponent part for integers");
      text += new Array(exp + 1).join("0");
      v = text;
    }
    var isValid = /^([0-9][0-9]*)$/.test(v);
    if (!isValid) throw new Error("Invalid integer: " + v);
    if (supportsNativeBigInt) {
      return new NativeBigInt(BigInt(sign ? "-" + v : v));
    }
    var r = [],
      max = v.length,
      l = LOG_BASE,
      min = max - l;
    while (max > 0) {
      r.push(+v.slice(min, max));
      min -= l;
      if (min < 0) min = 0;
      max -= l;
    }
    trim(r);
    return new BigInteger(r, sign);
  }
  function parseNumberValue(v) {
    if (supportsNativeBigInt) {
      return new NativeBigInt(BigInt(v));
    }
    if (isPrecise(v)) {
      if (v !== truncate(v)) throw new Error(v + " is not an integer.");
      return new SmallInteger(v);
    }
    return parseStringValue(v.toString());
  }
  function parseValue(v) {
    if (typeof v === "number") {
      return parseNumberValue(v);
    }
    if (typeof v === "string") {
      return parseStringValue(v);
    }
    if (typeof v === "bigint") {
      return new NativeBigInt(v);
    }
    return v;
  }
  // Pre-define numbers in range [-999,999]
  for (var i = 0; i < 1000; i++) {
    Integer[i] = parseValue(i);
    if (i > 0) Integer[-i] = parseValue(-i);
  }
  // Backwards compatibility
  Integer.one = Integer[1];
  Integer.zero = Integer[0];
  Integer.minusOne = Integer[-1];
  Integer.max = max;
  Integer.min = min;
  Integer.gcd = gcd;
  Integer.lcm = lcm;
  Integer.isInstance = function (x) {
    return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt;
  };
  Integer.randBetween = randBetween;
  Integer.fromArray = function (digits, base, isNegative) {
    return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);
  };
  return Integer;
}();

// Node.js check
if (typeof module !== "undefined" && module.hasOwnProperty("exports")) {
  module.exports = bigInt;
}

//amd check
if (typeof define === "function" && define.amd) {
  define(function () {
    return bigInt;
  });
}

},{"core-js/modules/es.array.concat.js":569,"core-js/modules/es.array.join.js":578,"core-js/modules/es.array.map.js":579,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.promise.js":614,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.split.js":631,"core-js/modules/web.url.to-json.js":680}],420:[function(require,module,exports){
"use strict";

module.exports = function _btoa(str) {
  return btoa(str);
};

},{}],421:[function(require,module,exports){
"use strict";

module.exports = function (it) {
  if (typeof it != 'function') {
    throw TypeError(String(it) + ' is not a function');
  }
  return it;
};

},{}],422:[function(require,module,exports){
"use strict";

var isObject = require('../internals/is-object');
module.exports = function (it) {
  if (!isObject(it) && it !== null) {
    throw TypeError("Can't set " + String(it) + ' as a prototype');
  }
  return it;
};

},{"../internals/is-object":491}],423:[function(require,module,exports){
"use strict";

var wellKnownSymbol = require('../internals/well-known-symbol');
var create = require('../internals/object-create');
var definePropertyModule = require('../internals/object-define-property');
var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] == undefined) {
  definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create(null)
  });
}

// add a key to Array.prototype[@@unscopables]
module.exports = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};

},{"../internals/object-create":508,"../internals/object-define-property":510,"../internals/well-known-symbol":564}],424:[function(require,module,exports){
'use strict';

var charAt = require('../internals/string-multibyte').charAt;

// `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? charAt(S, index).length : 1);
};

},{"../internals/string-multibyte":541}],425:[function(require,module,exports){
"use strict";

module.exports = function (it, Constructor, name) {
  if (!(it instanceof Constructor)) {
    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
  }
  return it;
};

},{}],426:[function(require,module,exports){
"use strict";

var isObject = require('../internals/is-object');
module.exports = function (it) {
  if (!isObject(it)) {
    throw TypeError(String(it) + ' is not an object');
  }
  return it;
};

},{"../internals/is-object":491}],427:[function(require,module,exports){
"use strict";

require("core-js/modules/es.array-buffer.constructor.js");
require("core-js/modules/es.array-buffer.slice.js");
require("core-js/modules/es.object.to-string.js");
module.exports = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined';

},{"core-js/modules/es.array-buffer.constructor.js":566,"core-js/modules/es.array-buffer.slice.js":568,"core-js/modules/es.object.to-string.js":612}],428:[function(require,module,exports){
'use strict';

var NATIVE_ARRAY_BUFFER = require('../internals/array-buffer-native');
var DESCRIPTORS = require('../internals/descriptors');
var global = require('../internals/global');
var isObject = require('../internals/is-object');
var has = require('../internals/has');
var classof = require('../internals/classof');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var redefine = require('../internals/redefine');
var defineProperty = require('../internals/object-define-property').f;
var getPrototypeOf = require('../internals/object-get-prototype-of');
var setPrototypeOf = require('../internals/object-set-prototype-of');
var wellKnownSymbol = require('../internals/well-known-symbol');
var uid = require('../internals/uid');
var Int8Array = global.Int8Array;
var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
var Uint8ClampedArray = global.Uint8ClampedArray;
var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
var TypedArray = Int8Array && getPrototypeOf(Int8Array);
var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
var ObjectPrototype = Object.prototype;
var isPrototypeOf = ObjectPrototype.isPrototypeOf;
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
// Fixing native typed arrays in Opera Presto crashes the browser, see #595
var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global.opera) !== 'Opera';
var TYPED_ARRAY_TAG_REQIRED = false;
var NAME;
var TypedArrayConstructorsList = {
  Int8Array: 1,
  Uint8Array: 1,
  Uint8ClampedArray: 1,
  Int16Array: 2,
  Uint16Array: 2,
  Int32Array: 4,
  Uint32Array: 4,
  Float32Array: 4,
  Float64Array: 8
};
var isView = function isView(it) {
  var klass = classof(it);
  return klass === 'DataView' || has(TypedArrayConstructorsList, klass);
};
var isTypedArray = function isTypedArray(it) {
  return isObject(it) && has(TypedArrayConstructorsList, classof(it));
};
var aTypedArray = function aTypedArray(it) {
  if (isTypedArray(it)) return it;
  throw TypeError('Target is not a typed array');
};
var aTypedArrayConstructor = function aTypedArrayConstructor(C) {
  if (setPrototypeOf) {
    if (isPrototypeOf.call(TypedArray, C)) return C;
  } else for (var ARRAY in TypedArrayConstructorsList) if (has(TypedArrayConstructorsList, NAME)) {
    var TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && (C === TypedArrayConstructor || isPrototypeOf.call(TypedArrayConstructor, C))) {
      return C;
    }
  }
  throw TypeError('Target is not a typed array constructor');
};
var exportTypedArrayMethod = function exportTypedArrayMethod(KEY, property, forced) {
  if (!DESCRIPTORS) return;
  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
    var TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && has(TypedArrayConstructor.prototype, KEY)) {
      delete TypedArrayConstructor.prototype[KEY];
    }
  }
  if (!TypedArrayPrototype[KEY] || forced) {
    redefine(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property);
  }
};
var exportTypedArrayStaticMethod = function exportTypedArrayStaticMethod(KEY, property, forced) {
  var ARRAY, TypedArrayConstructor;
  if (!DESCRIPTORS) return;
  if (setPrototypeOf) {
    if (forced) for (ARRAY in TypedArrayConstructorsList) {
      TypedArrayConstructor = global[ARRAY];
      if (TypedArrayConstructor && has(TypedArrayConstructor, KEY)) {
        delete TypedArrayConstructor[KEY];
      }
    }
    if (!TypedArray[KEY] || forced) {
      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
      try {
        return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8Array[KEY] || property);
      } catch (error) {/* empty */}
    } else return;
  }
  for (ARRAY in TypedArrayConstructorsList) {
    TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
      redefine(TypedArrayConstructor, KEY, property);
    }
  }
};
for (NAME in TypedArrayConstructorsList) {
  if (!global[NAME]) NATIVE_ARRAY_BUFFER_VIEWS = false;
}

// WebKit bug - typed arrays constructors prototype is Object.prototype
if (!NATIVE_ARRAY_BUFFER_VIEWS || typeof TypedArray != 'function' || TypedArray === Function.prototype) {
  // eslint-disable-next-line no-shadow
  TypedArray = function TypedArray() {
    throw TypeError('Incorrect invocation');
  };
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global[NAME]) setPrototypeOf(global[NAME], TypedArray);
  }
}
if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
  TypedArrayPrototype = TypedArray.prototype;
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global[NAME]) setPrototypeOf(global[NAME].prototype, TypedArrayPrototype);
  }
}

// WebKit bug - one more object in Uint8ClampedArray prototype chain
if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
  setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
}
if (DESCRIPTORS && !has(TypedArrayPrototype, TO_STRING_TAG)) {
  TYPED_ARRAY_TAG_REQIRED = true;
  defineProperty(TypedArrayPrototype, TO_STRING_TAG, {
    get: function get() {
      return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
    }
  });
  for (NAME in TypedArrayConstructorsList) if (global[NAME]) {
    createNonEnumerableProperty(global[NAME], TYPED_ARRAY_TAG, NAME);
  }
}
module.exports = {
  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,
  aTypedArray: aTypedArray,
  aTypedArrayConstructor: aTypedArrayConstructor,
  exportTypedArrayMethod: exportTypedArrayMethod,
  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
  isView: isView,
  isTypedArray: isTypedArray,
  TypedArray: TypedArray,
  TypedArrayPrototype: TypedArrayPrototype
};

},{"../internals/array-buffer-native":427,"../internals/classof":445,"../internals/create-non-enumerable-property":453,"../internals/descriptors":459,"../internals/global":475,"../internals/has":476,"../internals/is-object":491,"../internals/object-define-property":510,"../internals/object-get-prototype-of":515,"../internals/object-set-prototype-of":519,"../internals/redefine":527,"../internals/uid":561,"../internals/well-known-symbol":564}],429:[function(require,module,exports){
'use strict';

require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.function.name.js");
var global = require('../internals/global');
var DESCRIPTORS = require('../internals/descriptors');
var NATIVE_ARRAY_BUFFER = require('../internals/array-buffer-native');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var redefineAll = require('../internals/redefine-all');
var fails = require('../internals/fails');
var anInstance = require('../internals/an-instance');
var toInteger = require('../internals/to-integer');
var toLength = require('../internals/to-length');
var toIndex = require('../internals/to-index');
var IEEE754 = require('../internals/ieee754');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var setPrototypeOf = require('../internals/object-set-prototype-of');
var getOwnPropertyNames = require('../internals/object-get-own-property-names').f;
var defineProperty = require('../internals/object-define-property').f;
var arrayFill = require('../internals/array-fill');
var setToStringTag = require('../internals/set-to-string-tag');
var InternalStateModule = require('../internals/internal-state');
var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length';
var WRONG_INDEX = 'Wrong index';
var NativeArrayBuffer = global[ARRAY_BUFFER];
var $ArrayBuffer = NativeArrayBuffer;
var $DataView = global[DATA_VIEW];
var $DataViewPrototype = $DataView && $DataView[PROTOTYPE];
var ObjectPrototype = Object.prototype;
var RangeError = global.RangeError;
var packIEEE754 = IEEE754.pack;
var unpackIEEE754 = IEEE754.unpack;
var packInt8 = function packInt8(number) {
  return [number & 0xFF];
};
var packInt16 = function packInt16(number) {
  return [number & 0xFF, number >> 8 & 0xFF];
};
var packInt32 = function packInt32(number) {
  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
};
var unpackInt32 = function unpackInt32(buffer) {
  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
};
var packFloat32 = function packFloat32(number) {
  return packIEEE754(number, 23, 4);
};
var packFloat64 = function packFloat64(number) {
  return packIEEE754(number, 52, 8);
};
var addGetter = function addGetter(Constructor, key) {
  defineProperty(Constructor[PROTOTYPE], key, {
    get: function get() {
      return getInternalState(this)[key];
    }
  });
};
var get = function get(view, count, index, isLittleEndian) {
  var intIndex = toIndex(index);
  var store = getInternalState(view);
  if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
  var bytes = getInternalState(store.buffer).bytes;
  var start = intIndex + store.byteOffset;
  var pack = bytes.slice(start, start + count);
  return isLittleEndian ? pack : pack.reverse();
};
var set = function set(view, count, index, conversion, value, isLittleEndian) {
  var intIndex = toIndex(index);
  var store = getInternalState(view);
  if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
  var bytes = getInternalState(store.buffer).bytes;
  var start = intIndex + store.byteOffset;
  var pack = conversion(+value);
  for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
};
if (!NATIVE_ARRAY_BUFFER) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    setInternalState(this, {
      bytes: arrayFill.call(new Array(byteLength), 0),
      byteLength: byteLength
    });
    if (!DESCRIPTORS) this.byteLength = byteLength;
  };
  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = getInternalState(buffer).byteLength;
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    setInternalState(this, {
      buffer: buffer,
      byteLength: byteLength,
      byteOffset: offset
    });
    if (!DESCRIPTORS) {
      this.buffer = buffer;
      this.byteLength = byteLength;
      this.byteOffset = offset;
    }
  };
  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, 'byteLength');
    addGetter($DataView, 'buffer');
    addGetter($DataView, 'byteLength');
    addGetter($DataView, 'byteOffset');
  }
  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packInt8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packInt8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);
    }
  });
} else {
  if (!fails(function () {
    NativeArrayBuffer(1);
  }) || !fails(function () {
    new NativeArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new NativeArrayBuffer(); // eslint-disable-line no-new
    new NativeArrayBuffer(1.5); // eslint-disable-line no-new
    new NativeArrayBuffer(NaN); // eslint-disable-line no-new
    return NativeArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new NativeArrayBuffer(toIndex(length));
    };
    var ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE] = NativeArrayBuffer[PROTOTYPE];
    for (var keys = getOwnPropertyNames(NativeArrayBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) {
        createNonEnumerableProperty($ArrayBuffer, key, NativeArrayBuffer[key]);
      }
    }
    ArrayBufferPrototype.constructor = $ArrayBuffer;
  }

  // WebKit bug - the same parent prototype for typed arrays and data view
  if (setPrototypeOf && getPrototypeOf($DataViewPrototype) !== ObjectPrototype) {
    setPrototypeOf($DataViewPrototype, ObjectPrototype);
  }

  // iOS Safari 7.x bug
  var testView = new $DataView(new $ArrayBuffer(2));
  var nativeSetInt8 = $DataViewPrototype.setInt8;
  testView.setInt8(0, 2147483648);
  testView.setInt8(1, 2147483649);
  if (testView.getInt8(0) || !testView.getInt8(1)) redefineAll($DataViewPrototype, {
    setInt8: function setInt8(byteOffset, value) {
      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, {
    unsafe: true
  });
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
module.exports = {
  ArrayBuffer: $ArrayBuffer,
  DataView: $DataView
};

},{"../internals/an-instance":425,"../internals/array-buffer-native":427,"../internals/array-fill":431,"../internals/create-non-enumerable-property":453,"../internals/descriptors":459,"../internals/fails":467,"../internals/global":475,"../internals/ieee754":481,"../internals/internal-state":486,"../internals/object-define-property":510,"../internals/object-get-own-property-names":513,"../internals/object-get-prototype-of":515,"../internals/object-set-prototype-of":519,"../internals/redefine-all":526,"../internals/set-to-string-tag":536,"../internals/to-index":549,"../internals/to-integer":551,"../internals/to-length":552,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584}],430:[function(require,module,exports){
'use strict';

require("core-js/modules/es.array.copy-within.js");
var toObject = require('../internals/to-object');
var toAbsoluteIndex = require('../internals/to-absolute-index');
var toLength = require('../internals/to-length');
var min = Math.min;

// `Array.prototype.copyWithin` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.copywithin
module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];else delete O[to];
    to += inc;
    from += inc;
  }
  return O;
};

},{"../internals/to-absolute-index":548,"../internals/to-length":552,"../internals/to-object":553,"core-js/modules/es.array.copy-within.js":570}],431:[function(require,module,exports){
'use strict';

var toObject = require('../internals/to-object');
var toAbsoluteIndex = require('../internals/to-absolute-index');
var toLength = require('../internals/to-length');

// `Array.prototype.fill` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.fill
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var argumentsLength = arguments.length;
  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
  var end = argumentsLength > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};

},{"../internals/to-absolute-index":548,"../internals/to-length":552,"../internals/to-object":553}],432:[function(require,module,exports){
'use strict';

require("core-js/modules/es.object.to-string.js");
require("core-js/modules/web.dom-collections.for-each.js");
var $forEach = require('../internals/array-iteration').forEach;
var arrayMethodIsStrict = require('../internals/array-method-is-strict');
var arrayMethodUsesToLength = require('../internals/array-method-uses-to-length');
var STRICT_METHOD = arrayMethodIsStrict('forEach');
var USES_TO_LENGTH = arrayMethodUsesToLength('forEach');

// `Array.prototype.forEach` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
module.exports = !STRICT_METHOD || !USES_TO_LENGTH ? function forEach(callbackfn /* , thisArg */) {
  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
} : [].forEach;

},{"../internals/array-iteration":435,"../internals/array-method-is-strict":438,"../internals/array-method-uses-to-length":439,"core-js/modules/es.object.to-string.js":612,"core-js/modules/web.dom-collections.for-each.js":676}],433:[function(require,module,exports){
'use strict';

var bind = require('../internals/function-bind-context');
var toObject = require('../internals/to-object');
var callWithSafeIterationClosing = require('../internals/call-with-safe-iteration-closing');
var isArrayIteratorMethod = require('../internals/is-array-iterator-method');
var toLength = require('../internals/to-length');
var createProperty = require('../internals/create-property');
var getIteratorMethod = require('../internals/get-iterator-method');

// `Array.from` method implementation
// https://tc39.github.io/ecma262/#sec-array.from
module.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
  var O = toObject(arrayLike);
  var C = typeof this == 'function' ? this : Array;
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var iteratorMethod = getIteratorMethod(O);
  var index = 0;
  var length, result, step, iterator, next, value;
  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);
  // if the target is not iterable or it's an array with the default iterator - use a simple case
  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
    iterator = iteratorMethod.call(O);
    next = iterator.next;
    result = new C();
    for (; !(step = next.call(iterator)).done; index++) {
      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
      createProperty(result, index, value);
    }
  } else {
    length = toLength(O.length);
    result = new C(length);
    for (; length > index; index++) {
      value = mapping ? mapfn(O[index], index) : O[index];
      createProperty(result, index, value);
    }
  }
  result.length = index;
  return result;
};

},{"../internals/call-with-safe-iteration-closing":442,"../internals/create-property":455,"../internals/function-bind-context":470,"../internals/get-iterator-method":473,"../internals/is-array-iterator-method":487,"../internals/to-length":552,"../internals/to-object":553}],434:[function(require,module,exports){
"use strict";

var toIndexedObject = require('../internals/to-indexed-object');
var toLength = require('../internals/to-length');
var toAbsoluteIndex = require('../internals/to-absolute-index');

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function createMethod(IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
      // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    }
    return !IS_INCLUDES && -1;
  };
};
module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};

},{"../internals/to-absolute-index":548,"../internals/to-indexed-object":550,"../internals/to-length":552}],435:[function(require,module,exports){
"use strict";

var bind = require('../internals/function-bind-context');
var IndexedObject = require('../internals/indexed-object');
var toObject = require('../internals/to-object');
var toLength = require('../internals/to-length');
var arraySpeciesCreate = require('../internals/array-species-create');
var push = [].push;

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation
var createMethod = function createMethod(TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var boundFunction = bind(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var value, result;
    for (; length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3:
            return true;
          // some
          case 5:
            return value;
          // find
          case 6:
            return index;
          // findIndex
          case 2:
            push.call(target, value);
          // filter
        } else if (IS_EVERY) return false; // every
      }
    }

    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};
module.exports = {
  // `Array.prototype.forEach` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
  forEach: createMethod(0),
  // `Array.prototype.map` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.map
  map: createMethod(1),
  // `Array.prototype.filter` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.filter
  filter: createMethod(2),
  // `Array.prototype.some` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.some
  some: createMethod(3),
  // `Array.prototype.every` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.every
  every: createMethod(4),
  // `Array.prototype.find` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.find
  find: createMethod(5),
  // `Array.prototype.findIndex` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod(6)
};

},{"../internals/array-species-create":441,"../internals/function-bind-context":470,"../internals/indexed-object":482,"../internals/to-length":552,"../internals/to-object":553}],436:[function(require,module,exports){
'use strict';

var toIndexedObject = require('../internals/to-indexed-object');
var toInteger = require('../internals/to-integer');
var toLength = require('../internals/to-length');
var arrayMethodIsStrict = require('../internals/array-method-is-strict');
var arrayMethodUsesToLength = require('../internals/array-method-uses-to-length');
var min = Math.min;
var nativeLastIndexOf = [].lastIndexOf;
var NEGATIVE_ZERO = !!nativeLastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
var STRICT_METHOD = arrayMethodIsStrict('lastIndexOf');
// For preventing possible almost infinite loop in non-standard implementations, test the forward version of the method
var USES_TO_LENGTH = arrayMethodUsesToLength('indexOf', {
  ACCESSORS: true,
  1: 0
});
var FORCED = NEGATIVE_ZERO || !STRICT_METHOD || !USES_TO_LENGTH;

// `Array.prototype.lastIndexOf` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof
module.exports = FORCED ? function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
  // convert -0 to +0
  if (NEGATIVE_ZERO) return nativeLastIndexOf.apply(this, arguments) || 0;
  var O = toIndexedObject(this);
  var length = toLength(O.length);
  var index = length - 1;
  if (arguments.length > 1) index = min(index, toInteger(arguments[1]));
  if (index < 0) index = length + index;
  for (; index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;
  return -1;
} : nativeLastIndexOf;

},{"../internals/array-method-is-strict":438,"../internals/array-method-uses-to-length":439,"../internals/to-indexed-object":550,"../internals/to-integer":551,"../internals/to-length":552}],437:[function(require,module,exports){
"use strict";

var fails = require('../internals/fails');
var wellKnownSymbol = require('../internals/well-known-symbol');
var V8_VERSION = require('../internals/engine-v8-version');
var SPECIES = wellKnownSymbol('species');
module.exports = function (METHOD_NAME) {
  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/677
  return V8_VERSION >= 51 || !fails(function () {
    var array = [];
    var constructor = array.constructor = {};
    constructor[SPECIES] = function () {
      return {
        foo: 1
      };
    };
    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};

},{"../internals/engine-v8-version":464,"../internals/fails":467,"../internals/well-known-symbol":564}],438:[function(require,module,exports){
'use strict';

var fails = require('../internals/fails');
module.exports = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call,no-throw-literal
    method.call(null, argument || function () {
      throw 1;
    }, 1);
  });
};

},{"../internals/fails":467}],439:[function(require,module,exports){
"use strict";

var DESCRIPTORS = require('../internals/descriptors');
var fails = require('../internals/fails');
var has = require('../internals/has');
var defineProperty = Object.defineProperty;
var cache = {};
var thrower = function thrower(it) {
  throw it;
};
module.exports = function (METHOD_NAME, options) {
  if (has(cache, METHOD_NAME)) return cache[METHOD_NAME];
  if (!options) options = {};
  var method = [][METHOD_NAME];
  var ACCESSORS = has(options, 'ACCESSORS') ? options.ACCESSORS : false;
  var argument0 = has(options, 0) ? options[0] : thrower;
  var argument1 = has(options, 1) ? options[1] : undefined;
  return cache[METHOD_NAME] = !!method && !fails(function () {
    if (ACCESSORS && !DESCRIPTORS) return true;
    var O = {
      length: -1
    };
    if (ACCESSORS) defineProperty(O, 1, {
      enumerable: true,
      get: thrower
    });else O[1] = 1;
    method.call(O, argument0, argument1);
  });
};

},{"../internals/descriptors":459,"../internals/fails":467,"../internals/has":476}],440:[function(require,module,exports){
"use strict";

var aFunction = require('../internals/a-function');
var toObject = require('../internals/to-object');
var IndexedObject = require('../internals/indexed-object');
var toLength = require('../internals/to-length');

// `Array.prototype.{ reduce, reduceRight }` methods implementation
var createMethod = function createMethod(IS_RIGHT) {
  return function (that, callbackfn, argumentsLength, memo) {
    aFunction(callbackfn);
    var O = toObject(that);
    var self = IndexedObject(O);
    var length = toLength(O.length);
    var index = IS_RIGHT ? length - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2) while (true) {
      if (index in self) {
        memo = self[index];
        index += i;
        break;
      }
      index += i;
      if (IS_RIGHT ? index < 0 : length <= index) {
        throw TypeError('Reduce of empty array with no initial value');
      }
    }
    for (; IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
      memo = callbackfn(memo, self[index], index, O);
    }
    return memo;
  };
};
module.exports = {
  // `Array.prototype.reduce` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
  left: createMethod(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
  right: createMethod(true)
};

},{"../internals/a-function":421,"../internals/indexed-object":482,"../internals/to-length":552,"../internals/to-object":553}],441:[function(require,module,exports){
"use strict";

var isObject = require('../internals/is-object');
var isArray = require('../internals/is-array');
var wellKnownSymbol = require('../internals/well-known-symbol');
var SPECIES = wellKnownSymbol('species');

// `ArraySpeciesCreate` abstract operation
// https://tc39.github.io/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray, length) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  }
  return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
};

},{"../internals/is-array":488,"../internals/is-object":491,"../internals/well-known-symbol":564}],442:[function(require,module,exports){
"use strict";

var anObject = require('../internals/an-object');

// call something on iterator step with safe closing on error
module.exports = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
    // 7.4.6 IteratorClose(iterator, completion)
  } catch (error) {
    var returnMethod = iterator['return'];
    if (returnMethod !== undefined) anObject(returnMethod.call(iterator));
    throw error;
  }
};

},{"../internals/an-object":426}],443:[function(require,module,exports){
"use strict";

require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
var wellKnownSymbol = require('../internals/well-known-symbol');
var ITERATOR = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;
try {
  var called = 0;
  var iteratorWithReturn = {
    next: function next() {
      return {
        done: !!called++
      };
    },
    'return': function _return() {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR] = function () {
    return this;
  };
  // eslint-disable-next-line no-throw-literal
  Array.from(iteratorWithReturn, function () {
    throw 2;
  });
} catch (error) {/* empty */}
module.exports = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR] = function () {
      return {
        next: function next() {
          return {
            done: ITERATION_SUPPORT = true
          };
        }
      };
    };
    exec(object);
  } catch (error) {/* empty */}
  return ITERATION_SUPPORT;
};

},{"../internals/well-known-symbol":564,"core-js/modules/es.array.from.js":575,"core-js/modules/es.string.iterator.js":626}],444:[function(require,module,exports){
"use strict";

require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.array.slice.js");
var toString = {}.toString;
module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{"core-js/modules/es.array.slice.js":580,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.to-string.js":620}],445:[function(require,module,exports){
"use strict";

var TO_STRING_TAG_SUPPORT = require('../internals/to-string-tag-support');
var classofRaw = require('../internals/classof-raw');
var wellKnownSymbol = require('../internals/well-known-symbol');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () {
  return arguments;
}()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function tryGet(it, key) {
  try {
    return it[key];
  } catch (error) {/* empty */}
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
  // @@toStringTag case
  : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag
  // builtinTag case
  : CORRECT_ARGUMENTS ? classofRaw(O)
  // ES3 arguments fallback
  : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
};

},{"../internals/classof-raw":444,"../internals/to-string-tag-support":557,"../internals/well-known-symbol":564}],446:[function(require,module,exports){
'use strict';

var defineProperty = require('../internals/object-define-property').f;
var create = require('../internals/object-create');
var redefineAll = require('../internals/redefine-all');
var bind = require('../internals/function-bind-context');
var anInstance = require('../internals/an-instance');
var iterate = require('../internals/iterate');
var defineIterator = require('../internals/define-iterator');
var setSpecies = require('../internals/set-species');
var DESCRIPTORS = require('../internals/descriptors');
var fastKey = require('../internals/internal-metadata').fastKey;
var InternalStateModule = require('../internals/internal-state');
var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;
module.exports = {
  getConstructor: function getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, CONSTRUCTOR_NAME);
      setInternalState(that, {
        type: CONSTRUCTOR_NAME,
        index: create(null),
        first: undefined,
        last: undefined,
        size: 0
      });
      if (!DESCRIPTORS) that.size = 0;
      if (iterable != undefined) iterate(iterable, that[ADDER], that, IS_MAP);
    });
    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
    var define = function define(that, key, value) {
      var state = getInternalState(that);
      var entry = getEntry(that, key);
      var previous, index;
      // change existing entry
      if (entry) {
        entry.value = value;
        // create new entry
      } else {
        state.last = entry = {
          index: index = fastKey(key, true),
          key: key,
          value: value,
          previous: previous = state.last,
          next: undefined,
          removed: false
        };
        if (!state.first) state.first = entry;
        if (previous) previous.next = entry;
        if (DESCRIPTORS) state.size++;else that.size++;
        // add to index
        if (index !== 'F') state.index[index] = entry;
      }
      return that;
    };
    var getEntry = function getEntry(that, key) {
      var state = getInternalState(that);
      // fast case
      var index = fastKey(key);
      var entry;
      if (index !== 'F') return state.index[index];
      // frozen object case
      for (entry = state.first; entry; entry = entry.next) {
        if (entry.key == key) return entry;
      }
    };
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        var that = this;
        var state = getInternalState(that);
        var data = state.index;
        var entry = state.first;
        while (entry) {
          entry.removed = true;
          if (entry.previous) entry.previous = entry.previous.next = undefined;
          delete data[entry.index];
          entry = entry.next;
        }
        state.first = state.last = undefined;
        if (DESCRIPTORS) state.size = 0;else that.size = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function _delete(key) {
        var that = this;
        var state = getInternalState(that);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.next;
          var prev = entry.previous;
          delete state.index[entry.index];
          entry.removed = true;
          if (prev) prev.next = next;
          if (next) next.previous = prev;
          if (state.first == entry) state.first = next;
          if (state.last == entry) state.last = prev;
          if (DESCRIPTORS) state.size--;else that.size--;
        }
        return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        var state = getInternalState(this);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.next : state.first) {
          boundFunction(entry.value, entry.key, this);
          // revert to the last existing entry
          while (entry && entry.removed) entry = entry.previous;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(this, key);
      }
    });
    redefineAll(C.prototype, IS_MAP ? {
      // 23.1.3.6 Map.prototype.get(key)
      get: function get(key) {
        var entry = getEntry(this, key);
        return entry && entry.value;
      },
      // 23.1.3.9 Map.prototype.set(key, value)
      set: function set(key, value) {
        return define(this, key === 0 ? 0 : key, value);
      }
    } : {
      // 23.2.3.1 Set.prototype.add(value)
      add: function add(value) {
        return define(this, value = value === 0 ? 0 : value, value);
      }
    });
    if (DESCRIPTORS) defineProperty(C.prototype, 'size', {
      get: function get() {
        return getInternalState(this).size;
      }
    });
    return C;
  },
  setStrong: function setStrong(C, CONSTRUCTOR_NAME, IS_MAP) {
    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    defineIterator(C, CONSTRUCTOR_NAME, function (iterated, kind) {
      setInternalState(this, {
        type: ITERATOR_NAME,
        target: iterated,
        state: getInternalCollectionState(iterated),
        kind: kind,
        last: undefined
      });
    }, function () {
      var state = getInternalIteratorState(this);
      var kind = state.kind;
      var entry = state.last;
      // revert to the last existing entry
      while (entry && entry.removed) entry = entry.previous;
      // get next entry
      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
        // or finish the iteration
        state.target = undefined;
        return {
          value: undefined,
          done: true
        };
      }
      // return step by kind
      if (kind == 'keys') return {
        value: entry.key,
        done: false
      };
      if (kind == 'values') return {
        value: entry.value,
        done: false
      };
      return {
        value: [entry.key, entry.value],
        done: false
      };
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(CONSTRUCTOR_NAME);
  }
};

},{"../internals/an-instance":425,"../internals/define-iterator":457,"../internals/descriptors":459,"../internals/function-bind-context":470,"../internals/internal-metadata":485,"../internals/internal-state":486,"../internals/iterate":494,"../internals/object-create":508,"../internals/object-define-property":510,"../internals/redefine-all":526,"../internals/set-species":535}],447:[function(require,module,exports){
'use strict';

require("core-js/modules/es.array.find.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.array.find-index.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.array.splice.js");
var redefineAll = require('../internals/redefine-all');
var getWeakData = require('../internals/internal-metadata').getWeakData;
var anObject = require('../internals/an-object');
var isObject = require('../internals/is-object');
var anInstance = require('../internals/an-instance');
var iterate = require('../internals/iterate');
var ArrayIterationModule = require('../internals/array-iteration');
var $has = require('../internals/has');
var InternalStateModule = require('../internals/internal-state');
var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;
var find = ArrayIterationModule.find;
var findIndex = ArrayIterationModule.findIndex;
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function uncaughtFrozenStore(store) {
  return store.frozen || (store.frozen = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function UncaughtFrozenStore() {
  this.entries = [];
};
var findUncaughtFrozen = function findUncaughtFrozen(store, key) {
  return find(store.entries, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function get(key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function has(key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function set(key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;else this.entries.push([key, value]);
  },
  'delete': function _delete(key) {
    var index = findIndex(this.entries, function (it) {
      return it[0] === key;
    });
    if (~index) this.entries.splice(index, 1);
    return !!~index;
  }
};
module.exports = {
  getConstructor: function getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, CONSTRUCTOR_NAME);
      setInternalState(that, {
        type: CONSTRUCTOR_NAME,
        id: id++,
        frozen: undefined
      });
      if (iterable != undefined) iterate(iterable, that[ADDER], that, IS_MAP);
    });
    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
    var define = function define(that, key, value) {
      var state = getInternalState(that);
      var data = getWeakData(anObject(key), true);
      if (data === true) uncaughtFrozenStore(state).set(key, value);else data[state.id] = value;
      return that;
    };
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function _delete(key) {
        var state = getInternalState(this);
        if (!isObject(key)) return false;
        var data = getWeakData(key);
        if (data === true) return uncaughtFrozenStore(state)['delete'](key);
        return data && $has(data, state.id) && delete data[state.id];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        var state = getInternalState(this);
        if (!isObject(key)) return false;
        var data = getWeakData(key);
        if (data === true) return uncaughtFrozenStore(state).has(key);
        return data && $has(data, state.id);
      }
    });
    redefineAll(C.prototype, IS_MAP ? {
      // 23.3.3.3 WeakMap.prototype.get(key)
      get: function get(key) {
        var state = getInternalState(this);
        if (isObject(key)) {
          var data = getWeakData(key);
          if (data === true) return uncaughtFrozenStore(state).get(key);
          return data ? data[state.id] : undefined;
        }
      },
      // 23.3.3.5 WeakMap.prototype.set(key, value)
      set: function set(key, value) {
        return define(this, key, value);
      }
    } : {
      // 23.4.3.1 WeakSet.prototype.add(value)
      add: function add(value) {
        return define(this, value, true);
      }
    });
    return C;
  }
};

},{"../internals/an-instance":425,"../internals/an-object":426,"../internals/array-iteration":435,"../internals/has":476,"../internals/internal-metadata":485,"../internals/internal-state":486,"../internals/is-object":491,"../internals/iterate":494,"../internals/redefine-all":526,"core-js/modules/es.array.find-index.js":573,"core-js/modules/es.array.find.js":574,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.splice.js":582,"core-js/modules/es.object.to-string.js":612,"core-js/modules/web.dom-collections.iterator.js":677}],448:[function(require,module,exports){
'use strict';

require("core-js/modules/es.object.to-string.js");
require("core-js/modules/web.dom-collections.for-each.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
var $ = require('../internals/export');
var global = require('../internals/global');
var isForced = require('../internals/is-forced');
var redefine = require('../internals/redefine');
var InternalMetadataModule = require('../internals/internal-metadata');
var iterate = require('../internals/iterate');
var anInstance = require('../internals/an-instance');
var isObject = require('../internals/is-object');
var fails = require('../internals/fails');
var checkCorrectnessOfIteration = require('../internals/check-correctness-of-iteration');
var setToStringTag = require('../internals/set-to-string-tag');
var inheritIfRequired = require('../internals/inherit-if-required');
module.exports = function (CONSTRUCTOR_NAME, wrapper, common) {
  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
  var ADDER = IS_MAP ? 'set' : 'add';
  var NativeConstructor = global[CONSTRUCTOR_NAME];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  var Constructor = NativeConstructor;
  var exported = {};
  var fixMethod = function fixMethod(KEY) {
    var nativeMethod = NativePrototype[KEY];
    redefine(NativePrototype, KEY, KEY == 'add' ? function add(value) {
      nativeMethod.call(this, value === 0 ? 0 : value);
      return this;
    } : KEY == 'delete' ? function (key) {
      return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
    } : KEY == 'get' ? function get(key) {
      return IS_WEAK && !isObject(key) ? undefined : nativeMethod.call(this, key === 0 ? 0 : key);
    } : KEY == 'has' ? function has(key) {
      return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
    } : function set(key, value) {
      nativeMethod.call(this, key === 0 ? 0 : key, value);
      return this;
    });
  };

  // eslint-disable-next-line max-len
  if (isForced(CONSTRUCTOR_NAME, typeof NativeConstructor != 'function' || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
    new NativeConstructor().entries().next();
  })))) {
    // create collection constructor
    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
    InternalMetadataModule.REQUIRED = true;
  } else if (isForced(CONSTRUCTOR_NAME, true)) {
    var instance = new Constructor();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () {
      instance.has(1);
    });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    // eslint-disable-next-line no-new
    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) {
      new NativeConstructor(iterable);
    });
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new NativeConstructor();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      Constructor = wrapper(function (dummy, iterable) {
        anInstance(dummy, Constructor, CONSTRUCTOR_NAME);
        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
        if (iterable != undefined) iterate(iterable, that[ADDER], that, IS_MAP);
        return that;
      });
      Constructor.prototype = NativePrototype;
      NativePrototype.constructor = Constructor;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);

    // weak collections should not contains .clear method
    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
  }
  exported[CONSTRUCTOR_NAME] = Constructor;
  $({
    global: true,
    forced: Constructor != NativeConstructor
  }, exported);
  setToStringTag(Constructor, CONSTRUCTOR_NAME);
  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
  return Constructor;
};

},{"../internals/an-instance":425,"../internals/check-correctness-of-iteration":443,"../internals/export":466,"../internals/fails":467,"../internals/global":475,"../internals/inherit-if-required":483,"../internals/internal-metadata":485,"../internals/is-forced":489,"../internals/is-object":491,"../internals/iterate":494,"../internals/redefine":527,"../internals/set-to-string-tag":536,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.object.to-string.js":612,"core-js/modules/web.dom-collections.for-each.js":676,"core-js/modules/web.dom-collections.iterator.js":677}],449:[function(require,module,exports){
"use strict";

var has = require('../internals/has');
var ownKeys = require('../internals/own-keys');
var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
var definePropertyModule = require('../internals/object-define-property');
module.exports = function (target, source) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};

},{"../internals/has":476,"../internals/object-define-property":510,"../internals/object-get-own-property-descriptor":511,"../internals/own-keys":522}],450:[function(require,module,exports){
"use strict";

var wellKnownSymbol = require('../internals/well-known-symbol');
var MATCH = wellKnownSymbol('match');
module.exports = function (METHOD_NAME) {
  var regexp = /./;
  try {
    '/./'[METHOD_NAME](regexp);
  } catch (e) {
    try {
      regexp[MATCH] = false;
      return '/./'[METHOD_NAME](regexp);
    } catch (f) {/* empty */}
  }
  return false;
};

},{"../internals/well-known-symbol":564}],451:[function(require,module,exports){
"use strict";

require("core-js/modules/es.object.get-prototype-of.js");
var fails = require('../internals/fails');
module.exports = !fails(function () {
  function F() {/* empty */}
  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});

},{"../internals/fails":467,"core-js/modules/es.object.get-prototype-of.js":606}],452:[function(require,module,exports){
'use strict';

var IteratorPrototype = require('../internals/iterators-core').IteratorPrototype;
var create = require('../internals/object-create');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
var setToStringTag = require('../internals/set-to-string-tag');
var Iterators = require('../internals/iterators');
var returnThis = function returnThis() {
  return this;
};
module.exports = function (IteratorConstructor, NAME, next) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype, {
    next: createPropertyDescriptor(1, next)
  });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};

},{"../internals/create-property-descriptor":454,"../internals/iterators":496,"../internals/iterators-core":495,"../internals/object-create":508,"../internals/set-to-string-tag":536}],453:[function(require,module,exports){
"use strict";

var DESCRIPTORS = require('../internals/descriptors');
var definePropertyModule = require('../internals/object-define-property');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"../internals/create-property-descriptor":454,"../internals/descriptors":459,"../internals/object-define-property":510}],454:[function(require,module,exports){
"use strict";

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],455:[function(require,module,exports){
'use strict';

var toPrimitive = require('../internals/to-primitive');
var definePropertyModule = require('../internals/object-define-property');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
module.exports = function (object, key, value) {
  var propertyKey = toPrimitive(key);
  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));else object[propertyKey] = value;
};

},{"../internals/create-property-descriptor":454,"../internals/object-define-property":510,"../internals/to-primitive":556}],456:[function(require,module,exports){
'use strict';

var anObject = require('../internals/an-object');
var toPrimitive = require('../internals/to-primitive');
module.exports = function (hint) {
  if (hint !== 'string' && hint !== 'number' && hint !== 'default') {
    throw TypeError('Incorrect hint');
  }
  return toPrimitive(anObject(this), hint !== 'number');
};

},{"../internals/an-object":426,"../internals/to-primitive":556}],457:[function(require,module,exports){
'use strict';

require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.function.name.js");
var $ = require('../internals/export');
var createIteratorConstructor = require('../internals/create-iterator-constructor');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var setPrototypeOf = require('../internals/object-set-prototype-of');
var setToStringTag = require('../internals/set-to-string-tag');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var redefine = require('../internals/redefine');
var wellKnownSymbol = require('../internals/well-known-symbol');
var IS_PURE = require('../internals/is-pure');
var Iterators = require('../internals/iterators');
var IteratorsCore = require('../internals/iterators-core');
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';
var returnThis = function returnThis() {
  return this;
};
module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);
  var getIterationMethod = function getIterationMethod(KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS:
        return function keys() {
          return new IteratorConstructor(this, KIND);
        };
      case VALUES:
        return function values() {
          return new IteratorConstructor(this, KIND);
        };
      case ENTRIES:
        return function entries() {
          return new IteratorConstructor(this, KIND);
        };
    }
    return function () {
      return new IteratorConstructor(this);
    };
  };
  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') {
          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
    }
  }

  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    INCORRECT_VALUES_NAME = true;
    defaultIterator = function values() {
      return nativeIterator.call(this);
    };
  }

  // define iterator
  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
    createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
  }
  Iterators[NAME] = defaultIterator;

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        redefine(IterablePrototype, KEY, methods[KEY]);
      }
    } else $({
      target: NAME,
      proto: true,
      forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
    }, methods);
  }
  return methods;
};

},{"../internals/create-iterator-constructor":452,"../internals/create-non-enumerable-property":453,"../internals/export":466,"../internals/is-pure":492,"../internals/iterators":496,"../internals/iterators-core":495,"../internals/object-get-prototype-of":515,"../internals/object-set-prototype-of":519,"../internals/redefine":527,"../internals/set-to-string-tag":536,"../internals/well-known-symbol":564,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.to-string.js":612,"core-js/modules/web.dom-collections.iterator.js":677}],458:[function(require,module,exports){
"use strict";

var path = require('../internals/path');
var has = require('../internals/has');
var wrappedWellKnownSymbolModule = require('../internals/well-known-symbol-wrapped');
var defineProperty = require('../internals/object-define-property').f;
module.exports = function (NAME) {
  var _Symbol = path.Symbol || (path.Symbol = {});
  if (!has(_Symbol, NAME)) defineProperty(_Symbol, NAME, {
    value: wrappedWellKnownSymbolModule.f(NAME)
  });
};

},{"../internals/has":476,"../internals/object-define-property":510,"../internals/path":523,"../internals/well-known-symbol-wrapped":563}],459:[function(require,module,exports){
"use strict";

var fails = require('../internals/fails');

// Thank's IE8 for his funny defineProperty
module.exports = !fails(function () {
  return Object.defineProperty({}, 1, {
    get: function get() {
      return 7;
    }
  })[1] != 7;
});

},{"../internals/fails":467}],460:[function(require,module,exports){
"use strict";

var global = require('../internals/global');
var isObject = require('../internals/is-object');
var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};

},{"../internals/global":475,"../internals/is-object":491}],461:[function(require,module,exports){
"use strict";

// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};

},{}],462:[function(require,module,exports){
"use strict";

require("core-js/modules/es.regexp.exec.js");
var userAgent = require('../internals/engine-user-agent');
module.exports = /(iphone|ipod|ipad).*applewebkit/i.test(userAgent);

},{"../internals/engine-user-agent":463,"core-js/modules/es.regexp.exec.js":618}],463:[function(require,module,exports){
"use strict";

var getBuiltIn = require('../internals/get-built-in');
module.exports = getBuiltIn('navigator', 'userAgent') || '';

},{"../internals/get-built-in":472}],464:[function(require,module,exports){
"use strict";

require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.match.js");
var global = require('../internals/global');
var userAgent = require('../internals/engine-user-agent');
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8;
var match, version;
if (v8) {
  match = v8.split('.');
  version = match[0] + match[1];
} else if (userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = match[1];
  }
}
module.exports = version && +version;

},{"../internals/engine-user-agent":463,"../internals/global":475,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.string.match.js":627}],465:[function(require,module,exports){
"use strict";

// IE8- don't enum bug keys
module.exports = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];

},{}],466:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var global = require('../internals/global');
var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var redefine = require('../internals/redefine');
var setGlobal = require('../internals/set-global');
var copyConstructorProperties = require('../internals/copy-constructor-properties');
var isForced = require('../internals/is-forced');

/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if ((0, _typeof2.default)(sourceProperty) === (0, _typeof2.default)(targetProperty)) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || targetProperty && targetProperty.sham) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    // extend global
    redefine(target, key, sourceProperty, options);
  }
};

},{"../internals/copy-constructor-properties":449,"../internals/create-non-enumerable-property":453,"../internals/global":475,"../internals/is-forced":489,"../internals/object-get-own-property-descriptor":511,"../internals/redefine":527,"../internals/set-global":534,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252}],467:[function(require,module,exports){
"use strict";

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};

},{}],468:[function(require,module,exports){
'use strict';

// TODO: Remove from `core-js@4` since it's moved to entry points
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.string.split.js");
require("core-js/modules/es.regexp.flags.js");
require("core-js/modules/es.regexp.constructor.js");
require("core-js/modules/es.regexp.to-string.js");
require('../modules/es.regexp.exec');
var redefine = require('../internals/redefine');
var fails = require('../internals/fails');
var wellKnownSymbol = require('../internals/well-known-symbol');
var regexpExec = require('../internals/regexp-exec');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var SPECIES = wellKnownSymbol('species');
var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = {
      a: '7'
    };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

// IE <= 11 replaces $0 with the whole match, as if it was $&
// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
var REPLACE_KEEPS_$0 = function () {
  return 'a'.replace(/./, '$0') === '$0';
}();
var REPLACE = wellKnownSymbol('replace');
// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function () {
  if (/./[REPLACE]) {
    return /./[REPLACE]('a', '$0') === '';
  }
  return false;
}();

// Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
// Weex JS has frozen built-in prototypes, so use try / catch wrapper
var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () {
    return originalExec.apply(this, arguments);
  };
  var result = 'ab'.split(re);
  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
});
module.exports = function (KEY, length, exec, sham) {
  var SYMBOL = wellKnownSymbol(KEY);
  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () {
      return 7;
    };
    return ''[KEY](O) != 7;
  });
  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;
    if (KEY === 'split') {
      // We can't use real regex here since it causes deoptimization
      // and serious performance degradation in V8
      // https://github.com/zloirock/core-js/issues/306
      re = {};
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () {
        return re;
      };
      re.flags = '';
      re[SYMBOL] = /./[SYMBOL];
    }
    re.exec = function () {
      execCalled = true;
      return null;
    };
    re[SYMBOL]('');
    return !execCalled;
  });
  if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === 'replace' && !(REPLACE_SUPPORTS_NAMED_GROUPS && REPLACE_KEEPS_$0 && !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE) || KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
    var nativeRegExpMethod = /./[SYMBOL];
    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
      if (regexp.exec === regexpExec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return {
            done: true,
            value: nativeRegExpMethod.call(regexp, str, arg2)
          };
        }
        return {
          done: true,
          value: nativeMethod.call(str, regexp, arg2)
        };
      }
      return {
        done: false
      };
    }, {
      REPLACE_KEEPS_$0: REPLACE_KEEPS_$0,
      REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
    });
    var stringMethod = methods[0];
    var regexMethod = methods[1];
    redefine(String.prototype, KEY, stringMethod);
    redefine(RegExp.prototype, SYMBOL, length == 2
    // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
    // 21.2.5.11 RegExp.prototype[@@split](string, limit)
    ? function (string, arg) {
      return regexMethod.call(string, this, arg);
    }
    // 21.2.5.6 RegExp.prototype[@@match](string)
    // 21.2.5.9 RegExp.prototype[@@search](string)
    : function (string) {
      return regexMethod.call(string, this);
    });
  }
  if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], 'sham', true);
};

},{"../internals/create-non-enumerable-property":453,"../internals/fails":467,"../internals/redefine":527,"../internals/regexp-exec":529,"../internals/well-known-symbol":564,"../modules/es.regexp.exec":618,"core-js/modules/es.regexp.constructor.js":617,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.flags.js":619,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.replace.js":629,"core-js/modules/es.string.split.js":631}],469:[function(require,module,exports){
"use strict";

require("core-js/modules/es.object.is-extensible.js");
require("core-js/modules/es.object.prevent-extensions.js");
var fails = require('../internals/fails');
module.exports = !fails(function () {
  return Object.isExtensible(Object.preventExtensions({}));
});

},{"../internals/fails":467,"core-js/modules/es.object.is-extensible.js":607,"core-js/modules/es.object.prevent-extensions.js":610}],470:[function(require,module,exports){
"use strict";

var aFunction = require('../internals/a-function');

// optional / simple context binding
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 0:
      return function () {
        return fn.call(that);
      };
    case 1:
      return function (a) {
        return fn.call(that, a);
      };
    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };
    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }
  return function /* ...args */
  () {
    return fn.apply(that, arguments);
  };
};

},{"../internals/a-function":421}],471:[function(require,module,exports){
'use strict';

require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.array.join.js");
require("core-js/modules/es.array.concat.js");
var aFunction = require('../internals/a-function');
var isObject = require('../internals/is-object');
var slice = [].slice;
var factories = {};
var construct = function construct(C, argsLength, args) {
  if (!(argsLength in factories)) {
    for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[argsLength] = Function('C,a', 'return new C(' + list.join(',') + ')');
  }
  return factories[argsLength](C, args);
};

// `Function.prototype.bind` method implementation
// https://tc39.github.io/ecma262/#sec-function.prototype.bind
module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = slice.call(arguments, 1);
  var boundFunction = function bound( /* args... */
  ) {
    var args = partArgs.concat(slice.call(arguments));
    return this instanceof boundFunction ? construct(fn, args.length, args) : fn.apply(that, args);
  };
  if (isObject(fn.prototype)) boundFunction.prototype = fn.prototype;
  return boundFunction;
};

},{"../internals/a-function":421,"../internals/is-object":491,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.array.join.js":578,"core-js/modules/es.array.slice.js":580}],472:[function(require,module,exports){
"use strict";

var path = require('../internals/path');
var global = require('../internals/global');
var aFunction = function aFunction(variable) {
  return typeof variable == 'function' ? variable : undefined;
};
module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace]) : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
};

},{"../internals/global":475,"../internals/path":523}],473:[function(require,module,exports){
"use strict";

var classof = require('../internals/classof');
var Iterators = require('../internals/iterators');
var wellKnownSymbol = require('../internals/well-known-symbol');
var ITERATOR = wellKnownSymbol('iterator');
module.exports = function (it) {
  if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
};

},{"../internals/classof":445,"../internals/iterators":496,"../internals/well-known-symbol":564}],474:[function(require,module,exports){
"use strict";

var anObject = require('../internals/an-object');
var getIteratorMethod = require('../internals/get-iterator-method');
module.exports = function (it) {
  var iteratorMethod = getIteratorMethod(it);
  if (typeof iteratorMethod != 'function') {
    throw TypeError(String(it) + ' is not iterable');
  }
  return anObject(iteratorMethod.call(it));
};

},{"../internals/an-object":426,"../internals/get-iterator-method":473}],475:[function(require,module,exports){
(function (global){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/esnext.global-this.js");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var check = function check(it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
// eslint-disable-next-line no-undef
check((typeof globalThis === "undefined" ? "undefined" : (0, _typeof2.default)(globalThis)) == 'object' && globalThis) || check((typeof window === "undefined" ? "undefined" : (0, _typeof2.default)(window)) == 'object' && window) || check((typeof self === "undefined" ? "undefined" : (0, _typeof2.default)(self)) == 'object' && self) || check((typeof global === "undefined" ? "undefined" : (0, _typeof2.default)(global)) == 'object' && global) ||
// eslint-disable-next-line no-new-func
Function('return this')();

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/esnext.global-this.js":675}],476:[function(require,module,exports){
"use strict";

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],477:[function(require,module,exports){
"use strict";

module.exports = {};

},{}],478:[function(require,module,exports){
"use strict";

var global = require('../internals/global');
module.exports = function (a, b) {
  var console = global.console;
  if (console && console.error) {
    arguments.length === 1 ? console.error(a) : console.error(a, b);
  }
};

},{"../internals/global":475}],479:[function(require,module,exports){
"use strict";

var getBuiltIn = require('../internals/get-built-in');
module.exports = getBuiltIn('document', 'documentElement');

},{"../internals/get-built-in":472}],480:[function(require,module,exports){
"use strict";

var DESCRIPTORS = require('../internals/descriptors');
var fails = require('../internals/fails');
var createElement = require('../internals/document-create-element');

// Thank's IE8 for his funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  return Object.defineProperty(createElement('div'), 'a', {
    get: function get() {
      return 7;
    }
  }).a != 7;
});

},{"../internals/descriptors":459,"../internals/document-create-element":460,"../internals/fails":467}],481:[function(require,module,exports){
"use strict";

// IEEE754 conversions based on https://github.com/feross/ieee754
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = 1 / 0;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var pack = function pack(number, mantissaLength, bytes) {
  var buffer = new Array(bytes);
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
  var index = 0;
  var exponent, mantissa, c;
  number = abs(number);
  // eslint-disable-next-line no-self-compare
  if (number != number || number === Infinity) {
    // eslint-disable-next-line no-self-compare
    mantissa = number != number ? 1 : 0;
    exponent = eMax;
  } else {
    exponent = floor(log(number) / LN2);
    if (number * (c = pow(2, -exponent)) < 1) {
      exponent--;
      c *= 2;
    }
    if (exponent + eBias >= 1) {
      number += rt / c;
    } else {
      number += rt * pow(2, 1 - eBias);
    }
    if (number * c >= 2) {
      exponent++;
      c /= 2;
    }
    if (exponent + eBias >= eMax) {
      mantissa = 0;
      exponent = eMax;
    } else if (exponent + eBias >= 1) {
      mantissa = (number * c - 1) * pow(2, mantissaLength);
      exponent = exponent + eBias;
    } else {
      mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
      exponent = 0;
    }
  }
  for (; mantissaLength >= 8; buffer[index++] = mantissa & 255, mantissa /= 256, mantissaLength -= 8);
  exponent = exponent << mantissaLength | mantissa;
  exponentLength += mantissaLength;
  for (; exponentLength > 0; buffer[index++] = exponent & 255, exponent /= 256, exponentLength -= 8);
  buffer[--index] |= sign * 128;
  return buffer;
};
var unpack = function unpack(buffer, mantissaLength) {
  var bytes = buffer.length;
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var nBits = exponentLength - 7;
  var index = bytes - 1;
  var sign = buffer[index--];
  var exponent = sign & 127;
  var mantissa;
  sign >>= 7;
  for (; nBits > 0; exponent = exponent * 256 + buffer[index], index--, nBits -= 8);
  mantissa = exponent & (1 << -nBits) - 1;
  exponent >>= -nBits;
  nBits += mantissaLength;
  for (; nBits > 0; mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8);
  if (exponent === 0) {
    exponent = 1 - eBias;
  } else if (exponent === eMax) {
    return mantissa ? NaN : sign ? -Infinity : Infinity;
  } else {
    mantissa = mantissa + pow(2, mantissaLength);
    exponent = exponent - eBias;
  }
  return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
};
module.exports = {
  pack: pack,
  unpack: unpack
};

},{}],482:[function(require,module,exports){
"use strict";

require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.split.js");
var fails = require('../internals/fails');
var classof = require('../internals/classof-raw');
var split = ''.split;

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;

},{"../internals/classof-raw":444,"../internals/fails":467,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.string.split.js":631}],483:[function(require,module,exports){
"use strict";

var isObject = require('../internals/is-object');
var setPrototypeOf = require('../internals/object-set-prototype-of');

// makes subclassing work correct for wrapped built-ins
module.exports = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
  // it can work only with native `setPrototypeOf`
  setPrototypeOf &&
  // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
  typeof (NewTarget = dummy.constructor) == 'function' && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype) setPrototypeOf($this, NewTargetPrototype);
  return $this;
};

},{"../internals/is-object":491,"../internals/object-set-prototype-of":519}],484:[function(require,module,exports){
"use strict";

require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
var store = require('../internals/shared-store');
var functionToString = Function.toString;

// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
if (typeof store.inspectSource != 'function') {
  store.inspectSource = function (it) {
    return functionToString.call(it);
  };
}
module.exports = store.inspectSource;

},{"../internals/shared-store":538,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.to-string.js":620}],485:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.is-extensible.js");
var hiddenKeys = require('../internals/hidden-keys');
var isObject = require('../internals/is-object');
var has = require('../internals/has');
var defineProperty = require('../internals/object-define-property').f;
var uid = require('../internals/uid');
var FREEZING = require('../internals/freezing');
var METADATA = uid('meta');
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var setMetadata = function setMetadata(it) {
  defineProperty(it, METADATA, {
    value: {
      objectID: 'O' + ++id,
      // object ID
      weakData: {} // weak collections IDs
    }
  });
};

var fastKey = function fastKey(it, create) {
  // return a primitive with prefix
  if (!isObject(it)) return (0, _typeof2.default)(it) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMetadata(it);
    // return object ID
  }
  return it[METADATA].objectID;
};
var getWeakData = function getWeakData(it, create) {
  if (!has(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMetadata(it);
    // return the store of weak collections IDs
  }
  return it[METADATA].weakData;
};

// add metadata on freeze-family methods calling
var onFreeze = function onFreeze(it) {
  if (FREEZING && meta.REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it);
  return it;
};
var meta = module.exports = {
  REQUIRED: false,
  fastKey: fastKey,
  getWeakData: getWeakData,
  onFreeze: onFreeze
};
hiddenKeys[METADATA] = true;

},{"../internals/freezing":469,"../internals/has":476,"../internals/hidden-keys":477,"../internals/is-object":491,"../internals/object-define-property":510,"../internals/uid":561,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.is-extensible.js":607}],486:[function(require,module,exports){
"use strict";

var NATIVE_WEAK_MAP = require('../internals/native-weak-map');
var global = require('../internals/global');
var isObject = require('../internals/is-object');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var objectHas = require('../internals/has');
var sharedKey = require('../internals/shared-key');
var hiddenKeys = require('../internals/hidden-keys');
var WeakMap = global.WeakMap;
var set, get, has;
var enforce = function enforce(it) {
  return has(it) ? get(it) : set(it, {});
};
var getterFor = function getterFor(TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    }
    return state;
  };
};
if (NATIVE_WEAK_MAP) {
  var store = new WeakMap();
  var wmget = store.get;
  var wmhas = store.has;
  var wmset = store.set;
  set = function set(it, metadata) {
    wmset.call(store, it, metadata);
    return metadata;
  };
  get = function get(it) {
    return wmget.call(store, it) || {};
  };
  has = function has(it) {
    return wmhas.call(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function set(it, metadata) {
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function get(it) {
    return objectHas(it, STATE) ? it[STATE] : {};
  };
  has = function has(it) {
    return objectHas(it, STATE);
  };
}
module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};

},{"../internals/create-non-enumerable-property":453,"../internals/global":475,"../internals/has":476,"../internals/hidden-keys":477,"../internals/is-object":491,"../internals/native-weak-map":502,"../internals/shared-key":537}],487:[function(require,module,exports){
"use strict";

var wellKnownSymbol = require('../internals/well-known-symbol');
var Iterators = require('../internals/iterators');
var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};

},{"../internals/iterators":496,"../internals/well-known-symbol":564}],488:[function(require,module,exports){
"use strict";

var classof = require('../internals/classof-raw');

// `IsArray` abstract operation
// https://tc39.github.io/ecma262/#sec-isarray
module.exports = Array.isArray || function isArray(arg) {
  return classof(arg) == 'Array';
};

},{"../internals/classof-raw":444}],489:[function(require,module,exports){
"use strict";

require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
var fails = require('../internals/fails');
var replacement = /#|\.prototype\./;
var isForced = function isForced(feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == 'function' ? fails(detection) : !!detection;
};
var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};
var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';
module.exports = isForced;

},{"../internals/fails":467,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.string.replace.js":629}],490:[function(require,module,exports){
"use strict";

var isObject = require('../internals/is-object');
var floor = Math.floor;

// `Number.isInteger` method implementation
// https://tc39.github.io/ecma262/#sec-number.isinteger
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};

},{"../internals/is-object":491}],491:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
module.exports = function (it) {
  return (0, _typeof2.default)(it) === 'object' ? it !== null : typeof it === 'function';
};

},{"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252}],492:[function(require,module,exports){
"use strict";

module.exports = false;

},{}],493:[function(require,module,exports){
"use strict";

var isObject = require('../internals/is-object');
var classof = require('../internals/classof-raw');
var wellKnownSymbol = require('../internals/well-known-symbol');
var MATCH = wellKnownSymbol('match');

// `IsRegExp` abstract operation
// https://tc39.github.io/ecma262/#sec-isregexp
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');
};

},{"../internals/classof-raw":444,"../internals/is-object":491,"../internals/well-known-symbol":564}],494:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var anObject = require('../internals/an-object');
var isArrayIteratorMethod = require('../internals/is-array-iterator-method');
var toLength = require('../internals/to-length');
var bind = require('../internals/function-bind-context');
var getIteratorMethod = require('../internals/get-iterator-method');
var callWithSafeIterationClosing = require('../internals/call-with-safe-iteration-closing');
var Result = function Result(stopped, result) {
  this.stopped = stopped;
  this.result = result;
};
var iterate = module.exports = function (iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
  var boundFunction = bind(fn, that, AS_ENTRIES ? 2 : 1);
  var iterator, iterFn, index, length, result, next, step;
  if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (typeof iterFn != 'function') throw TypeError('Target is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = toLength(iterable.length); length > index; index++) {
        result = AS_ENTRIES ? boundFunction(anObject(step = iterable[index])[0], step[1]) : boundFunction(iterable[index]);
        if (result && result instanceof Result) return result;
      }
      return new Result(false);
    }
    iterator = iterFn.call(iterable);
  }
  next = iterator.next;
  while (!(step = next.call(iterator)).done) {
    result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);
    if ((0, _typeof2.default)(result) == 'object' && result && result instanceof Result) return result;
  }
  return new Result(false);
};
iterate.stop = function (result) {
  return new Result(true, result);
};

},{"../internals/an-object":426,"../internals/call-with-safe-iteration-closing":442,"../internals/function-bind-context":470,"../internals/get-iterator-method":473,"../internals/is-array-iterator-method":487,"../internals/to-length":552,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252}],495:[function(require,module,exports){
'use strict';

require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.object.to-string.js");
var getPrototypeOf = require('../internals/object-get-prototype-of');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var has = require('../internals/has');
var wellKnownSymbol = require('../internals/well-known-symbol');
var IS_PURE = require('../internals/is-pure');
var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;
var returnThis = function returnThis() {
  return this;
};

// `%IteratorPrototype%` object
// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}
if (IteratorPrototype == undefined) IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
if (!IS_PURE && !has(IteratorPrototype, ITERATOR)) {
  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
}
module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};

},{"../internals/create-non-enumerable-property":453,"../internals/has":476,"../internals/is-pure":492,"../internals/object-get-prototype-of":515,"../internals/well-known-symbol":564,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.object.to-string.js":612}],496:[function(require,module,exports){
"use strict";

module.exports = {};

},{}],497:[function(require,module,exports){
"use strict";

require("core-js/modules/es.math.sign.js");
// `Math.sign` method implementation
// https://tc39.github.io/ecma262/#sec-math.sign
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

},{"core-js/modules/es.math.sign.js":590}],498:[function(require,module,exports){
"use strict";

var global = require('../internals/global');
var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
var classof = require('../internals/classof-raw');
var macrotask = require('../internals/task').set;
var IS_IOS = require('../internals/engine-is-ios');
var MutationObserver = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var IS_NODE = classof(process) == 'process';
// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global, 'queueMicrotask');
var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
var flush, head, last, notify, toggle, node, promise, then;

// modern engines have queueMicrotask method
if (!queueMicrotask) {
  flush = function flush() {
    var parent, fn;
    if (IS_NODE && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (error) {
        if (head) notify();else last = undefined;
        throw error;
      }
    }
    last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (IS_NODE) {
    notify = function notify() {
      process.nextTick(flush);
    };
    // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
  } else if (MutationObserver && !IS_IOS) {
    toggle = true;
    node = document.createTextNode('');
    new MutationObserver(flush).observe(node, {
      characterData: true
    });
    notify = function notify() {
      node.data = toggle = !toggle;
    };
    // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    promise = Promise.resolve(undefined);
    then = promise.then;
    notify = function notify() {
      then.call(promise, flush);
    };
    // for other environments - macrotask based on:
    // - setImmediate
    // - MessageChannel
    // - window.postMessag
    // - onreadystatechange
    // - setTimeout
  } else {
    notify = function notify() {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }
}
module.exports = queueMicrotask || function (fn) {
  var task = {
    fn: fn,
    next: undefined
  };
  if (last) last.next = task;
  if (!head) {
    head = task;
    notify();
  }
  last = task;
};

},{"../internals/classof-raw":444,"../internals/engine-is-ios":462,"../internals/global":475,"../internals/object-get-own-property-descriptor":511,"../internals/task":546}],499:[function(require,module,exports){
"use strict";

var global = require('../internals/global');
module.exports = global.Promise;

},{"../internals/global":475}],500:[function(require,module,exports){
"use strict";

require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.object.to-string.js");
var fails = require('../internals/fails');
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  // Chrome 38 Symbol has incorrect toString conversion
  // eslint-disable-next-line no-undef
  return !String(Symbol());
});

},{"../internals/fails":467,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.js":638}],501:[function(require,module,exports){
"use strict";

require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/web.url.js");
require("core-js/modules/web.url-search-params.js");
require("core-js/modules/web.dom-collections.for-each.js");
require("core-js/modules/web.url.to-json.js");
require("core-js/modules/es.array.sort.js");
var fails = require('../internals/fails');
var wellKnownSymbol = require('../internals/well-known-symbol');
var IS_PURE = require('../internals/is-pure');
var ITERATOR = wellKnownSymbol('iterator');
module.exports = !fails(function () {
  var url = new URL('b?a=1&b=2&c=3', 'http://a');
  var searchParams = url.searchParams;
  var result = '';
  url.pathname = 'c%20d';
  searchParams.forEach(function (value, key) {
    searchParams['delete']('b');
    result += key + value;
  });
  return IS_PURE && !url.toJSON || !searchParams.sort || url.href !== 'http://a/c%20d?a=1&c=3' || searchParams.get('c') !== '3' || String(new URLSearchParams('?a=1')) !== 'a=1' || !searchParams[ITERATOR]
  // throws in Edge
  || new URL('https://a@b').username !== 'a' || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b'
  // not punycoded in Edge
  || new URL('http://').host !== 'xn--e1aybc'
  // not escaped in Chrome 62-
  || new URL('http://a#').hash !== '#%D0%B1'
  // fails in Chrome 66-
  || result !== 'a1c3'
  // throws in Safari
  || new URL('http://x', undefined).host !== 'x';
});

},{"../internals/fails":467,"../internals/is-pure":492,"../internals/well-known-symbol":564,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.sort.js":581,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.string.iterator.js":626,"core-js/modules/web.dom-collections.for-each.js":676,"core-js/modules/web.dom-collections.iterator.js":677,"core-js/modules/web.url-search-params.js":678,"core-js/modules/web.url.js":679,"core-js/modules/web.url.to-json.js":680}],502:[function(require,module,exports){
"use strict";

require("core-js/modules/es.regexp.exec.js");
var global = require('../internals/global');
var inspectSource = require('../internals/inspect-source');
var WeakMap = global.WeakMap;
module.exports = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));

},{"../internals/global":475,"../internals/inspect-source":484,"core-js/modules/es.regexp.exec.js":618}],503:[function(require,module,exports){
'use strict';

var aFunction = require('../internals/a-function');
var PromiseCapability = function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
};

// 25.4.1.5 NewPromiseCapability(C)
module.exports.f = function (C) {
  return new PromiseCapability(C);
};

},{"../internals/a-function":421}],504:[function(require,module,exports){
"use strict";

var isRegExp = require('../internals/is-regexp');
module.exports = function (it) {
  if (isRegExp(it)) {
    throw TypeError("The method doesn't accept regular expressions");
  }
  return it;
};

},{"../internals/is-regexp":493}],505:[function(require,module,exports){
"use strict";

require("core-js/modules/es.string.trim.js");
var global = require('../internals/global');
var trim = require('../internals/string-trim').trim;
var whitespaces = require('../internals/whitespaces');
var $parseFloat = global.parseFloat;
var FORCED = 1 / $parseFloat(whitespaces + '-0') !== -Infinity;

// `parseFloat` method
// https://tc39.github.io/ecma262/#sec-parsefloat-string
module.exports = FORCED ? function parseFloat(string) {
  var trimmedString = trim(String(string));
  var result = $parseFloat(trimmedString);
  return result === 0 && trimmedString.charAt(0) == '-' ? -0 : result;
} : $parseFloat;

},{"../internals/global":475,"../internals/string-trim":545,"../internals/whitespaces":565,"core-js/modules/es.string.trim.js":634}],506:[function(require,module,exports){
"use strict";

require("core-js/modules/es.string.trim.js");
require("core-js/modules/es.regexp.exec.js");
var global = require('../internals/global');
var trim = require('../internals/string-trim').trim;
var whitespaces = require('../internals/whitespaces');
var $parseInt = global.parseInt;
var hex = /^[+-]?0[Xx]/;
var FORCED = $parseInt(whitespaces + '08') !== 8 || $parseInt(whitespaces + '0x16') !== 22;

// `parseInt` method
// https://tc39.github.io/ecma262/#sec-parseint-string-radix
module.exports = FORCED ? function parseInt(string, radix) {
  var S = trim(String(string));
  return $parseInt(S, radix >>> 0 || (hex.test(S) ? 16 : 10));
} : $parseInt;

},{"../internals/global":475,"../internals/string-trim":545,"../internals/whitespaces":565,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.string.trim.js":634}],507:[function(require,module,exports){
'use strict';

require("core-js/modules/es.object.assign.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/web.dom-collections.for-each.js");
require("core-js/modules/es.array.join.js");
require("core-js/modules/es.array.concat.js");
var DESCRIPTORS = require('../internals/descriptors');
var fails = require('../internals/fails');
var objectKeys = require('../internals/object-keys');
var getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');
var propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');
var toObject = require('../internals/to-object');
var IndexedObject = require('../internals/indexed-object');
var nativeAssign = Object.assign;
var defineProperty = Object.defineProperty;

// `Object.assign` method
// https://tc39.github.io/ecma262/#sec-object.assign
module.exports = !nativeAssign || fails(function () {
  // should have correct order of operations (Edge bug)
  if (DESCRIPTORS && nativeAssign({
    b: 1
  }, nativeAssign(defineProperty({}, 'a', {
    enumerable: true,
    get: function get() {
      defineProperty(this, 'b', {
        value: 3,
        enumerable: false
      });
    }
  }), {
    b: 2
  })).b !== 1) return true;
  // should work with symbols and should have deterministic property order (V8 bug)
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var symbol = Symbol();
  var alphabet = 'abcdefghijklmnopqrst';
  A[symbol] = 7;
  alphabet.split('').forEach(function (chr) {
    B[chr] = chr;
  });
  return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;
}) ? function assign(target, source) {
  // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  var propertyIsEnumerable = propertyIsEnumerableModule.f;
  while (argumentsLength > index) {
    var S = IndexedObject(arguments[index++]);
    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || propertyIsEnumerable.call(S, key)) T[key] = S[key];
    }
  }
  return T;
} : nativeAssign;

},{"../internals/descriptors":459,"../internals/fails":467,"../internals/indexed-object":482,"../internals/object-get-own-property-symbols":514,"../internals/object-keys":517,"../internals/object-property-is-enumerable":518,"../internals/to-object":553,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.array.join.js":578,"core-js/modules/es.object.assign.js":601,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.for-each.js":676}],508:[function(require,module,exports){
"use strict";

var anObject = require('../internals/an-object');
var defineProperties = require('../internals/object-define-properties');
var enumBugKeys = require('../internals/enum-bug-keys');
var hiddenKeys = require('../internals/hidden-keys');
var html = require('../internals/html');
var documentCreateElement = require('../internals/document-create-element');
var sharedKey = require('../internals/shared-key');
var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');
var EmptyConstructor = function EmptyConstructor() {/* empty */};
var scriptTag = function scriptTag(content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function NullProtoObjectViaActiveX(activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function NullProtoObjectViaIFrame() {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var _NullProtoObject = function NullProtoObject() {
  try {
    /* global ActiveXObject */
    activeXDocument = document.domain && new ActiveXObject('htmlfile');
  } catch (error) {/* ignore */}
  _NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
  var length = enumBugKeys.length;
  while (length--) delete _NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return _NullProtoObject();
};
hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.github.io/ecma262/#sec-object.create
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = _NullProtoObject();
  return Properties === undefined ? result : defineProperties(result, Properties);
};

},{"../internals/an-object":426,"../internals/document-create-element":460,"../internals/enum-bug-keys":465,"../internals/hidden-keys":477,"../internals/html":479,"../internals/object-define-properties":509,"../internals/shared-key":537}],509:[function(require,module,exports){
"use strict";

var DESCRIPTORS = require('../internals/descriptors');
var definePropertyModule = require('../internals/object-define-property');
var anObject = require('../internals/an-object');
var objectKeys = require('../internals/object-keys');

// `Object.defineProperties` method
// https://tc39.github.io/ecma262/#sec-object.defineproperties
module.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], Properties[key]);
  return O;
};

},{"../internals/an-object":426,"../internals/descriptors":459,"../internals/object-define-property":510,"../internals/object-keys":517}],510:[function(require,module,exports){
"use strict";

var DESCRIPTORS = require('../internals/descriptors');
var IE8_DOM_DEFINE = require('../internals/ie8-dom-define');
var anObject = require('../internals/an-object');
var toPrimitive = require('../internals/to-primitive');
var nativeDefineProperty = Object.defineProperty;

// `Object.defineProperty` method
// https://tc39.github.io/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return nativeDefineProperty(O, P, Attributes);
  } catch (error) {/* empty */}
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"../internals/an-object":426,"../internals/descriptors":459,"../internals/ie8-dom-define":480,"../internals/to-primitive":556}],511:[function(require,module,exports){
"use strict";

require("core-js/modules/es.object.get-own-property-descriptor.js");
var DESCRIPTORS = require('../internals/descriptors');
var propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
var toIndexedObject = require('../internals/to-indexed-object');
var toPrimitive = require('../internals/to-primitive');
var has = require('../internals/has');
var IE8_DOM_DEFINE = require('../internals/ie8-dom-define');
var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return nativeGetOwnPropertyDescriptor(O, P);
  } catch (error) {/* empty */}
  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
};

},{"../internals/create-property-descriptor":454,"../internals/descriptors":459,"../internals/has":476,"../internals/ie8-dom-define":480,"../internals/object-property-is-enumerable":518,"../internals/to-indexed-object":550,"../internals/to-primitive":556,"core-js/modules/es.object.get-own-property-descriptor.js":603}],512:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.object.get-own-property-names.js");
require("core-js/modules/es.array.slice.js");
var toIndexedObject = require('../internals/to-indexed-object');
var nativeGetOwnPropertyNames = require('../internals/object-get-own-property-names').f;
var toString = {}.toString;
var windowNames = (typeof window === "undefined" ? "undefined" : (0, _typeof2.default)(window)) == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
var getWindowNames = function getWindowNames(it) {
  try {
    return nativeGetOwnPropertyNames(it);
  } catch (error) {
    return windowNames.slice();
  }
};

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : nativeGetOwnPropertyNames(toIndexedObject(it));
};

},{"../internals/object-get-own-property-names":513,"../internals/to-indexed-object":550,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.object.get-own-property-names.js":605,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.to-string.js":620}],513:[function(require,module,exports){
"use strict";

require("core-js/modules/es.array.concat.js");
require("core-js/modules/es.object.get-own-property-names.js");
var internalObjectKeys = require('../internals/object-keys-internal');
var enumBugKeys = require('../internals/enum-bug-keys');
var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertynames
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};

},{"../internals/enum-bug-keys":465,"../internals/object-keys-internal":516,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.object.get-own-property-names.js":605}],514:[function(require,module,exports){
"use strict";

require("core-js/modules/es.symbol.js");
exports.f = Object.getOwnPropertySymbols;

},{"core-js/modules/es.symbol.js":638}],515:[function(require,module,exports){
"use strict";

require("core-js/modules/es.object.get-prototype-of.js");
var has = require('../internals/has');
var toObject = require('../internals/to-object');
var sharedKey = require('../internals/shared-key');
var CORRECT_PROTOTYPE_GETTER = require('../internals/correct-prototype-getter');
var IE_PROTO = sharedKey('IE_PROTO');
var ObjectPrototype = Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.getprototypeof
module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  }
  return O instanceof Object ? ObjectPrototype : null;
};

},{"../internals/correct-prototype-getter":451,"../internals/has":476,"../internals/shared-key":537,"../internals/to-object":553,"core-js/modules/es.object.get-prototype-of.js":606}],516:[function(require,module,exports){
"use strict";

var has = require('../internals/has');
var toIndexedObject = require('../internals/to-indexed-object');
var indexOf = require('../internals/array-includes').indexOf;
var hiddenKeys = require('../internals/hidden-keys');
module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~indexOf(result, key) || result.push(key);
  }
  return result;
};

},{"../internals/array-includes":434,"../internals/has":476,"../internals/hidden-keys":477,"../internals/to-indexed-object":550}],517:[function(require,module,exports){
"use strict";

require("core-js/modules/es.object.keys.js");
var internalObjectKeys = require('../internals/object-keys-internal');
var enumBugKeys = require('../internals/enum-bug-keys');

// `Object.keys` method
// https://tc39.github.io/ecma262/#sec-object.keys
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};

},{"../internals/enum-bug-keys":465,"../internals/object-keys-internal":516,"core-js/modules/es.object.keys.js":609}],518:[function(require,module,exports){
'use strict';

require("core-js/modules/es.object.get-own-property-descriptor.js");
var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({
  1: 2
}, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : nativePropertyIsEnumerable;

},{"core-js/modules/es.object.get-own-property-descriptor.js":603}],519:[function(require,module,exports){
"use strict";

require("core-js/modules/es.object.set-prototype-of.js");
require("core-js/modules/es.object.get-own-property-descriptor.js");
var anObject = require('../internals/an-object');
var aPossiblePrototype = require('../internals/a-possible-prototype');

// `Object.setPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
    setter.call(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) {/* empty */}
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter.call(O, proto);else O.__proto__ = proto;
    return O;
  };
}() : undefined);

},{"../internals/a-possible-prototype":422,"../internals/an-object":426,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.set-prototype-of.js":611}],520:[function(require,module,exports){
"use strict";

var DESCRIPTORS = require('../internals/descriptors');
var objectKeys = require('../internals/object-keys');
var toIndexedObject = require('../internals/to-indexed-object');
var propertyIsEnumerable = require('../internals/object-property-is-enumerable').f;

// `Object.{ entries, values }` methods implementation
var createMethod = function createMethod(TO_ENTRIES) {
  return function (it) {
    var O = toIndexedObject(it);
    var keys = objectKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) {
      key = keys[i++];
      if (!DESCRIPTORS || propertyIsEnumerable.call(O, key)) {
        result.push(TO_ENTRIES ? [key, O[key]] : O[key]);
      }
    }
    return result;
  };
};
module.exports = {
  // `Object.entries` method
  // https://tc39.github.io/ecma262/#sec-object.entries
  entries: createMethod(true),
  // `Object.values` method
  // https://tc39.github.io/ecma262/#sec-object.values
  values: createMethod(false)
};

},{"../internals/descriptors":459,"../internals/object-keys":517,"../internals/object-property-is-enumerable":518,"../internals/to-indexed-object":550}],521:[function(require,module,exports){
'use strict';

require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
var TO_STRING_TAG_SUPPORT = require('../internals/to-string-tag-support');
var classof = require('../internals/classof');

// `Object.prototype.toString` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
  return '[object ' + classof(this) + ']';
};

},{"../internals/classof":445,"../internals/to-string-tag-support":557,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.to-string.js":620}],522:[function(require,module,exports){
"use strict";

require("core-js/modules/es.array.concat.js");
var getBuiltIn = require('../internals/get-built-in');
var getOwnPropertyNamesModule = require('../internals/object-get-own-property-names');
var getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');
var anObject = require('../internals/an-object');

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};

},{"../internals/an-object":426,"../internals/get-built-in":472,"../internals/object-get-own-property-names":513,"../internals/object-get-own-property-symbols":514,"core-js/modules/es.array.concat.js":569}],523:[function(require,module,exports){
"use strict";

var global = require('../internals/global');
module.exports = global;

},{"../internals/global":475}],524:[function(require,module,exports){
"use strict";

module.exports = function (exec) {
  try {
    return {
      error: false,
      value: exec()
    };
  } catch (error) {
    return {
      error: true,
      value: error
    };
  }
};

},{}],525:[function(require,module,exports){
"use strict";

var anObject = require('../internals/an-object');
var isObject = require('../internals/is-object');
var newPromiseCapability = require('../internals/new-promise-capability');
module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

},{"../internals/an-object":426,"../internals/is-object":491,"../internals/new-promise-capability":503}],526:[function(require,module,exports){
"use strict";

var redefine = require('../internals/redefine');
module.exports = function (target, src, options) {
  for (var key in src) redefine(target, key, src[key], options);
  return target;
};

},{"../internals/redefine":527}],527:[function(require,module,exports){
"use strict";

require("core-js/modules/es.array.join.js");
var global = require('../internals/global');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var has = require('../internals/has');
var setGlobal = require('../internals/set-global');
var inspectSource = require('../internals/inspect-source');
var InternalStateModule = require('../internals/internal-state');
var getInternalState = InternalStateModule.get;
var enforceInternalState = InternalStateModule.enforce;
var TEMPLATE = String(String).split('String');
(module.exports = function (O, key, value, options) {
  var unsafe = options ? !!options.unsafe : false;
  var simple = options ? !!options.enumerable : false;
  var noTargetGet = options ? !!options.noTargetGet : false;
  if (typeof value == 'function') {
    if (typeof key == 'string' && !has(value, 'name')) createNonEnumerableProperty(value, 'name', key);
    enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
  }
  if (O === global) {
    if (simple) O[key] = value;else setGlobal(key, value);
    return;
  } else if (!unsafe) {
    delete O[key];
  } else if (!noTargetGet && O[key]) {
    simple = true;
  }
  if (simple) O[key] = value;else createNonEnumerableProperty(O, key, value);
  // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
});

},{"../internals/create-non-enumerable-property":453,"../internals/global":475,"../internals/has":476,"../internals/inspect-source":484,"../internals/internal-state":486,"../internals/set-global":534,"core-js/modules/es.array.join.js":578}],528:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.regexp.exec.js");
var classof = require('./classof-raw');
var regexpExec = require('./regexp-exec');

// `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if ((0, _typeof2.default)(result) !== 'object') {
      throw TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }
  if (classof(R) !== 'RegExp') {
    throw TypeError('RegExp#exec called on incompatible receiver');
  }
  return regexpExec.call(R, S);
};

},{"./classof-raw":444,"./regexp-exec":529,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.regexp.exec.js":618}],529:[function(require,module,exports){
'use strict';

require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.constructor.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.array.slice.js");
var regexpFlags = require('./regexp-flags');
var stickyHelpers = require('./regexp-sticky-helpers');
var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;
var patchedExec = nativeExec;
var UPDATES_LAST_INDEX_WRONG = function () {
  var re1 = /a/;
  var re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
}();
var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y || stickyHelpers.BROKEN_CARET;

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y;
if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;
    var sticky = UNSUPPORTED_Y && re.sticky;
    var flags = regexpFlags.call(re);
    var source = re.source;
    var charsAdded = 0;
    var strCopy = str;
    if (sticky) {
      flags = flags.replace('y', '');
      if (flags.indexOf('g') === -1) {
        flags += 'g';
      }
      strCopy = String(str).slice(re.lastIndex);
      // Support anchored sticky behavior.
      if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== '\n')) {
        source = '(?: ' + source + ')';
        strCopy = ' ' + strCopy;
        charsAdded++;
      }
      // ^(? + rx + ) is needed, in combination with some str slicing, to
      // simulate the 'y' flag.
      reCopy = new RegExp('^(?:' + source + ')', flags);
    }
    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;
    match = nativeExec.call(sticky ? reCopy : re, strCopy);
    if (sticky) {
      if (match) {
        match.input = match.input.slice(charsAdded);
        match[0] = match[0].slice(charsAdded);
        match.index = re.lastIndex;
        re.lastIndex += match[0].length;
      } else re.lastIndex = 0;
    } else if (UPDATES_LAST_INDEX_WRONG && match) {
      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }
    return match;
  };
}
module.exports = patchedExec;

},{"./regexp-flags":530,"./regexp-sticky-helpers":531,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.regexp.constructor.js":617,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.replace.js":629}],530:[function(require,module,exports){
'use strict';

var anObject = require('../internals/an-object');

// `RegExp.prototype.flags` getter implementation
// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.dotAll) result += 's';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

},{"../internals/an-object":426}],531:[function(require,module,exports){
'use strict';

require("core-js/modules/es.regexp.constructor.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.to-string.js");
var fails = require('./fails');

// babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError,
// so we use an intermediate function.
function RE(s, f) {
  return RegExp(s, f);
}
exports.UNSUPPORTED_Y = fails(function () {
  // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
  var re = RE('a', 'y');
  re.lastIndex = 2;
  return re.exec('abcd') != null;
});
exports.BROKEN_CARET = fails(function () {
  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
  var re = RE('^r', 'gy');
  re.lastIndex = 2;
  return re.exec('str') != null;
});

},{"./fails":467,"core-js/modules/es.regexp.constructor.js":617,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620}],532:[function(require,module,exports){
"use strict";

// `RequireObjectCoercible` abstract operation
// https://tc39.github.io/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};

},{}],533:[function(require,module,exports){
"use strict";

require("core-js/modules/es.object.is.js");
// `SameValue` abstract operation
// https://tc39.github.io/ecma262/#sec-samevalue
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

},{"core-js/modules/es.object.is.js":608}],534:[function(require,module,exports){
"use strict";

var global = require('../internals/global');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
module.exports = function (key, value) {
  try {
    createNonEnumerableProperty(global, key, value);
  } catch (error) {
    global[key] = value;
  }
  return value;
};

},{"../internals/create-non-enumerable-property":453,"../internals/global":475}],535:[function(require,module,exports){
'use strict';

var getBuiltIn = require('../internals/get-built-in');
var definePropertyModule = require('../internals/object-define-property');
var wellKnownSymbol = require('../internals/well-known-symbol');
var DESCRIPTORS = require('../internals/descriptors');
var SPECIES = wellKnownSymbol('species');
module.exports = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
  var defineProperty = definePropertyModule.f;
  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
    defineProperty(Constructor, SPECIES, {
      configurable: true,
      get: function get() {
        return this;
      }
    });
  }
};

},{"../internals/descriptors":459,"../internals/get-built-in":472,"../internals/object-define-property":510,"../internals/well-known-symbol":564}],536:[function(require,module,exports){
"use strict";

var defineProperty = require('../internals/object-define-property').f;
var has = require('../internals/has');
var wellKnownSymbol = require('../internals/well-known-symbol');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
module.exports = function (it, TAG, STATIC) {
  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
    defineProperty(it, TO_STRING_TAG, {
      configurable: true,
      value: TAG
    });
  }
};

},{"../internals/has":476,"../internals/object-define-property":510,"../internals/well-known-symbol":564}],537:[function(require,module,exports){
"use strict";

var shared = require('../internals/shared');
var uid = require('../internals/uid');
var keys = shared('keys');
module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};

},{"../internals/shared":539,"../internals/uid":561}],538:[function(require,module,exports){
"use strict";

var global = require('../internals/global');
var setGlobal = require('../internals/set-global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || setGlobal(SHARED, {});
module.exports = store;

},{"../internals/global":475,"../internals/set-global":534}],539:[function(require,module,exports){
"use strict";

var IS_PURE = require('../internals/is-pure');
var store = require('../internals/shared-store');
(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.6.5',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: ' 2020 Denis Pushkarev (zloirock.ru)'
});

},{"../internals/is-pure":492,"../internals/shared-store":538}],540:[function(require,module,exports){
"use strict";

var anObject = require('../internals/an-object');
var aFunction = require('../internals/a-function');
var wellKnownSymbol = require('../internals/well-known-symbol');
var SPECIES = wellKnownSymbol('species');

// `SpeciesConstructor` abstract operation
// https://tc39.github.io/ecma262/#sec-speciesconstructor
module.exports = function (O, defaultConstructor) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aFunction(S);
};

},{"../internals/a-function":421,"../internals/an-object":426,"../internals/well-known-symbol":564}],541:[function(require,module,exports){
"use strict";

require("core-js/modules/es.array.slice.js");
var toInteger = require('../internals/to-integer');
var requireObjectCoercible = require('../internals/require-object-coercible');

// `String.prototype.{ codePointAt, at }` methods implementation
var createMethod = function createMethod(CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = String(requireObjectCoercible($this));
    var position = toInteger(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = S.charCodeAt(position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};
module.exports = {
  // `String.prototype.codePointAt` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod(true)
};

},{"../internals/require-object-coercible":532,"../internals/to-integer":551,"core-js/modules/es.array.slice.js":580}],542:[function(require,module,exports){
'use strict';

// based on https://github.com/bestiejs/punycode.js/blob/master/punycode.js
require("core-js/modules/es.array.join.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128; // 0x80
var delimiter = '-'; // '\x2D'
var regexNonASCII = /[^\0-\u007E]/; // non-ASCII chars
var regexSeparators = /[.\u3002\uFF0E\uFF61]/g; // RFC 3490 separators
var OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 */
var ucs2decode = function ucs2decode(string) {
  var output = [];
  var counter = 0;
  var length = string.length;
  while (counter < length) {
    var value = string.charCodeAt(counter++);
    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
      // It's a high surrogate, and there is a next character.
      var extra = string.charCodeAt(counter++);
      if ((extra & 0xFC00) == 0xDC00) {
        // Low surrogate.
        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
      } else {
        // It's an unmatched surrogate; only append this code unit, in case the
        // next code unit is the high surrogate of a surrogate pair.
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
};

/**
 * Converts a digit/integer into a basic code point.
 */
var digitToBasic = function digitToBasic(digit) {
  //  0..25 map to ASCII a..z or A..Z
  // 26..35 map to ASCII 0..9
  return digit + 22 + 75 * (digit < 26);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 */
var adapt = function adapt(delta, numPoints, firstTime) {
  var k = 0;
  delta = firstTime ? floor(delta / damp) : delta >> 1;
  delta += floor(delta / numPoints);
  for (; delta > baseMinusTMin * tMax >> 1; k += base) {
    delta = floor(delta / baseMinusTMin);
  }
  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 */
// eslint-disable-next-line  max-statements
var encode = function encode(input) {
  var output = [];

  // Convert the input in UCS-2 to an array of Unicode code points.
  input = ucs2decode(input);

  // Cache the length.
  var inputLength = input.length;

  // Initialize the state.
  var n = initialN;
  var delta = 0;
  var bias = initialBias;
  var i, currentValue;

  // Handle the basic code points.
  for (i = 0; i < input.length; i++) {
    currentValue = input[i];
    if (currentValue < 0x80) {
      output.push(stringFromCharCode(currentValue));
    }
  }
  var basicLength = output.length; // number of basic code points.
  var handledCPCount = basicLength; // number of code points that have been handled;

  // Finish the basic string with a delimiter unless it's empty.
  if (basicLength) {
    output.push(delimiter);
  }

  // Main encoding loop:
  while (handledCPCount < inputLength) {
    // All non-basic code points < n have been handled already. Find the next larger one:
    var m = maxInt;
    for (i = 0; i < input.length; i++) {
      currentValue = input[i];
      if (currentValue >= n && currentValue < m) {
        m = currentValue;
      }
    }

    // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.
    var handledCPCountPlusOne = handledCPCount + 1;
    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
      throw RangeError(OVERFLOW_ERROR);
    }
    delta += (m - n) * handledCPCountPlusOne;
    n = m;
    for (i = 0; i < input.length; i++) {
      currentValue = input[i];
      if (currentValue < n && ++delta > maxInt) {
        throw RangeError(OVERFLOW_ERROR);
      }
      if (currentValue == n) {
        // Represent delta as a generalized variable-length integer.
        var q = delta;
        for /* no condition */
        (var k = base;; k += base) {
          var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (q < t) break;
          var qMinusT = q - t;
          var baseMinusT = base - t;
          output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT)));
          q = floor(qMinusT / baseMinusT);
        }
        output.push(stringFromCharCode(digitToBasic(q)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }
    ++delta;
    ++n;
  }
  return output.join('');
};
module.exports = function (input) {
  var encoded = [];
  var labels = input.toLowerCase().replace(regexSeparators, ".").split('.');
  var i, label;
  for (i = 0; i < labels.length; i++) {
    label = labels[i];
    encoded.push(regexNonASCII.test(label) ? 'xn--' + encode(label) : label);
  }
  return encoded.join('.');
};

},{"core-js/modules/es.array.join.js":578,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.string.replace.js":629}],543:[function(require,module,exports){
'use strict';

require("core-js/modules/es.string.repeat.js");
var toInteger = require('../internals/to-integer');
var requireObjectCoercible = require('../internals/require-object-coercible');

// `String.prototype.repeat` method implementation
// https://tc39.github.io/ecma262/#sec-string.prototype.repeat
module.exports = ''.repeat || function repeat(count) {
  var str = String(requireObjectCoercible(this));
  var result = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError('Wrong number of repetitions');
  for (; n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;
  return result;
};

},{"../internals/require-object-coercible":532,"../internals/to-integer":551,"core-js/modules/es.string.repeat.js":628}],544:[function(require,module,exports){
"use strict";

require("core-js/modules/es.function.name.js");
var fails = require('../internals/fails');
var whitespaces = require('../internals/whitespaces');
var non = "\u200B\x85\u180E";

// check that a method works with the correct list
// of whitespaces and has a correct name
module.exports = function (METHOD_NAME) {
  return fails(function () {
    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;
  });
};

},{"../internals/fails":467,"../internals/whitespaces":565,"core-js/modules/es.function.name.js":584}],545:[function(require,module,exports){
"use strict";

require("core-js/modules/es.regexp.constructor.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.string.replace.js");
var requireObjectCoercible = require('../internals/require-object-coercible');
var whitespaces = require('../internals/whitespaces');
var whitespace = '[' + whitespaces + ']';
var ltrim = RegExp('^' + whitespace + whitespace + '*');
var rtrim = RegExp(whitespace + whitespace + '*$');

// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
var createMethod = function createMethod(TYPE) {
  return function ($this) {
    var string = String(requireObjectCoercible($this));
    if (TYPE & 1) string = string.replace(ltrim, '');
    if (TYPE & 2) string = string.replace(rtrim, '');
    return string;
  };
};
module.exports = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.github.io/ecma262/#sec-string.prototype.trimstart
  start: createMethod(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.github.io/ecma262/#sec-string.prototype.trimend
  end: createMethod(2),
  // `String.prototype.trim` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.trim
  trim: createMethod(3)
};

},{"../internals/require-object-coercible":532,"../internals/whitespaces":565,"core-js/modules/es.regexp.constructor.js":617,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.replace.js":629}],546:[function(require,module,exports){
"use strict";

var global = require('../internals/global');
var fails = require('../internals/fails');
var classof = require('../internals/classof-raw');
var bind = require('../internals/function-bind-context');
var html = require('../internals/html');
var createElement = require('../internals/document-create-element');
var IS_IOS = require('../internals/engine-is-ios');
var location = global.location;
var set = global.setImmediate;
var clear = global.clearImmediate;
var process = global.process;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function run(id) {
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var runner = function runner(id) {
  return function () {
    run(id);
  };
};
var listener = function listener(event) {
  run(event.data);
};
var post = function post(id) {
  // old engines have not location.origin
  global.postMessage(id + '', location.protocol + '//' + location.host);
};

// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!set || !clear) {
  set = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (classof(process) == 'process') {
    defer = function defer(id) {
      process.nextTick(runner(id));
    };
    // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function defer(id) {
      Dispatch.now(runner(id));
    };
    // Browsers with MessageChannel, includes WebWorkers
    // except iOS - https://github.com/zloirock/core-js/issues/624
  } else if (MessageChannel && !IS_IOS) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = bind(port.postMessage, port, 1);
    // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts && !fails(post) && location.protocol !== 'file:') {
    defer = post;
    global.addEventListener('message', listener, false);
    // IE8-
  } else if (ONREADYSTATECHANGE in createElement('script')) {
    defer = function defer(id) {
      html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run(id);
      };
    };
    // Rest old browsers
  } else {
    defer = function defer(id) {
      setTimeout(runner(id), 0);
    };
  }
}
module.exports = {
  set: set,
  clear: clear
};

},{"../internals/classof-raw":444,"../internals/document-create-element":460,"../internals/engine-is-ios":462,"../internals/fails":467,"../internals/function-bind-context":470,"../internals/global":475,"../internals/html":479}],547:[function(require,module,exports){
"use strict";

var classof = require('../internals/classof-raw');

// `thisNumberValue` abstract operation
// https://tc39.github.io/ecma262/#sec-thisnumbervalue
module.exports = function (value) {
  if (typeof value != 'number' && classof(value) != 'Number') {
    throw TypeError('Incorrect invocation');
  }
  return +value;
};

},{"../internals/classof-raw":444}],548:[function(require,module,exports){
"use strict";

var toInteger = require('../internals/to-integer');
var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};

},{"../internals/to-integer":551}],549:[function(require,module,exports){
"use strict";

var toInteger = require('../internals/to-integer');
var toLength = require('../internals/to-length');

// `ToIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-toindex
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length or index');
  return length;
};

},{"../internals/to-integer":551,"../internals/to-length":552}],550:[function(require,module,exports){
"use strict";

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = require('../internals/indexed-object');
var requireObjectCoercible = require('../internals/require-object-coercible');
module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};

},{"../internals/indexed-object":482,"../internals/require-object-coercible":532}],551:[function(require,module,exports){
"use strict";

var ceil = Math.ceil;
var floor = Math.floor;

// `ToInteger` abstract operation
// https://tc39.github.io/ecma262/#sec-tointeger
module.exports = function (argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};

},{}],552:[function(require,module,exports){
"use strict";

var toInteger = require('../internals/to-integer');
var min = Math.min;

// `ToLength` abstract operation
// https://tc39.github.io/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};

},{"../internals/to-integer":551}],553:[function(require,module,exports){
"use strict";

var requireObjectCoercible = require('../internals/require-object-coercible');

// `ToObject` abstract operation
// https://tc39.github.io/ecma262/#sec-toobject
module.exports = function (argument) {
  return Object(requireObjectCoercible(argument));
};

},{"../internals/require-object-coercible":532}],554:[function(require,module,exports){
"use strict";

var toPositiveInteger = require('../internals/to-positive-integer');
module.exports = function (it, BYTES) {
  var offset = toPositiveInteger(it);
  if (offset % BYTES) throw RangeError('Wrong offset');
  return offset;
};

},{"../internals/to-positive-integer":555}],555:[function(require,module,exports){
"use strict";

var toInteger = require('../internals/to-integer');
module.exports = function (it) {
  var result = toInteger(it);
  if (result < 0) throw RangeError("The argument can't be less than 0");
  return result;
};

},{"../internals/to-integer":551}],556:[function(require,module,exports){
"use strict";

require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
var isObject = require('../internals/is-object');

// `ToPrimitive` abstract operation
// https://tc39.github.io/ecma262/#sec-toprimitive
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (input, PREFERRED_STRING) {
  if (!isObject(input)) return input;
  var fn, val;
  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"../internals/is-object":491,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.to-string.js":620}],557:[function(require,module,exports){
"use strict";

var wellKnownSymbol = require('../internals/well-known-symbol');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};
test[TO_STRING_TAG] = 'z';
module.exports = String(test) === '[object z]';

},{"../internals/well-known-symbol":564}],558:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/web.dom-collections.for-each.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.match.js");
var $ = require('../internals/export');
var global = require('../internals/global');
var DESCRIPTORS = require('../internals/descriptors');
var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = require('../internals/typed-array-constructors-require-wrappers');
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var ArrayBufferModule = require('../internals/array-buffer');
var anInstance = require('../internals/an-instance');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var toLength = require('../internals/to-length');
var toIndex = require('../internals/to-index');
var toOffset = require('../internals/to-offset');
var toPrimitive = require('../internals/to-primitive');
var has = require('../internals/has');
var classof = require('../internals/classof');
var isObject = require('../internals/is-object');
var create = require('../internals/object-create');
var setPrototypeOf = require('../internals/object-set-prototype-of');
var getOwnPropertyNames = require('../internals/object-get-own-property-names').f;
var typedArrayFrom = require('../internals/typed-array-from');
var forEach = require('../internals/array-iteration').forEach;
var setSpecies = require('../internals/set-species');
var definePropertyModule = require('../internals/object-define-property');
var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
var InternalStateModule = require('../internals/internal-state');
var inheritIfRequired = require('../internals/inherit-if-required');
var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var round = Math.round;
var RangeError = global.RangeError;
var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
var DataView = ArrayBufferModule.DataView;
var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
var TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG;
var TypedArray = ArrayBufferViewCore.TypedArray;
var TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var isTypedArray = ArrayBufferViewCore.isTypedArray;
var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
var WRONG_LENGTH = 'Wrong length';
var fromList = function fromList(C, list) {
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor(C))(length);
  while (length > index) result[index] = list[index++];
  return result;
};
var addGetter = function addGetter(it, key) {
  nativeDefineProperty(it, key, {
    get: function get() {
      return getInternalState(this)[key];
    }
  });
};
var isArrayBuffer = function isArrayBuffer(it) {
  var klass;
  return it instanceof ArrayBuffer || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
};
var isTypedArrayIndex = function isTypedArrayIndex(target, key) {
  return isTypedArray(target) && (0, _typeof2.default)(key) != 'symbol' && key in target && String(+key) == String(key);
};
var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
  return isTypedArrayIndex(target, key = toPrimitive(key, true)) ? createPropertyDescriptor(2, target[key]) : nativeGetOwnPropertyDescriptor(target, key);
};
var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
  if (isTypedArrayIndex(target, key = toPrimitive(key, true)) && isObject(descriptor) && has(descriptor, 'value') && !has(descriptor, 'get') && !has(descriptor, 'set')
  // TODO: add validation descriptor w/o calling accessors
  && !descriptor.configurable && (!has(descriptor, 'writable') || descriptor.writable) && (!has(descriptor, 'enumerable') || descriptor.enumerable)) {
    target[key] = descriptor.value;
    return target;
  }
  return nativeDefineProperty(target, key, descriptor);
};
if (DESCRIPTORS) {
  if (!NATIVE_ARRAY_BUFFER_VIEWS) {
    getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
    definePropertyModule.f = wrappedDefineProperty;
    addGetter(TypedArrayPrototype, 'buffer');
    addGetter(TypedArrayPrototype, 'byteOffset');
    addGetter(TypedArrayPrototype, 'byteLength');
    addGetter(TypedArrayPrototype, 'length');
  }
  $({
    target: 'Object',
    stat: true,
    forced: !NATIVE_ARRAY_BUFFER_VIEWS
  }, {
    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
    defineProperty: wrappedDefineProperty
  });
  module.exports = function (TYPE, wrapper, CLAMPED) {
    var BYTES = TYPE.match(/\d+$/)[0] / 8;
    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + TYPE;
    var SETTER = 'set' + TYPE;
    var NativeTypedArrayConstructor = global[CONSTRUCTOR_NAME];
    var TypedArrayConstructor = NativeTypedArrayConstructor;
    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
    var exported = {};
    var getter = function getter(that, index) {
      var data = getInternalState(that);
      return data.view[GETTER](index * BYTES + data.byteOffset, true);
    };
    var setter = function setter(that, index, value) {
      var data = getInternalState(that);
      if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
      data.view[SETTER](index * BYTES + data.byteOffset, value, true);
    };
    var addElement = function addElement(that, index) {
      nativeDefineProperty(that, index, {
        get: function get() {
          return getter(this, index);
        },
        set: function set(value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
      TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
        anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);
        var index = 0;
        var byteOffset = 0;
        var buffer, byteLength, length;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new ArrayBuffer(byteLength);
        } else if (isArrayBuffer(data)) {
          buffer = data;
          byteOffset = toOffset(offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - byteOffset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (isTypedArray(data)) {
          return fromList(TypedArrayConstructor, data);
        } else {
          return typedArrayFrom.call(TypedArrayConstructor, data);
        }
        setInternalState(that, {
          buffer: buffer,
          byteOffset: byteOffset,
          byteLength: byteLength,
          length: length,
          view: new DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);
    } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
      TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {
        anInstance(dummy, TypedArrayConstructor, CONSTRUCTOR_NAME);
        return inheritIfRequired(function () {
          if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
          if (isArrayBuffer(data)) return $length !== undefined ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length) : typedArrayOffset !== undefined ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES)) : new NativeTypedArrayConstructor(data);
          if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
          return typedArrayFrom.call(TypedArrayConstructor, data);
        }(), dummy, TypedArrayConstructor);
      });
      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
      forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
        if (!(key in TypedArrayConstructor)) {
          createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
        }
      });
      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
    }
    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
    }
    if (TYPED_ARRAY_TAG) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
    }
    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;
    $({
      global: true,
      forced: TypedArrayConstructor != NativeTypedArrayConstructor,
      sham: !NATIVE_ARRAY_BUFFER_VIEWS
    }, exported);
    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
      createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
    }
    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
    }
    setSpecies(CONSTRUCTOR_NAME);
  };
} else module.exports = function () {/* empty */};

},{"../internals/an-instance":425,"../internals/array-buffer":429,"../internals/array-buffer-view-core":428,"../internals/array-iteration":435,"../internals/classof":445,"../internals/create-non-enumerable-property":453,"../internals/create-property-descriptor":454,"../internals/descriptors":459,"../internals/export":466,"../internals/global":475,"../internals/has":476,"../internals/inherit-if-required":483,"../internals/internal-state":486,"../internals/is-object":491,"../internals/object-create":508,"../internals/object-define-property":510,"../internals/object-get-own-property-descriptor":511,"../internals/object-get-own-property-names":513,"../internals/object-set-prototype-of":519,"../internals/set-species":535,"../internals/to-index":549,"../internals/to-length":552,"../internals/to-offset":554,"../internals/to-primitive":556,"../internals/typed-array-constructors-require-wrappers":559,"../internals/typed-array-from":560,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.string.match.js":627,"core-js/modules/web.dom-collections.for-each.js":676}],559:[function(require,module,exports){
"use strict";

/* eslint-disable no-new */
var global = require('../internals/global');
var fails = require('../internals/fails');
var checkCorrectnessOfIteration = require('../internals/check-correctness-of-iteration');
var NATIVE_ARRAY_BUFFER_VIEWS = require('../internals/array-buffer-view-core').NATIVE_ARRAY_BUFFER_VIEWS;
var ArrayBuffer = global.ArrayBuffer;
var Int8Array = global.Int8Array;
module.exports = !NATIVE_ARRAY_BUFFER_VIEWS || !fails(function () {
  Int8Array(1);
}) || !fails(function () {
  new Int8Array(-1);
}) || !checkCorrectnessOfIteration(function (iterable) {
  new Int8Array();
  new Int8Array(null);
  new Int8Array(1.5);
  new Int8Array(iterable);
}, true) || fails(function () {
  // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
  return new Int8Array(new ArrayBuffer(2), 1, undefined).length !== 1;
});

},{"../internals/array-buffer-view-core":428,"../internals/check-correctness-of-iteration":443,"../internals/fails":467,"../internals/global":475}],560:[function(require,module,exports){
"use strict";

var toObject = require('../internals/to-object');
var toLength = require('../internals/to-length');
var getIteratorMethod = require('../internals/get-iterator-method');
var isArrayIteratorMethod = require('../internals/is-array-iterator-method');
var bind = require('../internals/function-bind-context');
var aTypedArrayConstructor = require('../internals/array-buffer-view-core').aTypedArrayConstructor;
module.exports = function from(source /* , mapfn, thisArg */) {
  var O = toObject(source);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var iteratorMethod = getIteratorMethod(O);
  var i, length, result, step, iterator, next;
  if (iteratorMethod != undefined && !isArrayIteratorMethod(iteratorMethod)) {
    iterator = iteratorMethod.call(O);
    next = iterator.next;
    O = [];
    while (!(step = next.call(iterator)).done) {
      O.push(step.value);
    }
  }
  if (mapping && argumentsLength > 2) {
    mapfn = bind(mapfn, arguments[2], 2);
  }
  length = toLength(O.length);
  result = new (aTypedArrayConstructor(this))(length);
  for (i = 0; length > i; i++) {
    result[i] = mapping ? mapfn(O[i], i) : O[i];
  }
  return result;
};

},{"../internals/array-buffer-view-core":428,"../internals/function-bind-context":470,"../internals/get-iterator-method":473,"../internals/is-array-iterator-method":487,"../internals/to-length":552,"../internals/to-object":553}],561:[function(require,module,exports){
"use strict";

require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
var id = 0;
var postfix = Math.random();
module.exports = function (key) {
  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};

},{"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.to-string.js":620}],562:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
var NATIVE_SYMBOL = require('../internals/native-symbol');
module.exports = NATIVE_SYMBOL
// eslint-disable-next-line no-undef
&& !Symbol.sham
// eslint-disable-next-line no-undef
&& (0, _typeof2.default)(Symbol.iterator) == 'symbol';

},{"../internals/native-symbol":500,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],563:[function(require,module,exports){
"use strict";

var wellKnownSymbol = require('../internals/well-known-symbol');
exports.f = wellKnownSymbol;

},{"../internals/well-known-symbol":564}],564:[function(require,module,exports){
"use strict";

var global = require('../internals/global');
var shared = require('../internals/shared');
var has = require('../internals/has');
var uid = require('../internals/uid');
var NATIVE_SYMBOL = require('../internals/native-symbol');
var USE_SYMBOL_AS_UID = require('../internals/use-symbol-as-uid');
var WellKnownSymbolsStore = shared('wks');
var _Symbol = global.Symbol;
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? _Symbol : _Symbol && _Symbol.withoutSetter || uid;
module.exports = function (name) {
  if (!has(WellKnownSymbolsStore, name)) {
    if (NATIVE_SYMBOL && has(_Symbol, name)) WellKnownSymbolsStore[name] = _Symbol[name];else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
  }
  return WellKnownSymbolsStore[name];
};

},{"../internals/global":475,"../internals/has":476,"../internals/native-symbol":500,"../internals/shared":539,"../internals/uid":561,"../internals/use-symbol-as-uid":562}],565:[function(require,module,exports){
"use strict";

// a string of all valid unicode whitespaces
// eslint-disable-next-line max-len
module.exports = "\t\n\x0B\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";

},{}],566:[function(require,module,exports){
'use strict';

var $ = require('../internals/export');
var global = require('../internals/global');
var arrayBufferModule = require('../internals/array-buffer');
var setSpecies = require('../internals/set-species');
var ARRAY_BUFFER = 'ArrayBuffer';
var ArrayBuffer = arrayBufferModule[ARRAY_BUFFER];
var NativeArrayBuffer = global[ARRAY_BUFFER];

// `ArrayBuffer` constructor
// https://tc39.github.io/ecma262/#sec-arraybuffer-constructor
$({
  global: true,
  forced: NativeArrayBuffer !== ArrayBuffer
}, {
  ArrayBuffer: ArrayBuffer
});
setSpecies(ARRAY_BUFFER);

},{"../internals/array-buffer":429,"../internals/export":466,"../internals/global":475,"../internals/set-species":535}],567:[function(require,module,exports){
"use strict";

var $ = require('../internals/export');
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;

// `ArrayBuffer.isView` method
// https://tc39.github.io/ecma262/#sec-arraybuffer.isview
$({
  target: 'ArrayBuffer',
  stat: true,
  forced: !NATIVE_ARRAY_BUFFER_VIEWS
}, {
  isView: ArrayBufferViewCore.isView
});

},{"../internals/array-buffer-view-core":428,"../internals/export":466}],568:[function(require,module,exports){
'use strict';

require("core-js/modules/es.array.slice.js");
var $ = require('../internals/export');
var fails = require('../internals/fails');
var ArrayBufferModule = require('../internals/array-buffer');
var anObject = require('../internals/an-object');
var toAbsoluteIndex = require('../internals/to-absolute-index');
var toLength = require('../internals/to-length');
var speciesConstructor = require('../internals/species-constructor');
var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
var DataView = ArrayBufferModule.DataView;
var nativeArrayBufferSlice = ArrayBuffer.prototype.slice;
var INCORRECT_SLICE = fails(function () {
  return !new ArrayBuffer(2).slice(1, undefined).byteLength;
});

// `ArrayBuffer.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-arraybuffer.prototype.slice
$({
  target: 'ArrayBuffer',
  proto: true,
  unsafe: true,
  forced: INCORRECT_SLICE
}, {
  slice: function slice(start, end) {
    if (nativeArrayBufferSlice !== undefined && end === undefined) {
      return nativeArrayBufferSlice.call(anObject(this), start); // FF fix
    }

    var length = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    var result = new (speciesConstructor(this, ArrayBuffer))(toLength(fin - first));
    var viewSource = new DataView(this);
    var viewTarget = new DataView(result);
    var index = 0;
    while (first < fin) {
      viewTarget.setUint8(index++, viewSource.getUint8(first++));
    }
    return result;
  }
});

},{"../internals/an-object":426,"../internals/array-buffer":429,"../internals/export":466,"../internals/fails":467,"../internals/species-constructor":540,"../internals/to-absolute-index":548,"../internals/to-length":552,"core-js/modules/es.array.slice.js":580}],569:[function(require,module,exports){
'use strict';

require("core-js/modules/es.array.concat.js");
var $ = require('../internals/export');
var fails = require('../internals/fails');
var isArray = require('../internals/is-array');
var isObject = require('../internals/is-object');
var toObject = require('../internals/to-object');
var toLength = require('../internals/to-length');
var createProperty = require('../internals/create-property');
var arraySpeciesCreate = require('../internals/array-species-create');
var arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');
var wellKnownSymbol = require('../internals/well-known-symbol');
var V8_VERSION = require('../internals/engine-v8-version');
var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';

// We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679
var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});
var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');
var isConcatSpreadable = function isConcatSpreadable(O) {
  if (!isObject(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray(O);
};
var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;

// `Array.prototype.concat` method
// https://tc39.github.io/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species
$({
  target: 'Array',
  proto: true,
  forced: FORCED
}, {
  concat: function concat(arg) {
    // eslint-disable-line no-unused-vars
    var O = toObject(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length, len, E;
    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];
      if (isConcatSpreadable(E)) {
        len = toLength(E.length);
        if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
      } else {
        if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        createProperty(A, n++, E);
      }
    }
    A.length = n;
    return A;
  }
});

},{"../internals/array-method-has-species-support":437,"../internals/array-species-create":441,"../internals/create-property":455,"../internals/engine-v8-version":464,"../internals/export":466,"../internals/fails":467,"../internals/is-array":488,"../internals/is-object":491,"../internals/to-length":552,"../internals/to-object":553,"../internals/well-known-symbol":564,"core-js/modules/es.array.concat.js":569}],570:[function(require,module,exports){
"use strict";

var $ = require('../internals/export');
var copyWithin = require('../internals/array-copy-within');
var addToUnscopables = require('../internals/add-to-unscopables');

// `Array.prototype.copyWithin` method
// https://tc39.github.io/ecma262/#sec-array.prototype.copywithin
$({
  target: 'Array',
  proto: true
}, {
  copyWithin: copyWithin
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('copyWithin');

},{"../internals/add-to-unscopables":423,"../internals/array-copy-within":430,"../internals/export":466}],571:[function(require,module,exports){
"use strict";

var $ = require('../internals/export');
var fill = require('../internals/array-fill');
var addToUnscopables = require('../internals/add-to-unscopables');

// `Array.prototype.fill` method
// https://tc39.github.io/ecma262/#sec-array.prototype.fill
$({
  target: 'Array',
  proto: true
}, {
  fill: fill
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('fill');

},{"../internals/add-to-unscopables":423,"../internals/array-fill":431,"../internals/export":466}],572:[function(require,module,exports){
'use strict';

require("core-js/modules/es.array.filter.js");
require("core-js/modules/es.object.to-string.js");
var $ = require('../internals/export');
var $filter = require('../internals/array-iteration').filter;
var arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');
var arrayMethodUsesToLength = require('../internals/array-method-uses-to-length');
var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');
// Edge 14- issue
var USES_TO_LENGTH = arrayMethodUsesToLength('filter');

// `Array.prototype.filter` method
// https://tc39.github.io/ecma262/#sec-array.prototype.filter
// with adding support of @@species
$({
  target: 'Array',
  proto: true,
  forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH
}, {
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

},{"../internals/array-iteration":435,"../internals/array-method-has-species-support":437,"../internals/array-method-uses-to-length":439,"../internals/export":466,"core-js/modules/es.array.filter.js":572,"core-js/modules/es.object.to-string.js":612}],573:[function(require,module,exports){
'use strict';

require("core-js/modules/es.array.find-index.js");
var $ = require('../internals/export');
var $findIndex = require('../internals/array-iteration').findIndex;
var addToUnscopables = require('../internals/add-to-unscopables');
var arrayMethodUsesToLength = require('../internals/array-method-uses-to-length');
var FIND_INDEX = 'findIndex';
var SKIPS_HOLES = true;
var USES_TO_LENGTH = arrayMethodUsesToLength(FIND_INDEX);

// Shouldn't skip holes
if (FIND_INDEX in []) Array(1)[FIND_INDEX](function () {
  SKIPS_HOLES = false;
});

// `Array.prototype.findIndex` method
// https://tc39.github.io/ecma262/#sec-array.prototype.findindex
$({
  target: 'Array',
  proto: true,
  forced: SKIPS_HOLES || !USES_TO_LENGTH
}, {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND_INDEX);

},{"../internals/add-to-unscopables":423,"../internals/array-iteration":435,"../internals/array-method-uses-to-length":439,"../internals/export":466,"core-js/modules/es.array.find-index.js":573}],574:[function(require,module,exports){
'use strict';

require("core-js/modules/es.array.find.js");
require("core-js/modules/es.object.to-string.js");
var $ = require('../internals/export');
var $find = require('../internals/array-iteration').find;
var addToUnscopables = require('../internals/add-to-unscopables');
var arrayMethodUsesToLength = require('../internals/array-method-uses-to-length');
var FIND = 'find';
var SKIPS_HOLES = true;
var USES_TO_LENGTH = arrayMethodUsesToLength(FIND);

// Shouldn't skip holes
if (FIND in []) Array(1)[FIND](function () {
  SKIPS_HOLES = false;
});

// `Array.prototype.find` method
// https://tc39.github.io/ecma262/#sec-array.prototype.find
$({
  target: 'Array',
  proto: true,
  forced: SKIPS_HOLES || !USES_TO_LENGTH
}, {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND);

},{"../internals/add-to-unscopables":423,"../internals/array-iteration":435,"../internals/array-method-uses-to-length":439,"../internals/export":466,"core-js/modules/es.array.find.js":574,"core-js/modules/es.object.to-string.js":612}],575:[function(require,module,exports){
"use strict";

require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
var $ = require('../internals/export');
var from = require('../internals/array-from');
var checkCorrectnessOfIteration = require('../internals/check-correctness-of-iteration');
var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
  Array.from(iterable);
});

// `Array.from` method
// https://tc39.github.io/ecma262/#sec-array.from
$({
  target: 'Array',
  stat: true,
  forced: INCORRECT_ITERATION
}, {
  from: from
});

},{"../internals/array-from":433,"../internals/check-correctness-of-iteration":443,"../internals/export":466,"core-js/modules/es.array.from.js":575,"core-js/modules/es.string.iterator.js":626}],576:[function(require,module,exports){
'use strict';

require("core-js/modules/es.array.includes.js");
require("core-js/modules/es.string.includes.js");
var $ = require('../internals/export');
var $includes = require('../internals/array-includes').includes;
var addToUnscopables = require('../internals/add-to-unscopables');
var arrayMethodUsesToLength = require('../internals/array-method-uses-to-length');
var USES_TO_LENGTH = arrayMethodUsesToLength('indexOf', {
  ACCESSORS: true,
  1: 0
});

// `Array.prototype.includes` method
// https://tc39.github.io/ecma262/#sec-array.prototype.includes
$({
  target: 'Array',
  proto: true,
  forced: !USES_TO_LENGTH
}, {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('includes');

},{"../internals/add-to-unscopables":423,"../internals/array-includes":434,"../internals/array-method-uses-to-length":439,"../internals/export":466,"core-js/modules/es.array.includes.js":576,"core-js/modules/es.string.includes.js":625}],577:[function(require,module,exports){
'use strict';

var toIndexedObject = require('../internals/to-indexed-object');
var addToUnscopables = require('../internals/add-to-unscopables');
var Iterators = require('../internals/iterators');
var InternalStateModule = require('../internals/internal-state');
var defineIterator = require('../internals/define-iterator');
var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.github.io/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.github.io/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.github.io/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.github.io/ecma262/#sec-createarrayiterator
module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated),
    // target
    index: 0,
    // next index
    kind: kind // kind
  });
  // `%ArrayIteratorPrototype%.next` method
  // https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = undefined;
    return {
      value: undefined,
      done: true
    };
  }
  if (kind == 'keys') return {
    value: index,
    done: false
  };
  if (kind == 'values') return {
    value: target[index],
    done: false
  };
  return {
    value: [index, target[index]],
    done: false
  };
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject
Iterators.Arguments = Iterators.Array;

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"../internals/add-to-unscopables":423,"../internals/define-iterator":457,"../internals/internal-state":486,"../internals/iterators":496,"../internals/to-indexed-object":550}],578:[function(require,module,exports){
'use strict';

require("core-js/modules/es.array.join.js");
var $ = require('../internals/export');
var IndexedObject = require('../internals/indexed-object');
var toIndexedObject = require('../internals/to-indexed-object');
var arrayMethodIsStrict = require('../internals/array-method-is-strict');
var nativeJoin = [].join;
var ES3_STRINGS = IndexedObject != Object;
var STRICT_METHOD = arrayMethodIsStrict('join', ',');

// `Array.prototype.join` method
// https://tc39.github.io/ecma262/#sec-array.prototype.join
$({
  target: 'Array',
  proto: true,
  forced: ES3_STRINGS || !STRICT_METHOD
}, {
  join: function join(separator) {
    return nativeJoin.call(toIndexedObject(this), separator === undefined ? ',' : separator);
  }
});

},{"../internals/array-method-is-strict":438,"../internals/export":466,"../internals/indexed-object":482,"../internals/to-indexed-object":550,"core-js/modules/es.array.join.js":578}],579:[function(require,module,exports){
'use strict';

require("core-js/modules/es.array.map.js");
var $ = require('../internals/export');
var $map = require('../internals/array-iteration').map;
var arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');
var arrayMethodUsesToLength = require('../internals/array-method-uses-to-length');
var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map');
// FF49- issue
var USES_TO_LENGTH = arrayMethodUsesToLength('map');

// `Array.prototype.map` method
// https://tc39.github.io/ecma262/#sec-array.prototype.map
// with adding support of @@species
$({
  target: 'Array',
  proto: true,
  forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH
}, {
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

},{"../internals/array-iteration":435,"../internals/array-method-has-species-support":437,"../internals/array-method-uses-to-length":439,"../internals/export":466,"core-js/modules/es.array.map.js":579}],580:[function(require,module,exports){
'use strict';

require("core-js/modules/es.array.slice.js");
var $ = require('../internals/export');
var isObject = require('../internals/is-object');
var isArray = require('../internals/is-array');
var toAbsoluteIndex = require('../internals/to-absolute-index');
var toLength = require('../internals/to-length');
var toIndexedObject = require('../internals/to-indexed-object');
var createProperty = require('../internals/create-property');
var wellKnownSymbol = require('../internals/well-known-symbol');
var arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');
var arrayMethodUsesToLength = require('../internals/array-method-uses-to-length');
var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('slice');
var USES_TO_LENGTH = arrayMethodUsesToLength('slice', {
  ACCESSORS: true,
  0: 0,
  1: 2
});
var SPECIES = wellKnownSymbol('species');
var nativeSlice = [].slice;
var max = Math.max;

// `Array.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-array.prototype.slice
// fallback for not array-like ES3 strings and DOM objects
$({
  target: 'Array',
  proto: true,
  forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH
}, {
  slice: function slice(start, end) {
    var O = toIndexedObject(this);
    var length = toLength(O.length);
    var k = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
    var Constructor, result, n;
    if (isArray(O)) {
      Constructor = O.constructor;
      // cross-realm fallback
      if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {
        Constructor = undefined;
      } else if (isObject(Constructor)) {
        Constructor = Constructor[SPECIES];
        if (Constructor === null) Constructor = undefined;
      }
      if (Constructor === Array || Constructor === undefined) {
        return nativeSlice.call(O, k, fin);
      }
    }
    result = new (Constructor === undefined ? Array : Constructor)(max(fin - k, 0));
    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
    result.length = n;
    return result;
  }
});

},{"../internals/array-method-has-species-support":437,"../internals/array-method-uses-to-length":439,"../internals/create-property":455,"../internals/export":466,"../internals/is-array":488,"../internals/is-object":491,"../internals/to-absolute-index":548,"../internals/to-indexed-object":550,"../internals/to-length":552,"../internals/well-known-symbol":564,"core-js/modules/es.array.slice.js":580}],581:[function(require,module,exports){
'use strict';

require("core-js/modules/es.array.sort.js");
var $ = require('../internals/export');
var aFunction = require('../internals/a-function');
var toObject = require('../internals/to-object');
var fails = require('../internals/fails');
var arrayMethodIsStrict = require('../internals/array-method-is-strict');
var test = [];
var nativeSort = test.sort;

// IE8-
var FAILS_ON_UNDEFINED = fails(function () {
  test.sort(undefined);
});
// V8 bug
var FAILS_ON_NULL = fails(function () {
  test.sort(null);
});
// Old WebKit
var STRICT_METHOD = arrayMethodIsStrict('sort');
var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD;

// `Array.prototype.sort` method
// https://tc39.github.io/ecma262/#sec-array.prototype.sort
$({
  target: 'Array',
  proto: true,
  forced: FORCED
}, {
  sort: function sort(comparefn) {
    return comparefn === undefined ? nativeSort.call(toObject(this)) : nativeSort.call(toObject(this), aFunction(comparefn));
  }
});

},{"../internals/a-function":421,"../internals/array-method-is-strict":438,"../internals/export":466,"../internals/fails":467,"../internals/to-object":553,"core-js/modules/es.array.sort.js":581}],582:[function(require,module,exports){
'use strict';

var $ = require('../internals/export');
var toAbsoluteIndex = require('../internals/to-absolute-index');
var toInteger = require('../internals/to-integer');
var toLength = require('../internals/to-length');
var toObject = require('../internals/to-object');
var arraySpeciesCreate = require('../internals/array-species-create');
var createProperty = require('../internals/create-property');
var arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');
var arrayMethodUsesToLength = require('../internals/array-method-uses-to-length');
var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('splice');
var USES_TO_LENGTH = arrayMethodUsesToLength('splice', {
  ACCESSORS: true,
  0: 0,
  1: 2
});
var max = Math.max;
var min = Math.min;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';

// `Array.prototype.splice` method
// https://tc39.github.io/ecma262/#sec-array.prototype.splice
// with adding support of @@species
$({
  target: 'Array',
  proto: true,
  forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH
}, {
  splice: function splice(start, deleteCount /* , ...items */) {
    var O = toObject(this);
    var len = toLength(O.length);
    var actualStart = toAbsoluteIndex(start, len);
    var argumentsLength = arguments.length;
    var insertCount, actualDeleteCount, A, k, from, to;
    if (argumentsLength === 0) {
      insertCount = actualDeleteCount = 0;
    } else if (argumentsLength === 1) {
      insertCount = 0;
      actualDeleteCount = len - actualStart;
    } else {
      insertCount = argumentsLength - 2;
      actualDeleteCount = min(max(toInteger(deleteCount), 0), len - actualStart);
    }
    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
    }
    A = arraySpeciesCreate(O, actualDeleteCount);
    for (k = 0; k < actualDeleteCount; k++) {
      from = actualStart + k;
      if (from in O) createProperty(A, k, O[from]);
    }
    A.length = actualDeleteCount;
    if (insertCount < actualDeleteCount) {
      for (k = actualStart; k < len - actualDeleteCount; k++) {
        from = k + actualDeleteCount;
        to = k + insertCount;
        if (from in O) O[to] = O[from];else delete O[to];
      }
      for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
    } else if (insertCount > actualDeleteCount) {
      for (k = len - actualDeleteCount; k > actualStart; k--) {
        from = k + actualDeleteCount - 1;
        to = k + insertCount - 1;
        if (from in O) O[to] = O[from];else delete O[to];
      }
    }
    for (k = 0; k < insertCount; k++) {
      O[k + actualStart] = arguments[k + 2];
    }
    O.length = len - actualDeleteCount + insertCount;
    return A;
  }
});

},{"../internals/array-method-has-species-support":437,"../internals/array-method-uses-to-length":439,"../internals/array-species-create":441,"../internals/create-property":455,"../internals/export":466,"../internals/to-absolute-index":548,"../internals/to-integer":551,"../internals/to-length":552,"../internals/to-object":553}],583:[function(require,module,exports){
"use strict";

var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var dateToPrimitive = require('../internals/date-to-primitive');
var wellKnownSymbol = require('../internals/well-known-symbol');
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
var DatePrototype = Date.prototype;

// `Date.prototype[@@toPrimitive]` method
// https://tc39.github.io/ecma262/#sec-date.prototype-@@toprimitive
if (!(TO_PRIMITIVE in DatePrototype)) {
  createNonEnumerableProperty(DatePrototype, TO_PRIMITIVE, dateToPrimitive);
}

},{"../internals/create-non-enumerable-property":453,"../internals/date-to-primitive":456,"../internals/well-known-symbol":564}],584:[function(require,module,exports){
"use strict";

require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.match.js");
var DESCRIPTORS = require('../internals/descriptors');
var defineProperty = require('../internals/object-define-property').f;
var FunctionPrototype = Function.prototype;
var FunctionPrototypeToString = FunctionPrototype.toString;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// Function instances `.name` property
// https://tc39.github.io/ecma262/#sec-function-instances-name
if (DESCRIPTORS && !(NAME in FunctionPrototype)) {
  defineProperty(FunctionPrototype, NAME, {
    configurable: true,
    get: function get() {
      try {
        return FunctionPrototypeToString.call(this).match(nameRE)[1];
      } catch (error) {
        return '';
      }
    }
  });
}

},{"../internals/descriptors":459,"../internals/object-define-property":510,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.match.js":627}],585:[function(require,module,exports){
"use strict";

var $ = require('../internals/export');
var global = require('../internals/global');

// `globalThis` object
// https://github.com/tc39/proposal-global
$({
  global: true
}, {
  globalThis: global
});

},{"../internals/export":466,"../internals/global":475}],586:[function(require,module,exports){
"use strict";

var global = require('../internals/global');
var setToStringTag = require('../internals/set-to-string-tag');

// JSON[@@toStringTag] property
// https://tc39.github.io/ecma262/#sec-json-@@tostringtag
setToStringTag(global.JSON, 'JSON', true);

},{"../internals/global":475,"../internals/set-to-string-tag":536}],587:[function(require,module,exports){
'use strict';

var collection = require('../internals/collection');
var collectionStrong = require('../internals/collection-strong');

// `Map` constructor
// https://tc39.github.io/ecma262/#sec-map-objects
module.exports = collection('Map', function (init) {
  return function Map() {
    return init(this, arguments.length ? arguments[0] : undefined);
  };
}, collectionStrong);

},{"../internals/collection":448,"../internals/collection-strong":446}],588:[function(require,module,exports){
"use strict";

var $ = require('../internals/export');
var floor = Math.floor;
var log = Math.log;
var LOG2E = Math.LOG2E;

// `Math.clz32` method
// https://tc39.github.io/ecma262/#sec-math.clz32
$({
  target: 'Math',
  stat: true
}, {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - floor(log(x + 0.5) * LOG2E) : 32;
  }
});

},{"../internals/export":466}],589:[function(require,module,exports){
"use strict";

require("core-js/modules/es.math.imul.js");
var $ = require('../internals/export');
var fails = require('../internals/fails');
var nativeImul = Math.imul;
var FORCED = fails(function () {
  return nativeImul(0xFFFFFFFF, 5) != -5 || nativeImul.length != 2;
});

// `Math.imul` method
// https://tc39.github.io/ecma262/#sec-math.imul
// some WebKit versions fails with big numbers, some has wrong arity
$({
  target: 'Math',
  stat: true,
  forced: FORCED
}, {
  imul: function imul(x, y) {
    var UINT16 = 0xFFFF;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});

},{"../internals/export":466,"../internals/fails":467,"core-js/modules/es.math.imul.js":589}],590:[function(require,module,exports){
"use strict";

var $ = require('../internals/export');
var sign = require('../internals/math-sign');

// `Math.sign` method
// https://tc39.github.io/ecma262/#sec-math.sign
$({
  target: 'Math',
  stat: true
}, {
  sign: sign
});

},{"../internals/export":466,"../internals/math-sign":497}],591:[function(require,module,exports){
"use strict";

var setToStringTag = require('../internals/set-to-string-tag');

// Math[@@toStringTag] property
// https://tc39.github.io/ecma262/#sec-math-@@tostringtag
setToStringTag(Math, 'Math', true);

},{"../internals/set-to-string-tag":536}],592:[function(require,module,exports){
"use strict";

var $ = require('../internals/export');
var ceil = Math.ceil;
var floor = Math.floor;

// `Math.trunc` method
// https://tc39.github.io/ecma262/#sec-math.trunc
$({
  target: 'Math',
  stat: true
}, {
  trunc: function trunc(it) {
    return (it > 0 ? floor : ceil)(it);
  }
});

},{"../internals/export":466}],593:[function(require,module,exports){
'use strict';

require("core-js/modules/es.string.trim.js");
require("core-js/modules/es.array.slice.js");
var DESCRIPTORS = require('../internals/descriptors');
var global = require('../internals/global');
var isForced = require('../internals/is-forced');
var redefine = require('../internals/redefine');
var has = require('../internals/has');
var classof = require('../internals/classof-raw');
var inheritIfRequired = require('../internals/inherit-if-required');
var toPrimitive = require('../internals/to-primitive');
var fails = require('../internals/fails');
var create = require('../internals/object-create');
var getOwnPropertyNames = require('../internals/object-get-own-property-names').f;
var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
var defineProperty = require('../internals/object-define-property').f;
var trim = require('../internals/string-trim').trim;
var NUMBER = 'Number';
var NativeNumber = global[NUMBER];
var NumberPrototype = NativeNumber.prototype;

// Opera ~12 has broken Object#toString
var BROKEN_CLASSOF = classof(create(NumberPrototype)) == NUMBER;

// `ToNumber` abstract operation
// https://tc39.github.io/ecma262/#sec-tonumber
var toNumber = function toNumber(argument) {
  var it = toPrimitive(argument, false);
  var first, third, radix, maxCode, digits, length, index, code;
  if (typeof it == 'string' && it.length > 2) {
    it = trim(it);
    first = it.charCodeAt(0);
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66:
        case 98:
          radix = 2;
          maxCode = 49;
          break;
        // fast equal of /^0b[01]+$/i
        case 79:
        case 111:
          radix = 8;
          maxCode = 55;
          break;
        // fast equal of /^0o[0-7]+$/i
        default:
          return +it;
      }
      digits = it.slice(2);
      length = digits.length;
      for (index = 0; index < length; index++) {
        code = digits.charCodeAt(index);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      }
      return parseInt(digits, radix);
    }
  }
  return +it;
};

// `Number` constructor
// https://tc39.github.io/ecma262/#sec-number-constructor
if (isForced(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
  var NumberWrapper = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var dummy = this;
    return dummy instanceof NumberWrapper
    // check on 1..constructor(foo) case
    && (BROKEN_CLASSOF ? fails(function () {
      NumberPrototype.valueOf.call(dummy);
    }) : classof(dummy) != NUMBER) ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);
  };
  for (var keys = DESCRIPTORS ? getOwnPropertyNames(NativeNumber) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES2015 (in case, if modules with ES2015 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), j = 0, key; keys.length > j; j++) {
    if (has(NativeNumber, key = keys[j]) && !has(NumberWrapper, key)) {
      defineProperty(NumberWrapper, key, getOwnPropertyDescriptor(NativeNumber, key));
    }
  }
  NumberWrapper.prototype = NumberPrototype;
  NumberPrototype.constructor = NumberWrapper;
  redefine(global, NUMBER, NumberWrapper);
}

},{"../internals/classof-raw":444,"../internals/descriptors":459,"../internals/fails":467,"../internals/global":475,"../internals/has":476,"../internals/inherit-if-required":483,"../internals/is-forced":489,"../internals/object-create":508,"../internals/object-define-property":510,"../internals/object-get-own-property-descriptor":511,"../internals/object-get-own-property-names":513,"../internals/redefine":527,"../internals/string-trim":545,"../internals/to-primitive":556,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.string.trim.js":634}],594:[function(require,module,exports){
"use strict";

var $ = require('../internals/export');

// `Number.EPSILON` constant
// https://tc39.github.io/ecma262/#sec-number.epsilon
$({
  target: 'Number',
  stat: true
}, {
  EPSILON: Math.pow(2, -52)
});

},{"../internals/export":466}],595:[function(require,module,exports){
"use strict";

var $ = require('../internals/export');
var isInteger = require('../internals/is-integer');

// `Number.isInteger` method
// https://tc39.github.io/ecma262/#sec-number.isinteger
$({
  target: 'Number',
  stat: true
}, {
  isInteger: isInteger
});

},{"../internals/export":466,"../internals/is-integer":490}],596:[function(require,module,exports){
"use strict";

var $ = require('../internals/export');

// `Number.isNaN` method
// https://tc39.github.io/ecma262/#sec-number.isnan
$({
  target: 'Number',
  stat: true
}, {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});

},{"../internals/export":466}],597:[function(require,module,exports){
"use strict";

var $ = require('../internals/export');

// `Number.MAX_SAFE_INTEGER` constant
// https://tc39.github.io/ecma262/#sec-number.max_safe_integer
$({
  target: 'Number',
  stat: true
}, {
  MAX_SAFE_INTEGER: 0x1FFFFFFFFFFFFF
});

},{"../internals/export":466}],598:[function(require,module,exports){
"use strict";

require("core-js/modules/es.number.parse-float.js");
require("core-js/modules/es.number.constructor.js");
var $ = require('../internals/export');
var parseFloat = require('../internals/number-parse-float');

// `Number.parseFloat` method
// https://tc39.github.io/ecma262/#sec-number.parseFloat
$({
  target: 'Number',
  stat: true,
  forced: Number.parseFloat != parseFloat
}, {
  parseFloat: parseFloat
});

},{"../internals/export":466,"../internals/number-parse-float":505,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.number.parse-float.js":598}],599:[function(require,module,exports){
"use strict";

require("core-js/modules/es.number.parse-int.js");
require("core-js/modules/es.number.constructor.js");
var $ = require('../internals/export');
var parseInt = require('../internals/number-parse-int');

// `Number.parseInt` method
// https://tc39.github.io/ecma262/#sec-number.parseint
$({
  target: 'Number',
  stat: true,
  forced: Number.parseInt != parseInt
}, {
  parseInt: parseInt
});

},{"../internals/export":466,"../internals/number-parse-int":506,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.number.parse-int.js":599}],600:[function(require,module,exports){
'use strict';

require("core-js/modules/es.number.to-fixed.js");
require("core-js/modules/es.array.slice.js");
var $ = require('../internals/export');
var toInteger = require('../internals/to-integer');
var thisNumberValue = require('../internals/this-number-value');
var repeat = require('../internals/string-repeat');
var fails = require('../internals/fails');
var nativeToFixed = 1.0.toFixed;
var floor = Math.floor;
var pow = function pow(x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function log(x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  }
  return n;
};
var FORCED = nativeToFixed && (0.00008.toFixed(3) !== '0.000' || 0.9.toFixed(0) !== '1' || 1.255.toFixed(2) !== '1.25' || 1000000000000000128.0.toFixed(0) !== '1000000000000000128') || !fails(function () {
  // V8 ~ Android 4.3-
  nativeToFixed.call({});
});

// `Number.prototype.toFixed` method
// https://tc39.github.io/ecma262/#sec-number.prototype.tofixed
$({
  target: 'Number',
  proto: true,
  forced: FORCED
}, {
  // eslint-disable-next-line max-statements
  toFixed: function toFixed(fractionDigits) {
    var number = thisNumberValue(this);
    var fractDigits = toInteger(fractionDigits);
    var data = [0, 0, 0, 0, 0, 0];
    var sign = '';
    var result = '0';
    var e, z, j, k;
    var multiply = function multiply(n, c) {
      var index = -1;
      var c2 = c;
      while (++index < 6) {
        c2 += n * data[index];
        data[index] = c2 % 1e7;
        c2 = floor(c2 / 1e7);
      }
    };
    var divide = function divide(n) {
      var index = 6;
      var c = 0;
      while (--index >= 0) {
        c += data[index];
        data[index] = floor(c / n);
        c = c % n * 1e7;
      }
    };
    var dataToString = function dataToString() {
      var index = 6;
      var s = '';
      while (--index >= 0) {
        if (s !== '' || index === 0 || data[index] !== 0) {
          var t = String(data[index]);
          s = s === '' ? t : s + repeat.call('0', 7 - t.length) + t;
        }
      }
      return s;
    };
    if (fractDigits < 0 || fractDigits > 20) throw RangeError('Incorrect fraction digits');
    // eslint-disable-next-line no-self-compare
    if (number != number) return 'NaN';
    if (number <= -1e21 || number >= 1e21) return String(number);
    if (number < 0) {
      sign = '-';
      number = -number;
    }
    if (number > 1e-21) {
      e = log(number * pow(2, 69, 1)) - 69;
      z = e < 0 ? number * pow(2, -e, 1) : number / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(0, z);
        j = fractDigits;
        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        result = dataToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        result = dataToString() + repeat.call('0', fractDigits);
      }
    }
    if (fractDigits > 0) {
      k = result.length;
      result = sign + (k <= fractDigits ? '0.' + repeat.call('0', fractDigits - k) + result : result.slice(0, k - fractDigits) + '.' + result.slice(k - fractDigits));
    } else {
      result = sign + result;
    }
    return result;
  }
});

},{"../internals/export":466,"../internals/fails":467,"../internals/string-repeat":543,"../internals/this-number-value":547,"../internals/to-integer":551,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.number.to-fixed.js":600}],601:[function(require,module,exports){
"use strict";

require("core-js/modules/es.object.assign.js");
var $ = require('../internals/export');
var assign = require('../internals/object-assign');

// `Object.assign` method
// https://tc39.github.io/ecma262/#sec-object.assign
$({
  target: 'Object',
  stat: true,
  forced: Object.assign !== assign
}, {
  assign: assign
});

},{"../internals/export":466,"../internals/object-assign":507,"core-js/modules/es.object.assign.js":601}],602:[function(require,module,exports){
"use strict";

require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/web.dom-collections.iterator.js");
var $ = require('../internals/export');
var $entries = require('../internals/object-to-array').entries;

// `Object.entries` method
// https://tc39.github.io/ecma262/#sec-object.entries
$({
  target: 'Object',
  stat: true
}, {
  entries: function entries(O) {
    return $entries(O);
  }
});

},{"../internals/export":466,"../internals/object-to-array":520,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.object.to-string.js":612,"core-js/modules/web.dom-collections.iterator.js":677}],603:[function(require,module,exports){
"use strict";

var $ = require('../internals/export');
var fails = require('../internals/fails');
var toIndexedObject = require('../internals/to-indexed-object');
var nativeGetOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
var DESCRIPTORS = require('../internals/descriptors');
var FAILS_ON_PRIMITIVES = fails(function () {
  nativeGetOwnPropertyDescriptor(1);
});
var FORCED = !DESCRIPTORS || FAILS_ON_PRIMITIVES;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
$({
  target: 'Object',
  stat: true,
  forced: FORCED,
  sham: !DESCRIPTORS
}, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
    return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
  }
});

},{"../internals/descriptors":459,"../internals/export":466,"../internals/fails":467,"../internals/object-get-own-property-descriptor":511,"../internals/to-indexed-object":550}],604:[function(require,module,exports){
"use strict";

var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var ownKeys = require('../internals/own-keys');
var toIndexedObject = require('../internals/to-indexed-object');
var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
var createProperty = require('../internals/create-property');

// `Object.getOwnPropertyDescriptors` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
$({
  target: 'Object',
  stat: true,
  sham: !DESCRIPTORS
}, {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIndexedObject(object);
    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
    var keys = ownKeys(O);
    var result = {};
    var index = 0;
    var key, descriptor;
    while (keys.length > index) {
      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
      if (descriptor !== undefined) createProperty(result, key, descriptor);
    }
    return result;
  }
});

},{"../internals/create-property":455,"../internals/descriptors":459,"../internals/export":466,"../internals/object-get-own-property-descriptor":511,"../internals/own-keys":522,"../internals/to-indexed-object":550}],605:[function(require,module,exports){
"use strict";

require("core-js/modules/es.object.get-own-property-names.js");
var $ = require('../internals/export');
var fails = require('../internals/fails');
var nativeGetOwnPropertyNames = require('../internals/object-get-own-property-names-external').f;
var FAILS_ON_PRIMITIVES = fails(function () {
  return !Object.getOwnPropertyNames(1);
});

// `Object.getOwnPropertyNames` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertynames
$({
  target: 'Object',
  stat: true,
  forced: FAILS_ON_PRIMITIVES
}, {
  getOwnPropertyNames: nativeGetOwnPropertyNames
});

},{"../internals/export":466,"../internals/fails":467,"../internals/object-get-own-property-names-external":512,"core-js/modules/es.object.get-own-property-names.js":605}],606:[function(require,module,exports){
"use strict";

var $ = require('../internals/export');
var fails = require('../internals/fails');
var toObject = require('../internals/to-object');
var nativeGetPrototypeOf = require('../internals/object-get-prototype-of');
var CORRECT_PROTOTYPE_GETTER = require('../internals/correct-prototype-getter');
var FAILS_ON_PRIMITIVES = fails(function () {
  nativeGetPrototypeOf(1);
});

// `Object.getPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.getprototypeof
$({
  target: 'Object',
  stat: true,
  forced: FAILS_ON_PRIMITIVES,
  sham: !CORRECT_PROTOTYPE_GETTER
}, {
  getPrototypeOf: function getPrototypeOf(it) {
    return nativeGetPrototypeOf(toObject(it));
  }
});

},{"../internals/correct-prototype-getter":451,"../internals/export":466,"../internals/fails":467,"../internals/object-get-prototype-of":515,"../internals/to-object":553}],607:[function(require,module,exports){
"use strict";

require("core-js/modules/es.object.is-extensible.js");
var $ = require('../internals/export');
var fails = require('../internals/fails');
var isObject = require('../internals/is-object');
var nativeIsExtensible = Object.isExtensible;
var FAILS_ON_PRIMITIVES = fails(function () {
  nativeIsExtensible(1);
});

// `Object.isExtensible` method
// https://tc39.github.io/ecma262/#sec-object.isextensible
$({
  target: 'Object',
  stat: true,
  forced: FAILS_ON_PRIMITIVES
}, {
  isExtensible: function isExtensible(it) {
    return isObject(it) ? nativeIsExtensible ? nativeIsExtensible(it) : true : false;
  }
});

},{"../internals/export":466,"../internals/fails":467,"../internals/is-object":491,"core-js/modules/es.object.is-extensible.js":607}],608:[function(require,module,exports){
"use strict";

var $ = require('../internals/export');
var is = require('../internals/same-value');

// `Object.is` method
// https://tc39.github.io/ecma262/#sec-object.is
$({
  target: 'Object',
  stat: true
}, {
  is: is
});

},{"../internals/export":466,"../internals/same-value":533}],609:[function(require,module,exports){
"use strict";

var $ = require('../internals/export');
var toObject = require('../internals/to-object');
var nativeKeys = require('../internals/object-keys');
var fails = require('../internals/fails');
var FAILS_ON_PRIMITIVES = fails(function () {
  nativeKeys(1);
});

// `Object.keys` method
// https://tc39.github.io/ecma262/#sec-object.keys
$({
  target: 'Object',
  stat: true,
  forced: FAILS_ON_PRIMITIVES
}, {
  keys: function keys(it) {
    return nativeKeys(toObject(it));
  }
});

},{"../internals/export":466,"../internals/fails":467,"../internals/object-keys":517,"../internals/to-object":553}],610:[function(require,module,exports){
"use strict";

require("core-js/modules/es.object.prevent-extensions.js");
var $ = require('../internals/export');
var isObject = require('../internals/is-object');
var onFreeze = require('../internals/internal-metadata').onFreeze;
var FREEZING = require('../internals/freezing');
var fails = require('../internals/fails');
var nativePreventExtensions = Object.preventExtensions;
var FAILS_ON_PRIMITIVES = fails(function () {
  nativePreventExtensions(1);
});

// `Object.preventExtensions` method
// https://tc39.github.io/ecma262/#sec-object.preventextensions
$({
  target: 'Object',
  stat: true,
  forced: FAILS_ON_PRIMITIVES,
  sham: !FREEZING
}, {
  preventExtensions: function preventExtensions(it) {
    return nativePreventExtensions && isObject(it) ? nativePreventExtensions(onFreeze(it)) : it;
  }
});

},{"../internals/export":466,"../internals/fails":467,"../internals/freezing":469,"../internals/internal-metadata":485,"../internals/is-object":491,"core-js/modules/es.object.prevent-extensions.js":610}],611:[function(require,module,exports){
"use strict";

var $ = require('../internals/export');
var setPrototypeOf = require('../internals/object-set-prototype-of');

// `Object.setPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.setprototypeof
$({
  target: 'Object',
  stat: true
}, {
  setPrototypeOf: setPrototypeOf
});

},{"../internals/export":466,"../internals/object-set-prototype-of":519}],612:[function(require,module,exports){
"use strict";

var TO_STRING_TAG_SUPPORT = require('../internals/to-string-tag-support');
var redefine = require('../internals/redefine');
var toString = require('../internals/object-to-string');

// `Object.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
if (!TO_STRING_TAG_SUPPORT) {
  redefine(Object.prototype, 'toString', toString, {
    unsafe: true
  });
}

},{"../internals/object-to-string":521,"../internals/redefine":527,"../internals/to-string-tag-support":557}],613:[function(require,module,exports){
'use strict';

require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.promise.finally.js");
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var NativePromise = require('../internals/native-promise-constructor');
var fails = require('../internals/fails');
var getBuiltIn = require('../internals/get-built-in');
var speciesConstructor = require('../internals/species-constructor');
var promiseResolve = require('../internals/promise-resolve');
var redefine = require('../internals/redefine');

// Safari bug https://bugs.webkit.org/show_bug.cgi?id=200829
var NON_GENERIC = !!NativePromise && fails(function () {
  NativePromise.prototype['finally'].call({
    then: function then() {/* empty */}
  }, function () {/* empty */});
});

// `Promise.prototype.finally` method
// https://tc39.github.io/ecma262/#sec-promise.prototype.finally
$({
  target: 'Promise',
  proto: true,
  real: true,
  forced: NON_GENERIC
}, {
  'finally': function _finally(onFinally) {
    var C = speciesConstructor(this, getBuiltIn('Promise'));
    var isFunction = typeof onFinally == 'function';
    return this.then(isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () {
        return x;
      });
    } : onFinally, isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () {
        throw e;
      });
    } : onFinally);
  }
});

// patch native Promise.prototype for native async functions
if (!IS_PURE && typeof NativePromise == 'function' && !NativePromise.prototype['finally']) {
  redefine(NativePromise.prototype, 'finally', getBuiltIn('Promise').prototype['finally']);
}

},{"../internals/export":466,"../internals/fails":467,"../internals/get-built-in":472,"../internals/is-pure":492,"../internals/native-promise-constructor":499,"../internals/promise-resolve":525,"../internals/redefine":527,"../internals/species-constructor":540,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.promise.finally.js":613,"core-js/modules/es.promise.js":614}],614:[function(require,module,exports){
'use strict';

require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.promise.finally.js");
require("core-js/modules/es.regexp.exec.js");
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var global = require('../internals/global');
var getBuiltIn = require('../internals/get-built-in');
var NativePromise = require('../internals/native-promise-constructor');
var redefine = require('../internals/redefine');
var redefineAll = require('../internals/redefine-all');
var setToStringTag = require('../internals/set-to-string-tag');
var setSpecies = require('../internals/set-species');
var isObject = require('../internals/is-object');
var aFunction = require('../internals/a-function');
var anInstance = require('../internals/an-instance');
var classof = require('../internals/classof-raw');
var inspectSource = require('../internals/inspect-source');
var iterate = require('../internals/iterate');
var checkCorrectnessOfIteration = require('../internals/check-correctness-of-iteration');
var speciesConstructor = require('../internals/species-constructor');
var task = require('../internals/task').set;
var microtask = require('../internals/microtask');
var promiseResolve = require('../internals/promise-resolve');
var hostReportErrors = require('../internals/host-report-errors');
var newPromiseCapabilityModule = require('../internals/new-promise-capability');
var perform = require('../internals/perform');
var InternalStateModule = require('../internals/internal-state');
var isForced = require('../internals/is-forced');
var wellKnownSymbol = require('../internals/well-known-symbol');
var V8_VERSION = require('../internals/engine-v8-version');
var SPECIES = wellKnownSymbol('species');
var PROMISE = 'Promise';
var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
var PromiseConstructor = NativePromise;
var TypeError = global.TypeError;
var document = global.document;
var process = global.process;
var $fetch = getBuiltIn('fetch');
var newPromiseCapability = newPromiseCapabilityModule.f;
var newGenericPromiseCapability = newPromiseCapability;
var IS_NODE = classof(process) == 'process';
var DISPATCH_EVENT = !!(document && document.createEvent && global.dispatchEvent);
var UNHANDLED_REJECTION = 'unhandledrejection';
var REJECTION_HANDLED = 'rejectionhandled';
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;
var FORCED = isForced(PROMISE, function () {
  var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);
  if (!GLOBAL_CORE_JS_PROMISE) {
    // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
    // We can't detect it synchronously, so just check versions
    if (V8_VERSION === 66) return true;
    // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    if (!IS_NODE && typeof PromiseRejectionEvent != 'function') return true;
  }
  // We need Promise#finally in the pure version for preventing prototype pollution
  if (IS_PURE && !PromiseConstructor.prototype['finally']) return true;
  // We can't use @@species feature detection in V8 since it causes
  // deoptimization and performance degradation
  // https://github.com/zloirock/core-js/issues/679
  if (V8_VERSION >= 51 && /native code/.test(PromiseConstructor)) return false;
  // Detect correctness of subclassing with @@species support
  var promise = PromiseConstructor.resolve(1);
  var FakePromise = function FakePromise(exec) {
    exec(function () {/* empty */}, function () {/* empty */});
  };
  var constructor = promise.constructor = {};
  constructor[SPECIES] = FakePromise;
  return !(promise.then(function () {/* empty */}) instanceof FakePromise);
});
var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function (iterable) {
  PromiseConstructor.all(iterable)['catch'](function () {/* empty */});
});

// helpers
var isThenable = function isThenable(it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function notify(promise, state, isReject) {
  if (state.notified) return;
  state.notified = true;
  var chain = state.reactions;
  microtask(function () {
    var value = state.value;
    var ok = state.state == FULFILLED;
    var index = 0;
    // variable length - can't use forEach
    while (chain.length > index) {
      var reaction = chain[index++];
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (state.rejection === UNHANDLED) onHandleUnhandled(promise, state);
            state.rejection = HANDLED;
          }
          if (handler === true) result = value;else {
            if (domain) domain.enter();
            result = handler(value); // can throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (error) {
        if (domain && !exited) domain.exit();
        reject(error);
      }
    }
    state.reactions = [];
    state.notified = false;
    if (isReject && !state.rejection) onUnhandled(promise, state);
  });
};
var dispatchEvent = function dispatchEvent(name, promise, reason) {
  var event, handler;
  if (DISPATCH_EVENT) {
    event = document.createEvent('Event');
    event.promise = promise;
    event.reason = reason;
    event.initEvent(name, false, true);
    global.dispatchEvent(event);
  } else event = {
    promise: promise,
    reason: reason
  };
  if (handler = global['on' + name]) handler(event);else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
};
var onUnhandled = function onUnhandled(promise, state) {
  task.call(global, function () {
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform(function () {
        if (IS_NODE) {
          process.emit('unhandledRejection', value, promise);
        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error) throw result.value;
    }
  });
};
var isUnhandled = function isUnhandled(state) {
  return state.rejection !== HANDLED && !state.parent;
};
var onHandleUnhandled = function onHandleUnhandled(promise, state) {
  task.call(global, function () {
    if (IS_NODE) {
      process.emit('rejectionHandled', promise);
    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
  });
};
var bind = function bind(fn, promise, state, unwrap) {
  return function (value) {
    fn(promise, state, value, unwrap);
  };
};
var internalReject = function internalReject(promise, state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify(promise, state, true);
};
var internalResolve = function internalResolve(promise, state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    var then = isThenable(value);
    if (then) {
      microtask(function () {
        var wrapper = {
          done: false
        };
        try {
          then.call(value, bind(internalResolve, promise, wrapper, state), bind(internalReject, promise, wrapper, state));
        } catch (error) {
          internalReject(promise, wrapper, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify(promise, state, false);
    }
  } catch (error) {
    internalReject(promise, {
      done: false
    }, error, state);
  }
};

// constructor polyfill
if (FORCED) {
  // 25.4.3.1 Promise(executor)
  PromiseConstructor = function Promise(executor) {
    anInstance(this, PromiseConstructor, PROMISE);
    aFunction(executor);
    Internal.call(this);
    var state = getInternalState(this);
    try {
      executor(bind(internalResolve, this, state), bind(internalReject, this, state));
    } catch (error) {
      internalReject(this, state, error);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    setInternalState(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: [],
      rejection: false,
      state: PENDING,
      value: undefined
    });
  };
  Internal.prototype = redefineAll(PromiseConstructor.prototype, {
    // `Promise.prototype.then` method
    // https://tc39.github.io/ecma262/#sec-promise.prototype.then
    then: function then(onFulfilled, onRejected) {
      var state = getInternalPromiseState(this);
      var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = IS_NODE ? process.domain : undefined;
      state.parent = true;
      state.reactions.push(reaction);
      if (state.state != PENDING) notify(this, state, false);
      return reaction.promise;
    },
    // `Promise.prototype.catch` method
    // https://tc39.github.io/ecma262/#sec-promise.prototype.catch
    'catch': function _catch(onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function OwnPromiseCapability() {
    var promise = new Internal();
    var state = getInternalState(promise);
    this.promise = promise;
    this.resolve = bind(internalResolve, promise, state);
    this.reject = bind(internalReject, promise, state);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function newPromiseCapability(C) {
    return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
  };
  if (!IS_PURE && typeof NativePromise == 'function') {
    nativeThen = NativePromise.prototype.then;

    // wrap native Promise#then for native async functions
    redefine(NativePromise.prototype, 'then', function then(onFulfilled, onRejected) {
      var that = this;
      return new PromiseConstructor(function (resolve, reject) {
        nativeThen.call(that, resolve, reject);
      }).then(onFulfilled, onRejected);
      // https://github.com/zloirock/core-js/issues/640
    }, {
      unsafe: true
    });

    // wrap fetch result
    if (typeof $fetch == 'function') $({
      global: true,
      enumerable: true,
      forced: true
    }, {
      // eslint-disable-next-line no-unused-vars
      fetch: function fetch(input /* , init */) {
        return promiseResolve(PromiseConstructor, $fetch.apply(global, arguments));
      }
    });
  }
}
$({
  global: true,
  wrap: true,
  forced: FORCED
}, {
  Promise: PromiseConstructor
});
setToStringTag(PromiseConstructor, PROMISE, false, true);
setSpecies(PROMISE);
PromiseWrapper = getBuiltIn(PROMISE);

// statics
$({
  target: PROMISE,
  stat: true,
  forced: FORCED
}, {
  // `Promise.reject` method
  // https://tc39.github.io/ecma262/#sec-promise.reject
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    capability.reject.call(undefined, r);
    return capability.promise;
  }
});
$({
  target: PROMISE,
  stat: true,
  forced: IS_PURE || FORCED
}, {
  // `Promise.resolve` method
  // https://tc39.github.io/ecma262/#sec-promise.resolve
  resolve: function resolve(x) {
    return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x);
  }
});
$({
  target: PROMISE,
  stat: true,
  forced: INCORRECT_ITERATION
}, {
  // `Promise.all` method
  // https://tc39.github.io/ecma262/#sec-promise.all
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aFunction(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        $promiseResolve.call(C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  },
  // `Promise.race` method
  // https://tc39.github.io/ecma262/#sec-promise.race
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aFunction(C.resolve);
      iterate(iterable, function (promise) {
        $promiseResolve.call(C, promise).then(capability.resolve, reject);
      });
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});

},{"../internals/a-function":421,"../internals/an-instance":425,"../internals/check-correctness-of-iteration":443,"../internals/classof-raw":444,"../internals/engine-v8-version":464,"../internals/export":466,"../internals/get-built-in":472,"../internals/global":475,"../internals/host-report-errors":478,"../internals/inspect-source":484,"../internals/internal-state":486,"../internals/is-forced":489,"../internals/is-object":491,"../internals/is-pure":492,"../internals/iterate":494,"../internals/microtask":498,"../internals/native-promise-constructor":499,"../internals/new-promise-capability":503,"../internals/perform":524,"../internals/promise-resolve":525,"../internals/redefine":527,"../internals/redefine-all":526,"../internals/set-species":535,"../internals/set-to-string-tag":536,"../internals/species-constructor":540,"../internals/task":546,"../internals/well-known-symbol":564,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.promise.finally.js":613,"core-js/modules/es.promise.js":614,"core-js/modules/es.regexp.exec.js":618}],615:[function(require,module,exports){
"use strict";

var $ = require('../internals/export');
var getBuiltIn = require('../internals/get-built-in');
var aFunction = require('../internals/a-function');
var anObject = require('../internals/an-object');
var isObject = require('../internals/is-object');
var create = require('../internals/object-create');
var bind = require('../internals/function-bind');
var fails = require('../internals/fails');
var nativeConstruct = getBuiltIn('Reflect', 'construct');

// `Reflect.construct` method
// https://tc39.github.io/ecma262/#sec-reflect.construct
// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() {/* empty */}
  return !(nativeConstruct(function () {/* empty */}, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  nativeConstruct(function () {/* empty */});
});
var FORCED = NEW_TARGET_BUG || ARGS_BUG;
$({
  target: 'Reflect',
  stat: true,
  forced: FORCED,
  sham: FORCED
}, {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0:
          return new Target();
        case 1:
          return new Target(args[0]);
        case 2:
          return new Target(args[0], args[1]);
        case 3:
          return new Target(args[0], args[1], args[2]);
        case 4:
          return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

},{"../internals/a-function":421,"../internals/an-object":426,"../internals/export":466,"../internals/fails":467,"../internals/function-bind":471,"../internals/get-built-in":472,"../internals/is-object":491,"../internals/object-create":508}],616:[function(require,module,exports){
"use strict";

var $ = require('../internals/export');
var isObject = require('../internals/is-object');
var anObject = require('../internals/an-object');
var has = require('../internals/has');
var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
var getPrototypeOf = require('../internals/object-get-prototype-of');

// `Reflect.get` method
// https://tc39.github.io/ecma262/#sec-reflect.get
function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var descriptor, prototype;
  if (anObject(target) === receiver) return target[propertyKey];
  if (descriptor = getOwnPropertyDescriptorModule.f(target, propertyKey)) return has(descriptor, 'value') ? descriptor.value : descriptor.get === undefined ? undefined : descriptor.get.call(receiver);
  if (isObject(prototype = getPrototypeOf(target))) return get(prototype, propertyKey, receiver);
}
$({
  target: 'Reflect',
  stat: true
}, {
  get: get
});

},{"../internals/an-object":426,"../internals/export":466,"../internals/has":476,"../internals/is-object":491,"../internals/object-get-own-property-descriptor":511,"../internals/object-get-prototype-of":515}],617:[function(require,module,exports){
"use strict";

require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
var DESCRIPTORS = require('../internals/descriptors');
var global = require('../internals/global');
var isForced = require('../internals/is-forced');
var inheritIfRequired = require('../internals/inherit-if-required');
var defineProperty = require('../internals/object-define-property').f;
var getOwnPropertyNames = require('../internals/object-get-own-property-names').f;
var isRegExp = require('../internals/is-regexp');
var getFlags = require('../internals/regexp-flags');
var stickyHelpers = require('../internals/regexp-sticky-helpers');
var redefine = require('../internals/redefine');
var fails = require('../internals/fails');
var setInternalState = require('../internals/internal-state').set;
var setSpecies = require('../internals/set-species');
var wellKnownSymbol = require('../internals/well-known-symbol');
var MATCH = wellKnownSymbol('match');
var NativeRegExp = global.RegExp;
var RegExpPrototype = NativeRegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;

// "new" should create a new object, old webkit bug
var CORRECT_NEW = new NativeRegExp(re1) !== re1;
var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
var FORCED = DESCRIPTORS && isForced('RegExp', !CORRECT_NEW || UNSUPPORTED_Y || fails(function () {
  re2[MATCH] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, 'i') != '/a/i';
}));

// `RegExp` constructor
// https://tc39.github.io/ecma262/#sec-regexp-constructor
if (FORCED) {
  var RegExpWrapper = function RegExp(pattern, flags) {
    var thisIsRegExp = this instanceof RegExpWrapper;
    var patternIsRegExp = isRegExp(pattern);
    var flagsAreUndefined = flags === undefined;
    var sticky;
    if (!thisIsRegExp && patternIsRegExp && pattern.constructor === RegExpWrapper && flagsAreUndefined) {
      return pattern;
    }
    if (CORRECT_NEW) {
      if (patternIsRegExp && !flagsAreUndefined) pattern = pattern.source;
    } else if (pattern instanceof RegExpWrapper) {
      if (flagsAreUndefined) flags = getFlags.call(pattern);
      pattern = pattern.source;
    }
    if (UNSUPPORTED_Y) {
      sticky = !!flags && flags.indexOf('y') > -1;
      if (sticky) flags = flags.replace(/y/g, '');
    }
    var result = inheritIfRequired(CORRECT_NEW ? new NativeRegExp(pattern, flags) : NativeRegExp(pattern, flags), thisIsRegExp ? this : RegExpPrototype, RegExpWrapper);
    if (UNSUPPORTED_Y && sticky) setInternalState(result, {
      sticky: sticky
    });
    return result;
  };
  var proxy = function proxy(key) {
    key in RegExpWrapper || defineProperty(RegExpWrapper, key, {
      configurable: true,
      get: function get() {
        return NativeRegExp[key];
      },
      set: function set(it) {
        NativeRegExp[key] = it;
      }
    });
  };
  var keys = getOwnPropertyNames(NativeRegExp);
  var index = 0;
  while (keys.length > index) proxy(keys[index++]);
  RegExpPrototype.constructor = RegExpWrapper;
  RegExpWrapper.prototype = RegExpPrototype;
  redefine(global, 'RegExp', RegExpWrapper);
}

// https://tc39.github.io/ecma262/#sec-get-regexp-@@species
setSpecies('RegExp');

},{"../internals/descriptors":459,"../internals/fails":467,"../internals/global":475,"../internals/inherit-if-required":483,"../internals/internal-state":486,"../internals/is-forced":489,"../internals/is-regexp":493,"../internals/object-define-property":510,"../internals/object-get-own-property-names":513,"../internals/redefine":527,"../internals/regexp-flags":530,"../internals/regexp-sticky-helpers":531,"../internals/set-species":535,"../internals/well-known-symbol":564,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.string.replace.js":629}],618:[function(require,module,exports){
'use strict';

require("core-js/modules/es.regexp.exec.js");
var $ = require('../internals/export');
var exec = require('../internals/regexp-exec');
$({
  target: 'RegExp',
  proto: true,
  forced: /./.exec !== exec
}, {
  exec: exec
});

},{"../internals/export":466,"../internals/regexp-exec":529,"core-js/modules/es.regexp.exec.js":618}],619:[function(require,module,exports){
"use strict";

require("core-js/modules/es.regexp.flags.js");
require("core-js/modules/es.regexp.constructor.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.to-string.js");
var DESCRIPTORS = require('../internals/descriptors');
var objectDefinePropertyModule = require('../internals/object-define-property');
var regExpFlags = require('../internals/regexp-flags');
var UNSUPPORTED_Y = require('../internals/regexp-sticky-helpers').UNSUPPORTED_Y;

// `RegExp.prototype.flags` getter
// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags
if (DESCRIPTORS && (/./g.flags != 'g' || UNSUPPORTED_Y)) {
  objectDefinePropertyModule.f(RegExp.prototype, 'flags', {
    configurable: true,
    get: regExpFlags
  });
}

},{"../internals/descriptors":459,"../internals/object-define-property":510,"../internals/regexp-flags":530,"../internals/regexp-sticky-helpers":531,"core-js/modules/es.regexp.constructor.js":617,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.flags.js":619,"core-js/modules/es.regexp.to-string.js":620}],620:[function(require,module,exports){
'use strict';

require("core-js/modules/es.regexp.constructor.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.regexp.flags.js");
var redefine = require('../internals/redefine');
var anObject = require('../internals/an-object');
var fails = require('../internals/fails');
var flags = require('../internals/regexp-flags');
var TO_STRING = 'toString';
var RegExpPrototype = RegExp.prototype;
var nativeToString = RegExpPrototype[TO_STRING];
var NOT_GENERIC = fails(function () {
  return nativeToString.call({
    source: 'a',
    flags: 'b'
  }) != '/a/b';
});
// FF44- RegExp#toString has a wrong name
var INCORRECT_NAME = nativeToString.name != TO_STRING;

// `RegExp.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-regexp.prototype.tostring
if (NOT_GENERIC || INCORRECT_NAME) {
  redefine(RegExp.prototype, TO_STRING, function toString() {
    var R = anObject(this);
    var p = String(R.source);
    var rf = R.flags;
    var f = String(rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype) ? flags.call(R) : rf);
    return '/' + p + '/' + f;
  }, {
    unsafe: true
  });
}

},{"../internals/an-object":426,"../internals/fails":467,"../internals/redefine":527,"../internals/regexp-flags":530,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.constructor.js":617,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.flags.js":619,"core-js/modules/es.regexp.to-string.js":620}],621:[function(require,module,exports){
'use strict';

var collection = require('../internals/collection');
var collectionStrong = require('../internals/collection-strong');

// `Set` constructor
// https://tc39.github.io/ecma262/#sec-set-objects
module.exports = collection('Set', function (init) {
  return function Set() {
    return init(this, arguments.length ? arguments[0] : undefined);
  };
}, collectionStrong);

},{"../internals/collection":448,"../internals/collection-strong":446}],622:[function(require,module,exports){
'use strict';

var $ = require('../internals/export');
var codeAt = require('../internals/string-multibyte').codeAt;

// `String.prototype.codePointAt` method
// https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
$({
  target: 'String',
  proto: true
}, {
  codePointAt: function codePointAt(pos) {
    return codeAt(this, pos);
  }
});

},{"../internals/export":466,"../internals/string-multibyte":541}],623:[function(require,module,exports){
'use strict';

require("core-js/modules/es.string.ends-with.js");
require("core-js/modules/es.array.slice.js");
var $ = require('../internals/export');
var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
var toLength = require('../internals/to-length');
var notARegExp = require('../internals/not-a-regexp');
var requireObjectCoercible = require('../internals/require-object-coercible');
var correctIsRegExpLogic = require('../internals/correct-is-regexp-logic');
var IS_PURE = require('../internals/is-pure');
var nativeEndsWith = ''.endsWith;
var min = Math.min;
var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic('endsWith');
// https://github.com/zloirock/core-js/pull/702
var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function () {
  var descriptor = getOwnPropertyDescriptor(String.prototype, 'endsWith');
  return descriptor && !descriptor.writable;
}();

// `String.prototype.endsWith` method
// https://tc39.github.io/ecma262/#sec-string.prototype.endswith
$({
  target: 'String',
  proto: true,
  forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC
}, {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = String(requireObjectCoercible(this));
    notARegExp(searchString);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : min(toLength(endPosition), len);
    var search = String(searchString);
    return nativeEndsWith ? nativeEndsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
  }
});

},{"../internals/correct-is-regexp-logic":450,"../internals/export":466,"../internals/is-pure":492,"../internals/not-a-regexp":504,"../internals/object-get-own-property-descriptor":511,"../internals/require-object-coercible":532,"../internals/to-length":552,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.string.ends-with.js":623}],624:[function(require,module,exports){
"use strict";

require("core-js/modules/es.string.from-code-point.js");
require("core-js/modules/es.array.join.js");
var $ = require('../internals/export');
var toAbsoluteIndex = require('../internals/to-absolute-index');
var fromCharCode = String.fromCharCode;
var nativeFromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
var INCORRECT_LENGTH = !!nativeFromCodePoint && nativeFromCodePoint.length != 1;

// `String.fromCodePoint` method
// https://tc39.github.io/ecma262/#sec-string.fromcodepoint
$({
  target: 'String',
  stat: true,
  forced: INCORRECT_LENGTH
}, {
  fromCodePoint: function fromCodePoint(x) {
    // eslint-disable-line no-unused-vars
    var elements = [];
    var length = arguments.length;
    var i = 0;
    var code;
    while (length > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10FFFF) !== code) throw RangeError(code + ' is not a valid code point');
      elements.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xD800, code % 0x400 + 0xDC00));
    }
    return elements.join('');
  }
});

},{"../internals/export":466,"../internals/to-absolute-index":548,"core-js/modules/es.array.join.js":578,"core-js/modules/es.string.from-code-point.js":624}],625:[function(require,module,exports){
'use strict';

var $ = require('../internals/export');
var notARegExp = require('../internals/not-a-regexp');
var requireObjectCoercible = require('../internals/require-object-coercible');
var correctIsRegExpLogic = require('../internals/correct-is-regexp-logic');

// `String.prototype.includes` method
// https://tc39.github.io/ecma262/#sec-string.prototype.includes
$({
  target: 'String',
  proto: true,
  forced: !correctIsRegExpLogic('includes')
}, {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~String(requireObjectCoercible(this)).indexOf(notARegExp(searchString), arguments.length > 1 ? arguments[1] : undefined);
  }
});

},{"../internals/correct-is-regexp-logic":450,"../internals/export":466,"../internals/not-a-regexp":504,"../internals/require-object-coercible":532}],626:[function(require,module,exports){
'use strict';

var charAt = require('../internals/string-multibyte').charAt;
var InternalStateModule = require('../internals/internal-state');
var defineIterator = require('../internals/define-iterator');
var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

// `String.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator
defineIterator(String, 'String', function (iterated) {
  setInternalState(this, {
    type: STRING_ITERATOR,
    string: String(iterated),
    index: 0
  });
  // `%StringIteratorPrototype%.next` method
  // https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return {
    value: undefined,
    done: true
  };
  point = charAt(string, index);
  state.index += point.length;
  return {
    value: point,
    done: false
  };
});

},{"../internals/define-iterator":457,"../internals/internal-state":486,"../internals/string-multibyte":541}],627:[function(require,module,exports){
'use strict';

require("core-js/modules/es.regexp.constructor.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.to-string.js");
var fixRegExpWellKnownSymbolLogic = require('../internals/fix-regexp-well-known-symbol-logic');
var anObject = require('../internals/an-object');
var toLength = require('../internals/to-length');
var requireObjectCoercible = require('../internals/require-object-coercible');
var advanceStringIndex = require('../internals/advance-string-index');
var regExpExec = require('../internals/regexp-exec-abstract');

// @@match logic
fixRegExpWellKnownSymbolLogic('match', 1, function (MATCH, nativeMatch, maybeCallNative) {
  return [
  // `String.prototype.match` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.match
  function match(regexp) {
    var O = requireObjectCoercible(this);
    var matcher = regexp == undefined ? undefined : regexp[MATCH];
    return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  },
  // `RegExp.prototype[@@match]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
  function (regexp) {
    var res = maybeCallNative(nativeMatch, regexp, this);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    if (!rx.global) return regExpExec(rx, S);
    var fullUnicode = rx.unicode;
    rx.lastIndex = 0;
    var A = [];
    var n = 0;
    var result;
    while ((result = regExpExec(rx, S)) !== null) {
      var matchStr = String(result[0]);
      A[n] = matchStr;
      if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      n++;
    }
    return n === 0 ? null : A;
  }];
});

},{"../internals/advance-string-index":424,"../internals/an-object":426,"../internals/fix-regexp-well-known-symbol-logic":468,"../internals/regexp-exec-abstract":528,"../internals/require-object-coercible":532,"../internals/to-length":552,"core-js/modules/es.regexp.constructor.js":617,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620}],628:[function(require,module,exports){
"use strict";

var $ = require('../internals/export');
var repeat = require('../internals/string-repeat');

// `String.prototype.repeat` method
// https://tc39.github.io/ecma262/#sec-string.prototype.repeat
$({
  target: 'String',
  proto: true
}, {
  repeat: repeat
});

},{"../internals/export":466,"../internals/string-repeat":543}],629:[function(require,module,exports){
'use strict';

require("core-js/modules/es.array.concat.js");
require("core-js/modules/es.array.slice.js");
var fixRegExpWellKnownSymbolLogic = require('../internals/fix-regexp-well-known-symbol-logic');
var anObject = require('../internals/an-object');
var toObject = require('../internals/to-object');
var toLength = require('../internals/to-length');
var toInteger = require('../internals/to-integer');
var requireObjectCoercible = require('../internals/require-object-coercible');
var advanceStringIndex = require('../internals/advance-string-index');
var regExpExec = require('../internals/regexp-exec-abstract');
var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;
var maybeToString = function maybeToString(it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
fixRegExpWellKnownSymbolLogic('replace', 2, function (REPLACE, nativeReplace, maybeCallNative, reason) {
  var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
  var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;
  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';
  return [
  // `String.prototype.replace` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.replace
  function replace(searchValue, replaceValue) {
    var O = requireObjectCoercible(this);
    var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
    return replacer !== undefined ? replacer.call(searchValue, O, replaceValue) : nativeReplace.call(String(O), searchValue, replaceValue);
  },
  // `RegExp.prototype[@@replace]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
  function (regexp, replaceValue) {
    if (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE && REPLACE_KEEPS_$0 || typeof replaceValue === 'string' && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1) {
      var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
      if (res.done) return res.value;
    }
    var rx = anObject(regexp);
    var S = String(this);
    var functionalReplace = typeof replaceValue === 'function';
    if (!functionalReplace) replaceValue = String(replaceValue);
    var global = rx.global;
    if (global) {
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
    }
    var results = [];
    while (true) {
      var result = regExpExec(rx, S);
      if (result === null) break;
      results.push(result);
      if (!global) break;
      var matchStr = String(result[0]);
      if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
    }
    var accumulatedResult = '';
    var nextSourcePosition = 0;
    for (var i = 0; i < results.length; i++) {
      result = results[i];
      var matched = String(result[0]);
      var position = max(min(toInteger(result.index), S.length), 0);
      var captures = [];
      // NOTE: This is equivalent to
      //   captures = result.slice(1).map(maybeToString)
      // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
      // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
      // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
      for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
      var namedCaptures = result.groups;
      if (functionalReplace) {
        var replacerArgs = [matched].concat(captures, position, S);
        if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
        var replacement = String(replaceValue.apply(undefined, replacerArgs));
      } else {
        replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
      }
      if (position >= nextSourcePosition) {
        accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
        nextSourcePosition = position + matched.length;
      }
    }
    return accumulatedResult + S.slice(nextSourcePosition);
  }];

  // https://tc39.github.io/ecma262/#sec-getsubstitution
  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return nativeReplace.call(replacement, symbols, function (match, ch) {
      var capture;
      switch (ch.charAt(0)) {
        case '$':
          return '$';
        case '&':
          return matched;
        case '`':
          return str.slice(0, position);
        case "'":
          return str.slice(tailPos);
        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;
        default:
          // \d\d?
          var n = +ch;
          if (n === 0) return match;
          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }
          capture = captures[n - 1];
      }
      return capture === undefined ? '' : capture;
    });
  }
});

},{"../internals/advance-string-index":424,"../internals/an-object":426,"../internals/fix-regexp-well-known-symbol-logic":468,"../internals/regexp-exec-abstract":528,"../internals/require-object-coercible":532,"../internals/to-integer":551,"../internals/to-length":552,"../internals/to-object":553,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.array.slice.js":580}],630:[function(require,module,exports){
'use strict';

require("core-js/modules/es.regexp.constructor.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.to-string.js");
var fixRegExpWellKnownSymbolLogic = require('../internals/fix-regexp-well-known-symbol-logic');
var anObject = require('../internals/an-object');
var requireObjectCoercible = require('../internals/require-object-coercible');
var sameValue = require('../internals/same-value');
var regExpExec = require('../internals/regexp-exec-abstract');

// @@search logic
fixRegExpWellKnownSymbolLogic('search', 1, function (SEARCH, nativeSearch, maybeCallNative) {
  return [
  // `String.prototype.search` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.search
  function search(regexp) {
    var O = requireObjectCoercible(this);
    var searcher = regexp == undefined ? undefined : regexp[SEARCH];
    return searcher !== undefined ? searcher.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  },
  // `RegExp.prototype[@@search]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
  function (regexp) {
    var res = maybeCallNative(nativeSearch, regexp, this);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    var previousLastIndex = rx.lastIndex;
    if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
    var result = regExpExec(rx, S);
    if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
    return result === null ? -1 : result.index;
  }];
});

},{"../internals/an-object":426,"../internals/fix-regexp-well-known-symbol-logic":468,"../internals/regexp-exec-abstract":528,"../internals/require-object-coercible":532,"../internals/same-value":533,"core-js/modules/es.regexp.constructor.js":617,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620}],631:[function(require,module,exports){
'use strict';

require("core-js/modules/es.regexp.constructor.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.string.split.js");
require("core-js/modules/es.array.slice.js");
var fixRegExpWellKnownSymbolLogic = require('../internals/fix-regexp-well-known-symbol-logic');
var isRegExp = require('../internals/is-regexp');
var anObject = require('../internals/an-object');
var requireObjectCoercible = require('../internals/require-object-coercible');
var speciesConstructor = require('../internals/species-constructor');
var advanceStringIndex = require('../internals/advance-string-index');
var toLength = require('../internals/to-length');
var callRegExpExec = require('../internals/regexp-exec-abstract');
var regexpExec = require('../internals/regexp-exec');
var fails = require('../internals/fails');
var arrayPush = [].push;
var min = Math.min;
var MAX_UINT32 = 0xFFFFFFFF;

// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
var SUPPORTS_Y = !fails(function () {
  return !RegExp(MAX_UINT32, 'y');
});

// @@split logic
fixRegExpWellKnownSymbolLogic('split', 2, function (SPLIT, nativeSplit, maybeCallNative) {
  var internalSplit;
  if ('abbc'.split(/(b)*/)[1] == 'c' || 'test'.split(/(?:)/, -1).length != 4 || 'ab'.split(/(?:ab)*/).length != 2 || '.'.split(/(.?)(.?)/).length != 4 || '.'.split(/()()/).length > 1 || ''.split(/.?/).length) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function internalSplit(separator, limit) {
      var string = String(requireObjectCoercible(this));
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (separator === undefined) return [string];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) {
        return nativeSplit.call(string, separator, lim);
      }
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;
      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy.lastIndex;
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match.length > 1 && match.index < string.length) arrayPush.apply(output, match.slice(1));
          lastLength = match[0].length;
          lastLastIndex = lastIndex;
          if (output.length >= lim) break;
        }
        if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
      }

      if (lastLastIndex === string.length) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output.length > lim ? output.slice(0, lim) : output;
    };
    // Chakra, V8
  } else if ('0'.split(undefined, 0).length) {
    internalSplit = function internalSplit(separator, limit) {
      return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
    };
  } else internalSplit = nativeSplit;
  return [
  // `String.prototype.split` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.split
  function split(separator, limit) {
    var O = requireObjectCoercible(this);
    var splitter = separator == undefined ? undefined : separator[SPLIT];
    return splitter !== undefined ? splitter.call(separator, O, limit) : internalSplit.call(String(O), separator, limit);
  },
  // `RegExp.prototype[@@split]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
  //
  // NOTE: This cannot be properly polyfilled in engines that don't support
  // the 'y' flag.
  function (regexp, limit) {
    var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== nativeSplit);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    var C = speciesConstructor(rx, RegExp);
    var unicodeMatching = rx.unicode;
    var flags = (rx.ignoreCase ? 'i' : '') + (rx.multiline ? 'm' : '') + (rx.unicode ? 'u' : '') + (SUPPORTS_Y ? 'y' : 'g');

    // ^(? + rx + ) is needed, in combination with some S slicing, to
    // simulate the 'y' flag.
    var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
    var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
    if (lim === 0) return [];
    if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
    var p = 0;
    var q = 0;
    var A = [];
    while (q < S.length) {
      splitter.lastIndex = SUPPORTS_Y ? q : 0;
      var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
      var e;
      if (z === null || (e = min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p) {
        q = advanceStringIndex(S, q, unicodeMatching);
      } else {
        A.push(S.slice(p, q));
        if (A.length === lim) return A;
        for (var i = 1; i <= z.length - 1; i++) {
          A.push(z[i]);
          if (A.length === lim) return A;
        }
        q = p = e;
      }
    }
    A.push(S.slice(p));
    return A;
  }];
}, !SUPPORTS_Y);

},{"../internals/advance-string-index":424,"../internals/an-object":426,"../internals/fails":467,"../internals/fix-regexp-well-known-symbol-logic":468,"../internals/is-regexp":493,"../internals/regexp-exec":529,"../internals/regexp-exec-abstract":528,"../internals/require-object-coercible":532,"../internals/species-constructor":540,"../internals/to-length":552,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.regexp.constructor.js":617,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.split.js":631}],632:[function(require,module,exports){
'use strict';

require("core-js/modules/es.string.starts-with.js");
require("core-js/modules/es.array.slice.js");
var $ = require('../internals/export');
var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
var toLength = require('../internals/to-length');
var notARegExp = require('../internals/not-a-regexp');
var requireObjectCoercible = require('../internals/require-object-coercible');
var correctIsRegExpLogic = require('../internals/correct-is-regexp-logic');
var IS_PURE = require('../internals/is-pure');
var nativeStartsWith = ''.startsWith;
var min = Math.min;
var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic('startsWith');
// https://github.com/zloirock/core-js/pull/702
var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function () {
  var descriptor = getOwnPropertyDescriptor(String.prototype, 'startsWith');
  return descriptor && !descriptor.writable;
}();

// `String.prototype.startsWith` method
// https://tc39.github.io/ecma262/#sec-string.prototype.startswith
$({
  target: 'String',
  proto: true,
  forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC
}, {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = String(requireObjectCoercible(this));
    notARegExp(searchString);
    var index = toLength(min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return nativeStartsWith ? nativeStartsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
  }
});

},{"../internals/correct-is-regexp-logic":450,"../internals/export":466,"../internals/is-pure":492,"../internals/not-a-regexp":504,"../internals/object-get-own-property-descriptor":511,"../internals/require-object-coercible":532,"../internals/to-length":552,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.string.starts-with.js":632}],633:[function(require,module,exports){
'use strict';

require("core-js/modules/es.string.trim-start.js");
var $ = require('../internals/export');
var $trimStart = require('../internals/string-trim').start;
var forcedStringTrimMethod = require('../internals/string-trim-forced');
var FORCED = forcedStringTrimMethod('trimStart');
var trimStart = FORCED ? function trimStart() {
  return $trimStart(this);
} : ''.trimStart;

// `String.prototype.{ trimStart, trimLeft }` methods
// https://github.com/tc39/ecmascript-string-left-right-trim
$({
  target: 'String',
  proto: true,
  forced: FORCED
}, {
  trimStart: trimStart,
  trimLeft: trimStart
});

},{"../internals/export":466,"../internals/string-trim":545,"../internals/string-trim-forced":544,"core-js/modules/es.string.trim-start.js":633}],634:[function(require,module,exports){
'use strict';

require("core-js/modules/es.string.trim.js");
var $ = require('../internals/export');
var $trim = require('../internals/string-trim').trim;
var forcedStringTrimMethod = require('../internals/string-trim-forced');

// `String.prototype.trim` method
// https://tc39.github.io/ecma262/#sec-string.prototype.trim
$({
  target: 'String',
  proto: true,
  forced: forcedStringTrimMethod('trim')
}, {
  trim: function trim() {
    return $trim(this);
  }
});

},{"../internals/export":466,"../internals/string-trim":545,"../internals/string-trim-forced":544,"core-js/modules/es.string.trim.js":634}],635:[function(require,module,exports){
"use strict";

var defineWellKnownSymbol = require('../internals/define-well-known-symbol');

// `Symbol.asyncIterator` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.asynciterator
defineWellKnownSymbol('asyncIterator');

},{"../internals/define-well-known-symbol":458}],636:[function(require,module,exports){
// `Symbol.prototype.description` getter
// https://tc39.github.io/ecma262/#sec-symbol.prototype.description
'use strict';

require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var global = require('../internals/global');
var has = require('../internals/has');
var isObject = require('../internals/is-object');
var defineProperty = require('../internals/object-define-property').f;
var copyConstructorProperties = require('../internals/copy-constructor-properties');
var NativeSymbol = global.Symbol;
if (DESCRIPTORS && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) ||
// Safari 12 bug
NativeSymbol().description !== undefined)) {
  var EmptyStringDescriptionStore = {};
  // wrap Symbol constructor for correct work with undefined description
  var SymbolWrapper = function _Symbol() {
    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);
    var result = this instanceof SymbolWrapper ? new NativeSymbol(description)
    // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
    : description === undefined ? NativeSymbol() : NativeSymbol(description);
    if (description === '') EmptyStringDescriptionStore[result] = true;
    return result;
  };
  copyConstructorProperties(SymbolWrapper, NativeSymbol);
  var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
  symbolPrototype.constructor = SymbolWrapper;
  var symbolToString = symbolPrototype.toString;
  var native = String(NativeSymbol('test')) == 'Symbol(test)';
  var regexp = /^Symbol\((.*)\)[^)]+$/;
  defineProperty(symbolPrototype, 'description', {
    configurable: true,
    get: function description() {
      var symbol = isObject(this) ? this.valueOf() : this;
      var string = symbolToString.call(symbol);
      if (has(EmptyStringDescriptionStore, symbol)) return '';
      var desc = native ? string.slice(7, -1) : string.replace(regexp, '$1');
      return desc === '' ? undefined : desc;
    }
  });
  $({
    global: true,
    forced: true
  }, {
    Symbol: SymbolWrapper
  });
}

},{"../internals/copy-constructor-properties":449,"../internals/descriptors":459,"../internals/export":466,"../internals/global":475,"../internals/has":476,"../internals/is-object":491,"../internals/object-define-property":510,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.replace.js":629,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.js":638}],637:[function(require,module,exports){
"use strict";

var defineWellKnownSymbol = require('../internals/define-well-known-symbol');

// `Symbol.iterator` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.iterator
defineWellKnownSymbol('iterator');

},{"../internals/define-well-known-symbol":458}],638:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/web.dom-collections.for-each.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.array.concat.js");
var $ = require('../internals/export');
var global = require('../internals/global');
var getBuiltIn = require('../internals/get-built-in');
var IS_PURE = require('../internals/is-pure');
var DESCRIPTORS = require('../internals/descriptors');
var NATIVE_SYMBOL = require('../internals/native-symbol');
var USE_SYMBOL_AS_UID = require('../internals/use-symbol-as-uid');
var fails = require('../internals/fails');
var has = require('../internals/has');
var isArray = require('../internals/is-array');
var isObject = require('../internals/is-object');
var anObject = require('../internals/an-object');
var toObject = require('../internals/to-object');
var toIndexedObject = require('../internals/to-indexed-object');
var toPrimitive = require('../internals/to-primitive');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
var nativeObjectCreate = require('../internals/object-create');
var objectKeys = require('../internals/object-keys');
var getOwnPropertyNamesModule = require('../internals/object-get-own-property-names');
var getOwnPropertyNamesExternal = require('../internals/object-get-own-property-names-external');
var getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');
var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
var definePropertyModule = require('../internals/object-define-property');
var propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var redefine = require('../internals/redefine');
var shared = require('../internals/shared');
var sharedKey = require('../internals/shared-key');
var hiddenKeys = require('../internals/hidden-keys');
var uid = require('../internals/uid');
var wellKnownSymbol = require('../internals/well-known-symbol');
var wrappedWellKnownSymbolModule = require('../internals/well-known-symbol-wrapped');
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
var setToStringTag = require('../internals/set-to-string-tag');
var InternalStateModule = require('../internals/internal-state');
var $forEach = require('../internals/array-iteration').forEach;
var HIDDEN = sharedKey('hidden');
var SYMBOL = 'Symbol';
var PROTOTYPE = 'prototype';
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(SYMBOL);
var ObjectPrototype = Object[PROTOTYPE];
var $Symbol = global.Symbol;
var $stringify = getBuiltIn('JSON', 'stringify');
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var StringToSymbolRegistry = shared('string-to-symbol-registry');
var SymbolToStringRegistry = shared('symbol-to-string-registry');
var WellKnownSymbolsStore = shared('wks');
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDescriptor = DESCRIPTORS && fails(function () {
  return nativeObjectCreate(nativeDefineProperty({}, 'a', {
    get: function get() {
      return nativeDefineProperty(this, 'a', {
        value: 7
      }).a;
    }
  })).a != 7;
}) ? function (O, P, Attributes) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
  nativeDefineProperty(O, P, Attributes);
  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
    nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
  }
} : nativeDefineProperty;
var wrap = function wrap(tag, description) {
  var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]);
  setInternalState(symbol, {
    type: SYMBOL,
    tag: tag,
    description: description
  });
  if (!DESCRIPTORS) symbol.description = description;
  return symbol;
};
var isSymbol = USE_SYMBOL_AS_UID ? function (it) {
  return (0, _typeof2.default)(it) == 'symbol';
} : function (it) {
  return Object(it) instanceof $Symbol;
};
var $defineProperty = function defineProperty(O, P, Attributes) {
  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
  anObject(O);
  var key = toPrimitive(P, true);
  anObject(Attributes);
  if (has(AllSymbols, key)) {
    if (!Attributes.enumerable) {
      if (!has(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
      O[HIDDEN][key] = true;
    } else {
      if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
      Attributes = nativeObjectCreate(Attributes, {
        enumerable: createPropertyDescriptor(0, false)
      });
    }
    return setSymbolDescriptor(O, key, Attributes);
  }
  return nativeDefineProperty(O, key, Attributes);
};
var $defineProperties = function defineProperties(O, Properties) {
  anObject(O);
  var properties = toIndexedObject(Properties);
  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
  $forEach(keys, function (key) {
    if (!DESCRIPTORS || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);
  });
  return O;
};
var $create = function create(O, Properties) {
  return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
};
var $propertyIsEnumerable = function propertyIsEnumerable(V) {
  var P = toPrimitive(V, true);
  var enumerable = nativePropertyIsEnumerable.call(this, P);
  if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;
  return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
  var it = toIndexedObject(O);
  var key = toPrimitive(P, true);
  if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
  var descriptor = nativeGetOwnPropertyDescriptor(it, key);
  if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {
    descriptor.enumerable = true;
  }
  return descriptor;
};
var $getOwnPropertyNames = function getOwnPropertyNames(O) {
  var names = nativeGetOwnPropertyNames(toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);
  });
  return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {
      result.push(AllSymbols[key]);
    }
  });
  return result;
};

// `Symbol` constructor
// https://tc39.github.io/ecma262/#sec-symbol-constructor
if (!NATIVE_SYMBOL) {
  $Symbol = function _Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');
    var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);
    var tag = uid(description);
    var setter = function setter(value) {
      if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
    };
    if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, {
      configurable: true,
      set: setter
    });
    return wrap(tag, description);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return getInternalState(this).tag;
  });
  redefine($Symbol, 'withoutSetter', function (description) {
    return wrap(uid(description), description);
  });
  propertyIsEnumerableModule.f = $propertyIsEnumerable;
  definePropertyModule.f = $defineProperty;
  getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
  getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;
  wrappedWellKnownSymbolModule.f = function (name) {
    return wrap(wellKnownSymbol(name), name);
  };
  if (DESCRIPTORS) {
    // https://github.com/tc39/proposal-Symbol-description
    nativeDefineProperty($Symbol[PROTOTYPE], 'description', {
      configurable: true,
      get: function description() {
        return getInternalState(this).description;
      }
    });
    if (!IS_PURE) {
      redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, {
        unsafe: true
      });
    }
  }
}
$({
  global: true,
  wrap: true,
  forced: !NATIVE_SYMBOL,
  sham: !NATIVE_SYMBOL
}, {
  Symbol: $Symbol
});
$forEach(objectKeys(WellKnownSymbolsStore), function (name) {
  defineWellKnownSymbol(name);
});
$({
  target: SYMBOL,
  stat: true,
  forced: !NATIVE_SYMBOL
}, {
  // `Symbol.for` method
  // https://tc39.github.io/ecma262/#sec-symbol.for
  'for': function _for(key) {
    var string = String(key);
    if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
    var symbol = $Symbol(string);
    StringToSymbolRegistry[string] = symbol;
    SymbolToStringRegistry[symbol] = string;
    return symbol;
  },
  // `Symbol.keyFor` method
  // https://tc39.github.io/ecma262/#sec-symbol.keyfor
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
    if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
  },
  useSetter: function useSetter() {
    USE_SETTER = true;
  },
  useSimple: function useSimple() {
    USE_SETTER = false;
  }
});
$({
  target: 'Object',
  stat: true,
  forced: !NATIVE_SYMBOL,
  sham: !DESCRIPTORS
}, {
  // `Object.create` method
  // https://tc39.github.io/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});
$({
  target: 'Object',
  stat: true,
  forced: !NATIVE_SYMBOL
}, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames,
  // `Object.getOwnPropertySymbols` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
$({
  target: 'Object',
  stat: true,
  forced: fails(function () {
    getOwnPropertySymbolsModule.f(1);
  })
}, {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return getOwnPropertySymbolsModule.f(toObject(it));
  }
});

// `JSON.stringify` method behavior with symbols
// https://tc39.github.io/ecma262/#sec-json.stringify
if ($stringify) {
  var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function () {
    var symbol = $Symbol();
    // MS Edge converts symbol values to JSON as {}
    return $stringify([symbol]) != '[null]'
    // WebKit converts symbol values to JSON as null
    || $stringify({
      a: symbol
    }) != '{}'
    // V8 throws on boxed symbols
    || $stringify(Object(symbol)) != '{}';
  });
  $({
    target: 'JSON',
    stat: true,
    forced: FORCED_JSON_STRINGIFY
  }, {
    // eslint-disable-next-line no-unused-vars
    stringify: function stringify(it, replacer, space) {
      var args = [it];
      var index = 1;
      var $replacer;
      while (arguments.length > index) args.push(arguments[index++]);
      $replacer = replacer;
      if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
      if (!isArray(replacer)) replacer = function replacer(key, value) {
        if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
        if (!isSymbol(value)) return value;
      };
      args[1] = replacer;
      return $stringify.apply(null, args);
    }
  });
}

// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@toprimitive
if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) {
  createNonEnumerableProperty($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
}
// `Symbol.prototype[@@toStringTag]` property
// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag($Symbol, SYMBOL);
hiddenKeys[HIDDEN] = true;

},{"../internals/an-object":426,"../internals/array-iteration":435,"../internals/create-non-enumerable-property":453,"../internals/create-property-descriptor":454,"../internals/define-well-known-symbol":458,"../internals/descriptors":459,"../internals/export":466,"../internals/fails":467,"../internals/get-built-in":472,"../internals/global":475,"../internals/has":476,"../internals/hidden-keys":477,"../internals/internal-state":486,"../internals/is-array":488,"../internals/is-object":491,"../internals/is-pure":492,"../internals/native-symbol":500,"../internals/object-create":508,"../internals/object-define-property":510,"../internals/object-get-own-property-descriptor":511,"../internals/object-get-own-property-names":513,"../internals/object-get-own-property-names-external":512,"../internals/object-get-own-property-symbols":514,"../internals/object-keys":517,"../internals/object-property-is-enumerable":518,"../internals/redefine":527,"../internals/set-to-string-tag":536,"../internals/shared":539,"../internals/shared-key":537,"../internals/to-indexed-object":550,"../internals/to-object":553,"../internals/to-primitive":556,"../internals/uid":561,"../internals/use-symbol-as-uid":562,"../internals/well-known-symbol":564,"../internals/well-known-symbol-wrapped":563,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.for-each.js":676}],639:[function(require,module,exports){
"use strict";

var defineWellKnownSymbol = require('../internals/define-well-known-symbol');

// `Symbol.toPrimitive` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.toprimitive
defineWellKnownSymbol('toPrimitive');

},{"../internals/define-well-known-symbol":458}],640:[function(require,module,exports){
"use strict";

var defineWellKnownSymbol = require('../internals/define-well-known-symbol');

// `Symbol.toStringTag` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.tostringtag
defineWellKnownSymbol('toStringTag');

},{"../internals/define-well-known-symbol":458}],641:[function(require,module,exports){
'use strict';

var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $copyWithin = require('../internals/array-copy-within');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.copyWithin` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.copywithin
exportTypedArrayMethod('copyWithin', function copyWithin(target, start /* , end */) {
  return $copyWithin.call(aTypedArray(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
});

},{"../internals/array-buffer-view-core":428,"../internals/array-copy-within":430}],642:[function(require,module,exports){
'use strict';

require("core-js/modules/es.object.to-string.js");
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $every = require('../internals/array-iteration').every;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.every` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.every
exportTypedArrayMethod('every', function every(callbackfn /* , thisArg */) {
  return $every(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":428,"../internals/array-iteration":435,"core-js/modules/es.object.to-string.js":612}],643:[function(require,module,exports){
'use strict';

var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $fill = require('../internals/array-fill');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.fill` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.fill
// eslint-disable-next-line no-unused-vars
exportTypedArrayMethod('fill', function fill(value /* , start, end */) {
  return $fill.apply(aTypedArray(this), arguments);
});

},{"../internals/array-buffer-view-core":428,"../internals/array-fill":431}],644:[function(require,module,exports){
'use strict';

require("core-js/modules/es.array.filter.js");
require("core-js/modules/es.object.to-string.js");
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $filter = require('../internals/array-iteration').filter;
var speciesConstructor = require('../internals/species-constructor');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.filter` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.filter
exportTypedArrayMethod('filter', function filter(callbackfn /* , thisArg */) {
  var list = $filter(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  var C = speciesConstructor(this, this.constructor);
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor(C))(length);
  while (length > index) result[index] = list[index++];
  return result;
});

},{"../internals/array-buffer-view-core":428,"../internals/array-iteration":435,"../internals/species-constructor":540,"core-js/modules/es.array.filter.js":572,"core-js/modules/es.object.to-string.js":612}],645:[function(require,module,exports){
'use strict';

require("core-js/modules/es.array.find-index.js");
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $findIndex = require('../internals/array-iteration').findIndex;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.findIndex` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.findindex
exportTypedArrayMethod('findIndex', function findIndex(predicate /* , thisArg */) {
  return $findIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":428,"../internals/array-iteration":435,"core-js/modules/es.array.find-index.js":573}],646:[function(require,module,exports){
'use strict';

require("core-js/modules/es.array.find.js");
require("core-js/modules/es.object.to-string.js");
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $find = require('../internals/array-iteration').find;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.find` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.find
exportTypedArrayMethod('find', function find(predicate /* , thisArg */) {
  return $find(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":428,"../internals/array-iteration":435,"core-js/modules/es.array.find.js":574,"core-js/modules/es.object.to-string.js":612}],647:[function(require,module,exports){
"use strict";

var createTypedArrayConstructor = require('../internals/typed-array-constructor');

// `Float32Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Float32', function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"../internals/typed-array-constructor":558}],648:[function(require,module,exports){
"use strict";

var createTypedArrayConstructor = require('../internals/typed-array-constructor');

// `Float64Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Float64', function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"../internals/typed-array-constructor":558}],649:[function(require,module,exports){
'use strict';

require("core-js/modules/es.object.to-string.js");
require("core-js/modules/web.dom-collections.for-each.js");
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $forEach = require('../internals/array-iteration').forEach;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.forEach` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.foreach
exportTypedArrayMethod('forEach', function forEach(callbackfn /* , thisArg */) {
  $forEach(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":428,"../internals/array-iteration":435,"core-js/modules/es.object.to-string.js":612,"core-js/modules/web.dom-collections.for-each.js":676}],650:[function(require,module,exports){
'use strict';

require("core-js/modules/es.array.includes.js");
require("core-js/modules/es.string.includes.js");
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $includes = require('../internals/array-includes').includes;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.includes` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.includes
exportTypedArrayMethod('includes', function includes(searchElement /* , fromIndex */) {
  return $includes(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":428,"../internals/array-includes":434,"core-js/modules/es.array.includes.js":576,"core-js/modules/es.string.includes.js":625}],651:[function(require,module,exports){
'use strict';

var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $indexOf = require('../internals/array-includes').indexOf;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.indexOf` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.indexof
exportTypedArrayMethod('indexOf', function indexOf(searchElement /* , fromIndex */) {
  return $indexOf(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":428,"../internals/array-includes":434}],652:[function(require,module,exports){
"use strict";

var createTypedArrayConstructor = require('../internals/typed-array-constructor');

// `Int16Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Int16', function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"../internals/typed-array-constructor":558}],653:[function(require,module,exports){
"use strict";

var createTypedArrayConstructor = require('../internals/typed-array-constructor');

// `Int32Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Int32', function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"../internals/typed-array-constructor":558}],654:[function(require,module,exports){
"use strict";

var createTypedArrayConstructor = require('../internals/typed-array-constructor');

// `Int8Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Int8', function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"../internals/typed-array-constructor":558}],655:[function(require,module,exports){
'use strict';

require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.function.name.js");
var global = require('../internals/global');
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var ArrayIterators = require('../modules/es.array.iterator');
var wellKnownSymbol = require('../internals/well-known-symbol');
var ITERATOR = wellKnownSymbol('iterator');
var Uint8Array = global.Uint8Array;
var arrayValues = ArrayIterators.values;
var arrayKeys = ArrayIterators.keys;
var arrayEntries = ArrayIterators.entries;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var nativeTypedArrayIterator = Uint8Array && Uint8Array.prototype[ITERATOR];
var CORRECT_ITER_NAME = !!nativeTypedArrayIterator && (nativeTypedArrayIterator.name == 'values' || nativeTypedArrayIterator.name == undefined);
var typedArrayValues = function values() {
  return arrayValues.call(aTypedArray(this));
};

// `%TypedArray%.prototype.entries` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.entries
exportTypedArrayMethod('entries', function entries() {
  return arrayEntries.call(aTypedArray(this));
});
// `%TypedArray%.prototype.keys` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.keys
exportTypedArrayMethod('keys', function keys() {
  return arrayKeys.call(aTypedArray(this));
});
// `%TypedArray%.prototype.values` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.values
exportTypedArrayMethod('values', typedArrayValues, !CORRECT_ITER_NAME);
// `%TypedArray%.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype-@@iterator
exportTypedArrayMethod(ITERATOR, typedArrayValues, !CORRECT_ITER_NAME);

},{"../internals/array-buffer-view-core":428,"../internals/global":475,"../internals/well-known-symbol":564,"../modules/es.array.iterator":577,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.to-string.js":612,"core-js/modules/web.dom-collections.iterator.js":677}],656:[function(require,module,exports){
'use strict';

require("core-js/modules/es.array.join.js");
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $join = [].join;

// `%TypedArray%.prototype.join` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.join
// eslint-disable-next-line no-unused-vars
exportTypedArrayMethod('join', function join(separator) {
  return $join.apply(aTypedArray(this), arguments);
});

},{"../internals/array-buffer-view-core":428,"core-js/modules/es.array.join.js":578}],657:[function(require,module,exports){
'use strict';

var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $lastIndexOf = require('../internals/array-last-index-of');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.lastIndexOf` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.lastindexof
// eslint-disable-next-line no-unused-vars
exportTypedArrayMethod('lastIndexOf', function lastIndexOf(searchElement /* , fromIndex */) {
  return $lastIndexOf.apply(aTypedArray(this), arguments);
});

},{"../internals/array-buffer-view-core":428,"../internals/array-last-index-of":436}],658:[function(require,module,exports){
'use strict';

require("core-js/modules/es.array.map.js");
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $map = require('../internals/array-iteration').map;
var speciesConstructor = require('../internals/species-constructor');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.map` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.map
exportTypedArrayMethod('map', function map(mapfn /* , thisArg */) {
  return $map(aTypedArray(this), mapfn, arguments.length > 1 ? arguments[1] : undefined, function (O, length) {
    return new (aTypedArrayConstructor(speciesConstructor(O, O.constructor)))(length);
  });
});

},{"../internals/array-buffer-view-core":428,"../internals/array-iteration":435,"../internals/species-constructor":540,"core-js/modules/es.array.map.js":579}],659:[function(require,module,exports){
'use strict';

var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $reduceRight = require('../internals/array-reduce').right;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.reduceRicht` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduceright
exportTypedArrayMethod('reduceRight', function reduceRight(callbackfn /* , initialValue */) {
  return $reduceRight(aTypedArray(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":428,"../internals/array-reduce":440}],660:[function(require,module,exports){
'use strict';

var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $reduce = require('../internals/array-reduce').left;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.reduce` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduce
exportTypedArrayMethod('reduce', function reduce(callbackfn /* , initialValue */) {
  return $reduce(aTypedArray(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":428,"../internals/array-reduce":440}],661:[function(require,module,exports){
'use strict';

var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var floor = Math.floor;

// `%TypedArray%.prototype.reverse` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reverse
exportTypedArrayMethod('reverse', function reverse() {
  var that = this;
  var length = aTypedArray(that).length;
  var middle = floor(length / 2);
  var index = 0;
  var value;
  while (index < middle) {
    value = that[index];
    that[index++] = that[--length];
    that[length] = value;
  }
  return that;
});

},{"../internals/array-buffer-view-core":428}],662:[function(require,module,exports){
'use strict';

require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array-buffer.slice.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.typed-array.int8-array.js");
require("core-js/modules/es.typed-array.copy-within.js");
require("core-js/modules/es.typed-array.every.js");
require("core-js/modules/es.typed-array.fill.js");
require("core-js/modules/es.typed-array.filter.js");
require("core-js/modules/es.typed-array.find.js");
require("core-js/modules/es.typed-array.find-index.js");
require("core-js/modules/es.typed-array.for-each.js");
require("core-js/modules/es.typed-array.includes.js");
require("core-js/modules/es.typed-array.index-of.js");
require("core-js/modules/es.typed-array.iterator.js");
require("core-js/modules/es.typed-array.join.js");
require("core-js/modules/es.typed-array.last-index-of.js");
require("core-js/modules/es.typed-array.map.js");
require("core-js/modules/es.typed-array.reduce.js");
require("core-js/modules/es.typed-array.reduce-right.js");
require("core-js/modules/es.typed-array.reverse.js");
require("core-js/modules/es.typed-array.set.js");
require("core-js/modules/es.typed-array.slice.js");
require("core-js/modules/es.typed-array.some.js");
require("core-js/modules/es.typed-array.sort.js");
require("core-js/modules/es.typed-array.subarray.js");
require("core-js/modules/es.typed-array.to-locale-string.js");
require("core-js/modules/es.typed-array.to-string.js");
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var toLength = require('../internals/to-length');
var toOffset = require('../internals/to-offset');
var toObject = require('../internals/to-object');
var fails = require('../internals/fails');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var FORCED = fails(function () {
  // eslint-disable-next-line no-undef
  new Int8Array(1).set({});
});

// `%TypedArray%.prototype.set` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set
exportTypedArrayMethod('set', function set(arrayLike /* , offset */) {
  aTypedArray(this);
  var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
  var length = this.length;
  var src = toObject(arrayLike);
  var len = toLength(src.length);
  var index = 0;
  if (len + offset > length) throw RangeError('Wrong length');
  while (index < len) this[offset + index] = src[index++];
}, FORCED);

},{"../internals/array-buffer-view-core":428,"../internals/fails":467,"../internals/to-length":552,"../internals/to-object":553,"../internals/to-offset":554,"core-js/modules/es.array-buffer.slice.js":568,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.typed-array.copy-within.js":641,"core-js/modules/es.typed-array.every.js":642,"core-js/modules/es.typed-array.fill.js":643,"core-js/modules/es.typed-array.filter.js":644,"core-js/modules/es.typed-array.find-index.js":645,"core-js/modules/es.typed-array.find.js":646,"core-js/modules/es.typed-array.for-each.js":649,"core-js/modules/es.typed-array.includes.js":650,"core-js/modules/es.typed-array.index-of.js":651,"core-js/modules/es.typed-array.int8-array.js":654,"core-js/modules/es.typed-array.iterator.js":655,"core-js/modules/es.typed-array.join.js":656,"core-js/modules/es.typed-array.last-index-of.js":657,"core-js/modules/es.typed-array.map.js":658,"core-js/modules/es.typed-array.reduce-right.js":659,"core-js/modules/es.typed-array.reduce.js":660,"core-js/modules/es.typed-array.reverse.js":661,"core-js/modules/es.typed-array.set.js":662,"core-js/modules/es.typed-array.slice.js":663,"core-js/modules/es.typed-array.some.js":664,"core-js/modules/es.typed-array.sort.js":665,"core-js/modules/es.typed-array.subarray.js":666,"core-js/modules/es.typed-array.to-locale-string.js":667,"core-js/modules/es.typed-array.to-string.js":668}],663:[function(require,module,exports){
'use strict';

require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array-buffer.slice.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.typed-array.int8-array.js");
require("core-js/modules/es.typed-array.copy-within.js");
require("core-js/modules/es.typed-array.every.js");
require("core-js/modules/es.typed-array.fill.js");
require("core-js/modules/es.typed-array.filter.js");
require("core-js/modules/es.typed-array.find.js");
require("core-js/modules/es.typed-array.find-index.js");
require("core-js/modules/es.typed-array.for-each.js");
require("core-js/modules/es.typed-array.includes.js");
require("core-js/modules/es.typed-array.index-of.js");
require("core-js/modules/es.typed-array.iterator.js");
require("core-js/modules/es.typed-array.join.js");
require("core-js/modules/es.typed-array.last-index-of.js");
require("core-js/modules/es.typed-array.map.js");
require("core-js/modules/es.typed-array.reduce.js");
require("core-js/modules/es.typed-array.reduce-right.js");
require("core-js/modules/es.typed-array.reverse.js");
require("core-js/modules/es.typed-array.set.js");
require("core-js/modules/es.typed-array.slice.js");
require("core-js/modules/es.typed-array.some.js");
require("core-js/modules/es.typed-array.sort.js");
require("core-js/modules/es.typed-array.subarray.js");
require("core-js/modules/es.typed-array.to-locale-string.js");
require("core-js/modules/es.typed-array.to-string.js");
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var speciesConstructor = require('../internals/species-constructor');
var fails = require('../internals/fails');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $slice = [].slice;
var FORCED = fails(function () {
  // eslint-disable-next-line no-undef
  new Int8Array(1).slice();
});

// `%TypedArray%.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.slice
exportTypedArrayMethod('slice', function slice(start, end) {
  var list = $slice.call(aTypedArray(this), start, end);
  var C = speciesConstructor(this, this.constructor);
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor(C))(length);
  while (length > index) result[index] = list[index++];
  return result;
}, FORCED);

},{"../internals/array-buffer-view-core":428,"../internals/fails":467,"../internals/species-constructor":540,"core-js/modules/es.array-buffer.slice.js":568,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.typed-array.copy-within.js":641,"core-js/modules/es.typed-array.every.js":642,"core-js/modules/es.typed-array.fill.js":643,"core-js/modules/es.typed-array.filter.js":644,"core-js/modules/es.typed-array.find-index.js":645,"core-js/modules/es.typed-array.find.js":646,"core-js/modules/es.typed-array.for-each.js":649,"core-js/modules/es.typed-array.includes.js":650,"core-js/modules/es.typed-array.index-of.js":651,"core-js/modules/es.typed-array.int8-array.js":654,"core-js/modules/es.typed-array.iterator.js":655,"core-js/modules/es.typed-array.join.js":656,"core-js/modules/es.typed-array.last-index-of.js":657,"core-js/modules/es.typed-array.map.js":658,"core-js/modules/es.typed-array.reduce-right.js":659,"core-js/modules/es.typed-array.reduce.js":660,"core-js/modules/es.typed-array.reverse.js":661,"core-js/modules/es.typed-array.set.js":662,"core-js/modules/es.typed-array.slice.js":663,"core-js/modules/es.typed-array.some.js":664,"core-js/modules/es.typed-array.sort.js":665,"core-js/modules/es.typed-array.subarray.js":666,"core-js/modules/es.typed-array.to-locale-string.js":667,"core-js/modules/es.typed-array.to-string.js":668}],664:[function(require,module,exports){
'use strict';

require("core-js/modules/es.object.to-string.js");
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $some = require('../internals/array-iteration').some;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.some` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.some
exportTypedArrayMethod('some', function some(callbackfn /* , thisArg */) {
  return $some(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":428,"../internals/array-iteration":435,"core-js/modules/es.object.to-string.js":612}],665:[function(require,module,exports){
'use strict';

require("core-js/modules/es.array.sort.js");
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $sort = [].sort;

// `%TypedArray%.prototype.sort` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.sort
exportTypedArrayMethod('sort', function sort(comparefn) {
  return $sort.call(aTypedArray(this), comparefn);
});

},{"../internals/array-buffer-view-core":428,"core-js/modules/es.array.sort.js":581}],666:[function(require,module,exports){
'use strict';

var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var toLength = require('../internals/to-length');
var toAbsoluteIndex = require('../internals/to-absolute-index');
var speciesConstructor = require('../internals/species-constructor');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.subarray` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.subarray
exportTypedArrayMethod('subarray', function subarray(begin, end) {
  var O = aTypedArray(this);
  var length = O.length;
  var beginIndex = toAbsoluteIndex(begin, length);
  return new (speciesConstructor(O, O.constructor))(O.buffer, O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex));
});

},{"../internals/array-buffer-view-core":428,"../internals/species-constructor":540,"../internals/to-absolute-index":548,"../internals/to-length":552}],667:[function(require,module,exports){
'use strict';

require("core-js/modules/es.array.slice.js");
var global = require('../internals/global');
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var fails = require('../internals/fails');
var Int8Array = global.Int8Array;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $toLocaleString = [].toLocaleString;
var $slice = [].slice;

// iOS Safari 6.x fails here
var TO_LOCALE_STRING_BUG = !!Int8Array && fails(function () {
  $toLocaleString.call(new Int8Array(1));
});
var FORCED = fails(function () {
  return [1, 2].toLocaleString() != new Int8Array([1, 2]).toLocaleString();
}) || !fails(function () {
  Int8Array.prototype.toLocaleString.call([1, 2]);
});

// `%TypedArray%.prototype.toLocaleString` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tolocalestring
exportTypedArrayMethod('toLocaleString', function toLocaleString() {
  return $toLocaleString.apply(TO_LOCALE_STRING_BUG ? $slice.call(aTypedArray(this)) : aTypedArray(this), arguments);
}, FORCED);

},{"../internals/array-buffer-view-core":428,"../internals/fails":467,"../internals/global":475,"core-js/modules/es.array.slice.js":580}],668:[function(require,module,exports){
'use strict';

require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.array.join.js");
var exportTypedArrayMethod = require('../internals/array-buffer-view-core').exportTypedArrayMethod;
var fails = require('../internals/fails');
var global = require('../internals/global');
var Uint8Array = global.Uint8Array;
var Uint8ArrayPrototype = Uint8Array && Uint8Array.prototype || {};
var arrayToString = [].toString;
var arrayJoin = [].join;
if (fails(function () {
  arrayToString.call({});
})) {
  arrayToString = function toString() {
    return arrayJoin.call(this);
  };
}
var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString != arrayToString;

// `%TypedArray%.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tostring
exportTypedArrayMethod('toString', arrayToString, IS_NOT_ARRAY_METHOD);

},{"../internals/array-buffer-view-core":428,"../internals/fails":467,"../internals/global":475,"core-js/modules/es.array.join.js":578,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.to-string.js":620}],669:[function(require,module,exports){
"use strict";

var createTypedArrayConstructor = require('../internals/typed-array-constructor');

// `Uint16Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Uint16', function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"../internals/typed-array-constructor":558}],670:[function(require,module,exports){
"use strict";

var createTypedArrayConstructor = require('../internals/typed-array-constructor');

// `Uint32Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Uint32', function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"../internals/typed-array-constructor":558}],671:[function(require,module,exports){
"use strict";

var createTypedArrayConstructor = require('../internals/typed-array-constructor');

// `Uint8Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Uint8', function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"../internals/typed-array-constructor":558}],672:[function(require,module,exports){
"use strict";

var createTypedArrayConstructor = require('../internals/typed-array-constructor');

// `Uint8ClampedArray` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Uint8', function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);

},{"../internals/typed-array-constructor":558}],673:[function(require,module,exports){
'use strict';

require("core-js/modules/es.object.is-extensible.js");
var global = require('../internals/global');
var redefineAll = require('../internals/redefine-all');
var InternalMetadataModule = require('../internals/internal-metadata');
var collection = require('../internals/collection');
var collectionWeak = require('../internals/collection-weak');
var isObject = require('../internals/is-object');
var enforceIternalState = require('../internals/internal-state').enforce;
var NATIVE_WEAK_MAP = require('../internals/native-weak-map');
var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
var isExtensible = Object.isExtensible;
var InternalWeakMap;
var wrapper = function wrapper(init) {
  return function WeakMap() {
    return init(this, arguments.length ? arguments[0] : undefined);
  };
};

// `WeakMap` constructor
// https://tc39.github.io/ecma262/#sec-weakmap-constructor
var $WeakMap = module.exports = collection('WeakMap', wrapper, collectionWeak);

// IE11 WeakMap frozen keys fix
// We can't use feature detection because it crash some old IE builds
// https://github.com/zloirock/core-js/issues/485
if (NATIVE_WEAK_MAP && IS_IE11) {
  InternalWeakMap = collectionWeak.getConstructor(wrapper, 'WeakMap', true);
  InternalMetadataModule.REQUIRED = true;
  var WeakMapPrototype = $WeakMap.prototype;
  var nativeDelete = WeakMapPrototype['delete'];
  var nativeHas = WeakMapPrototype.has;
  var nativeGet = WeakMapPrototype.get;
  var nativeSet = WeakMapPrototype.set;
  redefineAll(WeakMapPrototype, {
    'delete': function _delete(key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceIternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeDelete.call(this, key) || state.frozen['delete'](key);
      }
      return nativeDelete.call(this, key);
    },
    has: function has(key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceIternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeHas.call(this, key) || state.frozen.has(key);
      }
      return nativeHas.call(this, key);
    },
    get: function get(key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceIternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeHas.call(this, key) ? nativeGet.call(this, key) : state.frozen.get(key);
      }
      return nativeGet.call(this, key);
    },
    set: function set(key, value) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceIternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        nativeHas.call(this, key) ? nativeSet.call(this, key, value) : state.frozen.set(key, value);
      } else nativeSet.call(this, key, value);
      return this;
    }
  });
}

},{"../internals/collection":448,"../internals/collection-weak":447,"../internals/global":475,"../internals/internal-metadata":485,"../internals/internal-state":486,"../internals/is-object":491,"../internals/native-weak-map":502,"../internals/redefine-all":526,"core-js/modules/es.object.is-extensible.js":607}],674:[function(require,module,exports){
'use strict';

var collection = require('../internals/collection');
var collectionWeak = require('../internals/collection-weak');

// `WeakSet` constructor
// https://tc39.github.io/ecma262/#sec-weakset-constructor
collection('WeakSet', function (init) {
  return function WeakSet() {
    return init(this, arguments.length ? arguments[0] : undefined);
  };
}, collectionWeak);

},{"../internals/collection":448,"../internals/collection-weak":447}],675:[function(require,module,exports){
"use strict";

// TODO: Remove from `core-js@4`
require('./es.global-this');

},{"./es.global-this":585}],676:[function(require,module,exports){
"use strict";

require("core-js/modules/es.object.to-string.js");
require("core-js/modules/web.dom-collections.for-each.js");
var global = require('../internals/global');
var DOMIterables = require('../internals/dom-iterables');
var forEach = require('../internals/array-for-each');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
for (var COLLECTION_NAME in DOMIterables) {
  var Collection = global[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;
  // some Chrome versions have non-configurable methods on DOMTokenList
  if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {
    createNonEnumerableProperty(CollectionPrototype, 'forEach', forEach);
  } catch (error) {
    CollectionPrototype.forEach = forEach;
  }
}

},{"../internals/array-for-each":432,"../internals/create-non-enumerable-property":453,"../internals/dom-iterables":461,"../internals/global":475,"core-js/modules/es.object.to-string.js":612,"core-js/modules/web.dom-collections.for-each.js":676}],677:[function(require,module,exports){
"use strict";

require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/web.dom-collections.iterator.js");
var global = require('../internals/global');
var DOMIterables = require('../internals/dom-iterables');
var ArrayIteratorMethods = require('../modules/es.array.iterator');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var wellKnownSymbol = require('../internals/well-known-symbol');
var ITERATOR = wellKnownSymbol('iterator');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var ArrayValues = ArrayIteratorMethods.values;
for (var COLLECTION_NAME in DOMIterables) {
  var Collection = global[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;
  if (CollectionPrototype) {
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
      createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
    } catch (error) {
      CollectionPrototype[ITERATOR] = ArrayValues;
    }
    if (!CollectionPrototype[TO_STRING_TAG]) {
      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
    }
    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
      } catch (error) {
        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
      }
    }
  }
}

},{"../internals/create-non-enumerable-property":453,"../internals/dom-iterables":461,"../internals/global":475,"../internals/well-known-symbol":564,"../modules/es.array.iterator":577,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.object.to-string.js":612,"core-js/modules/web.dom-collections.iterator.js":677}],678:[function(require,module,exports){
'use strict';

// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
require("core-js/modules/es.regexp.constructor.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.array.join.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.array.splice.js");
require('../modules/es.array.iterator');
var $ = require('../internals/export');
var getBuiltIn = require('../internals/get-built-in');
var USE_NATIVE_URL = require('../internals/native-url');
var redefine = require('../internals/redefine');
var redefineAll = require('../internals/redefine-all');
var setToStringTag = require('../internals/set-to-string-tag');
var createIteratorConstructor = require('../internals/create-iterator-constructor');
var InternalStateModule = require('../internals/internal-state');
var anInstance = require('../internals/an-instance');
var hasOwn = require('../internals/has');
var bind = require('../internals/function-bind-context');
var classof = require('../internals/classof');
var anObject = require('../internals/an-object');
var isObject = require('../internals/is-object');
var create = require('../internals/object-create');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
var getIterator = require('../internals/get-iterator');
var getIteratorMethod = require('../internals/get-iterator-method');
var wellKnownSymbol = require('../internals/well-known-symbol');
var $fetch = getBuiltIn('fetch');
var Headers = getBuiltIn('Headers');
var ITERATOR = wellKnownSymbol('iterator');
var URL_SEARCH_PARAMS = 'URLSearchParams';
var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';
var setInternalState = InternalStateModule.set;
var getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS);
var getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR);
var plus = /\+/g;
var sequences = Array(4);
var percentSequence = function percentSequence(bytes) {
  return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp('((?:%[\\da-f]{2}){' + bytes + '})', 'gi'));
};
var percentDecode = function percentDecode(sequence) {
  try {
    return decodeURIComponent(sequence);
  } catch (error) {
    return sequence;
  }
};
var deserialize = function deserialize(it) {
  var result = it.replace(plus, ' ');
  var bytes = 4;
  try {
    return decodeURIComponent(result);
  } catch (error) {
    while (bytes) {
      result = result.replace(percentSequence(bytes--), percentDecode);
    }
    return result;
  }
};
var find = /[!'()~]|%20/g;
var replace = {
  '!': '%21',
  "'": '%27',
  '(': '%28',
  ')': '%29',
  '~': '%7E',
  '%20': '+'
};
var replacer = function replacer(match) {
  return replace[match];
};
var serialize = function serialize(it) {
  return encodeURIComponent(it).replace(find, replacer);
};
var parseSearchParams = function parseSearchParams(result, query) {
  if (query) {
    var attributes = query.split('&');
    var index = 0;
    var attribute, entry;
    while (index < attributes.length) {
      attribute = attributes[index++];
      if (attribute.length) {
        entry = attribute.split('=');
        result.push({
          key: deserialize(entry.shift()),
          value: deserialize(entry.join('='))
        });
      }
    }
  }
};
var updateSearchParams = function updateSearchParams(query) {
  this.entries.length = 0;
  parseSearchParams(this.entries, query);
};
var validateArgumentsLength = function validateArgumentsLength(passed, required) {
  if (passed < required) throw TypeError('Not enough arguments');
};
var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
  setInternalState(this, {
    type: URL_SEARCH_PARAMS_ITERATOR,
    iterator: getIterator(getInternalParamsState(params).entries),
    kind: kind
  });
}, 'Iterator', function next() {
  var state = getInternalIteratorState(this);
  var kind = state.kind;
  var step = state.iterator.next();
  var entry = step.value;
  if (!step.done) {
    step.value = kind === 'keys' ? entry.key : kind === 'values' ? entry.value : [entry.key, entry.value];
  }
  return step;
});

// `URLSearchParams` constructor
// https://url.spec.whatwg.org/#interface-urlsearchparams
var URLSearchParamsConstructor = function URLSearchParams( /* init */
) {
  anInstance(this, URLSearchParamsConstructor, URL_SEARCH_PARAMS);
  var init = arguments.length > 0 ? arguments[0] : undefined;
  var that = this;
  var entries = [];
  var iteratorMethod, iterator, next, step, entryIterator, entryNext, first, second, key;
  setInternalState(that, {
    type: URL_SEARCH_PARAMS,
    entries: entries,
    updateURL: function updateURL() {/* empty */},
    updateSearchParams: updateSearchParams
  });
  if (init !== undefined) {
    if (isObject(init)) {
      iteratorMethod = getIteratorMethod(init);
      if (typeof iteratorMethod === 'function') {
        iterator = iteratorMethod.call(init);
        next = iterator.next;
        while (!(step = next.call(iterator)).done) {
          entryIterator = getIterator(anObject(step.value));
          entryNext = entryIterator.next;
          if ((first = entryNext.call(entryIterator)).done || (second = entryNext.call(entryIterator)).done || !entryNext.call(entryIterator).done) throw TypeError('Expected sequence with length 2');
          entries.push({
            key: first.value + '',
            value: second.value + ''
          });
        }
      } else for (key in init) if (hasOwn(init, key)) entries.push({
        key: key,
        value: init[key] + ''
      });
    } else {
      parseSearchParams(entries, typeof init === 'string' ? init.charAt(0) === '?' ? init.slice(1) : init : init + '');
    }
  }
};
var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;
redefineAll(URLSearchParamsPrototype, {
  // `URLSearchParams.prototype.appent` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-append
  append: function append(name, value) {
    validateArgumentsLength(arguments.length, 2);
    var state = getInternalParamsState(this);
    state.entries.push({
      key: name + '',
      value: value + ''
    });
    state.updateURL();
  },
  // `URLSearchParams.prototype.delete` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
  'delete': function _delete(name) {
    validateArgumentsLength(arguments.length, 1);
    var state = getInternalParamsState(this);
    var entries = state.entries;
    var key = name + '';
    var index = 0;
    while (index < entries.length) {
      if (entries[index].key === key) entries.splice(index, 1);else index++;
    }
    state.updateURL();
  },
  // `URLSearchParams.prototype.get` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-get
  get: function get(name) {
    validateArgumentsLength(arguments.length, 1);
    var entries = getInternalParamsState(this).entries;
    var key = name + '';
    var index = 0;
    for (; index < entries.length; index++) {
      if (entries[index].key === key) return entries[index].value;
    }
    return null;
  },
  // `URLSearchParams.prototype.getAll` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
  getAll: function getAll(name) {
    validateArgumentsLength(arguments.length, 1);
    var entries = getInternalParamsState(this).entries;
    var key = name + '';
    var result = [];
    var index = 0;
    for (; index < entries.length; index++) {
      if (entries[index].key === key) result.push(entries[index].value);
    }
    return result;
  },
  // `URLSearchParams.prototype.has` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-has
  has: function has(name) {
    validateArgumentsLength(arguments.length, 1);
    var entries = getInternalParamsState(this).entries;
    var key = name + '';
    var index = 0;
    while (index < entries.length) {
      if (entries[index++].key === key) return true;
    }
    return false;
  },
  // `URLSearchParams.prototype.set` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-set
  set: function set(name, value) {
    validateArgumentsLength(arguments.length, 1);
    var state = getInternalParamsState(this);
    var entries = state.entries;
    var found = false;
    var key = name + '';
    var val = value + '';
    var index = 0;
    var entry;
    for (; index < entries.length; index++) {
      entry = entries[index];
      if (entry.key === key) {
        if (found) entries.splice(index--, 1);else {
          found = true;
          entry.value = val;
        }
      }
    }
    if (!found) entries.push({
      key: key,
      value: val
    });
    state.updateURL();
  },
  // `URLSearchParams.prototype.sort` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
  sort: function sort() {
    var state = getInternalParamsState(this);
    var entries = state.entries;
    // Array#sort is not stable in some engines
    var slice = entries.slice();
    var entry, entriesIndex, sliceIndex;
    entries.length = 0;
    for (sliceIndex = 0; sliceIndex < slice.length; sliceIndex++) {
      entry = slice[sliceIndex];
      for (entriesIndex = 0; entriesIndex < sliceIndex; entriesIndex++) {
        if (entries[entriesIndex].key > entry.key) {
          entries.splice(entriesIndex, 0, entry);
          break;
        }
      }
      if (entriesIndex === sliceIndex) entries.push(entry);
    }
    state.updateURL();
  },
  // `URLSearchParams.prototype.forEach` method
  forEach: function forEach(callback /* , thisArg */) {
    var entries = getInternalParamsState(this).entries;
    var boundFunction = bind(callback, arguments.length > 1 ? arguments[1] : undefined, 3);
    var index = 0;
    var entry;
    while (index < entries.length) {
      entry = entries[index++];
      boundFunction(entry.value, entry.key, this);
    }
  },
  // `URLSearchParams.prototype.keys` method
  keys: function keys() {
    return new URLSearchParamsIterator(this, 'keys');
  },
  // `URLSearchParams.prototype.values` method
  values: function values() {
    return new URLSearchParamsIterator(this, 'values');
  },
  // `URLSearchParams.prototype.entries` method
  entries: function entries() {
    return new URLSearchParamsIterator(this, 'entries');
  }
}, {
  enumerable: true
});

// `URLSearchParams.prototype[@@iterator]` method
redefine(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries);

// `URLSearchParams.prototype.toString` method
// https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior
redefine(URLSearchParamsPrototype, 'toString', function toString() {
  var entries = getInternalParamsState(this).entries;
  var result = [];
  var index = 0;
  var entry;
  while (index < entries.length) {
    entry = entries[index++];
    result.push(serialize(entry.key) + '=' + serialize(entry.value));
  }
  return result.join('&');
}, {
  enumerable: true
});
setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);
$({
  global: true,
  forced: !USE_NATIVE_URL
}, {
  URLSearchParams: URLSearchParamsConstructor
});

// Wrap `fetch` for correct work with polyfilled `URLSearchParams`
// https://github.com/zloirock/core-js/issues/674
if (!USE_NATIVE_URL && typeof $fetch == 'function' && typeof Headers == 'function') {
  $({
    global: true,
    enumerable: true,
    forced: true
  }, {
    fetch: function fetch(input /* , init */) {
      var args = [input];
      var init, body, headers;
      if (arguments.length > 1) {
        init = arguments[1];
        if (isObject(init)) {
          body = init.body;
          if (classof(body) === URL_SEARCH_PARAMS) {
            headers = init.headers ? new Headers(init.headers) : new Headers();
            if (!headers.has('content-type')) {
              headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
            }
            init = create(init, {
              body: createPropertyDescriptor(0, String(body)),
              headers: createPropertyDescriptor(0, headers)
            });
          }
        }
        args.push(init);
      }
      return $fetch.apply(this, args);
    }
  });
}
module.exports = {
  URLSearchParams: URLSearchParamsConstructor,
  getState: getInternalParamsState
};

},{"../internals/an-instance":425,"../internals/an-object":426,"../internals/classof":445,"../internals/create-iterator-constructor":452,"../internals/create-property-descriptor":454,"../internals/export":466,"../internals/function-bind-context":470,"../internals/get-built-in":472,"../internals/get-iterator":474,"../internals/get-iterator-method":473,"../internals/has":476,"../internals/internal-state":486,"../internals/is-object":491,"../internals/native-url":501,"../internals/object-create":508,"../internals/redefine":527,"../internals/redefine-all":526,"../internals/set-to-string-tag":536,"../internals/well-known-symbol":564,"../modules/es.array.iterator":577,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.join.js":578,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.array.splice.js":582,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.constructor.js":617,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.replace.js":629,"core-js/modules/web.dom-collections.iterator.js":677}],679:[function(require,module,exports){
'use strict';

// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.array.join.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.string.search.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/web.url.js");
require("core-js/modules/web.url-search-params.js");
require('../modules/es.string.iterator');
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var USE_NATIVE_URL = require('../internals/native-url');
var global = require('../internals/global');
var defineProperties = require('../internals/object-define-properties');
var redefine = require('../internals/redefine');
var anInstance = require('../internals/an-instance');
var has = require('../internals/has');
var assign = require('../internals/object-assign');
var arrayFrom = require('../internals/array-from');
var codeAt = require('../internals/string-multibyte').codeAt;
var toASCII = require('../internals/string-punycode-to-ascii');
var setToStringTag = require('../internals/set-to-string-tag');
var URLSearchParamsModule = require('../modules/web.url-search-params');
var InternalStateModule = require('../internals/internal-state');
var NativeURL = global.URL;
var URLSearchParams = URLSearchParamsModule.URLSearchParams;
var getInternalSearchParamsState = URLSearchParamsModule.getState;
var setInternalState = InternalStateModule.set;
var getInternalURLState = InternalStateModule.getterFor('URL');
var floor = Math.floor;
var pow = Math.pow;
var INVALID_AUTHORITY = 'Invalid authority';
var INVALID_SCHEME = 'Invalid scheme';
var INVALID_HOST = 'Invalid host';
var INVALID_PORT = 'Invalid port';
var ALPHA = /[A-Za-z]/;
var ALPHANUMERIC = /[\d+-.A-Za-z]/;
var DIGIT = /\d/;
var HEX_START = /^(0x|0X)/;
var OCT = /^[0-7]+$/;
var DEC = /^\d+$/;
var HEX = /^[\dA-Fa-f]+$/;
// eslint-disable-next-line no-control-regex
var FORBIDDEN_HOST_CODE_POINT = /[\u0000\u0009\u000A\u000D #%/:?@[\\]]/;
// eslint-disable-next-line no-control-regex
var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\u0000\u0009\u000A\u000D #/:?@[\\]]/;
// eslint-disable-next-line no-control-regex
var LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\u0000-\u001F ]+|[\u0000-\u001F ]+$/g;
// eslint-disable-next-line no-control-regex
var TAB_AND_NEW_LINE = /[\u0009\u000A\u000D]/g;
var EOF;
var parseHost = function parseHost(url, input) {
  var result, codePoints, index;
  if (input.charAt(0) == '[') {
    if (input.charAt(input.length - 1) != ']') return INVALID_HOST;
    result = parseIPv6(input.slice(1, -1));
    if (!result) return INVALID_HOST;
    url.host = result;
    // opaque host
  } else if (!isSpecial(url)) {
    if (FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT.test(input)) return INVALID_HOST;
    result = '';
    codePoints = arrayFrom(input);
    for (index = 0; index < codePoints.length; index++) {
      result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
    }
    url.host = result;
  } else {
    input = toASCII(input);
    if (FORBIDDEN_HOST_CODE_POINT.test(input)) return INVALID_HOST;
    result = parseIPv4(input);
    if (result === null) return INVALID_HOST;
    url.host = result;
  }
};
var parseIPv4 = function parseIPv4(input) {
  var parts = input.split('.');
  var partsLength, numbers, index, part, radix, number, ipv4;
  if (parts.length && parts[parts.length - 1] == '') {
    parts.pop();
  }
  partsLength = parts.length;
  if (partsLength > 4) return input;
  numbers = [];
  for (index = 0; index < partsLength; index++) {
    part = parts[index];
    if (part == '') return input;
    radix = 10;
    if (part.length > 1 && part.charAt(0) == '0') {
      radix = HEX_START.test(part) ? 16 : 8;
      part = part.slice(radix == 8 ? 1 : 2);
    }
    if (part === '') {
      number = 0;
    } else {
      if (!(radix == 10 ? DEC : radix == 8 ? OCT : HEX).test(part)) return input;
      number = parseInt(part, radix);
    }
    numbers.push(number);
  }
  for (index = 0; index < partsLength; index++) {
    number = numbers[index];
    if (index == partsLength - 1) {
      if (number >= pow(256, 5 - partsLength)) return null;
    } else if (number > 255) return null;
  }
  ipv4 = numbers.pop();
  for (index = 0; index < numbers.length; index++) {
    ipv4 += numbers[index] * pow(256, 3 - index);
  }
  return ipv4;
};

// eslint-disable-next-line max-statements
var parseIPv6 = function parseIPv6(input) {
  var address = [0, 0, 0, 0, 0, 0, 0, 0];
  var pieceIndex = 0;
  var compress = null;
  var pointer = 0;
  var value, length, numbersSeen, ipv4Piece, number, swaps, swap;
  var char = function char() {
    return input.charAt(pointer);
  };
  if (char() == ':') {
    if (input.charAt(1) != ':') return;
    pointer += 2;
    pieceIndex++;
    compress = pieceIndex;
  }
  while (char()) {
    if (pieceIndex == 8) return;
    if (char() == ':') {
      if (compress !== null) return;
      pointer++;
      pieceIndex++;
      compress = pieceIndex;
      continue;
    }
    value = length = 0;
    while (length < 4 && HEX.test(char())) {
      value = value * 16 + parseInt(char(), 16);
      pointer++;
      length++;
    }
    if (char() == '.') {
      if (length == 0) return;
      pointer -= length;
      if (pieceIndex > 6) return;
      numbersSeen = 0;
      while (char()) {
        ipv4Piece = null;
        if (numbersSeen > 0) {
          if (char() == '.' && numbersSeen < 4) pointer++;else return;
        }
        if (!DIGIT.test(char())) return;
        while (DIGIT.test(char())) {
          number = parseInt(char(), 10);
          if (ipv4Piece === null) ipv4Piece = number;else if (ipv4Piece == 0) return;else ipv4Piece = ipv4Piece * 10 + number;
          if (ipv4Piece > 255) return;
          pointer++;
        }
        address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
        numbersSeen++;
        if (numbersSeen == 2 || numbersSeen == 4) pieceIndex++;
      }
      if (numbersSeen != 4) return;
      break;
    } else if (char() == ':') {
      pointer++;
      if (!char()) return;
    } else if (char()) return;
    address[pieceIndex++] = value;
  }
  if (compress !== null) {
    swaps = pieceIndex - compress;
    pieceIndex = 7;
    while (pieceIndex != 0 && swaps > 0) {
      swap = address[pieceIndex];
      address[pieceIndex--] = address[compress + swaps - 1];
      address[compress + --swaps] = swap;
    }
  } else if (pieceIndex != 8) return;
  return address;
};
var findLongestZeroSequence = function findLongestZeroSequence(ipv6) {
  var maxIndex = null;
  var maxLength = 1;
  var currStart = null;
  var currLength = 0;
  var index = 0;
  for (; index < 8; index++) {
    if (ipv6[index] !== 0) {
      if (currLength > maxLength) {
        maxIndex = currStart;
        maxLength = currLength;
      }
      currStart = null;
      currLength = 0;
    } else {
      if (currStart === null) currStart = index;
      ++currLength;
    }
  }
  if (currLength > maxLength) {
    maxIndex = currStart;
    maxLength = currLength;
  }
  return maxIndex;
};
var serializeHost = function serializeHost(host) {
  var result, index, compress, ignore0;
  // ipv4
  if (typeof host == 'number') {
    result = [];
    for (index = 0; index < 4; index++) {
      result.unshift(host % 256);
      host = floor(host / 256);
    }
    return result.join('.');
    // ipv6
  } else if ((0, _typeof2.default)(host) == 'object') {
    result = '';
    compress = findLongestZeroSequence(host);
    for (index = 0; index < 8; index++) {
      if (ignore0 && host[index] === 0) continue;
      if (ignore0) ignore0 = false;
      if (compress === index) {
        result += index ? ':' : '::';
        ignore0 = true;
      } else {
        result += host[index].toString(16);
        if (index < 7) result += ':';
      }
    }
    return '[' + result + ']';
  }
  return host;
};
var C0ControlPercentEncodeSet = {};
var fragmentPercentEncodeSet = assign({}, C0ControlPercentEncodeSet, {
  ' ': 1,
  '"': 1,
  '<': 1,
  '>': 1,
  '`': 1
});
var pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, {
  '#': 1,
  '?': 1,
  '{': 1,
  '}': 1
});
var userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, {
  '/': 1,
  ':': 1,
  ';': 1,
  '=': 1,
  '@': 1,
  '[': 1,
  '\\': 1,
  ']': 1,
  '^': 1,
  '|': 1
});
var percentEncode = function percentEncode(char, set) {
  var code = codeAt(char, 0);
  return code > 0x20 && code < 0x7F && !has(set, char) ? char : encodeURIComponent(char);
};
var specialSchemes = {
  ftp: 21,
  file: null,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443
};
var isSpecial = function isSpecial(url) {
  return has(specialSchemes, url.scheme);
};
var includesCredentials = function includesCredentials(url) {
  return url.username != '' || url.password != '';
};
var cannotHaveUsernamePasswordPort = function cannotHaveUsernamePasswordPort(url) {
  return !url.host || url.cannotBeABaseURL || url.scheme == 'file';
};
var isWindowsDriveLetter = function isWindowsDriveLetter(string, normalized) {
  var second;
  return string.length == 2 && ALPHA.test(string.charAt(0)) && ((second = string.charAt(1)) == ':' || !normalized && second == '|');
};
var startsWithWindowsDriveLetter = function startsWithWindowsDriveLetter(string) {
  var third;
  return string.length > 1 && isWindowsDriveLetter(string.slice(0, 2)) && (string.length == 2 || (third = string.charAt(2)) === '/' || third === '\\' || third === '?' || third === '#');
};
var shortenURLsPath = function shortenURLsPath(url) {
  var path = url.path;
  var pathSize = path.length;
  if (pathSize && (url.scheme != 'file' || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) {
    path.pop();
  }
};
var isSingleDot = function isSingleDot(segment) {
  return segment === '.' || segment.toLowerCase() === '%2e';
};
var isDoubleDot = function isDoubleDot(segment) {
  segment = segment.toLowerCase();
  return segment === '..' || segment === '%2e.' || segment === '.%2e' || segment === '%2e%2e';
};

// States:
var SCHEME_START = {};
var SCHEME = {};
var NO_SCHEME = {};
var SPECIAL_RELATIVE_OR_AUTHORITY = {};
var PATH_OR_AUTHORITY = {};
var RELATIVE = {};
var RELATIVE_SLASH = {};
var SPECIAL_AUTHORITY_SLASHES = {};
var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
var AUTHORITY = {};
var HOST = {};
var HOSTNAME = {};
var PORT = {};
var FILE = {};
var FILE_SLASH = {};
var FILE_HOST = {};
var PATH_START = {};
var PATH = {};
var CANNOT_BE_A_BASE_URL_PATH = {};
var QUERY = {};
var FRAGMENT = {};

// eslint-disable-next-line max-statements
var parseURL = function parseURL(url, input, stateOverride, base) {
  var state = stateOverride || SCHEME_START;
  var pointer = 0;
  var buffer = '';
  var seenAt = false;
  var seenBracket = false;
  var seenPasswordToken = false;
  var codePoints, char, bufferCodePoints, failure;
  if (!stateOverride) {
    url.scheme = '';
    url.username = '';
    url.password = '';
    url.host = null;
    url.port = null;
    url.path = [];
    url.query = null;
    url.fragment = null;
    url.cannotBeABaseURL = false;
    input = input.replace(LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, '');
  }
  input = input.replace(TAB_AND_NEW_LINE, '');
  codePoints = arrayFrom(input);
  while (pointer <= codePoints.length) {
    char = codePoints[pointer];
    switch (state) {
      case SCHEME_START:
        if (char && ALPHA.test(char)) {
          buffer += char.toLowerCase();
          state = SCHEME;
        } else if (!stateOverride) {
          state = NO_SCHEME;
          continue;
        } else return INVALID_SCHEME;
        break;
      case SCHEME:
        if (char && (ALPHANUMERIC.test(char) || char == '+' || char == '-' || char == '.')) {
          buffer += char.toLowerCase();
        } else if (char == ':') {
          if (stateOverride && (isSpecial(url) != has(specialSchemes, buffer) || buffer == 'file' && (includesCredentials(url) || url.port !== null) || url.scheme == 'file' && !url.host)) return;
          url.scheme = buffer;
          if (stateOverride) {
            if (isSpecial(url) && specialSchemes[url.scheme] == url.port) url.port = null;
            return;
          }
          buffer = '';
          if (url.scheme == 'file') {
            state = FILE;
          } else if (isSpecial(url) && base && base.scheme == url.scheme) {
            state = SPECIAL_RELATIVE_OR_AUTHORITY;
          } else if (isSpecial(url)) {
            state = SPECIAL_AUTHORITY_SLASHES;
          } else if (codePoints[pointer + 1] == '/') {
            state = PATH_OR_AUTHORITY;
            pointer++;
          } else {
            url.cannotBeABaseURL = true;
            url.path.push('');
            state = CANNOT_BE_A_BASE_URL_PATH;
          }
        } else if (!stateOverride) {
          buffer = '';
          state = NO_SCHEME;
          pointer = 0;
          continue;
        } else return INVALID_SCHEME;
        break;
      case NO_SCHEME:
        if (!base || base.cannotBeABaseURL && char != '#') return INVALID_SCHEME;
        if (base.cannotBeABaseURL && char == '#') {
          url.scheme = base.scheme;
          url.path = base.path.slice();
          url.query = base.query;
          url.fragment = '';
          url.cannotBeABaseURL = true;
          state = FRAGMENT;
          break;
        }
        state = base.scheme == 'file' ? FILE : RELATIVE;
        continue;
      case SPECIAL_RELATIVE_OR_AUTHORITY:
        if (char == '/' && codePoints[pointer + 1] == '/') {
          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
          pointer++;
        } else {
          state = RELATIVE;
          continue;
        }
        break;
      case PATH_OR_AUTHORITY:
        if (char == '/') {
          state = AUTHORITY;
          break;
        } else {
          state = PATH;
          continue;
        }
      case RELATIVE:
        url.scheme = base.scheme;
        if (char == EOF) {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          url.path = base.path.slice();
          url.query = base.query;
        } else if (char == '/' || char == '\\' && isSpecial(url)) {
          state = RELATIVE_SLASH;
        } else if (char == '?') {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          url.path = base.path.slice();
          url.query = '';
          state = QUERY;
        } else if (char == '#') {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          url.path = base.path.slice();
          url.query = base.query;
          url.fragment = '';
          state = FRAGMENT;
        } else {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          url.path = base.path.slice();
          url.path.pop();
          state = PATH;
          continue;
        }
        break;
      case RELATIVE_SLASH:
        if (isSpecial(url) && (char == '/' || char == '\\')) {
          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
        } else if (char == '/') {
          state = AUTHORITY;
        } else {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          state = PATH;
          continue;
        }
        break;
      case SPECIAL_AUTHORITY_SLASHES:
        state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
        if (char != '/' || buffer.charAt(pointer + 1) != '/') continue;
        pointer++;
        break;
      case SPECIAL_AUTHORITY_IGNORE_SLASHES:
        if (char != '/' && char != '\\') {
          state = AUTHORITY;
          continue;
        }
        break;
      case AUTHORITY:
        if (char == '@') {
          if (seenAt) buffer = '%40' + buffer;
          seenAt = true;
          bufferCodePoints = arrayFrom(buffer);
          for (var i = 0; i < bufferCodePoints.length; i++) {
            var codePoint = bufferCodePoints[i];
            if (codePoint == ':' && !seenPasswordToken) {
              seenPasswordToken = true;
              continue;
            }
            var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
            if (seenPasswordToken) url.password += encodedCodePoints;else url.username += encodedCodePoints;
          }
          buffer = '';
        } else if (char == EOF || char == '/' || char == '?' || char == '#' || char == '\\' && isSpecial(url)) {
          if (seenAt && buffer == '') return INVALID_AUTHORITY;
          pointer -= arrayFrom(buffer).length + 1;
          buffer = '';
          state = HOST;
        } else buffer += char;
        break;
      case HOST:
      case HOSTNAME:
        if (stateOverride && url.scheme == 'file') {
          state = FILE_HOST;
          continue;
        } else if (char == ':' && !seenBracket) {
          if (buffer == '') return INVALID_HOST;
          failure = parseHost(url, buffer);
          if (failure) return failure;
          buffer = '';
          state = PORT;
          if (stateOverride == HOSTNAME) return;
        } else if (char == EOF || char == '/' || char == '?' || char == '#' || char == '\\' && isSpecial(url)) {
          if (isSpecial(url) && buffer == '') return INVALID_HOST;
          if (stateOverride && buffer == '' && (includesCredentials(url) || url.port !== null)) return;
          failure = parseHost(url, buffer);
          if (failure) return failure;
          buffer = '';
          state = PATH_START;
          if (stateOverride) return;
          continue;
        } else {
          if (char == '[') seenBracket = true;else if (char == ']') seenBracket = false;
          buffer += char;
        }
        break;
      case PORT:
        if (DIGIT.test(char)) {
          buffer += char;
        } else if (char == EOF || char == '/' || char == '?' || char == '#' || char == '\\' && isSpecial(url) || stateOverride) {
          if (buffer != '') {
            var port = parseInt(buffer, 10);
            if (port > 0xFFFF) return INVALID_PORT;
            url.port = isSpecial(url) && port === specialSchemes[url.scheme] ? null : port;
            buffer = '';
          }
          if (stateOverride) return;
          state = PATH_START;
          continue;
        } else return INVALID_PORT;
        break;
      case FILE:
        url.scheme = 'file';
        if (char == '/' || char == '\\') state = FILE_SLASH;else if (base && base.scheme == 'file') {
          if (char == EOF) {
            url.host = base.host;
            url.path = base.path.slice();
            url.query = base.query;
          } else if (char == '?') {
            url.host = base.host;
            url.path = base.path.slice();
            url.query = '';
            state = QUERY;
          } else if (char == '#') {
            url.host = base.host;
            url.path = base.path.slice();
            url.query = base.query;
            url.fragment = '';
            state = FRAGMENT;
          } else {
            if (!startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
              url.host = base.host;
              url.path = base.path.slice();
              shortenURLsPath(url);
            }
            state = PATH;
            continue;
          }
        } else {
          state = PATH;
          continue;
        }
        break;
      case FILE_SLASH:
        if (char == '/' || char == '\\') {
          state = FILE_HOST;
          break;
        }
        if (base && base.scheme == 'file' && !startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
          if (isWindowsDriveLetter(base.path[0], true)) url.path.push(base.path[0]);else url.host = base.host;
        }
        state = PATH;
        continue;
      case FILE_HOST:
        if (char == EOF || char == '/' || char == '\\' || char == '?' || char == '#') {
          if (!stateOverride && isWindowsDriveLetter(buffer)) {
            state = PATH;
          } else if (buffer == '') {
            url.host = '';
            if (stateOverride) return;
            state = PATH_START;
          } else {
            failure = parseHost(url, buffer);
            if (failure) return failure;
            if (url.host == 'localhost') url.host = '';
            if (stateOverride) return;
            buffer = '';
            state = PATH_START;
          }
          continue;
        } else buffer += char;
        break;
      case PATH_START:
        if (isSpecial(url)) {
          state = PATH;
          if (char != '/' && char != '\\') continue;
        } else if (!stateOverride && char == '?') {
          url.query = '';
          state = QUERY;
        } else if (!stateOverride && char == '#') {
          url.fragment = '';
          state = FRAGMENT;
        } else if (char != EOF) {
          state = PATH;
          if (char != '/') continue;
        }
        break;
      case PATH:
        if (char == EOF || char == '/' || char == '\\' && isSpecial(url) || !stateOverride && (char == '?' || char == '#')) {
          if (isDoubleDot(buffer)) {
            shortenURLsPath(url);
            if (char != '/' && !(char == '\\' && isSpecial(url))) {
              url.path.push('');
            }
          } else if (isSingleDot(buffer)) {
            if (char != '/' && !(char == '\\' && isSpecial(url))) {
              url.path.push('');
            }
          } else {
            if (url.scheme == 'file' && !url.path.length && isWindowsDriveLetter(buffer)) {
              if (url.host) url.host = '';
              buffer = buffer.charAt(0) + ':'; // normalize windows drive letter
            }

            url.path.push(buffer);
          }
          buffer = '';
          if (url.scheme == 'file' && (char == EOF || char == '?' || char == '#')) {
            while (url.path.length > 1 && url.path[0] === '') {
              url.path.shift();
            }
          }
          if (char == '?') {
            url.query = '';
            state = QUERY;
          } else if (char == '#') {
            url.fragment = '';
            state = FRAGMENT;
          }
        } else {
          buffer += percentEncode(char, pathPercentEncodeSet);
        }
        break;
      case CANNOT_BE_A_BASE_URL_PATH:
        if (char == '?') {
          url.query = '';
          state = QUERY;
        } else if (char == '#') {
          url.fragment = '';
          state = FRAGMENT;
        } else if (char != EOF) {
          url.path[0] += percentEncode(char, C0ControlPercentEncodeSet);
        }
        break;
      case QUERY:
        if (!stateOverride && char == '#') {
          url.fragment = '';
          state = FRAGMENT;
        } else if (char != EOF) {
          if (char == "'" && isSpecial(url)) url.query += '%27';else if (char == '#') url.query += '%23';else url.query += percentEncode(char, C0ControlPercentEncodeSet);
        }
        break;
      case FRAGMENT:
        if (char != EOF) url.fragment += percentEncode(char, fragmentPercentEncodeSet);
        break;
    }
    pointer++;
  }
};

// `URL` constructor
// https://url.spec.whatwg.org/#url-class
var URLConstructor = function URL(url /* , base */) {
  var that = anInstance(this, URLConstructor, 'URL');
  var base = arguments.length > 1 ? arguments[1] : undefined;
  var urlString = String(url);
  var state = setInternalState(that, {
    type: 'URL'
  });
  var baseState, failure;
  if (base !== undefined) {
    if (base instanceof URLConstructor) baseState = getInternalURLState(base);else {
      failure = parseURL(baseState = {}, String(base));
      if (failure) throw TypeError(failure);
    }
  }
  failure = parseURL(state, urlString, null, baseState);
  if (failure) throw TypeError(failure);
  var searchParams = state.searchParams = new URLSearchParams();
  var searchParamsState = getInternalSearchParamsState(searchParams);
  searchParamsState.updateSearchParams(state.query);
  searchParamsState.updateURL = function () {
    state.query = String(searchParams) || null;
  };
  if (!DESCRIPTORS) {
    that.href = serializeURL.call(that);
    that.origin = getOrigin.call(that);
    that.protocol = getProtocol.call(that);
    that.username = getUsername.call(that);
    that.password = getPassword.call(that);
    that.host = getHost.call(that);
    that.hostname = getHostname.call(that);
    that.port = getPort.call(that);
    that.pathname = getPathname.call(that);
    that.search = getSearch.call(that);
    that.searchParams = getSearchParams.call(that);
    that.hash = getHash.call(that);
  }
};
var URLPrototype = URLConstructor.prototype;
var serializeURL = function serializeURL() {
  var url = getInternalURLState(this);
  var scheme = url.scheme;
  var username = url.username;
  var password = url.password;
  var host = url.host;
  var port = url.port;
  var path = url.path;
  var query = url.query;
  var fragment = url.fragment;
  var output = scheme + ':';
  if (host !== null) {
    output += '//';
    if (includesCredentials(url)) {
      output += username + (password ? ':' + password : '') + '@';
    }
    output += serializeHost(host);
    if (port !== null) output += ':' + port;
  } else if (scheme == 'file') output += '//';
  output += url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
  if (query !== null) output += '?' + query;
  if (fragment !== null) output += '#' + fragment;
  return output;
};
var getOrigin = function getOrigin() {
  var url = getInternalURLState(this);
  var scheme = url.scheme;
  var port = url.port;
  if (scheme == 'blob') try {
    return new URL(scheme.path[0]).origin;
  } catch (error) {
    return 'null';
  }
  if (scheme == 'file' || !isSpecial(url)) return 'null';
  return scheme + '://' + serializeHost(url.host) + (port !== null ? ':' + port : '');
};
var getProtocol = function getProtocol() {
  return getInternalURLState(this).scheme + ':';
};
var getUsername = function getUsername() {
  return getInternalURLState(this).username;
};
var getPassword = function getPassword() {
  return getInternalURLState(this).password;
};
var getHost = function getHost() {
  var url = getInternalURLState(this);
  var host = url.host;
  var port = url.port;
  return host === null ? '' : port === null ? serializeHost(host) : serializeHost(host) + ':' + port;
};
var getHostname = function getHostname() {
  var host = getInternalURLState(this).host;
  return host === null ? '' : serializeHost(host);
};
var getPort = function getPort() {
  var port = getInternalURLState(this).port;
  return port === null ? '' : String(port);
};
var getPathname = function getPathname() {
  var url = getInternalURLState(this);
  var path = url.path;
  return url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
};
var getSearch = function getSearch() {
  var query = getInternalURLState(this).query;
  return query ? '?' + query : '';
};
var getSearchParams = function getSearchParams() {
  return getInternalURLState(this).searchParams;
};
var getHash = function getHash() {
  var fragment = getInternalURLState(this).fragment;
  return fragment ? '#' + fragment : '';
};
var accessorDescriptor = function accessorDescriptor(getter, setter) {
  return {
    get: getter,
    set: setter,
    configurable: true,
    enumerable: true
  };
};
if (DESCRIPTORS) {
  defineProperties(URLPrototype, {
    // `URL.prototype.href` accessors pair
    // https://url.spec.whatwg.org/#dom-url-href
    href: accessorDescriptor(serializeURL, function (href) {
      var url = getInternalURLState(this);
      var urlString = String(href);
      var failure = parseURL(url, urlString);
      if (failure) throw TypeError(failure);
      getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
    }),
    // `URL.prototype.origin` getter
    // https://url.spec.whatwg.org/#dom-url-origin
    origin: accessorDescriptor(getOrigin),
    // `URL.prototype.protocol` accessors pair
    // https://url.spec.whatwg.org/#dom-url-protocol
    protocol: accessorDescriptor(getProtocol, function (protocol) {
      var url = getInternalURLState(this);
      parseURL(url, String(protocol) + ':', SCHEME_START);
    }),
    // `URL.prototype.username` accessors pair
    // https://url.spec.whatwg.org/#dom-url-username
    username: accessorDescriptor(getUsername, function (username) {
      var url = getInternalURLState(this);
      var codePoints = arrayFrom(String(username));
      if (cannotHaveUsernamePasswordPort(url)) return;
      url.username = '';
      for (var i = 0; i < codePoints.length; i++) {
        url.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
      }
    }),
    // `URL.prototype.password` accessors pair
    // https://url.spec.whatwg.org/#dom-url-password
    password: accessorDescriptor(getPassword, function (password) {
      var url = getInternalURLState(this);
      var codePoints = arrayFrom(String(password));
      if (cannotHaveUsernamePasswordPort(url)) return;
      url.password = '';
      for (var i = 0; i < codePoints.length; i++) {
        url.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
      }
    }),
    // `URL.prototype.host` accessors pair
    // https://url.spec.whatwg.org/#dom-url-host
    host: accessorDescriptor(getHost, function (host) {
      var url = getInternalURLState(this);
      if (url.cannotBeABaseURL) return;
      parseURL(url, String(host), HOST);
    }),
    // `URL.prototype.hostname` accessors pair
    // https://url.spec.whatwg.org/#dom-url-hostname
    hostname: accessorDescriptor(getHostname, function (hostname) {
      var url = getInternalURLState(this);
      if (url.cannotBeABaseURL) return;
      parseURL(url, String(hostname), HOSTNAME);
    }),
    // `URL.prototype.port` accessors pair
    // https://url.spec.whatwg.org/#dom-url-port
    port: accessorDescriptor(getPort, function (port) {
      var url = getInternalURLState(this);
      if (cannotHaveUsernamePasswordPort(url)) return;
      port = String(port);
      if (port == '') url.port = null;else parseURL(url, port, PORT);
    }),
    // `URL.prototype.pathname` accessors pair
    // https://url.spec.whatwg.org/#dom-url-pathname
    pathname: accessorDescriptor(getPathname, function (pathname) {
      var url = getInternalURLState(this);
      if (url.cannotBeABaseURL) return;
      url.path = [];
      parseURL(url, pathname + '', PATH_START);
    }),
    // `URL.prototype.search` accessors pair
    // https://url.spec.whatwg.org/#dom-url-search
    search: accessorDescriptor(getSearch, function (search) {
      var url = getInternalURLState(this);
      search = String(search);
      if (search == '') {
        url.query = null;
      } else {
        if ('?' == search.charAt(0)) search = search.slice(1);
        url.query = '';
        parseURL(url, search, QUERY);
      }
      getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
    }),
    // `URL.prototype.searchParams` getter
    // https://url.spec.whatwg.org/#dom-url-searchparams
    searchParams: accessorDescriptor(getSearchParams),
    // `URL.prototype.hash` accessors pair
    // https://url.spec.whatwg.org/#dom-url-hash
    hash: accessorDescriptor(getHash, function (hash) {
      var url = getInternalURLState(this);
      hash = String(hash);
      if (hash == '') {
        url.fragment = null;
        return;
      }
      if ('#' == hash.charAt(0)) hash = hash.slice(1);
      url.fragment = '';
      parseURL(url, hash, FRAGMENT);
    })
  });
}

// `URL.prototype.toJSON` method
// https://url.spec.whatwg.org/#dom-url-tojson
redefine(URLPrototype, 'toJSON', function toJSON() {
  return serializeURL.call(this);
}, {
  enumerable: true
});

// `URL.prototype.toString` method
// https://url.spec.whatwg.org/#URL-stringification-behavior
redefine(URLPrototype, 'toString', function toString() {
  return serializeURL.call(this);
}, {
  enumerable: true
});
if (NativeURL) {
  var nativeCreateObjectURL = NativeURL.createObjectURL;
  var nativeRevokeObjectURL = NativeURL.revokeObjectURL;
  // `URL.createObjectURL` method
  // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL
  // eslint-disable-next-line no-unused-vars
  if (nativeCreateObjectURL) redefine(URLConstructor, 'createObjectURL', function createObjectURL(blob) {
    return nativeCreateObjectURL.apply(NativeURL, arguments);
  });
  // `URL.revokeObjectURL` method
  // https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL
  // eslint-disable-next-line no-unused-vars
  if (nativeRevokeObjectURL) redefine(URLConstructor, 'revokeObjectURL', function revokeObjectURL(url) {
    return nativeRevokeObjectURL.apply(NativeURL, arguments);
  });
}
setToStringTag(URLConstructor, 'URL');
$({
  global: true,
  forced: !USE_NATIVE_URL,
  sham: !DESCRIPTORS
}, {
  URL: URLConstructor
});

},{"../internals/an-instance":425,"../internals/array-from":433,"../internals/descriptors":459,"../internals/export":466,"../internals/global":475,"../internals/has":476,"../internals/internal-state":486,"../internals/native-url":501,"../internals/object-assign":507,"../internals/object-define-properties":509,"../internals/redefine":527,"../internals/set-to-string-tag":536,"../internals/string-multibyte":541,"../internals/string-punycode-to-ascii":542,"../modules/es.string.iterator":626,"../modules/web.url-search-params":678,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.join.js":578,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.string.replace.js":629,"core-js/modules/es.string.search.js":630,"core-js/modules/web.dom-collections.iterator.js":677,"core-js/modules/web.url-search-params.js":678,"core-js/modules/web.url.js":679}],680:[function(require,module,exports){
'use strict';

require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/web.url.js");
require("core-js/modules/web.url-search-params.js");
var $ = require('../internals/export');

// `URL.prototype.toJSON` method
// https://url.spec.whatwg.org/#dom-url-tojson
$({
  target: 'URL',
  proto: true,
  enumerable: true
}, {
  toJSON: function toJSON() {
    return URL.prototype.toString.call(this);
  }
});

},{"../internals/export":466,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/web.dom-collections.iterator.js":677,"core-js/modules/web.url-search-params.js":678,"core-js/modules/web.url.js":679}],681:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = defaultLocale;
exports.formatPrefix = exports.format = void 0;
var _locale = _interopRequireDefault(require("./locale.js"));
var locale;
var format;
var formatPrefix;
defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""],
  minus: "-"
});
function defaultLocale(definition) {
  locale = (0, _locale.default)(definition);
  exports.format = format = locale.format;
  exports.formatPrefix = formatPrefix = locale.formatPrefix;
  return locale;
}

},{"./locale.js":693,"@babel/runtime/helpers/interopRequireDefault":237}],682:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _formatDecimal = require("./formatDecimal.js");
function _default(x) {
  return x = (0, _formatDecimal.formatDecimalParts)(Math.abs(x)), x ? x[1] : NaN;
}

},{"./formatDecimal.js":683}],683:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.formatDecimalParts = formatDecimalParts;
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.array.slice.js");
function _default(x) {
  return Math.abs(x = Math.round(x)) >= 1e21 ? x.toLocaleString("en").replace(/,/g, "") : x.toString(10);
}

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimalParts(1.23) returns ["123", 0].
function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, Infinity
  var i,
    coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient, +x.slice(i + 1)];
}

},{"core-js/modules/es.array.slice.js":580,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.replace.js":629}],684:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
require("core-js/modules/es.array.join.js");
function _default(grouping, thousands) {
  return function (value, width) {
    var i = value.length,
      t = [],
      j = 0,
      g = grouping[0],
      length = 0;
    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}

},{"core-js/modules/es.array.join.js":578}],685:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
function _default(numerals) {
  return function (value) {
    return value.replace(/[0-9]/g, function (i) {
      return numerals[+i];
    });
  };
}

},{"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.string.replace.js":629}],686:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.prefixExponent = void 0;
require("core-js/modules/es.array.join.js");
require("core-js/modules/es.array.slice.js");
var _formatDecimal = require("./formatDecimal.js");
var prefixExponent;
function _default(x, p) {
  var d = (0, _formatDecimal.formatDecimalParts)(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
    exponent = d[1],
    i = exponent - (exports.prefixExponent = prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
    n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + (0, _formatDecimal.formatDecimalParts)(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}

},{"./formatDecimal.js":683,"core-js/modules/es.array.join.js":578,"core-js/modules/es.array.slice.js":580}],687:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
require("core-js/modules/es.array.join.js");
require("core-js/modules/es.array.slice.js");
var _formatDecimal = require("./formatDecimal.js");
function _default(x, p) {
  var d = (0, _formatDecimal.formatDecimalParts)(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
    exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

},{"./formatDecimal.js":683,"core-js/modules/es.array.join.js":578,"core-js/modules/es.array.slice.js":580}],688:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FormatSpecifier = FormatSpecifier;
exports.default = formatSpecifier;
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.array.fill.js");
require("core-js/modules/es.string.trim.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
  this.align = specifier.align === undefined ? ">" : specifier.align + "";
  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === undefined ? undefined : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === undefined ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function () {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === undefined ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

},{"core-js/modules/es.array.fill.js":571,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.trim.js":634}],689:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
require("core-js/modules/es.array.slice.js");
// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
function _default(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".":
        i0 = i1 = i;
        break;
      case "0":
        if (i0 === 0) i0 = i;
        i1 = i;
        break;
      default:
        if (!+s[i]) break out;
        if (i0 > 0) i0 = 0;
        break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}

},{"core-js/modules/es.array.slice.js":580}],690:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
require("core-js/modules/es.number.to-fixed.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
var _formatDecimal = _interopRequireDefault(require("./formatDecimal.js"));
var _formatPrefixAuto = _interopRequireDefault(require("./formatPrefixAuto.js"));
var _formatRounded = _interopRequireDefault(require("./formatRounded.js"));
var _default = exports.default = {
  "%": function _(x, p) {
    return (x * 100).toFixed(p);
  },
  "b": function b(x) {
    return Math.round(x).toString(2);
  },
  "c": function c(x) {
    return x + "";
  },
  "d": _formatDecimal.default,
  "e": function e(x, p) {
    return x.toExponential(p);
  },
  "f": function f(x, p) {
    return x.toFixed(p);
  },
  "g": function g(x, p) {
    return x.toPrecision(p);
  },
  "o": function o(x) {
    return Math.round(x).toString(8);
  },
  "p": function p(x, _p) {
    return (0, _formatRounded.default)(x * 100, _p);
  },
  "r": _formatRounded.default,
  "s": _formatPrefixAuto.default,
  "X": function X(x) {
    return Math.round(x).toString(16).toUpperCase();
  },
  "x": function x(_x) {
    return Math.round(_x).toString(16);
  }
};

},{"./formatDecimal.js":683,"./formatPrefixAuto.js":686,"./formatRounded.js":687,"@babel/runtime/helpers/interopRequireDefault":237,"core-js/modules/es.number.to-fixed.js":600,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.to-string.js":620}],691:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function _default(x) {
  return x;
}

},{}],692:[function(require,module,exports){
"use strict";

require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.weak-map.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.object.get-own-property-descriptor.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "FormatSpecifier", {
  enumerable: true,
  get: function get() {
    return _formatSpecifier.FormatSpecifier;
  }
});
Object.defineProperty(exports, "format", {
  enumerable: true,
  get: function get() {
    return _defaultLocale.format;
  }
});
Object.defineProperty(exports, "formatDefaultLocale", {
  enumerable: true,
  get: function get() {
    return _defaultLocale.default;
  }
});
Object.defineProperty(exports, "formatLocale", {
  enumerable: true,
  get: function get() {
    return _locale.default;
  }
});
Object.defineProperty(exports, "formatPrefix", {
  enumerable: true,
  get: function get() {
    return _defaultLocale.formatPrefix;
  }
});
Object.defineProperty(exports, "formatSpecifier", {
  enumerable: true,
  get: function get() {
    return _formatSpecifier.default;
  }
});
Object.defineProperty(exports, "precisionFixed", {
  enumerable: true,
  get: function get() {
    return _precisionFixed.default;
  }
});
Object.defineProperty(exports, "precisionPrefix", {
  enumerable: true,
  get: function get() {
    return _precisionPrefix.default;
  }
});
Object.defineProperty(exports, "precisionRound", {
  enumerable: true,
  get: function get() {
    return _precisionRound.default;
  }
});
var _defaultLocale = _interopRequireWildcard(require("./defaultLocale.js"));
var _locale = _interopRequireDefault(require("./locale.js"));
var _formatSpecifier = _interopRequireWildcard(require("./formatSpecifier.js"));
var _precisionFixed = _interopRequireDefault(require("./precisionFixed.js"));
var _precisionPrefix = _interopRequireDefault(require("./precisionPrefix.js"));
var _precisionRound = _interopRequireDefault(require("./precisionRound.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }

},{"./defaultLocale.js":681,"./formatSpecifier.js":688,"./locale.js":693,"./precisionFixed.js":694,"./precisionPrefix.js":695,"./precisionRound.js":696,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.weak-map.js":673,"core-js/modules/web.dom-collections.iterator.js":677}],693:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
require("core-js/modules/es.array.map.js");
require("core-js/modules/es.number.constructor.js");
require("core-js/modules/es.array.fill.js");
require("core-js/modules/es.string.trim.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.array.join.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
var _exponent = _interopRequireDefault(require("./exponent.js"));
var _formatGroup = _interopRequireDefault(require("./formatGroup.js"));
var _formatNumerals = _interopRequireDefault(require("./formatNumerals.js"));
var _formatSpecifier = _interopRequireDefault(require("./formatSpecifier.js"));
var _formatTrim = _interopRequireDefault(require("./formatTrim.js"));
var _formatTypes = _interopRequireDefault(require("./formatTypes.js"));
var _formatPrefixAuto = require("./formatPrefixAuto.js");
var _identity = _interopRequireDefault(require("./identity.js"));
var map = Array.prototype.map,
  prefixes = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function _default(locale) {
  var group = locale.grouping === undefined || locale.thousands === undefined ? _identity.default : (0, _formatGroup.default)(map.call(locale.grouping, Number), locale.thousands + ""),
    currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
    currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
    decimal = locale.decimal === undefined ? "." : locale.decimal + "",
    numerals = locale.numerals === undefined ? _identity.default : (0, _formatNumerals.default)(map.call(locale.numerals, String)),
    percent = locale.percent === undefined ? "%" : locale.percent + "",
    minus = locale.minus === undefined ? "-" : locale.minus + "",
    nan = locale.nan === undefined ? "NaN" : locale.nan + "";
  function newFormat(specifier) {
    specifier = (0, _formatSpecifier.default)(specifier);
    var fill = specifier.fill,
      align = specifier.align,
      sign = specifier.sign,
      symbol = specifier.symbol,
      zero = specifier.zero,
      width = specifier.width,
      comma = specifier.comma,
      precision = specifier.precision,
      trim = specifier.trim,
      type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!_formatTypes.default[type]) precision === undefined && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || fill === "0" && align === "=") zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
      suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = _formatTypes.default[type],
      maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision === undefined ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format(value) {
      var valuePrefix = prefix,
        valueSuffix = suffix,
        i,
        n,
        c;
      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Determine the sign. -0 is not less than 0, but 1 / -0 is!
        var valueNegative = value < 0 || 1 / value < 0;

        // Perform the initial formatting.
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = (0, _formatTrim.default)(value);

        // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
        if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + _formatPrefixAuto.prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer value part that can be
        // grouped, and fractional or exponential suffix part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
        padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format.toString = function () {
      return specifier + "";
    };
    return format;
  }
  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = (0, _formatSpecifier.default)(specifier), specifier.type = "f", specifier)),
      e = Math.max(-8, Math.min(8, Math.floor((0, _exponent.default)(value) / 3))) * 3,
      k = Math.pow(10, -e),
      prefix = prefixes[8 + e / 3];
    return function (value) {
      return f(k * value) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}

},{"./exponent.js":682,"./formatGroup.js":684,"./formatNumerals.js":685,"./formatPrefixAuto.js":686,"./formatSpecifier.js":688,"./formatTrim.js":689,"./formatTypes.js":690,"./identity.js":691,"@babel/runtime/helpers/interopRequireDefault":237,"core-js/modules/es.array.fill.js":571,"core-js/modules/es.array.join.js":578,"core-js/modules/es.array.map.js":579,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.trim.js":634}],694:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _exponent = _interopRequireDefault(require("./exponent.js"));
function _default(step) {
  return Math.max(0, -(0, _exponent.default)(Math.abs(step)));
}

},{"./exponent.js":682,"@babel/runtime/helpers/interopRequireDefault":237}],695:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _exponent = _interopRequireDefault(require("./exponent.js"));
function _default(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor((0, _exponent.default)(value) / 3))) * 3 - (0, _exponent.default)(Math.abs(step)));
}

},{"./exponent.js":682,"@babel/runtime/helpers/interopRequireDefault":237}],696:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _exponent = _interopRequireDefault(require("./exponent.js"));
function _default(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, (0, _exponent.default)(max) - (0, _exponent.default)(step)) + 1;
}

},{"./exponent.js":682,"@babel/runtime/helpers/interopRequireDefault":237}],697:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.join.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.string.match.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.number.constructor.js");
require("core-js/modules/web.url.to-json.js");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
!function (t, e) {
  "object" == (typeof exports === "undefined" ? "undefined" : (0, _typeof2.default)(exports)) && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : t.dayjs = e();
}(void 0, function () {
  "use strict";

  var t = "millisecond",
    e = "second",
    n = "minute",
    r = "hour",
    i = "day",
    s = "week",
    u = "month",
    a = "quarter",
    o = "year",
    f = "date",
    h = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[^0-9]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
    c = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
    d = {
      name: "en",
      weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
      months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_")
    },
    $ = function $(t, e, n) {
      var r = String(t);
      return !r || r.length >= e ? t : "" + Array(e + 1 - r.length).join(n) + t;
    },
    l = {
      s: $,
      z: function z(t) {
        var e = -t.utcOffset(),
          n = Math.abs(e),
          r = Math.floor(n / 60),
          i = n % 60;
        return (e <= 0 ? "+" : "-") + $(r, 2, "0") + ":" + $(i, 2, "0");
      },
      m: function t(e, n) {
        if (e.date() < n.date()) return -t(n, e);
        var r = 12 * (n.year() - e.year()) + (n.month() - e.month()),
          i = e.clone().add(r, u),
          s = n - i < 0,
          a = e.clone().add(r + (s ? -1 : 1), u);
        return +(-(r + (n - i) / (s ? i - a : a - i)) || 0);
      },
      a: function a(t) {
        return t < 0 ? Math.ceil(t) || 0 : Math.floor(t);
      },
      p: function p(h) {
        return {
          M: u,
          y: o,
          w: s,
          d: i,
          D: f,
          h: r,
          m: n,
          s: e,
          ms: t,
          Q: a
        }[h] || String(h || "").toLowerCase().replace(/s$/, "");
      },
      u: function u(t) {
        return void 0 === t;
      }
    },
    y = "en",
    M = {};
  M[y] = d;
  var m = function m(t) {
      return t instanceof S;
    },
    D = function D(t, e, n) {
      var r;
      if (!t) return y;
      if ("string" == typeof t) M[t] && (r = t), e && (M[t] = e, r = t);else {
        var i = t.name;
        M[i] = t, r = i;
      }
      return !n && r && (y = r), r || !n && y;
    },
    v = function v(t, e) {
      if (m(t)) return t.clone();
      var n = "object" == (0, _typeof2.default)(e) ? e : {};
      return n.date = t, n.args = arguments, new S(n);
    },
    g = l;
  g.l = D, g.i = m, g.w = function (t, e) {
    return v(t, {
      locale: e.$L,
      utc: e.$u,
      x: e.$x,
      $offset: e.$offset
    });
  };
  var S = function () {
      function d(t) {
        this.$L = D(t.locale, null, !0), this.parse(t);
      }
      var $ = d.prototype;
      return $.parse = function (t) {
        this.$d = function (t) {
          var e = t.date,
            n = t.utc;
          if (null === e) return new Date(NaN);
          if (g.u(e)) return new Date();
          if (e instanceof Date) return new Date(e);
          if ("string" == typeof e && !/Z$/i.test(e)) {
            var r = e.match(h);
            if (r) {
              var i = r[2] - 1 || 0,
                s = (r[7] || "0").substring(0, 3);
              return n ? new Date(Date.UTC(r[1], i, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, s)) : new Date(r[1], i, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, s);
            }
          }
          return new Date(e);
        }(t), this.$x = t.x || {}, this.init();
      }, $.init = function () {
        var t = this.$d;
        this.$y = t.getFullYear(), this.$M = t.getMonth(), this.$D = t.getDate(), this.$W = t.getDay(), this.$H = t.getHours(), this.$m = t.getMinutes(), this.$s = t.getSeconds(), this.$ms = t.getMilliseconds();
      }, $.$utils = function () {
        return g;
      }, $.isValid = function () {
        return !("Invalid Date" === this.$d.toString());
      }, $.isSame = function (t, e) {
        var n = v(t);
        return this.startOf(e) <= n && n <= this.endOf(e);
      }, $.isAfter = function (t, e) {
        return v(t) < this.startOf(e);
      }, $.isBefore = function (t, e) {
        return this.endOf(e) < v(t);
      }, $.$g = function (t, e, n) {
        return g.u(t) ? this[e] : this.set(n, t);
      }, $.unix = function () {
        return Math.floor(this.valueOf() / 1e3);
      }, $.valueOf = function () {
        return this.$d.getTime();
      }, $.startOf = function (t, a) {
        var h = this,
          c = !!g.u(a) || a,
          d = g.p(t),
          $ = function $(t, e) {
            var n = g.w(h.$u ? Date.UTC(h.$y, e, t) : new Date(h.$y, e, t), h);
            return c ? n : n.endOf(i);
          },
          l = function l(t, e) {
            return g.w(h.toDate()[t].apply(h.toDate("s"), (c ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e)), h);
          },
          y = this.$W,
          M = this.$M,
          m = this.$D,
          D = "set" + (this.$u ? "UTC" : "");
        switch (d) {
          case o:
            return c ? $(1, 0) : $(31, 11);
          case u:
            return c ? $(1, M) : $(0, M + 1);
          case s:
            var v = this.$locale().weekStart || 0,
              S = (y < v ? y + 7 : y) - v;
            return $(c ? m - S : m + (6 - S), M);
          case i:
          case f:
            return l(D + "Hours", 0);
          case r:
            return l(D + "Minutes", 1);
          case n:
            return l(D + "Seconds", 2);
          case e:
            return l(D + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, $.endOf = function (t) {
        return this.startOf(t, !1);
      }, $.$set = function (s, a) {
        var h,
          c = g.p(s),
          d = "set" + (this.$u ? "UTC" : ""),
          $ = (h = {}, h[i] = d + "Date", h[f] = d + "Date", h[u] = d + "Month", h[o] = d + "FullYear", h[r] = d + "Hours", h[n] = d + "Minutes", h[e] = d + "Seconds", h[t] = d + "Milliseconds", h)[c],
          l = c === i ? this.$D + (a - this.$W) : a;
        if (c === u || c === o) {
          var y = this.clone().set(f, 1);
          y.$d[$](l), y.init(), this.$d = y.set(f, Math.min(this.$D, y.daysInMonth())).$d;
        } else $ && this.$d[$](l);
        return this.init(), this;
      }, $.set = function (t, e) {
        return this.clone().$set(t, e);
      }, $.get = function (t) {
        return this[g.p(t)]();
      }, $.add = function (t, a) {
        var f,
          h = this;
        t = Number(t);
        var c = g.p(a),
          d = function d(e) {
            var n = v(h);
            return g.w(n.date(n.date() + Math.round(e * t)), h);
          };
        if (c === u) return this.set(u, this.$M + t);
        if (c === o) return this.set(o, this.$y + t);
        if (c === i) return d(1);
        if (c === s) return d(7);
        var $ = (f = {}, f[n] = 6e4, f[r] = 36e5, f[e] = 1e3, f)[c] || 1,
          l = this.$d.getTime() + t * $;
        return g.w(l, this);
      }, $.subtract = function (t, e) {
        return this.add(-1 * t, e);
      }, $.format = function (t) {
        var e = this;
        if (!this.isValid()) return "Invalid Date";
        var n = t || "YYYY-MM-DDTHH:mm:ssZ",
          r = g.z(this),
          i = this.$locale(),
          s = this.$H,
          u = this.$m,
          a = this.$M,
          o = i.weekdays,
          f = i.months,
          h = function h(t, r, i, s) {
            return t && (t[r] || t(e, n)) || i[r].substr(0, s);
          },
          d = function d(t) {
            return g.s(s % 12 || 12, t, "0");
          },
          $ = i.meridiem || function (t, e, n) {
            var r = t < 12 ? "AM" : "PM";
            return n ? r.toLowerCase() : r;
          },
          l = {
            YY: String(this.$y).slice(-2),
            YYYY: this.$y,
            M: a + 1,
            MM: g.s(a + 1, 2, "0"),
            MMM: h(i.monthsShort, a, f, 3),
            MMMM: h(f, a),
            D: this.$D,
            DD: g.s(this.$D, 2, "0"),
            d: String(this.$W),
            dd: h(i.weekdaysMin, this.$W, o, 2),
            ddd: h(i.weekdaysShort, this.$W, o, 3),
            dddd: o[this.$W],
            H: String(s),
            HH: g.s(s, 2, "0"),
            h: d(1),
            hh: d(2),
            a: $(s, u, !0),
            A: $(s, u, !1),
            m: String(u),
            mm: g.s(u, 2, "0"),
            s: String(this.$s),
            ss: g.s(this.$s, 2, "0"),
            SSS: g.s(this.$ms, 3, "0"),
            Z: r
          };
        return n.replace(c, function (t, e) {
          return e || l[t] || r.replace(":", "");
        });
      }, $.utcOffset = function () {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, $.diff = function (t, f, h) {
        var c,
          d = g.p(f),
          $ = v(t),
          l = 6e4 * ($.utcOffset() - this.utcOffset()),
          y = this - $,
          M = g.m(this, $);
        return M = (c = {}, c[o] = M / 12, c[u] = M, c[a] = M / 3, c[s] = (y - l) / 6048e5, c[i] = (y - l) / 864e5, c[r] = y / 36e5, c[n] = y / 6e4, c[e] = y / 1e3, c)[d] || y, h ? M : g.a(M);
      }, $.daysInMonth = function () {
        return this.endOf(u).$D;
      }, $.$locale = function () {
        return M[this.$L];
      }, $.locale = function (t, e) {
        if (!t) return this.$L;
        var n = this.clone(),
          r = D(t, e, !0);
        return r && (n.$L = r), n;
      }, $.clone = function () {
        return g.w(this.$d, this);
      }, $.toDate = function () {
        return new Date(this.valueOf());
      }, $.toJSON = function () {
        return this.isValid() ? this.toISOString() : null;
      }, $.toISOString = function () {
        return this.$d.toISOString();
      }, $.toString = function () {
        return this.$d.toUTCString();
      }, d;
    }(),
    p = S.prototype;
  return v.prototype = p, [["$ms", t], ["$s", e], ["$m", n], ["$H", r], ["$W", i], ["$M", u], ["$y", o], ["$D", f]].forEach(function (t) {
    p[t[1]] = function (e) {
      return this.$g(e, t[0], t[1]);
    };
  }), v.extend = function (t, e) {
    return t.$i || (t(e, S, v), t.$i = !0), v;
  }, v.locale = D, v.isDayjs = m, v.unix = function (t) {
    return v(1e3 * t);
  }, v.en = M[y], v.Ls = M, v.p = {}, v;
});

},{"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.join.js":578,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.match.js":627,"core-js/modules/es.string.replace.js":629,"core-js/modules/web.url.to-json.js":680}],698:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
!function (t, e) {
  "object" == (typeof exports === "undefined" ? "undefined" : (0, _typeof2.default)(exports)) && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : t.dayjs_plugin_dayOfYear = e();
}(void 0, function () {
  "use strict";

  return function (t, e) {
    e.prototype.dayOfYear = function (t) {
      var e = Math.round((this.startOf("day") - this.startOf("year")) / 864e5) + 1;
      return null == t ? e : this.add(t - e, "day");
    };
  };
});

},{"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252}],699:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.find.js");
require("core-js/modules/es.object.to-string.js");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
!function (t, e) {
  "object" == (typeof exports === "undefined" ? "undefined" : (0, _typeof2.default)(exports)) && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : t.dayjs_plugin_timezone = e();
}(void 0, function () {
  "use strict";

  var t = {
      year: 0,
      month: 1,
      day: 2,
      hour: 3,
      minute: 4,
      second: 5
    },
    e = {};
  return function (n, i, r) {
    var o,
      u = r().utcOffset(),
      a = function a(t, n, i) {
        void 0 === i && (i = {});
        var r = new Date(t);
        return function (t, n) {
          void 0 === n && (n = {});
          var i = n.timeZoneName || "short",
            r = t + "|" + i,
            o = e[r];
          return o || (o = new Intl.DateTimeFormat("en-US", {
            hour12: !1,
            timeZone: t,
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit",
            timeZoneName: i
          }), e[r] = o), o;
        }(n, i).formatToParts(r);
      },
      f = function f(e, n) {
        for (var i = a(e, n), o = [], u = 0; u < i.length; u += 1) {
          var f = i[u],
            s = f.type,
            m = f.value,
            c = t[s];
          c >= 0 && (o[c] = parseInt(m, 10));
        }
        var d = o[3],
          v = 24 === d ? 0 : d,
          h = o[0] + "-" + o[1] + "-" + o[2] + " " + v + ":" + o[4] + ":" + o[5] + ":000",
          l = +e;
        return (r.utc(h).valueOf() - (l -= l % 1e3)) / 6e4;
      },
      s = i.prototype;
    s.tz = function (t, e) {
      void 0 === t && (t = o);
      var n = this.utcOffset(),
        i = this.toDate().toLocaleString("en-US", {
          timeZone: t
        }),
        a = Math.round((this.toDate() - new Date(i)) / 1e3 / 60),
        f = r(i).$set("millisecond", this.$ms).utcOffset(u - a, !0);
      if (e) {
        var s = f.utcOffset();
        f = f.add(n - s, "minute");
      }
      return f.$x.$timezone = t, f;
    }, s.offsetName = function (t) {
      var e = this.$x.$timezone || r.tz.guess(),
        n = a(this.valueOf(), e, {
          timeZoneName: t
        }).find(function (t) {
          return "timezonename" === t.type.toLowerCase();
        });
      return n && n.value;
    };
    var m = s.startOf;
    s.startOf = function (t, e) {
      if (!this.$x || !this.$x.$timezone) return m.call(this, t, e);
      var n = r(this.format("YYYY-MM-DD HH:mm:ss:SSS"));
      return m.call(n, t, e).tz(this.$x.$timezone, !0);
    }, r.tz = function (t, e, n) {
      var i = n && e,
        u = n || e || o,
        a = f(+r(), u);
      if ("string" != typeof t) return r(t).tz(u);
      var s = function (t, e, n) {
          var i = t - 60 * e * 1e3,
            r = f(i, n);
          if (e === r) return [i, e];
          var o = f(i -= 60 * (r - e) * 1e3, n);
          return r === o ? [i, r] : [t - 60 * Math.min(r, o) * 1e3, Math.max(r, o)];
        }(r.utc(t, i).valueOf(), a, u),
        m = s[0],
        c = s[1],
        d = r(m).utcOffset(c);
      return d.$x.$timezone = u, d;
    }, r.tz.guess = function () {
      return Intl.DateTimeFormat().resolvedOptions().timeZone;
    }, r.tz.setDefault = function (t) {
      o = t;
    };
  };
});

},{"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.find.js":574,"core-js/modules/es.object.to-string.js":612}],700:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
!function (t, i) {
  "object" == (typeof exports === "undefined" ? "undefined" : (0, _typeof2.default)(exports)) && "undefined" != typeof module ? module.exports = i() : "function" == typeof define && define.amd ? define(i) : t.dayjs_plugin_utc = i();
}(void 0, function () {
  "use strict";

  return function (t, i, e) {
    var s = i.prototype;
    e.utc = function (t) {
      return new i({
        date: t,
        utc: !0,
        args: arguments
      });
    }, s.utc = function (t) {
      var i = e(this.toDate(), {
        locale: this.$L,
        utc: !0
      });
      return t ? i.add(this.utcOffset(), "minute") : i;
    }, s.local = function () {
      return e(this.toDate(), {
        locale: this.$L,
        utc: !1
      });
    };
    var f = s.parse;
    s.parse = function (t) {
      t.utc && (this.$u = !0), this.$utils().u(t.$offset) || (this.$offset = t.$offset), f.call(this, t);
    };
    var n = s.init;
    s.init = function () {
      if (this.$u) {
        var t = this.$d;
        this.$y = t.getUTCFullYear(), this.$M = t.getUTCMonth(), this.$D = t.getUTCDate(), this.$W = t.getUTCDay(), this.$H = t.getUTCHours(), this.$m = t.getUTCMinutes(), this.$s = t.getUTCSeconds(), this.$ms = t.getUTCMilliseconds();
      } else n.call(this);
    };
    var u = s.utcOffset;
    s.utcOffset = function (t, i) {
      var e = this.$utils().u;
      if (e(t)) return this.$u ? 0 : e(this.$offset) ? u.call(this) : this.$offset;
      var s = Math.abs(t) <= 16 ? 60 * t : t,
        f = this;
      if (i) return f.$offset = s, f.$u = 0 === t, f;
      if (0 !== t) {
        var n = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
        (f = this.local().add(s + n, "minute")).$offset = s, f.$x.$localOffset = n;
      } else f = this.utc();
      return f;
    };
    var o = s.format;
    s.format = function (t) {
      var i = t || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
      return o.call(this, i);
    }, s.valueOf = function () {
      var t = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || new Date().getTimezoneOffset());
      return this.$d.valueOf() - 6e4 * t;
    }, s.isUTC = function () {
      return !!this.$u;
    }, s.toISOString = function () {
      return this.toDate().toISOString();
    }, s.toString = function () {
      return this.toDate().toUTCString();
    };
    var r = s.toDate;
    s.toDate = function (t) {
      return "s" === t && this.$offset ? e(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : r.call(this);
    };
    var a = s.diff;
    s.diff = function (t, i, s) {
      if (t && this.$u === t.$u) return a.call(this, t, i, s);
      var f = this.local(),
        n = e(t).local();
      return a.call(f, n, i, s);
    };
  };
});

},{"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.to-string.js":620}],701:[function(require,module,exports){
'use strict';

var validator = require('./validator');
var XMLParser = require('./xmlparser/XMLParser');
var XMLBuilder = require('./xmlbuilder/json2xml');
module.exports = {
  XMLParser: XMLParser,
  XMLValidator: validator,
  XMLBuilder: XMLBuilder
};

},{"./validator":703,"./xmlbuilder/json2xml":704,"./xmlparser/XMLParser":709}],702:[function(require,module,exports){
'use strict';

require("core-js/modules/es.regexp.constructor.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.object.keys.js");
var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
var nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*';
var regexName = new RegExp('^' + nameRegexp + '$');
var getAllMatches = function getAllMatches(string, regex) {
  var matches = [];
  var match = regex.exec(string);
  while (match) {
    var allmatches = [];
    allmatches.startIndex = regex.lastIndex - match[0].length;
    var len = match.length;
    for (var index = 0; index < len; index++) {
      allmatches.push(match[index]);
    }
    matches.push(allmatches);
    match = regex.exec(string);
  }
  return matches;
};
var isName = function isName(string) {
  var match = regexName.exec(string);
  return !(match === null || typeof match === 'undefined');
};
exports.isExist = function (v) {
  return typeof v !== 'undefined';
};
exports.isEmptyObject = function (obj) {
  return Object.keys(obj).length === 0;
};

/**
 * Copy all the properties of a into b.
 * @param {*} target
 * @param {*} a
 */
exports.merge = function (target, a, arrayMode) {
  if (a) {
    var keys = Object.keys(a); // will return an array of own properties
    var len = keys.length; //don't make it inline
    for (var i = 0; i < len; i++) {
      if (arrayMode === 'strict') {
        target[keys[i]] = [a[keys[i]]];
      } else {
        target[keys[i]] = a[keys[i]];
      }
    }
  }
};
/* exports.merge =function (b,a){
  return Object.assign(b,a);
} */

exports.getValue = function (v) {
  if (exports.isExist(v)) {
    return v;
  } else {
    return '';
  }
};

// const fakeCall = function(a) {return a;};
// const fakeCallNoReturn = function() {};

exports.isName = isName;
exports.getAllMatches = getAllMatches;
exports.nameRegexp = nameRegexp;

},{"core-js/modules/es.object.keys.js":609,"core-js/modules/es.regexp.constructor.js":617,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620}],703:[function(require,module,exports){
'use strict';

require("core-js/modules/es.object.assign.js");
require("core-js/modules/es.string.trim.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.array.map.js");
require("core-js/modules/es.regexp.constructor.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.string.match.js");
require("core-js/modules/es.string.split.js");
var util = require('./util');
var defaultOptions = {
  allowBooleanAttributes: false,
  //A tag can have attributes without any value
  unpairedTags: []
};

//const tagsPattern = new RegExp("<\\/?([\\w:\\-_\.]+)\\s*\/?>","g");
exports.validate = function (xmlData, options) {
  options = Object.assign({}, defaultOptions, options);

  //xmlData = xmlData.replace(/(\r\n|\n|\r)/gm,"");//make it single line
  //xmlData = xmlData.replace(/(^\s*<\?xml.*?\?>)/g,"");//Remove XML starting tag
  //xmlData = xmlData.replace(/(<!DOCTYPE[\s\w\"\.\/\-\:]+(\[.*\])*\s*>)/g,"");//Remove DOCTYPE
  var tags = [];
  var tagFound = false;

  //indicates that the root tag has been closed (aka. depth 0 has been reached)
  var reachedRoot = false;
  if (xmlData[0] === "\uFEFF") {
    // check for byte order mark (BOM)
    xmlData = xmlData.substr(1);
  }
  for (var i = 0; i < xmlData.length; i++) {
    if (xmlData[i] === '<' && xmlData[i + 1] === '?') {
      i += 2;
      i = readPI(xmlData, i);
      if (i.err) return i;
    } else if (xmlData[i] === '<') {
      //starting of tag
      //read until you reach to '>' avoiding any '>' in attribute value
      var tagStartPos = i;
      i++;
      if (xmlData[i] === '!') {
        i = readCommentAndCDATA(xmlData, i);
        continue;
      } else {
        var closingTag = false;
        if (xmlData[i] === '/') {
          //closing tag
          closingTag = true;
          i++;
        }
        //read tagname
        var tagName = '';
        for (; i < xmlData.length && xmlData[i] !== '>' && xmlData[i] !== ' ' && xmlData[i] !== '\t' && xmlData[i] !== '\n' && xmlData[i] !== '\r'; i++) {
          tagName += xmlData[i];
        }
        tagName = tagName.trim();
        //console.log(tagName);

        if (tagName[tagName.length - 1] === '/') {
          //self closing tag without attributes
          tagName = tagName.substring(0, tagName.length - 1);
          //continue;
          i--;
        }
        if (!validateTagName(tagName)) {
          var msg = void 0;
          if (tagName.trim().length === 0) {
            msg = "Invalid space after '<'.";
          } else {
            msg = "Tag '" + tagName + "' is an invalid name.";
          }
          return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));
        }
        var result = readAttributeStr(xmlData, i);
        if (result === false) {
          return getErrorObject('InvalidAttr', "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i));
        }
        var attrStr = result.value;
        i = result.index;
        if (attrStr[attrStr.length - 1] === '/') {
          //self closing tag
          var attrStrStart = i - attrStr.length;
          attrStr = attrStr.substring(0, attrStr.length - 1);
          var isValid = validateAttributeString(attrStr, options);
          if (isValid === true) {
            tagFound = true;
            //continue; //text may presents after self closing tag
          } else {
            //the result from the nested function returns the position of the error within the attribute
            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
            //this gives us the absolute index in the entire xml, which we can use to find the line at last
            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
          }
        } else if (closingTag) {
          if (!result.tagClosed) {
            return getErrorObject('InvalidTag', "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i));
          } else if (attrStr.trim().length > 0) {
            return getErrorObject('InvalidTag', "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
          } else if (tags.length === 0) {
            return getErrorObject('InvalidTag', "Closing tag '" + tagName + "' has not been opened.", getLineNumberForPosition(xmlData, tagStartPos));
          } else {
            var otg = tags.pop();
            if (tagName !== otg.tagName) {
              var openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
              return getErrorObject('InvalidTag', "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.", getLineNumberForPosition(xmlData, tagStartPos));
            }

            //when there are no more tags, we reached the root level.
            if (tags.length == 0) {
              reachedRoot = true;
            }
          }
        } else {
          var _isValid = validateAttributeString(attrStr, options);
          if (_isValid !== true) {
            //the result from the nested function returns the position of the error within the attribute
            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
            //this gives us the absolute index in the entire xml, which we can use to find the line at last
            return getErrorObject(_isValid.err.code, _isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + _isValid.err.line));
          }

          //if the root level has been reached before ...
          if (reachedRoot === true) {
            return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));
          } else if (options.unpairedTags.indexOf(tagName) !== -1) {
            //don't push into stack
          } else {
            tags.push({
              tagName: tagName,
              tagStartPos: tagStartPos
            });
          }
          tagFound = true;
        }

        //skip tag text value
        //It may include comments and CDATA value
        for (i++; i < xmlData.length; i++) {
          if (xmlData[i] === '<') {
            if (xmlData[i + 1] === '!') {
              //comment or CADATA
              i++;
              i = readCommentAndCDATA(xmlData, i);
              continue;
            } else if (xmlData[i + 1] === '?') {
              i = readPI(xmlData, ++i);
              if (i.err) return i;
            } else {
              break;
            }
          } else if (xmlData[i] === '&') {
            var afterAmp = validateAmpersand(xmlData, i);
            if (afterAmp == -1) return getErrorObject('InvalidChar', "char '&' is not expected.", getLineNumberForPosition(xmlData, i));
            i = afterAmp;
          } else {
            if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {
              return getErrorObject('InvalidXml', "Extra text at the end", getLineNumberForPosition(xmlData, i));
            }
          }
        } //end of reading tag text value
        if (xmlData[i] === '<') {
          i--;
        }
      }
    } else {
      if (isWhiteSpace(xmlData[i])) {
        continue;
      }
      return getErrorObject('InvalidChar', "char '" + xmlData[i] + "' is not expected.", getLineNumberForPosition(xmlData, i));
    }
  }
  if (!tagFound) {
    return getErrorObject('InvalidXml', 'Start tag expected.', 1);
  } else if (tags.length == 1) {
    return getErrorObject('InvalidTag', "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
  } else if (tags.length > 0) {
    return getErrorObject('InvalidXml', "Invalid '" + JSON.stringify(tags.map(function (t) {
      return t.tagName;
    }), null, 4).replace(/\r?\n/g, '') + "' found.", {
      line: 1,
      col: 1
    });
  }
  return true;
};
function isWhiteSpace(char) {
  return char === ' ' || char === '\t' || char === '\n' || char === '\r';
}
/**
 * Read Processing insstructions and skip
 * @param {*} xmlData
 * @param {*} i
 */
function readPI(xmlData, i) {
  var start = i;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] == '?' || xmlData[i] == ' ') {
      //tagname
      var tagname = xmlData.substr(start, i - start);
      if (i > 5 && tagname === 'xml') {
        return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));
      } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {
        //check if valid attribut string
        i++;
        break;
      } else {
        continue;
      }
    }
  }
  return i;
}
function readCommentAndCDATA(xmlData, i) {
  if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {
    //comment
    for (i += 3; i < xmlData.length; i++) {
      if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {
        i += 2;
        break;
      }
    }
  } else if (xmlData.length > i + 8 && xmlData[i + 1] === 'D' && xmlData[i + 2] === 'O' && xmlData[i + 3] === 'C' && xmlData[i + 4] === 'T' && xmlData[i + 5] === 'Y' && xmlData[i + 6] === 'P' && xmlData[i + 7] === 'E') {
    var angleBracketsCount = 1;
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === '<') {
        angleBracketsCount++;
      } else if (xmlData[i] === '>') {
        angleBracketsCount--;
        if (angleBracketsCount === 0) {
          break;
        }
      }
    }
  } else if (xmlData.length > i + 9 && xmlData[i + 1] === '[' && xmlData[i + 2] === 'C' && xmlData[i + 3] === 'D' && xmlData[i + 4] === 'A' && xmlData[i + 5] === 'T' && xmlData[i + 6] === 'A' && xmlData[i + 7] === '[') {
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {
        i += 2;
        break;
      }
    }
  }
  return i;
}
var doubleQuote = '"';
var singleQuote = "'";

/**
 * Keep reading xmlData until '<' is found outside the attribute value.
 * @param {string} xmlData
 * @param {number} i
 */
function readAttributeStr(xmlData, i) {
  var attrStr = '';
  var startChar = '';
  var tagClosed = false;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
      if (startChar === '') {
        startChar = xmlData[i];
      } else if (startChar !== xmlData[i]) {
        //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa
      } else {
        startChar = '';
      }
    } else if (xmlData[i] === '>') {
      if (startChar === '') {
        tagClosed = true;
        break;
      }
    }
    attrStr += xmlData[i];
  }
  if (startChar !== '') {
    return false;
  }
  return {
    value: attrStr,
    index: i,
    tagClosed: tagClosed
  };
}

/**
 * Select all the attributes whether valid or invalid.
 */
var validAttrStrRegxp = new RegExp('(\\s*)([^\\s=]+)(\\s*=)?(\\s*([\'"])(([\\s\\S])*?)\\5)?', 'g');

//attr, ="sd", a="amit's", a="sd"b="saf", ab  cd=""

function validateAttributeString(attrStr, options) {
  //console.log("start:"+attrStr+":end");

  //if(attrStr.trim().length === 0) return true; //empty string

  var matches = util.getAllMatches(attrStr, validAttrStrRegxp);
  var attrNames = {};
  for (var i = 0; i < matches.length; i++) {
    if (matches[i][1].length === 0) {
      //nospace before attribute name: a="sd"b="saf"
      return getErrorObject('InvalidAttr', "Attribute '" + matches[i][2] + "' has no space in starting.", getPositionFromMatch(matches[i]));
    } else if (matches[i][3] !== undefined && matches[i][4] === undefined) {
      return getErrorObject('InvalidAttr', "Attribute '" + matches[i][2] + "' is without value.", getPositionFromMatch(matches[i]));
    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {
      //independent attribute: ab
      return getErrorObject('InvalidAttr', "boolean attribute '" + matches[i][2] + "' is not allowed.", getPositionFromMatch(matches[i]));
    }
    /* else if(matches[i][6] === undefined){//attribute without value: ab=
                    return { err: { code:"InvalidAttr",msg:"attribute " + matches[i][2] + " has no value assigned."}};
                } */
    var attrName = matches[i][2];
    if (!validateAttrName(attrName)) {
      return getErrorObject('InvalidAttr', "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i]));
    }
    if (!attrNames.hasOwnProperty(attrName)) {
      //check for duplicate attribute.
      attrNames[attrName] = 1;
    } else {
      return getErrorObject('InvalidAttr', "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i]));
    }
  }
  return true;
}
function validateNumberAmpersand(xmlData, i) {
  var re = /\d/;
  if (xmlData[i] === 'x') {
    i++;
    re = /[\da-fA-F]/;
  }
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === ';') return i;
    if (!xmlData[i].match(re)) break;
  }
  return -1;
}
function validateAmpersand(xmlData, i) {
  // https://www.w3.org/TR/xml/#dt-charref
  i++;
  if (xmlData[i] === ';') return -1;
  if (xmlData[i] === '#') {
    i++;
    return validateNumberAmpersand(xmlData, i);
  }
  var count = 0;
  for (; i < xmlData.length; i++, count++) {
    if (xmlData[i].match(/\w/) && count < 20) continue;
    if (xmlData[i] === ';') break;
    return -1;
  }
  return i;
}
function getErrorObject(code, message, lineNumber) {
  return {
    err: {
      code: code,
      msg: message,
      line: lineNumber.line || lineNumber,
      col: lineNumber.col
    }
  };
}
function validateAttrName(attrName) {
  return util.isName(attrName);
}

// const startsWithXML = /^xml/i;

function validateTagName(tagname) {
  return util.isName(tagname) /* && !tagname.match(startsWithXML) */;
}

//this function returns the line number for the character at the given index
function getLineNumberForPosition(xmlData, index) {
  var lines = xmlData.substring(0, index).split(/\r?\n/);
  return {
    line: lines.length,
    // column number is last line's length + 1, because column numbering starts at 1:
    col: lines[lines.length - 1].length + 1
  };
}

//this function returns the position of the first character of match within attrStr
function getPositionFromMatch(match) {
  return match.startIndex + match[1].length;
}

},{"./util":702,"core-js/modules/es.array.map.js":579,"core-js/modules/es.object.assign.js":601,"core-js/modules/es.regexp.constructor.js":617,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.match.js":627,"core-js/modules/es.string.replace.js":629,"core-js/modules/es.string.split.js":631,"core-js/modules/es.string.trim.js":634}],704:[function(require,module,exports){
'use strict';

//parse Empty Node as self closing node
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
require("core-js/modules/es.regexp.constructor.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.object.assign.js");
require("core-js/modules/es.object.keys.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.string.repeat.js");
require("core-js/modules/es.string.starts-with.js");
var buildFromOrderedJs = require('./orderedJs2Xml');
var defaultOptions = {
  attributeNamePrefix: '@_',
  attributesGroupName: false,
  textNodeName: '#text',
  ignoreAttributes: true,
  cdataPropName: false,
  format: false,
  indentBy: '  ',
  suppressEmptyNode: false,
  suppressUnpairedNode: true,
  suppressBooleanAttributes: true,
  tagValueProcessor: function tagValueProcessor(key, a) {
    return a;
  },
  attributeValueProcessor: function attributeValueProcessor(attrName, a) {
    return a;
  },
  preserveOrder: false,
  commentPropName: false,
  unpairedTags: [],
  entities: [{
    regex: new RegExp("&", "g"),
    val: "&amp;"
  },
  //it must be on top
  {
    regex: new RegExp(">", "g"),
    val: "&gt;"
  }, {
    regex: new RegExp("<", "g"),
    val: "&lt;"
  }, {
    regex: new RegExp("\'", "g"),
    val: "&apos;"
  }, {
    regex: new RegExp("\"", "g"),
    val: "&quot;"
  }],
  processEntities: true,
  stopNodes: [],
  // transformTagName: false,
  // transformAttributeName: false,
  oneListGroup: false
};
function Builder(options) {
  this.options = Object.assign({}, defaultOptions, options);
  if (this.options.ignoreAttributes || this.options.attributesGroupName) {
    this.isAttribute = function /*a*/
    () {
      return false;
    };
  } else {
    this.attrPrefixLen = this.options.attributeNamePrefix.length;
    this.isAttribute = isAttribute;
  }
  this.processTextOrObjNode = processTextOrObjNode;
  if (this.options.format) {
    this.indentate = indentate;
    this.tagEndChar = '>\n';
    this.newLine = '\n';
  } else {
    this.indentate = function () {
      return '';
    };
    this.tagEndChar = '>';
    this.newLine = '';
  }
}
Builder.prototype.build = function (jObj) {
  if (this.options.preserveOrder) {
    return buildFromOrderedJs(jObj, this.options);
  } else {
    if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
      jObj = (0, _defineProperty2.default)({}, this.options.arrayNodeName, jObj);
    }
    return this.j2x(jObj, 0).val;
  }
};
Builder.prototype.j2x = function (jObj, level) {
  var attrStr = '';
  var val = '';
  for (var key in jObj) {
    if (!Object.prototype.hasOwnProperty.call(jObj, key)) continue;
    if (typeof jObj[key] === 'undefined') {
      // supress undefined node only if it is not an attribute
      if (this.isAttribute(key)) {
        val += '';
      }
    } else if (jObj[key] === null) {
      // null attribute should be ignored by the attribute list, but should not cause the tag closing
      if (this.isAttribute(key)) {
        val += '';
      } else if (key[0] === '?') {
        val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;
      } else {
        val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
      }
      // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
    } else if (jObj[key] instanceof Date) {
      val += this.buildTextValNode(jObj[key], key, '', level);
    } else if ((0, _typeof2.default)(jObj[key]) !== 'object') {
      //premitive type
      var attr = this.isAttribute(key);
      if (attr) {
        attrStr += this.buildAttrPairStr(attr, '' + jObj[key]);
      } else {
        //tag value
        if (key === this.options.textNodeName) {
          var newval = this.options.tagValueProcessor(key, '' + jObj[key]);
          val += this.replaceEntitiesValue(newval);
        } else {
          val += this.buildTextValNode(jObj[key], key, '', level);
        }
      }
    } else if (Array.isArray(jObj[key])) {
      //repeated nodes
      var arrLen = jObj[key].length;
      var listTagVal = "";
      var listTagAttr = "";
      for (var j = 0; j < arrLen; j++) {
        var item = jObj[key][j];
        if (typeof item === 'undefined') {
          // supress undefined node
        } else if (item === null) {
          if (key[0] === "?") val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;else val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
          // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
        } else if ((0, _typeof2.default)(item) === 'object') {
          if (this.options.oneListGroup) {
            var result = this.j2x(item, level + 1);
            listTagVal += result.val;
            if (this.options.attributesGroupName && item.hasOwnProperty(this.options.attributesGroupName)) {
              listTagAttr += result.attrStr;
            }
          } else {
            listTagVal += this.processTextOrObjNode(item, key, level);
          }
        } else {
          if (this.options.oneListGroup) {
            var textValue = this.options.tagValueProcessor(key, item);
            textValue = this.replaceEntitiesValue(textValue);
            listTagVal += textValue;
          } else {
            listTagVal += this.buildTextValNode(item, key, '', level);
          }
        }
      }
      if (this.options.oneListGroup) {
        listTagVal = this.buildObjectNode(listTagVal, key, listTagAttr, level);
      }
      val += listTagVal;
    } else {
      //nested node
      if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
        var Ks = Object.keys(jObj[key]);
        var L = Ks.length;
        for (var _j = 0; _j < L; _j++) {
          attrStr += this.buildAttrPairStr(Ks[_j], '' + jObj[key][Ks[_j]]);
        }
      } else {
        val += this.processTextOrObjNode(jObj[key], key, level);
      }
    }
  }
  return {
    attrStr: attrStr,
    val: val
  };
};
Builder.prototype.buildAttrPairStr = function (attrName, val) {
  val = this.options.attributeValueProcessor(attrName, '' + val);
  val = this.replaceEntitiesValue(val);
  if (this.options.suppressBooleanAttributes && val === "true") {
    return ' ' + attrName;
  } else return ' ' + attrName + '="' + val + '"';
};
function processTextOrObjNode(object, key, level) {
  var result = this.j2x(object, level + 1);
  if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {
    return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);
  } else {
    return this.buildObjectNode(result.val, key, result.attrStr, level);
  }
}
Builder.prototype.buildObjectNode = function (val, key, attrStr, level) {
  if (val === "") {
    if (key[0] === "?") return this.indentate(level) + '<' + key + attrStr + '?' + this.tagEndChar;else {
      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;
    }
  } else {
    var tagEndExp = '</' + key + this.tagEndChar;
    var piClosingChar = "";
    if (key[0] === "?") {
      piClosingChar = "?";
      tagEndExp = "";
    }

    // attrStr is an empty string in case the attribute came as undefined or null
    if ((attrStr || attrStr === '') && val.indexOf('<') === -1) {
      return this.indentate(level) + '<' + key + attrStr + piClosingChar + '>' + val + tagEndExp;
    } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
      return this.indentate(level) + "<!--".concat(val, "-->") + this.newLine;
    } else {
      return this.indentate(level) + '<' + key + attrStr + piClosingChar + this.tagEndChar + val + this.indentate(level) + tagEndExp;
    }
  }
};
Builder.prototype.closeTag = function (key) {
  var closeTag = "";
  if (this.options.unpairedTags.indexOf(key) !== -1) {
    //unpaired
    if (!this.options.suppressUnpairedNode) closeTag = "/";
  } else if (this.options.suppressEmptyNode) {
    //empty
    closeTag = "/";
  } else {
    closeTag = "></".concat(key);
  }
  return closeTag;
};
function buildEmptyObjNode(val, key, attrStr, level) {
  if (val !== '') {
    return this.buildObjectNode(val, key, attrStr, level);
  } else {
    if (key[0] === "?") return this.indentate(level) + '<' + key + attrStr + '?' + this.tagEndChar;else {
      return this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;
      // return this.buildTagStr(level,key, attrStr);
    }
  }
}

Builder.prototype.buildTextValNode = function (val, key, attrStr, level) {
  if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
    return this.indentate(level) + "<![CDATA[".concat(val, "]]>") + this.newLine;
  } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
    return this.indentate(level) + "<!--".concat(val, "-->") + this.newLine;
  } else if (key[0] === "?") {
    //PI tag
    return this.indentate(level) + '<' + key + attrStr + '?' + this.tagEndChar;
  } else {
    var textValue = this.options.tagValueProcessor(key, val);
    textValue = this.replaceEntitiesValue(textValue);
    if (textValue === '') {
      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;
    } else {
      return this.indentate(level) + '<' + key + attrStr + '>' + textValue + '</' + key + this.tagEndChar;
    }
  }
};
Builder.prototype.replaceEntitiesValue = function (textValue) {
  if (textValue && textValue.length > 0 && this.options.processEntities) {
    for (var i = 0; i < this.options.entities.length; i++) {
      var entity = this.options.entities[i];
      textValue = textValue.replace(entity.regex, entity.val);
    }
  }
  return textValue;
};
function indentate(level) {
  return this.options.indentBy.repeat(level);
}
function isAttribute(name /*, options*/) {
  if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {
    return name.substr(this.attrPrefixLen);
  } else {
    return false;
  }
}
module.exports = Builder;

},{"./orderedJs2Xml":705,"@babel/runtime/helpers/defineProperty":233,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.assign.js":601,"core-js/modules/es.object.keys.js":609,"core-js/modules/es.regexp.constructor.js":617,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.repeat.js":628,"core-js/modules/es.string.replace.js":629,"core-js/modules/es.string.starts-with.js":632}],705:[function(require,module,exports){
"use strict";

require("core-js/modules/es.array.concat.js");
require("core-js/modules/es.string.ends-with.js");
require("core-js/modules/es.array.includes.js");
require("core-js/modules/es.string.includes.js");
require("core-js/modules/es.object.keys.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
var EOL = "\n";

/**
 * 
 * @param {array} jArray 
 * @param {any} options 
 * @returns 
 */
function toXml(jArray, options) {
  var indentation = "";
  if (options.format && options.indentBy.length > 0) {
    indentation = EOL;
  }
  return arrToStr(jArray, options, "", indentation);
}
function arrToStr(arr, options, jPath, indentation) {
  var xmlStr = "";
  var isPreviousElementTag = false;
  for (var i = 0; i < arr.length; i++) {
    var tagObj = arr[i];
    var tagName = propName(tagObj);
    if (tagName === undefined) continue;
    var newJPath = "";
    if (jPath.length === 0) newJPath = tagName;else newJPath = "".concat(jPath, ".").concat(tagName);
    if (tagName === options.textNodeName) {
      var tagText = tagObj[tagName];
      if (!isStopNode(newJPath, options)) {
        tagText = options.tagValueProcessor(tagName, tagText);
        tagText = replaceEntitiesValue(tagText, options);
      }
      if (isPreviousElementTag) {
        xmlStr += indentation;
      }
      xmlStr += tagText;
      isPreviousElementTag = false;
      continue;
    } else if (tagName === options.cdataPropName) {
      if (isPreviousElementTag) {
        xmlStr += indentation;
      }
      xmlStr += "<![CDATA[".concat(tagObj[tagName][0][options.textNodeName], "]]>");
      isPreviousElementTag = false;
      continue;
    } else if (tagName === options.commentPropName) {
      xmlStr += indentation + "<!--".concat(tagObj[tagName][0][options.textNodeName], "-->");
      isPreviousElementTag = true;
      continue;
    } else if (tagName[0] === "?") {
      var _attStr = attr_to_str(tagObj[":@"], options);
      var tempInd = tagName === "?xml" ? "" : indentation;
      var piTextNodeName = tagObj[tagName][0][options.textNodeName];
      piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : ""; //remove extra spacing
      xmlStr += tempInd + "<".concat(tagName).concat(piTextNodeName).concat(_attStr, "?>");
      isPreviousElementTag = true;
      continue;
    }
    var newIdentation = indentation;
    if (newIdentation !== "") {
      newIdentation += options.indentBy;
    }
    var attStr = attr_to_str(tagObj[":@"], options);
    var tagStart = indentation + "<".concat(tagName).concat(attStr);
    var tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
    if (options.unpairedTags.indexOf(tagName) !== -1) {
      if (options.suppressUnpairedNode) xmlStr += tagStart + ">";else xmlStr += tagStart + "/>";
    } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
      xmlStr += tagStart + "/>";
    } else if (tagValue && tagValue.endsWith(">")) {
      xmlStr += tagStart + ">".concat(tagValue).concat(indentation, "</").concat(tagName, ">");
    } else {
      xmlStr += tagStart + ">";
      if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
        xmlStr += indentation + options.indentBy + tagValue + indentation;
      } else {
        xmlStr += tagValue;
      }
      xmlStr += "</".concat(tagName, ">");
    }
    isPreviousElementTag = true;
  }
  return xmlStr;
}
function propName(obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!obj.hasOwnProperty(key)) continue;
    if (key !== ":@") return key;
  }
}
function attr_to_str(attrMap, options) {
  var attrStr = "";
  if (attrMap && !options.ignoreAttributes) {
    for (var attr in attrMap) {
      if (!attrMap.hasOwnProperty(attr)) continue;
      var attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
      attrVal = replaceEntitiesValue(attrVal, options);
      if (attrVal === true && options.suppressBooleanAttributes) {
        attrStr += " ".concat(attr.substr(options.attributeNamePrefix.length));
      } else {
        attrStr += " ".concat(attr.substr(options.attributeNamePrefix.length), "=\"").concat(attrVal, "\"");
      }
    }
  }
  return attrStr;
}
function isStopNode(jPath, options) {
  jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
  var tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
  for (var index in options.stopNodes) {
    if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName) return true;
  }
  return false;
}
function replaceEntitiesValue(textValue, options) {
  if (textValue && textValue.length > 0 && options.processEntities) {
    for (var i = 0; i < options.entities.length; i++) {
      var entity = options.entities[i];
      textValue = textValue.replace(entity.regex, entity.val);
    }
  }
  return textValue;
}
module.exports = toXml;

},{"core-js/modules/es.array.concat.js":569,"core-js/modules/es.array.includes.js":576,"core-js/modules/es.object.keys.js":609,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.string.ends-with.js":623,"core-js/modules/es.string.includes.js":625,"core-js/modules/es.string.replace.js":629}],706:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.regexp.constructor.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.string.trim.js");
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var util = require('../util');

//TODO: handle comments
function readDocType(xmlData, i) {
  var entities = {};
  if (xmlData[i + 3] === 'O' && xmlData[i + 4] === 'C' && xmlData[i + 5] === 'T' && xmlData[i + 6] === 'Y' && xmlData[i + 7] === 'P' && xmlData[i + 8] === 'E') {
    i = i + 9;
    var angleBracketsCount = 1;
    var hasBody = false,
      comment = false;
    var exp = "";
    for (; i < xmlData.length; i++) {
      if (xmlData[i] === '<' && !comment) {
        //Determine the tag type
        if (hasBody && isEntity(xmlData, i)) {
          i += 7;
          var _readEntityExp = readEntityExp(xmlData, i + 1);
          var _readEntityExp2 = (0, _slicedToArray2.default)(_readEntityExp, 3);
          entityName = _readEntityExp2[0];
          val = _readEntityExp2[1];
          i = _readEntityExp2[2];
          if (val.indexOf("&") === -1)
            //Parameter entities are not supported
            entities[validateEntityName(entityName)] = {
              regx: RegExp("&".concat(entityName, ";"), "g"),
              val: val
            };
        } else if (hasBody && isElement(xmlData, i)) i += 8; //Not supported
        else if (hasBody && isAttlist(xmlData, i)) i += 8; //Not supported
        else if (hasBody && isNotation(xmlData, i)) i += 9; //Not supported
        else if (isComment) comment = true;else throw new Error("Invalid DOCTYPE");
        angleBracketsCount++;
        exp = "";
      } else if (xmlData[i] === '>') {
        //Read tag content
        if (comment) {
          if (xmlData[i - 1] === "-" && xmlData[i - 2] === "-") {
            comment = false;
            angleBracketsCount--;
          }
        } else {
          angleBracketsCount--;
        }
        if (angleBracketsCount === 0) {
          break;
        }
      } else if (xmlData[i] === '[') {
        hasBody = true;
      } else {
        exp += xmlData[i];
      }
    }
    if (angleBracketsCount !== 0) {
      throw new Error("Unclosed DOCTYPE");
    }
  } else {
    throw new Error("Invalid Tag instead of DOCTYPE");
  }
  return {
    entities: entities,
    i: i
  };
}
function readEntityExp(xmlData, i) {
  //External entities are not supported
  //    <!ENTITY ext SYSTEM "http://normal-website.com" >

  //Parameter entities are not supported
  //    <!ENTITY entityname "&anotherElement;">

  //Internal entities are supported
  //    <!ENTITY entityname "replacement text">

  //read EntityName
  var entityName = "";
  for (; i < xmlData.length && xmlData[i] !== "'" && xmlData[i] !== '"'; i++) {
    // if(xmlData[i] === " ") continue;
    // else 
    entityName += xmlData[i];
  }
  entityName = entityName.trim();
  if (entityName.indexOf(" ") !== -1) throw new Error("External entites are not supported");

  //read Entity Value
  var startChar = xmlData[i++];
  var val = "";
  for (; i < xmlData.length && xmlData[i] !== startChar; i++) {
    val += xmlData[i];
  }
  return [entityName, val, i];
}
function isComment(xmlData, i) {
  if (xmlData[i + 1] === '!' && xmlData[i + 2] === '-' && xmlData[i + 3] === '-') return true;
  return false;
}
function isEntity(xmlData, i) {
  if (xmlData[i + 1] === '!' && xmlData[i + 2] === 'E' && xmlData[i + 3] === 'N' && xmlData[i + 4] === 'T' && xmlData[i + 5] === 'I' && xmlData[i + 6] === 'T' && xmlData[i + 7] === 'Y') return true;
  return false;
}
function isElement(xmlData, i) {
  if (xmlData[i + 1] === '!' && xmlData[i + 2] === 'E' && xmlData[i + 3] === 'L' && xmlData[i + 4] === 'E' && xmlData[i + 5] === 'M' && xmlData[i + 6] === 'E' && xmlData[i + 7] === 'N' && xmlData[i + 8] === 'T') return true;
  return false;
}
function isAttlist(xmlData, i) {
  if (xmlData[i + 1] === '!' && xmlData[i + 2] === 'A' && xmlData[i + 3] === 'T' && xmlData[i + 4] === 'T' && xmlData[i + 5] === 'L' && xmlData[i + 6] === 'I' && xmlData[i + 7] === 'S' && xmlData[i + 8] === 'T') return true;
  return false;
}
function isNotation(xmlData, i) {
  if (xmlData[i + 1] === '!' && xmlData[i + 2] === 'N' && xmlData[i + 3] === 'O' && xmlData[i + 4] === 'T' && xmlData[i + 5] === 'A' && xmlData[i + 6] === 'T' && xmlData[i + 7] === 'I' && xmlData[i + 8] === 'O' && xmlData[i + 9] === 'N') return true;
  return false;
}
function validateEntityName(name) {
  if (util.isName(name)) return name;else throw new Error("Invalid entity name ".concat(name));
}
module.exports = readDocType;

},{"../util":702,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/slicedToArray":247,"core-js/modules/es.regexp.constructor.js":617,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.trim.js":634}],707:[function(require,module,exports){
"use strict";

require("core-js/modules/es.object.assign.js");
var defaultOptions = {
  preserveOrder: false,
  attributeNamePrefix: '@_',
  attributesGroupName: false,
  textNodeName: '#text',
  ignoreAttributes: true,
  removeNSPrefix: false,
  // remove NS from tag name or attribute name if true
  allowBooleanAttributes: false,
  //a tag can have attributes without any value
  //ignoreRootElement : false,
  parseTagValue: true,
  parseAttributeValue: false,
  trimValues: true,
  //Trim string values of tag and attributes
  cdataPropName: false,
  numberParseOptions: {
    hex: true,
    leadingZeros: true,
    eNotation: true
  },
  tagValueProcessor: function tagValueProcessor(tagName, val) {
    return val;
  },
  attributeValueProcessor: function attributeValueProcessor(attrName, val) {
    return val;
  },
  stopNodes: [],
  //nested tags will not be parsed even for errors
  alwaysCreateTextNode: false,
  isArray: function isArray() {
    return false;
  },
  commentPropName: false,
  unpairedTags: [],
  processEntities: true,
  htmlEntities: false,
  ignoreDeclaration: false,
  ignorePiTags: false,
  transformTagName: false,
  transformAttributeName: false,
  updateTag: function updateTag(tagName, jPath, attrs) {
    return tagName;
  }
  // skipEmptyListItem: false
};

var buildOptions = function buildOptions(options) {
  return Object.assign({}, defaultOptions, options);
};
exports.buildOptions = buildOptions;
exports.defaultOptions = defaultOptions;

},{"core-js/modules/es.object.assign.js":601}],708:[function(require,module,exports){
'use strict';

///@ts-check
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.number.parse-int.js");
require("core-js/modules/es.number.constructor.js");
require("core-js/modules/es.object.keys.js");
require("core-js/modules/es.regexp.constructor.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.string.trim.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.string.search.js");
require("core-js/modules/es.string.trim-start.js");
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var util = require('../util');
var xmlNode = require('./xmlNode');
var readDocType = require("./DocTypeReader");
var toNumber = require("strnum");

// const regx =
//   '<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)'
//   .replace(/NAME/g, util.nameRegexp);

//const tagsRegx = new RegExp("<(\\/?[\\w:\\-\._]+)([^>]*)>(\\s*"+cdataRegx+")*([^<]+)?","g");
//const tagsRegx = new RegExp("<(\\/?)((\\w*:)?([\\w:\\-\._]+))([^>]*)>([^<]*)("+cdataRegx+"([^<]*))*([^<]+)?","g");
var OrderedObjParser = /*#__PURE__*/(0, _createClass2.default)(function OrderedObjParser(options) {
  (0, _classCallCheck2.default)(this, OrderedObjParser);
  this.options = options;
  this.currentNode = null;
  this.tagsNodeStack = [];
  this.docTypeEntities = {};
  this.lastEntities = {
    "apos": {
      regex: /&(apos|#39|#x27);/g,
      val: "'"
    },
    "gt": {
      regex: /&(gt|#62|#x3E);/g,
      val: ">"
    },
    "lt": {
      regex: /&(lt|#60|#x3C);/g,
      val: "<"
    },
    "quot": {
      regex: /&(quot|#34|#x22);/g,
      val: "\""
    }
  };
  this.ampEntity = {
    regex: /&(amp|#38|#x26);/g,
    val: "&"
  };
  this.htmlEntities = {
    "space": {
      regex: /&(nbsp|#160);/g,
      val: " "
    },
    // "lt" : { regex: /&(lt|#60);/g, val: "<" },
    // "gt" : { regex: /&(gt|#62);/g, val: ">" },
    // "amp" : { regex: /&(amp|#38);/g, val: "&" },
    // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
    // "apos" : { regex: /&(apos|#39);/g, val: "'" },
    "cent": {
      regex: /&(cent|#162);/g,
      val: ""
    },
    "pound": {
      regex: /&(pound|#163);/g,
      val: ""
    },
    "yen": {
      regex: /&(yen|#165);/g,
      val: ""
    },
    "euro": {
      regex: /&(euro|#8364);/g,
      val: ""
    },
    "copyright": {
      regex: /&(copy|#169);/g,
      val: ""
    },
    "reg": {
      regex: /&(reg|#174);/g,
      val: ""
    },
    "inr": {
      regex: /&(inr|#8377);/g,
      val: ""
    },
    "num_dec": {
      regex: /&#([0-9]{1,7});/g,
      val: function val(_, str) {
        return String.fromCharCode(Number.parseInt(str, 10));
      }
    },
    "num_hex": {
      regex: /&#x([0-9a-fA-F]{1,6});/g,
      val: function val(_, str) {
        return String.fromCharCode(Number.parseInt(str, 16));
      }
    }
  };
  this.addExternalEntities = addExternalEntities;
  this.parseXml = parseXml;
  this.parseTextData = parseTextData;
  this.resolveNameSpace = resolveNameSpace;
  this.buildAttributesMap = buildAttributesMap;
  this.isItStopNode = isItStopNode;
  this.replaceEntitiesValue = replaceEntitiesValue;
  this.readStopNodeData = readStopNodeData;
  this.saveTextToParentTag = saveTextToParentTag;
  this.addChild = addChild;
});
function addExternalEntities(externalEntities) {
  var entKeys = Object.keys(externalEntities);
  for (var i = 0; i < entKeys.length; i++) {
    var ent = entKeys[i];
    this.lastEntities[ent] = {
      regex: new RegExp("&" + ent + ";", "g"),
      val: externalEntities[ent]
    };
  }
}

/**
 * @param {string} val
 * @param {string} tagName
 * @param {string} jPath
 * @param {boolean} dontTrim
 * @param {boolean} hasAttributes
 * @param {boolean} isLeafNode
 * @param {boolean} escapeEntities
 */
function parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
  if (val !== undefined) {
    if (this.options.trimValues && !dontTrim) {
      val = val.trim();
    }
    if (val.length > 0) {
      if (!escapeEntities) val = this.replaceEntitiesValue(val);
      var newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);
      if (newval === null || newval === undefined) {
        //don't parse
        return val;
      } else if ((0, _typeof2.default)(newval) !== (0, _typeof2.default)(val) || newval !== val) {
        //overwrite
        return newval;
      } else if (this.options.trimValues) {
        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
      } else {
        var trimmedVal = val.trim();
        if (trimmedVal === val) {
          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
        } else {
          return val;
        }
      }
    }
  }
}
function resolveNameSpace(tagname) {
  if (this.options.removeNSPrefix) {
    var tags = tagname.split(':');
    var prefix = tagname.charAt(0) === '/' ? '/' : '';
    if (tags[0] === 'xmlns') {
      return '';
    }
    if (tags.length === 2) {
      tagname = prefix + tags[1];
    }
  }
  return tagname;
}

//TODO: change regex to capture NS
//const attrsRegx = new RegExp("([\\w\\-\\.\\:]+)\\s*=\\s*(['\"])((.|\n)*?)\\2","gm");
var attrsRegx = new RegExp('([^\\s=]+)\\s*(=\\s*([\'"])([\\s\\S]*?)\\3)?', 'gm');
function buildAttributesMap(attrStr, jPath, tagName) {
  if (!this.options.ignoreAttributes && typeof attrStr === 'string') {
    // attrStr = attrStr.replace(/\r?\n/g, ' ');
    //attrStr = attrStr || attrStr.trim();

    var matches = util.getAllMatches(attrStr, attrsRegx);
    var len = matches.length; //don't make it inline
    var attrs = {};
    for (var i = 0; i < len; i++) {
      var attrName = this.resolveNameSpace(matches[i][1]);
      var oldVal = matches[i][4];
      var aName = this.options.attributeNamePrefix + attrName;
      if (attrName.length) {
        if (this.options.transformAttributeName) {
          aName = this.options.transformAttributeName(aName);
        }
        if (aName === "__proto__") aName = "#__proto__";
        if (oldVal !== undefined) {
          if (this.options.trimValues) {
            oldVal = oldVal.trim();
          }
          oldVal = this.replaceEntitiesValue(oldVal);
          var newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
          if (newVal === null || newVal === undefined) {
            //don't parse
            attrs[aName] = oldVal;
          } else if ((0, _typeof2.default)(newVal) !== (0, _typeof2.default)(oldVal) || newVal !== oldVal) {
            //overwrite
            attrs[aName] = newVal;
          } else {
            //parse
            attrs[aName] = parseValue(oldVal, this.options.parseAttributeValue, this.options.numberParseOptions);
          }
        } else if (this.options.allowBooleanAttributes) {
          attrs[aName] = true;
        }
      }
    }
    if (!Object.keys(attrs).length) {
      return;
    }
    if (this.options.attributesGroupName) {
      var attrCollection = {};
      attrCollection[this.options.attributesGroupName] = attrs;
      return attrCollection;
    }
    return attrs;
  }
}
var parseXml = function parseXml(xmlData) {
  xmlData = xmlData.replace(/\r\n?/g, "\n"); //TODO: remove this line
  var xmlObj = new xmlNode('!xml');
  var currentNode = xmlObj;
  var textData = "";
  var jPath = "";
  for (var i = 0; i < xmlData.length; i++) {
    //for each char in XML data
    var ch = xmlData[i];
    if (ch === '<') {
      // const nextIndex = i+1;
      // const _2ndChar = xmlData[nextIndex];
      if (xmlData[i + 1] === '/') {
        //Closing Tag
        var closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed.");
        var tagName = xmlData.substring(i + 2, closeIndex).trim();
        if (this.options.removeNSPrefix) {
          var colonIndex = tagName.indexOf(":");
          if (colonIndex !== -1) {
            tagName = tagName.substr(colonIndex + 1);
          }
        }
        if (this.options.transformTagName) {
          tagName = this.options.transformTagName(tagName);
        }
        if (currentNode) {
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
        }

        //check if last tag of nested tag was unpaired tag
        var lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
        if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
          throw new Error("Unpaired tag can not be used as closing tag: </".concat(tagName, ">"));
        }
        var propIndex = 0;
        if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
          propIndex = jPath.lastIndexOf('.', jPath.lastIndexOf('.') - 1);
          this.tagsNodeStack.pop();
        } else {
          propIndex = jPath.lastIndexOf(".");
        }
        jPath = jPath.substring(0, propIndex);
        currentNode = this.tagsNodeStack.pop(); //avoid recursion, set the parent tag scope
        textData = "";
        i = closeIndex;
      } else if (xmlData[i + 1] === '?') {
        var tagData = readTagExp(xmlData, i, false, "?>");
        if (!tagData) throw new Error("Pi Tag is not closed.");
        textData = this.saveTextToParentTag(textData, currentNode, jPath);
        if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {} else {
          var childNode = new xmlNode(tagData.tagName);
          childNode.add(this.options.textNodeName, "");
          if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
            childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
          }
          this.addChild(currentNode, childNode, jPath);
        }
        i = tagData.closeIndex + 1;
      } else if (xmlData.substr(i + 1, 3) === '!--') {
        var endIndex = findClosingIndex(xmlData, "-->", i + 4, "Comment is not closed.");
        if (this.options.commentPropName) {
          var comment = xmlData.substring(i + 4, endIndex - 2);
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
          currentNode.add(this.options.commentPropName, [(0, _defineProperty2.default)({}, this.options.textNodeName, comment)]);
        }
        i = endIndex;
      } else if (xmlData.substr(i + 1, 2) === '!D') {
        var result = readDocType(xmlData, i);
        this.docTypeEntities = result.entities;
        i = result.i;
      } else if (xmlData.substr(i + 1, 2) === '![') {
        var _closeIndex = findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2;
        var tagExp = xmlData.substring(i + 9, _closeIndex);
        textData = this.saveTextToParentTag(textData, currentNode, jPath);
        var val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);
        if (val == undefined) val = "";

        //cdata should be set even if it is 0 length string
        if (this.options.cdataPropName) {
          currentNode.add(this.options.cdataPropName, [(0, _defineProperty2.default)({}, this.options.textNodeName, tagExp)]);
        } else {
          currentNode.add(this.options.textNodeName, val);
        }
        i = _closeIndex + 2;
      } else {
        //Opening tag
        var _result = readTagExp(xmlData, i, this.options.removeNSPrefix);
        var _tagName = _result.tagName;
        var rawTagName = _result.rawTagName;
        var _tagExp = _result.tagExp;
        var attrExpPresent = _result.attrExpPresent;
        var _closeIndex2 = _result.closeIndex;
        if (this.options.transformTagName) {
          _tagName = this.options.transformTagName(_tagName);
        }

        //save text as child node
        if (currentNode && textData) {
          if (currentNode.tagname !== '!xml') {
            //when nested tag is found
            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
          }
        }

        //check if last tag was unpaired tag
        var lastTag = currentNode;
        if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
          currentNode = this.tagsNodeStack.pop();
          jPath = jPath.substring(0, jPath.lastIndexOf("."));
        }
        if (_tagName !== xmlObj.tagname) {
          jPath += jPath ? "." + _tagName : _tagName;
        }
        if (this.isItStopNode(this.options.stopNodes, jPath, _tagName)) {
          var tagContent = "";
          //self-closing tag
          if (_tagExp.length > 0 && _tagExp.lastIndexOf("/") === _tagExp.length - 1) {
            if (_tagName[_tagName.length - 1] === "/") {
              //remove trailing '/'
              _tagName = _tagName.substr(0, _tagName.length - 1);
              jPath = jPath.substr(0, jPath.length - 1);
              _tagExp = _tagName;
            } else {
              _tagExp = _tagExp.substr(0, _tagExp.length - 1);
            }
            i = _result.closeIndex;
          }
          //unpaired tag
          else if (this.options.unpairedTags.indexOf(_tagName) !== -1) {
            i = _result.closeIndex;
          }
          //normal tag
          else {
            //read until closing tag is found
            var _result2 = this.readStopNodeData(xmlData, rawTagName, _closeIndex2 + 1);
            if (!_result2) throw new Error("Unexpected end of ".concat(rawTagName));
            i = _result2.i;
            tagContent = _result2.tagContent;
          }
          var _childNode = new xmlNode(_tagName);
          if (_tagName !== _tagExp && attrExpPresent) {
            _childNode[":@"] = this.buildAttributesMap(_tagExp, jPath, _tagName);
          }
          if (tagContent) {
            tagContent = this.parseTextData(tagContent, _tagName, jPath, true, attrExpPresent, true, true);
          }
          jPath = jPath.substr(0, jPath.lastIndexOf("."));
          _childNode.add(this.options.textNodeName, tagContent);
          this.addChild(currentNode, _childNode, jPath);
        } else {
          //selfClosing tag
          if (_tagExp.length > 0 && _tagExp.lastIndexOf("/") === _tagExp.length - 1) {
            if (_tagName[_tagName.length - 1] === "/") {
              //remove trailing '/'
              _tagName = _tagName.substr(0, _tagName.length - 1);
              jPath = jPath.substr(0, jPath.length - 1);
              _tagExp = _tagName;
            } else {
              _tagExp = _tagExp.substr(0, _tagExp.length - 1);
            }
            if (this.options.transformTagName) {
              _tagName = this.options.transformTagName(_tagName);
            }
            var _childNode2 = new xmlNode(_tagName);
            if (_tagName !== _tagExp && attrExpPresent) {
              _childNode2[":@"] = this.buildAttributesMap(_tagExp, jPath, _tagName);
            }
            this.addChild(currentNode, _childNode2, jPath);
            jPath = jPath.substr(0, jPath.lastIndexOf("."));
          }
          //opening tag
          else {
            var _childNode3 = new xmlNode(_tagName);
            this.tagsNodeStack.push(currentNode);
            if (_tagName !== _tagExp && attrExpPresent) {
              _childNode3[":@"] = this.buildAttributesMap(_tagExp, jPath, _tagName);
            }
            this.addChild(currentNode, _childNode3, jPath);
            currentNode = _childNode3;
          }
          textData = "";
          i = _closeIndex2;
        }
      }
    } else {
      textData += xmlData[i];
    }
  }
  return xmlObj.child;
};
function addChild(currentNode, childNode, jPath) {
  var result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
  if (result === false) {} else if (typeof result === "string") {
    childNode.tagname = result;
    currentNode.addChild(childNode);
  } else {
    currentNode.addChild(childNode);
  }
}
var replaceEntitiesValue = function replaceEntitiesValue(val) {
  if (this.options.processEntities) {
    for (var entityName in this.docTypeEntities) {
      var entity = this.docTypeEntities[entityName];
      val = val.replace(entity.regx, entity.val);
    }
    for (var _entityName in this.lastEntities) {
      var _entity = this.lastEntities[_entityName];
      val = val.replace(_entity.regex, _entity.val);
    }
    if (this.options.htmlEntities) {
      for (var _entityName2 in this.htmlEntities) {
        var _entity2 = this.htmlEntities[_entityName2];
        val = val.replace(_entity2.regex, _entity2.val);
      }
    }
    val = val.replace(this.ampEntity.regex, this.ampEntity.val);
  }
  return val;
};
function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
  if (textData) {
    //store previously collected data as textNode
    if (isLeafNode === undefined) isLeafNode = Object.keys(currentNode.child).length === 0;
    textData = this.parseTextData(textData, currentNode.tagname, jPath, false, currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false, isLeafNode);
    if (textData !== undefined && textData !== "") currentNode.add(this.options.textNodeName, textData);
    textData = "";
  }
  return textData;
}

//TODO: use jPath to simplify the logic
/**
 * 
 * @param {string[]} stopNodes 
 * @param {string} jPath
 * @param {string} currentTagName 
 */
function isItStopNode(stopNodes, jPath, currentTagName) {
  var allNodesExp = "*." + currentTagName;
  for (var stopNodePath in stopNodes) {
    var stopNodeExp = stopNodes[stopNodePath];
    if (allNodesExp === stopNodeExp || jPath === stopNodeExp) return true;
  }
  return false;
}

/**
 * Returns the tag Expression and where it is ending handling single-double quotes situation
 * @param {string} xmlData 
 * @param {number} i starting index
 * @returns 
 */
function tagExpWithClosingIndex(xmlData, i) {
  var closingChar = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ">";
  var attrBoundary;
  var tagExp = "";
  for (var index = i; index < xmlData.length; index++) {
    var ch = xmlData[index];
    if (attrBoundary) {
      if (ch === attrBoundary) attrBoundary = ""; //reset
    } else if (ch === '"' || ch === "'") {
      attrBoundary = ch;
    } else if (ch === closingChar[0]) {
      if (closingChar[1]) {
        if (xmlData[index + 1] === closingChar[1]) {
          return {
            data: tagExp,
            index: index
          };
        }
      } else {
        return {
          data: tagExp,
          index: index
        };
      }
    } else if (ch === '\t') {
      ch = " ";
    }
    tagExp += ch;
  }
}
function findClosingIndex(xmlData, str, i, errMsg) {
  var closingIndex = xmlData.indexOf(str, i);
  if (closingIndex === -1) {
    throw new Error(errMsg);
  } else {
    return closingIndex + str.length - 1;
  }
}
function readTagExp(xmlData, i, removeNSPrefix) {
  var closingChar = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ">";
  var result = tagExpWithClosingIndex(xmlData, i + 1, closingChar);
  if (!result) return;
  var tagExp = result.data;
  var closeIndex = result.index;
  var separatorIndex = tagExp.search(/\s/);
  var tagName = tagExp;
  var attrExpPresent = true;
  if (separatorIndex !== -1) {
    //separate tag name and attributes expression
    tagName = tagExp.substring(0, separatorIndex);
    tagExp = tagExp.substring(separatorIndex + 1).trimStart();
  }
  var rawTagName = tagName;
  if (removeNSPrefix) {
    var colonIndex = tagName.indexOf(":");
    if (colonIndex !== -1) {
      tagName = tagName.substr(colonIndex + 1);
      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
    }
  }
  return {
    tagName: tagName,
    tagExp: tagExp,
    closeIndex: closeIndex,
    attrExpPresent: attrExpPresent,
    rawTagName: rawTagName
  };
}
/**
 * find paired tag for a stop node
 * @param {string} xmlData 
 * @param {string} tagName 
 * @param {number} i 
 */
function readStopNodeData(xmlData, tagName, i) {
  var startIndex = i;
  // Starting at 1 since we already have an open tag
  var openTagCount = 1;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === "<") {
      if (xmlData[i + 1] === "/") {
        //close tag
        var closeIndex = findClosingIndex(xmlData, ">", i, "".concat(tagName, " is not closed"));
        var closeTagName = xmlData.substring(i + 2, closeIndex).trim();
        if (closeTagName === tagName) {
          openTagCount--;
          if (openTagCount === 0) {
            return {
              tagContent: xmlData.substring(startIndex, i),
              i: closeIndex
            };
          }
        }
        i = closeIndex;
      } else if (xmlData[i + 1] === '?') {
        var _closeIndex3 = findClosingIndex(xmlData, "?>", i + 1, "StopNode is not closed.");
        i = _closeIndex3;
      } else if (xmlData.substr(i + 1, 3) === '!--') {
        var _closeIndex4 = findClosingIndex(xmlData, "-->", i + 3, "StopNode is not closed.");
        i = _closeIndex4;
      } else if (xmlData.substr(i + 1, 2) === '![') {
        var _closeIndex5 = findClosingIndex(xmlData, "]]>", i, "StopNode is not closed.") - 2;
        i = _closeIndex5;
      } else {
        var tagData = readTagExp(xmlData, i, '>');
        if (tagData) {
          var openTagName = tagData && tagData.tagName;
          if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
            openTagCount++;
          }
          i = tagData.closeIndex;
        }
      }
    }
  } //end for loop
}

function parseValue(val, shouldParse, options) {
  if (shouldParse && typeof val === 'string') {
    //console.log(options)
    var newval = val.trim();
    if (newval === 'true') return true;else if (newval === 'false') return false;else return toNumber(val, options);
  } else {
    if (util.isExist(val)) {
      return val;
    } else {
      return '';
    }
  }
}
module.exports = OrderedObjParser;

},{"../util":702,"./DocTypeReader":706,"./xmlNode":711,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/defineProperty":233,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.number.parse-int.js":599,"core-js/modules/es.object.keys.js":609,"core-js/modules/es.regexp.constructor.js":617,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.replace.js":629,"core-js/modules/es.string.search.js":630,"core-js/modules/es.string.trim-start.js":633,"core-js/modules/es.string.trim.js":634,"strnum":733}],709:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.array.concat.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _require = require("./OptionsBuilder"),
  buildOptions = _require.buildOptions;
var OrderedObjParser = require("./OrderedObjParser");
var _require2 = require("./node2json"),
  prettify = _require2.prettify;
var validator = require('../validator');
var XMLParser = /*#__PURE__*/function () {
  function XMLParser(options) {
    (0, _classCallCheck2.default)(this, XMLParser);
    this.externalEntities = {};
    this.options = buildOptions(options);
  }
  /**
   * Parse XML dats to JS object 
   * @param {string|Buffer} xmlData 
   * @param {boolean|Object} validationOption 
   */
  (0, _createClass2.default)(XMLParser, [{
    key: "parse",
    value: function parse(xmlData, validationOption) {
      if (typeof xmlData === "string") {} else if (xmlData.toString) {
        xmlData = xmlData.toString();
      } else {
        throw new Error("XML data is accepted in String or Bytes[] form.");
      }
      if (validationOption) {
        if (validationOption === true) validationOption = {}; //validate with default options

        var result = validator.validate(xmlData, validationOption);
        if (result !== true) {
          throw Error("".concat(result.err.msg, ":").concat(result.err.line, ":").concat(result.err.col));
        }
      }
      var orderedObjParser = new OrderedObjParser(this.options);
      orderedObjParser.addExternalEntities(this.externalEntities);
      var orderedResult = orderedObjParser.parseXml(xmlData);
      if (this.options.preserveOrder || orderedResult === undefined) return orderedResult;else return prettify(orderedResult, this.options);
    }

    /**
     * Add Entity which is not by default supported by this library
     * @param {string} key 
     * @param {string} value 
     */
  }, {
    key: "addEntity",
    value: function addEntity(key, value) {
      if (value.indexOf("&") !== -1) {
        throw new Error("Entity value can't have '&'");
      } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
        throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
      } else if (value === "&") {
        throw new Error("An entity with value '&' is not permitted");
      } else {
        this.externalEntities[key] = value;
      }
    }
  }]);
  return XMLParser;
}();
module.exports = XMLParser;

},{"../validator":703,"./OptionsBuilder":707,"./OrderedObjParser":708,"./node2json":710,"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/interopRequireDefault":237,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.to-string.js":620}],710:[function(require,module,exports){
'use strict';

/**
 * 
 * @param {array} node 
 * @param {any} options 
 * @returns 
 */
require("core-js/modules/es.object.keys.js");
function prettify(node, options) {
  return compress(node, options);
}

/**
 * 
 * @param {array} arr 
 * @param {object} options 
 * @param {string} jPath 
 * @returns object
 */
function compress(arr, options, jPath) {
  var text;
  var compressedObj = {};
  for (var i = 0; i < arr.length; i++) {
    var tagObj = arr[i];
    var property = propName(tagObj);
    var newJpath = "";
    if (jPath === undefined) newJpath = property;else newJpath = jPath + "." + property;
    if (property === options.textNodeName) {
      if (text === undefined) text = tagObj[property];else text += "" + tagObj[property];
    } else if (property === undefined) {
      continue;
    } else if (tagObj[property]) {
      var val = compress(tagObj[property], options, newJpath);
      var isLeaf = isLeafTag(val, options);
      if (tagObj[":@"]) {
        assignAttributes(val, tagObj[":@"], newJpath, options);
      } else if (Object.keys(val).length === 1 && val[options.textNodeName] !== undefined && !options.alwaysCreateTextNode) {
        val = val[options.textNodeName];
      } else if (Object.keys(val).length === 0) {
        if (options.alwaysCreateTextNode) val[options.textNodeName] = "";else val = "";
      }
      if (compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {
        if (!Array.isArray(compressedObj[property])) {
          compressedObj[property] = [compressedObj[property]];
        }
        compressedObj[property].push(val);
      } else {
        //TODO: if a node is not an array, then check if it should be an array
        //also determine if it is a leaf node
        if (options.isArray(property, newJpath, isLeaf)) {
          compressedObj[property] = [val];
        } else {
          compressedObj[property] = val;
        }
      }
    }
  }
  // if(text && text.length > 0) compressedObj[options.textNodeName] = text;
  if (typeof text === "string") {
    if (text.length > 0) compressedObj[options.textNodeName] = text;
  } else if (text !== undefined) compressedObj[options.textNodeName] = text;
  return compressedObj;
}
function propName(obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (key !== ":@") return key;
  }
}
function assignAttributes(obj, attrMap, jpath, options) {
  if (attrMap) {
    var keys = Object.keys(attrMap);
    var len = keys.length; //don't make it inline
    for (var i = 0; i < len; i++) {
      var atrrName = keys[i];
      if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
        obj[atrrName] = [attrMap[atrrName]];
      } else {
        obj[atrrName] = attrMap[atrrName];
      }
    }
  }
}
function isLeafTag(obj, options) {
  var textNodeName = options.textNodeName;
  var propCount = Object.keys(obj).length;
  if (propCount === 0) {
    return true;
  }
  if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
    return true;
  }
  return false;
}
exports.prettify = prettify;

},{"core-js/modules/es.object.keys.js":609}],711:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.object.keys.js");
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var XmlNode = /*#__PURE__*/function () {
  function XmlNode(tagname) {
    (0, _classCallCheck2.default)(this, XmlNode);
    this.tagname = tagname;
    this.child = []; //nested tags, text, cdata, comments in order
    this[":@"] = {}; //attributes map
  }
  (0, _createClass2.default)(XmlNode, [{
    key: "add",
    value: function add(key, val) {
      // this.child.push( {name : key, val: val, isCdata: isCdata });
      if (key === "__proto__") key = "#__proto__";
      this.child.push((0, _defineProperty2.default)({}, key, val));
    }
  }, {
    key: "addChild",
    value: function addChild(node) {
      if (node.tagname === "__proto__") node.tagname = "#__proto__";
      if (node[":@"] && Object.keys(node[":@"]).length > 0) {
        var _this$child$push2;
        this.child.push((_this$child$push2 = {}, (0, _defineProperty2.default)(_this$child$push2, node.tagname, node.child), (0, _defineProperty2.default)(_this$child$push2, ":@", node[":@"]), _this$child$push2));
      } else {
        this.child.push((0, _defineProperty2.default)({}, node.tagname, node.child));
      }
    }
  }]);
  return XmlNode;
}();
;
module.exports = XmlNode;

},{"@babel/runtime/helpers/classCallCheck":230,"@babel/runtime/helpers/createClass":232,"@babel/runtime/helpers/defineProperty":233,"@babel/runtime/helpers/interopRequireDefault":237,"core-js/modules/es.object.keys.js":609}],712:[function(require,module,exports){
"use strict";

require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;
module.exports = function forEach(obj, fn, ctx) {
  if (toString.call(fn) !== '[object Function]') {
    throw new TypeError('iterator must be a function');
  }
  var l = obj.length;
  if (l === +l) {
    for (var i = 0; i < l; i++) {
      fn.call(ctx, obj[i], i, obj);
    }
  } else {
    for (var k in obj) {
      if (hasOwn.call(obj, k)) {
        fn.call(ctx, obj[k], k, obj);
      }
    }
  }
};

},{"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.to-string.js":620}],713:[function(require,module,exports){
'use strict';

/* eslint no-invalid-this: 1 */
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.array.concat.js");
require("core-js/modules/es.array.join.js");
var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';
module.exports = function bind(that) {
  var target = this;
  if (typeof target !== 'function' || toStr.call(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }
  var args = slice.call(arguments, 1);
  var bound;
  var binder = function binder() {
    if (this instanceof bound) {
      var result = target.apply(this, args.concat(slice.call(arguments)));
      if (Object(result) === result) {
        return result;
      }
      return this;
    } else {
      return target.apply(that, args.concat(slice.call(arguments)));
    }
  };
  var boundLength = Math.max(0, target.length - args.length);
  var boundArgs = [];
  for (var i = 0; i < boundLength; i++) {
    boundArgs.push('$' + i);
  }
  bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);
  if (target.prototype) {
    var Empty = function Empty() {};
    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    Empty.prototype = null;
  }
  return bound;
};

},{"core-js/modules/es.array.concat.js":569,"core-js/modules/es.array.join.js":578,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.to-string.js":620}],714:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');
module.exports = Function.prototype.bind || implementation;

},{"./implementation":713}],715:[function(require,module,exports){
(function (global){(function (){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.object.to-string.js");
var origSymbol = global.Symbol;
var hasSymbolSham = require('./shams');
module.exports = function hasNativeSymbols() {
  if (typeof origSymbol !== 'function') {
    return false;
  }
  if (typeof Symbol !== 'function') {
    return false;
  }
  if ((0, _typeof2.default)(origSymbol('foo')) !== 'symbol') {
    return false;
  }
  if ((0, _typeof2.default)(Symbol('bar')) !== 'symbol') {
    return false;
  }
  return hasSymbolSham();
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./shams":716,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.js":638}],716:[function(require,module,exports){
'use strict';

/* eslint complexity: [2, 18], max-statements: [2, 33] */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.object.keys.js");
require("core-js/modules/es.object.get-own-property-names.js");
require("core-js/modules/es.object.get-own-property-descriptor.js");
module.exports = function hasSymbols() {
  if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
    return false;
  }
  if ((0, _typeof2.default)(Symbol.iterator) === 'symbol') {
    return true;
  }
  var obj = {};
  var sym = Symbol('test');
  var symObj = Object(sym);
  if (typeof sym === 'string') {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
    return false;
  }

  // temp disabled per https://github.com/ljharb/object.assign/issues/17
  // if (sym instanceof Symbol) { return false; }
  // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
  // if (!(symObj instanceof Symbol)) { return false; }

  // if (typeof Symbol.prototype.toString !== 'function') { return false; }
  // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

  var symVal = 42;
  obj[sym] = symVal;
  for (sym in obj) {
    return false;
  } // eslint-disable-line no-restricted-syntax
  if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === 'function') {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }
  return true;
};

},{"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.get-own-property-names.js":605,"core-js/modules/es.object.keys.js":609,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],717:[function(require,module,exports){
'use strict';

/* eslint complexity: [2, 18], max-statements: [2, 33] */
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.object.keys.js");
require("core-js/modules/es.object.get-own-property-names.js");
require("core-js/modules/es.object.get-own-property-descriptor.js");
module.exports = function hasSymbols() {
  if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
    return false;
  }
  if ((0, _typeof2.default)(Symbol.iterator) === 'symbol') {
    return true;
  }
  var obj = {};
  var sym = Symbol('test');
  var symObj = Object(sym);
  if (typeof sym === 'string') {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
    return false;
  }

  // temp disabled per https://github.com/ljharb/object.assign/issues/17
  // if (sym instanceof Symbol) { return false; }
  // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
  // if (!(symObj instanceof Symbol)) { return false; }

  // if (typeof Symbol.prototype.toString !== 'function') { return false; }
  // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

  var symVal = 42;
  obj[sym] = symVal;
  for (sym in obj) {
    return false;
  } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
  if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === 'function') {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }
  return true;
};

},{"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.get-own-property-names.js":605,"core-js/modules/es.object.keys.js":609,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.iterator.js":677}],718:[function(require,module,exports){
'use strict';

require("core-js/modules/es.symbol.to-string-tag.js");
require("core-js/modules/es.json.to-string-tag.js");
require("core-js/modules/es.math.to-string-tag.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
var hasSymbols = require('has-symbols/shams');
module.exports = function hasToStringTagShams() {
  return hasSymbols() && !!Symbol.toStringTag;
};

},{"core-js/modules/es.json.to-string-tag.js":586,"core-js/modules/es.math.to-string-tag.js":591,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.js":638,"core-js/modules/es.symbol.to-string-tag.js":640,"has-symbols/shams":717}],719:[function(require,module,exports){
"use strict";

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function TempCtor() {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}

},{}],720:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.symbol.to-string-tag.js");
require("core-js/modules/es.json.to-string-tag.js");
require("core-js/modules/es.math.to-string-tag.js");
require("core-js/modules/es.regexp.to-string.js");
var hasToStringTag = typeof Symbol === 'function' && (0, _typeof2.default)(Symbol.toStringTag) === 'symbol';
var toStr = Object.prototype.toString;
var isStandardArguments = function isArguments(value) {
  if (hasToStringTag && value && (0, _typeof2.default)(value) === 'object' && Symbol.toStringTag in value) {
    return false;
  }
  return toStr.call(value) === '[object Arguments]';
};
var isLegacyArguments = function isArguments(value) {
  if (isStandardArguments(value)) {
    return true;
  }
  return value !== null && (0, _typeof2.default)(value) === 'object' && typeof value.length === 'number' && value.length >= 0 && toStr.call(value) !== '[object Array]' && toStr.call(value.callee) === '[object Function]';
};
var supportsStandardArguments = function () {
  return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

},{"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.json.to-string-tag.js":586,"core-js/modules/es.math.to-string-tag.js":591,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.js":638,"core-js/modules/es.symbol.to-string-tag.js":640}],721:[function(require,module,exports){
'use strict';

require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.object.get-prototype-of.js");
require("core-js/modules/es.regexp.exec.js");
var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag = require('has-tostringtag/shams')();
var getProto = Object.getPrototypeOf;
var getGeneratorFunc = function getGeneratorFunc() {
  // eslint-disable-line consistent-return
  if (!hasToStringTag) {
    return false;
  }
  try {
    return Function('return function*() {}')();
  } catch (e) {}
};
var GeneratorFunction;
module.exports = function isGeneratorFunction(fn) {
  if (typeof fn !== 'function') {
    return false;
  }
  if (isFnRegex.test(fnToStr.call(fn))) {
    return true;
  }
  if (!hasToStringTag) {
    var str = toStr.call(fn);
    return str === '[object GeneratorFunction]';
  }
  if (!getProto) {
    return false;
  }
  if (typeof GeneratorFunction === 'undefined') {
    var generatorFunc = getGeneratorFunc();
    GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
  }
  return getProto(fn) === GeneratorFunction;
};

},{"core-js/modules/es.object.get-prototype-of.js":606,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"has-tostringtag/shams":718}],722:[function(require,module,exports){
(function (global){(function (){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.symbol.to-string-tag.js");
require("core-js/modules/es.json.to-string-tag.js");
require("core-js/modules/es.math.to-string-tag.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.object.get-prototype-of.js");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var forEach = require('foreach');
var availableTypedArrays = require('available-typed-arrays');
var callBound = require('es-abstract/helpers/callBound');
var $toString = callBound('Object.prototype.toString');
var hasSymbols = require('has-symbols')();
var hasToStringTag = hasSymbols && (0, _typeof2.default)(Symbol.toStringTag) === 'symbol';
var typedArrays = availableTypedArrays();
var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
  for (var i = 0; i < array.length; i += 1) {
    if (array[i] === value) {
      return i;
    }
  }
  return -1;
};
var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) {
  forEach(typedArrays, function (typedArray) {
    var arr = new global[typedArray]();
    if (!(Symbol.toStringTag in arr)) {
      throw new EvalError('this engine has support for Symbol.toStringTag, but ' + typedArray + ' does not have the property! Please report this.');
    }
    var proto = getPrototypeOf(arr);
    var descriptor = gOPD(proto, Symbol.toStringTag);
    if (!descriptor) {
      var superProto = getPrototypeOf(proto);
      descriptor = gOPD(superProto, Symbol.toStringTag);
    }
    toStrTags[typedArray] = descriptor.get;
  });
}
var tryTypedArrays = function tryAllTypedArrays(value) {
  var anyTrue = false;
  forEach(toStrTags, function (getter, typedArray) {
    if (!anyTrue) {
      try {
        anyTrue = getter.call(value) === typedArray;
      } catch (e) {/**/}
    }
  });
  return anyTrue;
};
module.exports = function isTypedArray(value) {
  if (!value || (0, _typeof2.default)(value) !== 'object') {
    return false;
  }
  if (!hasToStringTag) {
    var tag = $slice($toString(value), 8, -1);
    return $indexOf(typedArrays, tag) > -1;
  }
  if (!gOPD) {
    return false;
  }
  return tryTypedArrays(value);
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"available-typed-arrays":418,"core-js/modules/es.json.to-string-tag.js":586,"core-js/modules/es.math.to-string-tag.js":591,"core-js/modules/es.object.get-prototype-of.js":606,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.js":638,"core-js/modules/es.symbol.to-string-tag.js":640,"es-abstract/helpers/callBound":725,"es-abstract/helpers/getOwnPropertyDescriptor":726,"foreach":712,"has-symbols":715}],723:[function(require,module,exports){
'use strict';

/* globals
	Atomics,
	SharedArrayBuffer,
*/
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.object.get-prototype-of.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array-buffer.slice.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.typed-array.uint8-array.js");
require("core-js/modules/es.typed-array.copy-within.js");
require("core-js/modules/es.typed-array.every.js");
require("core-js/modules/es.typed-array.fill.js");
require("core-js/modules/es.typed-array.filter.js");
require("core-js/modules/es.typed-array.find.js");
require("core-js/modules/es.typed-array.find-index.js");
require("core-js/modules/es.typed-array.for-each.js");
require("core-js/modules/es.typed-array.includes.js");
require("core-js/modules/es.typed-array.index-of.js");
require("core-js/modules/es.typed-array.iterator.js");
require("core-js/modules/es.typed-array.join.js");
require("core-js/modules/es.typed-array.last-index-of.js");
require("core-js/modules/es.typed-array.map.js");
require("core-js/modules/es.typed-array.reduce.js");
require("core-js/modules/es.typed-array.reduce-right.js");
require("core-js/modules/es.typed-array.reverse.js");
require("core-js/modules/es.typed-array.set.js");
require("core-js/modules/es.typed-array.slice.js");
require("core-js/modules/es.typed-array.some.js");
require("core-js/modules/es.typed-array.sort.js");
require("core-js/modules/es.typed-array.subarray.js");
require("core-js/modules/es.typed-array.to-locale-string.js");
require("core-js/modules/es.typed-array.to-string.js");
require("core-js/modules/es.array-buffer.constructor.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.async-iterator.js");
require("core-js/modules/es.typed-array.float32-array.js");
require("core-js/modules/es.typed-array.float64-array.js");
require("core-js/modules/es.typed-array.int8-array.js");
require("core-js/modules/es.typed-array.int16-array.js");
require("core-js/modules/es.typed-array.int32-array.js");
require("core-js/modules/es.object.keys.js");
require("core-js/modules/es.map.js");
require("core-js/modules/es.number.constructor.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.constructor.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.set.js");
require("core-js/modules/es.typed-array.uint8-clamped-array.js");
require("core-js/modules/es.typed-array.uint16-array.js");
require("core-js/modules/es.typed-array.uint32-array.js");
require("core-js/modules/es.weak-map.js");
require("core-js/modules/es.weak-set.js");
require("core-js/modules/es.string.replace.js");
var undefined;
var $TypeError = TypeError;
var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
  try {
    $gOPD({}, '');
  } catch (e) {
    $gOPD = null; // this is IE 8, which has a broken gOPD
  }
}

var throwTypeError = function throwTypeError() {
  throw new $TypeError();
};
var ThrowTypeError = $gOPD ? function () {
  try {
    // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
    arguments.callee; // IE 8 does not throw here
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
      return $gOPD(arguments, 'callee').get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols = require('has-symbols')();
var getProto = Object.getPrototypeOf || function (x) {
  return x.__proto__;
}; // eslint-disable-line no-proto

var generator; // = function * () {};
var generatorFunction = generator ? getProto(generator) : undefined;
var asyncFn; // async function() {};
var asyncFunction = asyncFn ? asyncFn.constructor : undefined;
var asyncGen; // async function * () {};
var asyncGenFunction = asyncGen ? getProto(asyncGen) : undefined;
var asyncGenIterator = asyncGen ? asyncGen() : undefined;
var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);
var INTRINSICS = {
  '%Array%': Array,
  '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
  '%ArrayBufferPrototype%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer.prototype,
  '%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
  '%ArrayPrototype%': Array.prototype,
  '%ArrayProto_entries%': Array.prototype.entries,
  '%ArrayProto_forEach%': Array.prototype.forEach,
  '%ArrayProto_keys%': Array.prototype.keys,
  '%ArrayProto_values%': Array.prototype.values,
  '%AsyncFromSyncIteratorPrototype%': undefined,
  '%AsyncFunction%': asyncFunction,
  '%AsyncFunctionPrototype%': asyncFunction ? asyncFunction.prototype : undefined,
  '%AsyncGenerator%': asyncGen ? getProto(asyncGenIterator) : undefined,
  '%AsyncGeneratorFunction%': asyncGenFunction,
  '%AsyncGeneratorPrototype%': asyncGenFunction ? asyncGenFunction.prototype : undefined,
  '%AsyncIteratorPrototype%': asyncGenIterator && hasSymbols && Symbol.asyncIterator ? asyncGenIterator[Symbol.asyncIterator]() : undefined,
  '%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
  '%Boolean%': Boolean,
  '%BooleanPrototype%': Boolean.prototype,
  '%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
  '%DataViewPrototype%': typeof DataView === 'undefined' ? undefined : DataView.prototype,
  '%Date%': Date,
  '%DatePrototype%': Date.prototype,
  '%decodeURI%': decodeURI,
  '%decodeURIComponent%': decodeURIComponent,
  '%encodeURI%': encodeURI,
  '%encodeURIComponent%': encodeURIComponent,
  '%Error%': Error,
  '%ErrorPrototype%': Error.prototype,
  '%eval%': eval,
  // eslint-disable-line no-eval
  '%EvalError%': EvalError,
  '%EvalErrorPrototype%': EvalError.prototype,
  '%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
  '%Float32ArrayPrototype%': typeof Float32Array === 'undefined' ? undefined : Float32Array.prototype,
  '%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
  '%Float64ArrayPrototype%': typeof Float64Array === 'undefined' ? undefined : Float64Array.prototype,
  '%Function%': Function,
  '%FunctionPrototype%': Function.prototype,
  '%Generator%': generator ? getProto(generator()) : undefined,
  '%GeneratorFunction%': generatorFunction,
  '%GeneratorPrototype%': generatorFunction ? generatorFunction.prototype : undefined,
  '%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
  '%Int8ArrayPrototype%': typeof Int8Array === 'undefined' ? undefined : Int8Array.prototype,
  '%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
  '%Int16ArrayPrototype%': typeof Int16Array === 'undefined' ? undefined : Int8Array.prototype,
  '%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
  '%Int32ArrayPrototype%': typeof Int32Array === 'undefined' ? undefined : Int32Array.prototype,
  '%isFinite%': isFinite,
  '%isNaN%': isNaN,
  '%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
  '%JSON%': (typeof JSON === "undefined" ? "undefined" : (0, _typeof2.default)(JSON)) === 'object' ? JSON : undefined,
  '%JSONParse%': (typeof JSON === "undefined" ? "undefined" : (0, _typeof2.default)(JSON)) === 'object' ? JSON.parse : undefined,
  '%Map%': typeof Map === 'undefined' ? undefined : Map,
  '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
  '%MapPrototype%': typeof Map === 'undefined' ? undefined : Map.prototype,
  '%Math%': Math,
  '%Number%': Number,
  '%NumberPrototype%': Number.prototype,
  '%Object%': Object,
  '%ObjectPrototype%': Object.prototype,
  '%ObjProto_toString%': Object.prototype.toString,
  '%ObjProto_valueOf%': Object.prototype.valueOf,
  '%parseFloat%': parseFloat,
  '%parseInt%': parseInt,
  '%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
  '%PromisePrototype%': typeof Promise === 'undefined' ? undefined : Promise.prototype,
  '%PromiseProto_then%': typeof Promise === 'undefined' ? undefined : Promise.prototype.then,
  '%Promise_all%': typeof Promise === 'undefined' ? undefined : Promise.all,
  '%Promise_reject%': typeof Promise === 'undefined' ? undefined : Promise.reject,
  '%Promise_resolve%': typeof Promise === 'undefined' ? undefined : Promise.resolve,
  '%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
  '%RangeError%': RangeError,
  '%RangeErrorPrototype%': RangeError.prototype,
  '%ReferenceError%': ReferenceError,
  '%ReferenceErrorPrototype%': ReferenceError.prototype,
  '%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
  '%RegExp%': RegExp,
  '%RegExpPrototype%': RegExp.prototype,
  '%Set%': typeof Set === 'undefined' ? undefined : Set,
  '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
  '%SetPrototype%': typeof Set === 'undefined' ? undefined : Set.prototype,
  '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
  '%SharedArrayBufferPrototype%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer.prototype,
  '%String%': String,
  '%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
  '%StringPrototype%': String.prototype,
  '%Symbol%': hasSymbols ? Symbol : undefined,
  '%SymbolPrototype%': hasSymbols ? Symbol.prototype : undefined,
  '%SyntaxError%': SyntaxError,
  '%SyntaxErrorPrototype%': SyntaxError.prototype,
  '%ThrowTypeError%': ThrowTypeError,
  '%TypedArray%': TypedArray,
  '%TypedArrayPrototype%': TypedArray ? TypedArray.prototype : undefined,
  '%TypeError%': $TypeError,
  '%TypeErrorPrototype%': $TypeError.prototype,
  '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
  '%Uint8ArrayPrototype%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array.prototype,
  '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
  '%Uint8ClampedArrayPrototype%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray.prototype,
  '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
  '%Uint16ArrayPrototype%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array.prototype,
  '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
  '%Uint32ArrayPrototype%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array.prototype,
  '%URIError%': URIError,
  '%URIErrorPrototype%': URIError.prototype,
  '%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
  '%WeakMapPrototype%': typeof WeakMap === 'undefined' ? undefined : WeakMap.prototype,
  '%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,
  '%WeakSetPrototype%': typeof WeakSet === 'undefined' ? undefined : WeakSet.prototype
};
var bind = require('function-bind');
var $replace = bind.call(Function.call, String.prototype.replace);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
  var result = [];
  $replace(string, rePropName, function (match, number, quote, subString) {
    result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
  });
  return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
  if (!(name in INTRINSICS)) {
    throw new SyntaxError('intrinsic ' + name + ' does not exist!');
  }

  // istanbul ignore if // hopefully this is impossible to test :-)
  if (typeof INTRINSICS[name] === 'undefined' && !allowMissing) {
    throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
  }
  return INTRINSICS[name];
};
module.exports = function GetIntrinsic(name, allowMissing) {
  if (typeof name !== 'string' || name.length === 0) {
    throw new TypeError('intrinsic name must be a non-empty string');
  }
  if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
    throw new TypeError('"allowMissing" argument must be a boolean');
  }
  var parts = stringToPath(name);
  var value = getBaseIntrinsic('%' + (parts.length > 0 ? parts[0] : '') + '%', allowMissing);
  for (var i = 1; i < parts.length; i += 1) {
    if (value != null) {
      if ($gOPD && i + 1 >= parts.length) {
        var desc = $gOPD(value, parts[i]);
        if (!allowMissing && !(parts[i] in value)) {
          throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
        }
        // By convention, when a data property is converted to an accessor
        // property to emulate a data property that does not suffer from
        // the override mistake, that accessor's getter is marked with
        // an `originalValue` property. Here, when we detect this, we
        // uphold the illusion by pretending to see that original data
        // property, i.e., returning the value rather than the getter
        // itself.
        value = desc && 'get' in desc && !('originalValue' in desc.get) ? desc.get : value[parts[i]];
      } else {
        value = value[parts[i]];
      }
    }
  }
  return value;
};

},{"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array-buffer.constructor.js":566,"core-js/modules/es.array-buffer.slice.js":568,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.map.js":587,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.get-prototype-of.js":606,"core-js/modules/es.object.keys.js":609,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.promise.js":614,"core-js/modules/es.regexp.constructor.js":617,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.set.js":621,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.string.replace.js":629,"core-js/modules/es.symbol.async-iterator.js":635,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/es.typed-array.copy-within.js":641,"core-js/modules/es.typed-array.every.js":642,"core-js/modules/es.typed-array.fill.js":643,"core-js/modules/es.typed-array.filter.js":644,"core-js/modules/es.typed-array.find-index.js":645,"core-js/modules/es.typed-array.find.js":646,"core-js/modules/es.typed-array.float32-array.js":647,"core-js/modules/es.typed-array.float64-array.js":648,"core-js/modules/es.typed-array.for-each.js":649,"core-js/modules/es.typed-array.includes.js":650,"core-js/modules/es.typed-array.index-of.js":651,"core-js/modules/es.typed-array.int16-array.js":652,"core-js/modules/es.typed-array.int32-array.js":653,"core-js/modules/es.typed-array.int8-array.js":654,"core-js/modules/es.typed-array.iterator.js":655,"core-js/modules/es.typed-array.join.js":656,"core-js/modules/es.typed-array.last-index-of.js":657,"core-js/modules/es.typed-array.map.js":658,"core-js/modules/es.typed-array.reduce-right.js":659,"core-js/modules/es.typed-array.reduce.js":660,"core-js/modules/es.typed-array.reverse.js":661,"core-js/modules/es.typed-array.set.js":662,"core-js/modules/es.typed-array.slice.js":663,"core-js/modules/es.typed-array.some.js":664,"core-js/modules/es.typed-array.sort.js":665,"core-js/modules/es.typed-array.subarray.js":666,"core-js/modules/es.typed-array.to-locale-string.js":667,"core-js/modules/es.typed-array.to-string.js":668,"core-js/modules/es.typed-array.uint16-array.js":669,"core-js/modules/es.typed-array.uint32-array.js":670,"core-js/modules/es.typed-array.uint8-array.js":671,"core-js/modules/es.typed-array.uint8-clamped-array.js":672,"core-js/modules/es.weak-map.js":673,"core-js/modules/es.weak-set.js":674,"core-js/modules/web.dom-collections.iterator.js":677,"function-bind":714,"has-symbols":715}],724:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var GetIntrinsic = require('../GetIntrinsic');
var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
if ($defineProperty) {
  try {
    $defineProperty({}, 'a', {
      value: 1
    });
  } catch (e) {
    // IE 8 has a broken defineProperty
    $defineProperty = null;
  }
}
module.exports = function callBind() {
  return $reflectApply(bind, $call, arguments);
};
var applyBind = function applyBind() {
  return $reflectApply(bind, $apply, arguments);
};
if ($defineProperty) {
  $defineProperty(module.exports, 'apply', {
    value: applyBind
  });
} else {
  module.exports.apply = applyBind;
}

},{"../GetIntrinsic":723,"function-bind":714}],725:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('../GetIntrinsic');
var callBind = require('./callBind');
var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));
module.exports = function callBoundIntrinsic(name, allowMissing) {
  var intrinsic = GetIntrinsic(name, !!allowMissing);
  if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.')) {
    return callBind(intrinsic);
  }
  return intrinsic;
};

},{"../GetIntrinsic":723,"./callBind":724}],726:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('../GetIntrinsic');
var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%');
if ($gOPD) {
  try {
    $gOPD([], 'length');
  } catch (e) {
    // IE 8 has a broken gOPD
    $gOPD = null;
  }
}
module.exports = $gOPD;

},{"../GetIntrinsic":723}],727:[function(require,module,exports){
"use strict";

module.exports = require('./lib/jspath');

},{"./lib/jspath":728}],728:[function(require,module,exports){
'use strict';

/**
* JSPath
*
* Copyright (c) 2012 Filatov Dmitry (dfilatov@yandex-team.ru)
* With parts by Marat Dulin (mdevils@gmail.com)
* Dual licensed under the MIT and GPL licenses:
* http://www.opensource.org/licenses/mit-license.php
* http://www.gnu.org/licenses/gpl.html
*
* @version 0.4.0
*/
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.array.concat.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.array.join.js");
require("core-js/modules/es.array.splice.js");
(function () {
  var SYNTAX = {
    PATH: 1,
    SELECTOR: 2,
    OBJ_PRED: 3,
    POS_PRED: 4,
    LOGICAL_EXPR: 5,
    COMPARISON_EXPR: 6,
    MATH_EXPR: 7,
    CONCAT_EXPR: 8,
    UNARY_EXPR: 9,
    POS_EXPR: 10,
    LITERAL: 11
  };

  // parser

  var parse = function () {
    var TOKEN = {
        ID: 1,
        NUM: 2,
        STR: 3,
        BOOL: 4,
        NULL: 5,
        PUNCT: 6,
        EOP: 7
      },
      MESSAGES = {
        UNEXP_TOKEN: 'Unexpected token "%0"',
        UNEXP_EOP: 'Unexpected end of path'
      };
    var path, idx, buf, len;
    function parse(_path) {
      path = _path.split('');
      idx = 0;
      buf = null;
      len = path.length;
      var res = parsePathConcatExpr(),
        token = lex();
      if (token.type !== TOKEN.EOP) {
        throwUnexpected(token);
      }
      return res;
    }
    function parsePathConcatExpr() {
      var expr = parsePathConcatPartExpr(),
        operands;
      while (match('|')) {
        lex();
        (operands || (operands = [expr])).push(parsePathConcatPartExpr());
      }
      return operands ? {
        type: SYNTAX.CONCAT_EXPR,
        args: operands
      } : expr;
    }
    function parsePathConcatPartExpr() {
      return match('(') ? parsePathGroupExpr() : parsePath();
    }
    function parsePathGroupExpr() {
      expect('(');
      var expr = parsePathConcatExpr();
      expect(')');
      var parts = [],
        part;
      while (part = parsePredicate()) {
        parts.push(part);
      }
      if (!parts.length) {
        return expr;
      } else if (expr.type === SYNTAX.PATH) {
        expr.parts = expr.parts.concat(parts);
        return expr;
      }
      parts.unshift(expr);
      return {
        type: SYNTAX.PATH,
        parts: parts
      };
    }
    function parsePredicate() {
      if (match('[')) {
        return parsePosPredicate();
      }
      if (match('{')) {
        return parseObjectPredicate();
      }
      if (match('(')) {
        return parsePathGroupExpr();
      }
    }
    function parsePath() {
      if (!matchPath()) {
        throwUnexpected(lex());
      }
      var fromRoot = false,
        subst;
      if (match('^')) {
        lex();
        fromRoot = true;
      } else if (matchSubst()) {
        subst = lex().val.substr(1);
      }
      var parts = [],
        part;
      while (part = parsePathPart()) {
        parts.push(part);
      }
      return {
        type: SYNTAX.PATH,
        fromRoot: fromRoot,
        subst: subst,
        parts: parts
      };
    }
    function parsePathPart() {
      return matchSelector() ? parseSelector() : parsePredicate();
    }
    function parseSelector() {
      var selector = lex().val,
        token = lookahead(),
        prop;
      if (match('*') || token.type === TOKEN.ID || token.type === TOKEN.STR) {
        prop = lex().val;
      }
      return {
        type: SYNTAX.SELECTOR,
        selector: selector,
        prop: prop
      };
    }
    function parsePosPredicate() {
      expect('[');
      var expr = parsePosExpr();
      expect(']');
      return {
        type: SYNTAX.POS_PRED,
        arg: expr
      };
    }
    function parseObjectPredicate() {
      expect('{');
      var expr = parseLogicalORExpr();
      expect('}');
      return {
        type: SYNTAX.OBJ_PRED,
        arg: expr
      };
    }
    function parseLogicalORExpr() {
      var expr = parseLogicalANDExpr(),
        operands;
      while (match('||')) {
        lex();
        (operands || (operands = [expr])).push(parseLogicalANDExpr());
      }
      return operands ? {
        type: SYNTAX.LOGICAL_EXPR,
        op: '||',
        args: operands
      } : expr;
    }
    function parseLogicalANDExpr() {
      var expr = parseEqualityExpr(),
        operands;
      while (match('&&')) {
        lex();
        (operands || (operands = [expr])).push(parseEqualityExpr());
      }
      return operands ? {
        type: SYNTAX.LOGICAL_EXPR,
        op: '&&',
        args: operands
      } : expr;
    }
    function parseEqualityExpr() {
      var expr = parseRelationalExpr();
      while (match('==') || match('!=') || match('===') || match('!==') || match('^==') || match('==^') || match('^=') || match('=^') || match('$==') || match('==$') || match('$=') || match('=$') || match('*==') || match('==*') || match('*=') || match('=*')) {
        expr = {
          type: SYNTAX.COMPARISON_EXPR,
          op: lex().val,
          args: [expr, parseEqualityExpr()]
        };
      }
      return expr;
    }
    function parseRelationalExpr() {
      var expr = parseAdditiveExpr();
      while (match('<') || match('>') || match('<=') || match('>=')) {
        expr = {
          type: SYNTAX.COMPARISON_EXPR,
          op: lex().val,
          args: [expr, parseRelationalExpr()]
        };
      }
      return expr;
    }
    function parseAdditiveExpr() {
      var expr = parseMultiplicativeExpr();
      while (match('+') || match('-')) {
        expr = {
          type: SYNTAX.MATH_EXPR,
          op: lex().val,
          args: [expr, parseMultiplicativeExpr()]
        };
      }
      return expr;
    }
    function parseMultiplicativeExpr() {
      var expr = parseUnaryExpr();
      while (match('*') || match('/') || match('%')) {
        expr = {
          type: SYNTAX.MATH_EXPR,
          op: lex().val,
          args: [expr, parseMultiplicativeExpr()]
        };
      }
      return expr;
    }
    function parsePosExpr() {
      if (match(':')) {
        lex();
        return {
          type: SYNTAX.POS_EXPR,
          toIdx: parseUnaryExpr()
        };
      }
      var fromExpr = parseUnaryExpr();
      if (match(':')) {
        lex();
        if (match(']')) {
          return {
            type: SYNTAX.POS_EXPR,
            fromIdx: fromExpr
          };
        }
        return {
          type: SYNTAX.POS_EXPR,
          fromIdx: fromExpr,
          toIdx: parseUnaryExpr()
        };
      }
      return {
        type: SYNTAX.POS_EXPR,
        idx: fromExpr
      };
    }
    function parseUnaryExpr() {
      if (match('!') || match('-')) {
        return {
          type: SYNTAX.UNARY_EXPR,
          op: lex().val,
          arg: parseUnaryExpr()
        };
      }
      return parsePrimaryExpr();
    }
    function parsePrimaryExpr() {
      var token = lookahead(),
        type = token.type;
      if (type === TOKEN.STR || type === TOKEN.NUM || type === TOKEN.BOOL || type === TOKEN.NULL) {
        return {
          type: SYNTAX.LITERAL,
          val: lex().val
        };
      }
      if (matchPath()) {
        return parsePath();
      }
      if (match('(')) {
        return parseGroupExpr();
      }
      return throwUnexpected(lex());
    }
    function parseGroupExpr() {
      expect('(');
      var expr = parseLogicalORExpr();
      expect(')');
      return expr;
    }
    function match(val) {
      var token = lookahead();
      return token.type === TOKEN.PUNCT && token.val === val;
    }
    function matchPath() {
      return matchSelector() || matchSubst() || match('^');
    }
    function matchSelector() {
      var token = lookahead();
      if (token.type === TOKEN.PUNCT) {
        var val = token.val;
        return val === '.' || val === '..';
      }
      return false;
    }
    function matchSubst() {
      var token = lookahead();
      return token.type === TOKEN.ID && token.val[0] === '$';
    }
    function expect(val) {
      var token = lex();
      if (token.type !== TOKEN.PUNCT || token.val !== val) {
        throwUnexpected(token);
      }
    }
    function lookahead() {
      if (buf !== null) {
        return buf;
      }
      var pos = idx;
      buf = advance();
      idx = pos;
      return buf;
    }
    function advance() {
      while (isWhiteSpace(path[idx])) {
        ++idx;
      }
      if (idx >= len) {
        return {
          type: TOKEN.EOP,
          range: [idx, idx]
        };
      }
      var token = scanPunctuator();
      if (token || (token = scanId()) || (token = scanString()) || (token = scanNumeric())) {
        return token;
      }
      token = {
        range: [idx, idx]
      };
      idx >= len ? token.type = TOKEN.EOP : token.val = path[idx];
      throwUnexpected(token);
    }
    function lex() {
      var token;
      if (buf) {
        idx = buf.range[1];
        token = buf;
        buf = null;
        return token;
      }
      return advance();
    }
    function isDigit(ch) {
      return '0123456789'.indexOf(ch) >= 0;
    }
    function isWhiteSpace(ch) {
      return ' \r\n\t'.indexOf(ch) > -1;
    }
    function isIdStart(ch) {
      return ch === '$' || ch === '@' || ch === '_' || ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z';
    }
    function isIdPart(ch) {
      return isIdStart(ch) || ch >= '0' && ch <= '9';
    }
    function scanId() {
      var ch = path[idx];
      if (!isIdStart(ch)) {
        return;
      }
      var start = idx,
        id = ch;
      while (++idx < len) {
        ch = path[idx];
        if (!isIdPart(ch)) {
          break;
        }
        id += ch;
      }
      switch (id) {
        case 'true':
        case 'false':
          return {
            type: TOKEN.BOOL,
            val: id === 'true',
            range: [start, idx]
          };
        case 'null':
          return {
            type: TOKEN.NULL,
            val: null,
            range: [start, idx]
          };
        default:
          return {
            type: TOKEN.ID,
            val: id,
            range: [start, idx]
          };
      }
    }
    function scanString() {
      if (path[idx] !== '"' && path[idx] !== '\'') {
        return;
      }
      var orig = path[idx],
        start = ++idx,
        str = '',
        eosFound = false,
        ch;
      while (idx < len) {
        ch = path[idx++];
        if (ch === '\\') {
          ch = path[idx++];
        } else if ((ch === '"' || ch === '\'') && ch === orig) {
          eosFound = true;
          break;
        }
        str += ch;
      }
      if (eosFound) {
        return {
          type: TOKEN.STR,
          val: str,
          range: [start, idx]
        };
      }
    }
    function scanNumeric() {
      var start = idx,
        ch = path[idx],
        isFloat = ch === '.';
      if (isFloat || isDigit(ch)) {
        var num = ch;
        while (++idx < len) {
          ch = path[idx];
          if (ch === '.') {
            if (isFloat) {
              return;
            }
            isFloat = true;
          } else if (!isDigit(ch)) {
            break;
          }
          num += ch;
        }
        return {
          type: TOKEN.NUM,
          val: isFloat ? parseFloat(num) : parseInt(num, 10),
          range: [start, idx]
        };
      }
    }
    function scanPunctuator() {
      var start = idx,
        ch1 = path[idx],
        ch2 = path[idx + 1];
      if (ch1 === '.') {
        if (isDigit(ch2)) {
          return;
        }
        return path[++idx] === '.' ? {
          type: TOKEN.PUNCT,
          val: '..',
          range: [start, ++idx]
        } : {
          type: TOKEN.PUNCT,
          val: '.',
          range: [start, idx]
        };
      }
      if (ch2 === '=') {
        var ch3 = path[idx + 2];
        if (ch3 === '=') {
          if ('=!^$*'.indexOf(ch1) >= 0) {
            return {
              type: TOKEN.PUNCT,
              val: ch1 + ch2 + ch3,
              range: [start, idx += 3]
            };
          }
        } else if ('^$*'.indexOf(ch3) >= 0) {
          if (ch1 === '=') {
            return {
              type: TOKEN.PUNCT,
              val: ch1 + ch2 + ch3,
              range: [start, idx += 3]
            };
          }
        } else if ('=!^$*><'.indexOf(ch1) >= 0) {
          return {
            type: TOKEN.PUNCT,
            val: ch1 + ch2,
            range: [start, idx += 2]
          };
        }
      } else if (ch1 === '=' && '^$*'.indexOf(ch2) >= 0) {
        return {
          type: TOKEN.PUNCT,
          val: ch1 + ch2,
          range: [start, idx += 2]
        };
      }
      if (ch1 === ch2 && (ch1 === '|' || ch1 === '&')) {
        return {
          type: TOKEN.PUNCT,
          val: ch1 + ch2,
          range: [start, idx += 2]
        };
      }
      if (':{}()[]^+-*/%!><|'.indexOf(ch1) >= 0) {
        return {
          type: TOKEN.PUNCT,
          val: ch1,
          range: [start, ++idx]
        };
      }
    }
    function throwUnexpected(token) {
      if (token.type === TOKEN.EOP) {
        throwError(token, MESSAGES.UNEXP_EOP);
      }
      throwError(token, MESSAGES.UNEXP_TOKEN, token.val);
    }
    function throwError(token, messageFormat) {
      var args = Array.prototype.slice.call(arguments, 2),
        msg = messageFormat.replace(/%(\d)/g, function (_, idx) {
          return args[idx] || '';
        }),
        error = new Error(msg);
      error.column = token.range[0];
      throw error;
    }
    return parse;
  }();

  // translator

  var translate = function () {
    var body, vars, lastVarId, unusedVars;
    function acquireVar() {
      if (unusedVars.length) {
        return unusedVars.shift();
      }
      var varName = 'v' + ++lastVarId;
      vars.push(varName);
      return varName;
    }
    function releaseVars() {
      var args = arguments,
        i = args.length;
      while (i--) {
        unusedVars.push(args[i]);
      }
    }
    function translate(ast) {
      body = [];
      vars = ['res'];
      lastVarId = 0;
      unusedVars = [];
      translateExpr(ast, 'res', 'data');
      body.unshift('var ', Array.isArray ? 'isArr = Array.isArray' : 'toStr = Object.prototype.toString, isArr = function(o) { return toStr.call(o) === "[object Array]"; }', ', concat = Array.prototype.concat', ',', vars.join(','), ';');
      if (ast.type === SYNTAX.PATH) {
        var lastPart = ast.parts[ast.parts.length - 1];
        if (lastPart && lastPart.type === SYNTAX.POS_PRED && 'idx' in lastPart.arg) {
          body.push('res = res[0];');
        }
      }
      body.push('return res;');
      return body.join('');
    }
    function translatePath(path, dest, ctx) {
      var parts = path.parts,
        i = 0,
        len = parts.length;
      body.push(dest, '=', path.fromRoot ? 'data' : path.subst ? 'subst.' + path.subst : ctx, ';', 'isArr(' + dest + ') || (' + dest + ' = [' + dest + ']);');
      while (i < len) {
        var item = parts[i++];
        switch (item.type) {
          case SYNTAX.SELECTOR:
            item.selector === '..' ? translateDescendantSelector(item, dest, dest) : translateSelector(item, dest, dest);
            break;
          case SYNTAX.OBJ_PRED:
            translateObjectPredicate(item, dest, dest);
            break;
          case SYNTAX.POS_PRED:
            translatePosPredicate(item, dest, dest);
            break;
          case SYNTAX.CONCAT_EXPR:
            translateConcatExpr(item, dest, dest);
            break;
        }
      }
    }
    function translateSelector(sel, dest, ctx) {
      if (sel.prop) {
        var propStr = escapeStr(sel.prop),
          res = acquireVar(),
          i = acquireVar(),
          len = acquireVar(),
          curCtx = acquireVar(),
          j = acquireVar(),
          val = acquireVar(),
          tmpArr = acquireVar();
        body.push(res, '= [];', i, '= 0;', len, '=', ctx, '.length;', tmpArr, '= [];', 'while(', i, '<', len, ') {', curCtx, '=', ctx, '[', i, '++];', 'if(', curCtx, '!= null) {');
        if (sel.prop === '*') {
          body.push('if(typeof ', curCtx, '=== "object") {', 'if(isArr(', curCtx, ')) {', res, '=', res, '.concat(', curCtx, ');', '}', 'else {', 'for(', j, ' in ', curCtx, ') {', 'if(', curCtx, '.hasOwnProperty(', j, ')) {', val, '=', curCtx, '[', j, '];');
          inlineAppendToArray(res, val);
          body.push('}', '}', '}', '}');
        } else {
          body.push(val, '=', curCtx, '[', propStr, '];');
          inlineAppendToArray(res, val, tmpArr, len);
        }
        body.push('}', '}', dest, '=', len, '> 1 &&', tmpArr, '.length?', tmpArr, '.length > 1?', 'concat.apply(', res, ',', tmpArr, ') :', res, '.concat(', tmpArr, '[0]) :', res, ';');
        releaseVars(res, i, len, curCtx, j, val, tmpArr);
      }
    }
    function translateDescendantSelector(sel, dest, baseCtx) {
      var prop = sel.prop,
        ctx = acquireVar(),
        curCtx = acquireVar(),
        childCtxs = acquireVar(),
        i = acquireVar(),
        j = acquireVar(),
        val = acquireVar(),
        len = acquireVar(),
        res = acquireVar();
      body.push(ctx, '=', baseCtx, '.slice(),', res, '= [];', 'while(', ctx, '.length) {', curCtx, '=', ctx, '.shift();');
      prop ? body.push('if(typeof ', curCtx, '=== "object" &&', curCtx, ') {') : body.push('if(typeof ', curCtx, '!= null) {');
      body.push(childCtxs, '= [];', 'if(isArr(', curCtx, ')) {', i, '= 0,', len, '=', curCtx, '.length;', 'while(', i, '<', len, ') {', val, '=', curCtx, '[', i, '++];');
      prop && body.push('if(typeof ', val, '=== "object") {');
      inlineAppendToArray(childCtxs, val);
      prop && body.push('}');
      body.push('}', '}', 'else {');
      if (prop) {
        if (prop !== '*') {
          body.push(val, '=', curCtx, '["' + prop + '"];');
          inlineAppendToArray(res, val);
        }
      } else {
        inlineAppendToArray(res, curCtx);
        body.push('if(typeof ', curCtx, '=== "object") {');
      }
      body.push('for(', j, ' in ', curCtx, ') {', 'if(', curCtx, '.hasOwnProperty(', j, ')) {', val, '=', curCtx, '[', j, '];');
      inlineAppendToArray(childCtxs, val);
      prop === '*' && inlineAppendToArray(res, val);
      body.push('}', '}');
      prop || body.push('}');
      body.push('}', childCtxs, '.length &&', ctx, '.unshift.apply(', ctx, ',', childCtxs, ');', '}', '}', dest, '=', res, ';');
      releaseVars(ctx, curCtx, childCtxs, i, j, val, len, res);
    }
    function translateObjectPredicate(expr, dest, ctx) {
      var resVar = acquireVar(),
        i = acquireVar(),
        len = acquireVar(),
        cond = acquireVar(),
        curItem = acquireVar();
      body.push(resVar, '= [];', i, '= 0;', len, '=', ctx, '.length;', 'while(', i, '<', len, ') {', curItem, '=', ctx, '[', i, '++];');
      translateExpr(expr.arg, cond, curItem);
      body.push(convertToBool(expr.arg, cond), '&&', resVar, '.push(', curItem, ');', '}', dest, '=', resVar, ';');
      releaseVars(resVar, i, len, curItem, cond);
    }
    function translatePosPredicate(item, dest, ctx) {
      var arrayExpr = item.arg,
        fromIdx,
        toIdx;
      if (arrayExpr.idx) {
        var idx = acquireVar();
        translateExpr(arrayExpr.idx, idx, ctx);
        body.push(idx, '< 0 && (', idx, '=', ctx, '.length +', idx, ');', dest, '=', ctx, '[', idx, '] == null? [] : [', ctx, '[', idx, ']];');
        releaseVars(idx);
        return false;
      } else if (arrayExpr.fromIdx) {
        if (arrayExpr.toIdx) {
          translateExpr(arrayExpr.fromIdx, fromIdx = acquireVar(), ctx);
          translateExpr(arrayExpr.toIdx, toIdx = acquireVar(), ctx);
          body.push(dest, '=', ctx, '.slice(', fromIdx, ',', toIdx, ');');
          releaseVars(fromIdx, toIdx);
        } else {
          translateExpr(arrayExpr.fromIdx, fromIdx = acquireVar(), ctx);
          body.push(dest, '=', ctx, '.slice(', fromIdx, ');');
          releaseVars(fromIdx);
        }
      } else {
        translateExpr(arrayExpr.toIdx, toIdx = acquireVar(), ctx);
        body.push(dest, '=', ctx, '.slice(0,', toIdx, ');');
        releaseVars(toIdx);
      }
    }
    function translateExpr(expr, dest, ctx) {
      switch (expr.type) {
        case SYNTAX.PATH:
          translatePath(expr, dest, ctx);
          break;
        case SYNTAX.CONCAT_EXPR:
          translateConcatExpr(expr, dest, ctx);
          break;
        case SYNTAX.COMPARISON_EXPR:
          translateComparisonExpr(expr, dest, ctx);
          break;
        case SYNTAX.MATH_EXPR:
          translateMathExpr(expr, dest, ctx);
          break;
        case SYNTAX.LOGICAL_EXPR:
          translateLogicalExpr(expr, dest, ctx);
          break;
        case SYNTAX.UNARY_EXPR:
          translateUnaryExpr(expr, dest, ctx);
          break;
        case SYNTAX.LITERAL:
          body.push(dest, '=');
          translateLiteral(expr.val);
          body.push(';');
          break;
      }
    }
    function translateLiteral(val) {
      body.push(typeof val === 'string' ? escapeStr(val) : val === null ? 'null' : val);
    }
    function translateComparisonExpr(expr, dest, ctx) {
      var val1 = acquireVar(),
        val2 = acquireVar(),
        isVal1Array = acquireVar(),
        isVal2Array = acquireVar(),
        i = acquireVar(),
        j = acquireVar(),
        len1 = acquireVar(),
        len2 = acquireVar(),
        leftArg = expr.args[0],
        rightArg = expr.args[1];
      body.push(dest, '= false;');
      translateExpr(leftArg, val1, ctx);
      translateExpr(rightArg, val2, ctx);
      var isLeftArgPath = leftArg.type === SYNTAX.PATH,
        isRightArgLiteral = rightArg.type === SYNTAX.LITERAL;
      body.push(isVal1Array, '=');
      isLeftArgPath ? body.push('true;') : body.push('isArr(', val1, ');');
      body.push(isVal2Array, '=');
      isRightArgLiteral ? body.push('false;') : body.push('isArr(', val2, ');');
      body.push('if(');
      isLeftArgPath || body.push(isVal1Array, '&&');
      body.push(val1, '.length === 1) {', val1, '=', val1, '[0];', isVal1Array, '= false;', '}');
      isRightArgLiteral || body.push('if(', isVal2Array, '&&', val2, '.length === 1) {', val2, '=', val2, '[0];', isVal2Array, '= false;', '}');
      body.push(i, '= 0;', 'if(', isVal1Array, ') {', len1, '=', val1, '.length;');
      if (!isRightArgLiteral) {
        body.push('if(', isVal2Array, ') {', len2, '=', val2, '.length;', 'while(', i, '<', len1, '&& !', dest, ') {', j, '= 0;', 'while(', j, '<', len2, ') {');
        writeCondition(expr.op, [val1, '[', i, ']'].join(''), [val2, '[', j, ']'].join(''));
        body.push(dest, '= true;', 'break;', '}', '++', j, ';', '}', '++', i, ';', '}', '}', 'else {');
      }
      body.push('while(', i, '<', len1, ') {');
      writeCondition(expr.op, [val1, '[', i, ']'].join(''), val2);
      body.push(dest, '= true;', 'break;', '}', '++', i, ';', '}');
      isRightArgLiteral || body.push('}');
      body.push('}');
      if (!isRightArgLiteral) {
        body.push('else if(', isVal2Array, ') {', len2, '=', val2, '.length;', 'while(', i, '<', len2, ') {');
        writeCondition(expr.op, val1, [val2, '[', i, ']'].join(''));
        body.push(dest, '= true;', 'break;', '}', '++', i, ';', '}', '}');
      }
      body.push('else {', dest, '=', binaryOperators[expr.op](val1, val2), ';', '}');
      releaseVars(val1, val2, isVal1Array, isVal2Array, i, j, len1, len2);
    }
    function writeCondition(op, val1Expr, val2Expr) {
      body.push('if(', binaryOperators[op](val1Expr, val2Expr), ') {');
    }
    function translateLogicalExpr(expr, dest, ctx) {
      var conditionVars = [],
        args = expr.args,
        len = args.length,
        i = 0,
        val;
      body.push(dest, '= false;');
      switch (expr.op) {
        case '&&':
          while (i < len) {
            conditionVars.push(val = acquireVar());
            translateExpr(args[i], val, ctx);
            body.push('if(', convertToBool(args[i++], val), ') {');
          }
          body.push(dest, '= true;');
          break;
        case '||':
          while (i < len) {
            conditionVars.push(val = acquireVar());
            translateExpr(args[i], val, ctx);
            body.push('if(', convertToBool(args[i], val), ') {', dest, '= true;', '}');
            if (i++ + 1 < len) {
              body.push('else {');
            }
          }
          --len;
          break;
      }
      while (len--) {
        body.push('}');
      }
      releaseVars.apply(null, conditionVars);
    }
    function translateMathExpr(expr, dest, ctx) {
      var val1 = acquireVar(),
        val2 = acquireVar(),
        args = expr.args;
      translateExpr(args[0], val1, ctx);
      translateExpr(args[1], val2, ctx);
      body.push(dest, '=', binaryOperators[expr.op](convertToSingleValue(args[0], val1), convertToSingleValue(args[1], val2)), ';');
      releaseVars(val1, val2);
    }
    function translateUnaryExpr(expr, dest, ctx) {
      var val = acquireVar(),
        arg = expr.arg;
      translateExpr(arg, val, ctx);
      switch (expr.op) {
        case '!':
          body.push(dest, '= !', convertToBool(arg, val) + ';');
          break;
        case '-':
          body.push(dest, '= -', convertToSingleValue(arg, val) + ';');
          break;
      }
      releaseVars(val);
    }
    function translateConcatExpr(expr, dest, ctx) {
      var argVars = [],
        args = expr.args,
        len = args.length,
        i = 0;
      while (i < len) {
        argVars.push(acquireVar());
        translateExpr(args[i], argVars[i++], ctx);
      }
      body.push(dest, '= concat.call(', argVars.join(','), ');');
      releaseVars.apply(null, argVars);
    }
    function escapeStr(s) {
      return '\'' + s.replace(/\\/g, '\\\\').replace(/'/g, '\\\'') + '\'';
    }
    function inlineAppendToArray(res, val, tmpArr, len) {
      body.push('if(typeof ', val, '!== "undefined") {', 'if(isArr(', val, ')) {');
      if (tmpArr) {
        body.push(len, '> 1?');
        inlinePushToArray(tmpArr, val);
        body.push(':');
      }
      body.push(res, '=', res, '.length?', res, '.concat(', val, ') :', val, '.slice()', ';', '}', 'else {');
      tmpArr && body.push('if(', tmpArr, '.length) {', res, '= concat.apply(', res, ',', tmpArr, ');', tmpArr, '= [];', '}');
      inlinePushToArray(res, val);
      body.push(';', '}', '}');
    }
    function inlinePushToArray(res, val) {
      body.push(res, '.length?', res, '.push(', val, ') :', res, '[0] =', val);
    }
    function convertToBool(arg, varName) {
      switch (arg.type) {
        case SYNTAX.LOGICAL_EXPR:
          return varName;
        case SYNTAX.LITERAL:
          return '!!' + varName;
        case SYNTAX.PATH:
          return varName + '.length > 0';
        default:
          return ['(typeof ', varName, '=== "boolean"?', varName, ':', 'isArr(', varName, ')?', varName, '.length > 0 : !!', varName, ')'].join('');
      }
    }
    function convertToSingleValue(arg, varName) {
      switch (arg.type) {
        case SYNTAX.LITERAL:
          return varName;
        case SYNTAX.PATH:
          return varName + '[0]';
        default:
          return ['(isArr(', varName, ')?', varName, '[0] : ', varName, ')'].join('');
      }
    }
    function startsWithStrict(val1, val2) {
      return ['typeof ', val1, '=== "string" && typeof ', val2, '=== "string" &&', val1, '.indexOf(', val2, ') === 0'].join('');
    }
    function startsWith(val1, val2) {
      return [val1, '!= null &&', val2, '!= null &&', val1, '.toString().toLowerCase().indexOf(', val2, '.toString().toLowerCase()) === 0'].join('');
    }
    function endsWithStrict(val1, val2) {
      return ['typeof ', val1, '=== "string" && typeof ', val2, '=== "string" &&', val1, '.length >=', val2, '.length &&', val1, '.lastIndexOf(', val2, ') ===', val1, '.length -', val2, '.length'].join('');
    }
    function endsWith(val1, val2) {
      return [val1, '!= null &&', val2, '!= null &&', '(', val1, '=', val1, '.toString()).length >=', '(', val2, '=', val2, '.toString()).length &&', '(', val1, '.toLowerCase()).lastIndexOf(', '(', val2, '.toLowerCase())) ===', val1, '.length -', val2, '.length'].join('');
    }
    function containsStrict(val1, val2) {
      return ['typeof ', val1, '=== "string" && typeof ', val2, '=== "string" &&', val1, '.indexOf(', val2, ') > -1'].join('');
    }
    function contains(val1, val2) {
      return [val1, '!= null && ', val2, '!= null &&', val1, '.toString().toLowerCase().indexOf(', val2, '.toString().toLowerCase()) > -1'].join('');
    }
    var binaryOperators = {
      '===': function _(val1, val2) {
        return val1 + '===' + val2;
      },
      '==': function _(val1, val2) {
        return ['typeof ', val1, '=== "string" && typeof ', val2, '=== "string"?', val1, '.toLowerCase() ===', val2, '.toLowerCase() :' + val1, '==', val2].join('');
      },
      '>=': function _(val1, val2) {
        return val1 + '>=' + val2;
      },
      '>': function _(val1, val2) {
        return val1 + '>' + val2;
      },
      '<=': function _(val1, val2) {
        return val1 + '<=' + val2;
      },
      '<': function _(val1, val2) {
        return val1 + '<' + val2;
      },
      '!==': function _(val1, val2) {
        return val1 + '!==' + val2;
      },
      '!=': function _(val1, val2) {
        return val1 + '!=' + val2;
      },
      '^==': startsWithStrict,
      '==^': function _(val1, val2) {
        return startsWithStrict(val2, val1);
      },
      '^=': startsWith,
      '=^': function _(val1, val2) {
        return startsWith(val2, val1);
      },
      '$==': endsWithStrict,
      '==$': function $(val1, val2) {
        return endsWithStrict(val2, val1);
      },
      '$=': endsWith,
      '=$': function $(val1, val2) {
        return endsWith(val2, val1);
      },
      '*==': containsStrict,
      '==*': function _(val1, val2) {
        return containsStrict(val2, val1);
      },
      '=*': function _(val1, val2) {
        return contains(val2, val1);
      },
      '*=': contains,
      '+': function _(val1, val2) {
        return val1 + '+' + val2;
      },
      '-': function _(val1, val2) {
        return val1 + '-' + val2;
      },
      '*': function _(val1, val2) {
        return val1 + '*' + val2;
      },
      '/': function _(val1, val2) {
        return val1 + '/' + val2;
      },
      '%': function _(val1, val2) {
        return val1 + '%' + val2;
      }
    };
    return translate;
  }();
  function compile(path) {
    return Function('data,subst', translate(parse(path)));
  }
  var cache = {},
    cacheKeys = [],
    params = {
      cacheSize: 100
    },
    setParamsHooks = {
      cacheSize: function cacheSize(oldVal, newVal) {
        if (newVal < oldVal && cacheKeys.length > newVal) {
          var removedKeys = cacheKeys.splice(0, cacheKeys.length - newVal),
            i = removedKeys.length;
          while (i--) {
            delete cache[removedKeys[i]];
          }
        }
      }
    };
  var decl = function decl(path, ctx, substs) {
    if (!cache[path]) {
      cache[path] = compile(path);
      if (cacheKeys.push(path) > params.cacheSize) {
        delete cache[cacheKeys.shift()];
      }
    }
    return cache[path](ctx, substs || {});
  };
  decl.version = '0.3.4';
  decl.params = function (_params) {
    if (!arguments.length) {
      return params;
    }
    for (var name in _params) {
      if (_params.hasOwnProperty(name)) {
        setParamsHooks[name] && setParamsHooks[name](params[name], _params[name]);
        params[name] = _params[name];
      }
    }
  };
  decl.compile = compile;
  decl.apply = decl;
  if ((typeof module === "undefined" ? "undefined" : (0, _typeof2.default)(module)) === 'object' && (0, _typeof2.default)(module.exports) === 'object') {
    module.exports = decl;
  } else if ((typeof modules === "undefined" ? "undefined" : (0, _typeof2.default)(modules)) === 'object') {
    modules.define('jspath', function (provide) {
      provide(decl);
    });
  } else if (typeof define === 'function') {
    define(function (require, exports, module) {
      module.exports = decl;
    });
  } else {
    window.JSPath = decl;
  }
})();

},{"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.array.join.js":578,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.array.splice.js":582,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.string.replace.js":629}],729:[function(require,module,exports){
(function (global){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/web.dom-collections.for-each.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.regexp.constructor.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.array.splice.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.object.keys.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.map.js");
require("core-js/modules/es.array-buffer.constructor.js");
require("core-js/modules/es.array-buffer.slice.js");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
/**
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
  COMPARE_UNORDERED_FLAG = 2;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
  arrayTag = '[object Array]',
  asyncTag = '[object AsyncFunction]',
  boolTag = '[object Boolean]',
  dateTag = '[object Date]',
  errorTag = '[object Error]',
  funcTag = '[object Function]',
  genTag = '[object GeneratorFunction]',
  mapTag = '[object Map]',
  numberTag = '[object Number]',
  nullTag = '[object Null]',
  objectTag = '[object Object]',
  promiseTag = '[object Promise]',
  proxyTag = '[object Proxy]',
  regexpTag = '[object RegExp]',
  setTag = '[object Set]',
  stringTag = '[object String]',
  symbolTag = '[object Symbol]',
  undefinedTag = '[object Undefined]',
  weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
  dataViewTag = '[object DataView]',
  float32Tag = '[object Float32Array]',
  float64Tag = '[object Float64Array]',
  int8Tag = '[object Int8Array]',
  int16Tag = '[object Int16Array]',
  int32Tag = '[object Int32Array]',
  uint8Tag = '[object Uint8Array]',
  uint8ClampedTag = '[object Uint8ClampedArray]',
  uint16Tag = '[object Uint16Array]',
  uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = (typeof global === "undefined" ? "undefined" : (0, _typeof2.default)(global)) == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = (typeof self === "undefined" ? "undefined" : (0, _typeof2.default)(self)) == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports = (typeof exports === "undefined" ? "undefined" : (0, _typeof2.default)(exports)) == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && (typeof module === "undefined" ? "undefined" : (0, _typeof2.default)(module)) == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = function () {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
    length = array == null ? 0 : array.length,
    resIndex = 0,
    result = [];
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
    length = values.length,
    offset = array.length;
  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
    length = array == null ? 0 : array.length;
  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
    result = Array(n);
  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
    result = Array(map.size);
  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
    result = Array(set.size);
  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
  funcProto = Function.prototype,
  objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect methods masquerading as native. */
var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
  _Symbol = root.Symbol,
  Uint8Array = root.Uint8Array,
  propertyIsEnumerable = objectProto.propertyIsEnumerable,
  splice = arrayProto.splice,
  symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols,
  nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
  nativeKeys = overArg(Object.keys, Object);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
  Map = getNative(root, 'Map'),
  Promise = getNative(root, 'Promise'),
  Set = getNative(root, 'Set'),
  WeakMap = getNative(root, 'WeakMap'),
  nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
  mapCtorString = toSource(Map),
  promiseCtorString = toSource(Promise),
  setCtorString = toSource(Set),
  weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = _Symbol ? _Symbol.prototype : undefined,
  symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
    length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
    length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
    index = assocIndexOf(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
    index = assocIndexOf(data, key);
  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
    index = assocIndexOf(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
    length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map || ListCache)(),
    'string': new Hash()
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
    size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
    length = values == null ? 0 : values.length;
  this.__data__ = new MapCache();
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
    result = data['delete'](key);
  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
    isArg = !isArr && isArguments(value),
    isBuff = !isArr && !isArg && isBuffer(value),
    isType = !isArr && !isArg && !isBuff && isTypedArray(value),
    skipIndexes = isArr || isArg || isBuff || isType,
    result = skipIndexes ? baseTimes(value.length, String) : [],
    length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (
    // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' ||
    // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') ||
    // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||
    // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
    othIsArr = isArray(other),
    objTag = objIsArr ? arrayTag : getTag(object),
    othTag = othIsArr ? arrayTag : getTag(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag,
    othIsObj = othTag == objectTag,
    isSameTag = objTag == othTag;
  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
      othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
        othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
    arrLength = array.length,
    othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
    result = true,
    seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
      othValue = other[index];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function (othValue, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;
    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);
    case errorTag:
      return object.name == other.name && object.message == other.message;
    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == other + '';
    case mapTag:
      var convert = mapToArray;
    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;
    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
    objProps = getAllKeys(object),
    objLength = objProps.length,
    othProps = getAllKeys(other),
    othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
      othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
      othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
    tag = value[symToStringTag];
  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function (symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
  getTag = function getTag(value) {
    var result = baseGetTag(value),
      Ctor = result == objectTag ? value.constructor : undefined,
      ctorString = Ctor ? toSource(Ctor) : '';
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;
        case mapCtorString:
          return mapTag;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag;
        case weakMapCtorString:
          return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = (0, _typeof2.default)(value);
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
    proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
  return value === proto;
}

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return func + '';
    } catch (e) {}
  }
  return '';
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function () {
  return arguments;
}()) ? baseIsArguments : function (value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = (0, _typeof2.default)(value);
  return value != null && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && (0, _typeof2.default)(value) == 'object';
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}
module.exports = isEqual;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array-buffer.constructor.js":566,"core-js/modules/es.array-buffer.slice.js":568,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.map.js":579,"core-js/modules/es.array.splice.js":582,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.keys.js":609,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.constructor.js":617,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.replace.js":629,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.for-each.js":676,"core-js/modules/web.dom-collections.iterator.js":677}],730:[function(require,module,exports){
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

'use strict';

/* eslint-disable no-unused-vars */
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.object.assign.js");
require("core-js/modules/es.object.get-own-property-names.js");
require("core-js/modules/es.array.map.js");
require("core-js/modules/es.array.join.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/web.dom-collections.for-each.js");
require("core-js/modules/es.object.keys.js");
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
  if (val === null || val === undefined) {
    throw new TypeError('Object.assign cannot be called with null or undefined');
  }
  return Object(val);
}
function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    }

    // Detect buggy property enumeration order in older V8 versions.

    // https://bugs.chromium.org/p/v8/issues/detail?id=4118
    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
    test1[5] = 'de';
    if (Object.getOwnPropertyNames(test1)[0] === '5') {
      return false;
    }

    // https://bugs.chromium.org/p/v8/issues/detail?id=3056
    var test2 = {};
    for (var i = 0; i < 10; i++) {
      test2['_' + String.fromCharCode(i)] = i;
    }
    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
      return test2[n];
    });
    if (order2.join('') !== '0123456789') {
      return false;
    }

    // https://bugs.chromium.org/p/v8/issues/detail?id=3056
    var test3 = {};
    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
      return false;
    }
    return true;
  } catch (err) {
    // We don't expect any of the above to throw, but better to be safe.
    return false;
  }
}
module.exports = shouldUseNative() ? Object.assign : function (target, source) {
  var from;
  var to = toObject(target);
  var symbols;
  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);
    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }
    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);
      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }
  return to;
};

},{"core-js/modules/es.array.join.js":578,"core-js/modules/es.array.map.js":579,"core-js/modules/es.object.assign.js":601,"core-js/modules/es.object.get-own-property-names.js":605,"core-js/modules/es.object.keys.js":609,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.for-each.js":676}],731:[function(require,module,exports){
"use strict";

require("core-js/modules/es.number.constructor.js");
exports.endianness = function () {
  return 'LE';
};
exports.hostname = function () {
  if (typeof location !== 'undefined') {
    return location.hostname;
  } else return '';
};
exports.loadavg = function () {
  return [];
};
exports.uptime = function () {
  return 0;
};
exports.freemem = function () {
  return Number.MAX_VALUE;
};
exports.totalmem = function () {
  return Number.MAX_VALUE;
};
exports.cpus = function () {
  return [];
};
exports.type = function () {
  return 'Browser';
};
exports.release = function () {
  if (typeof navigator !== 'undefined') {
    return navigator.appVersion;
  }
  return '';
};
exports.networkInterfaces = exports.getNetworkInterfaces = function () {
  return {};
};
exports.arch = function () {
  return 'javascript';
};
exports.platform = function () {
  return 'browser';
};
exports.tmpdir = exports.tmpDir = function () {
  return '/tmp';
};
exports.EOL = '\n';
exports.homedir = function () {
  return '/';
};

},{"core-js/modules/es.number.constructor.js":593}],732:[function(require,module,exports){
"use strict";

require("core-js/modules/es.array.concat.js");
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}
(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  }
  // if setTimeout wasn't available but was latter defined
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  }
  // if clearTimeout wasn't available but was latter defined
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};

// v8 likes predictible objects
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function (name) {
  return [];
};
process.binding = function (name) {
  throw new Error('process.binding is not supported');
};
process.cwd = function () {
  return '/';
};
process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};
process.umask = function () {
  return 0;
};

},{"core-js/modules/es.array.concat.js":569}],733:[function(require,module,exports){
"use strict";

require("core-js/modules/es.number.parse-int.js");
require("core-js/modules/es.number.constructor.js");
require("core-js/modules/es.number.parse-float.js");
require("core-js/modules/es.object.assign.js");
require("core-js/modules/es.string.trim.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.search.js");
require("core-js/modules/es.string.replace.js");
var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
var numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
// const octRegex = /0x[a-z0-9]+/;
// const binRegex = /0x[a-z0-9]+/;

//polyfill
if (!Number.parseInt && window.parseInt) {
  Number.parseInt = window.parseInt;
}
if (!Number.parseFloat && window.parseFloat) {
  Number.parseFloat = window.parseFloat;
}
var consider = {
  hex: true,
  leadingZeros: true,
  decimalPoint: "\.",
  eNotation: true
  //skipLike: /regex/
};

function toNumber(str) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  // const options = Object.assign({}, consider);
  // if(opt.leadingZeros === false){
  //     options.leadingZeros = false;
  // }else if(opt.hex === false){
  //     options.hex = false;
  // }

  options = Object.assign({}, consider, options);
  if (!str || typeof str !== "string") return str;
  var trimmedStr = str.trim();
  // if(trimmedStr === "0.0") return 0;
  // else if(trimmedStr === "+0.0") return 0;
  // else if(trimmedStr === "-0.0") return -0;

  if (options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;else if (options.hex && hexRegex.test(trimmedStr)) {
    return Number.parseInt(trimmedStr, 16);
    // } else if (options.parseOct && octRegex.test(str)) {
    //     return Number.parseInt(val, 8);
    // }else if (options.parseBin && binRegex.test(str)) {
    //     return Number.parseInt(val, 2);
  } else {
    //separate negative sign, leading zeros, and rest number
    var match = numRegex.exec(trimmedStr);
    if (match) {
      var sign = match[1];
      var leadingZeros = match[2];
      var numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros
      //trim ending zeros for floating number

      var eNotation = match[4] || match[6];
      if (!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".") return str; //-0123
      else if (!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".") return str; //0123
      else {
        //no leading zeros or leading zeros are allowed
        var num = Number(trimmedStr);
        var numStr = "" + num;
        if (numStr.search(/[eE]/) !== -1) {
          //given number is long and parsed to eNotation
          if (options.eNotation) return num;else return str;
        } else if (eNotation) {
          //given number has enotation
          if (options.eNotation) return num;else return str;
        } else if (trimmedStr.indexOf(".") !== -1) {
          //floating number
          // const decimalPart = match[5].substr(1);
          // const intPart = trimmedStr.substr(0,trimmedStr.indexOf("."));

          // const p = numStr.indexOf(".");
          // const givenIntPart = numStr.substr(0,p);
          // const givenDecPart = numStr.substr(p+1);
          if (numStr === "0" && numTrimmedByZeros === "") return num; //0.0
          else if (numStr === numTrimmedByZeros) return num; //0.456. 0.79000
          else if (sign && numStr === "-" + numTrimmedByZeros) return num;else return str;
        }
        if (leadingZeros) {
          // if(numTrimmedByZeros === numStr){
          //     if(options.leadingZeros) return num;
          //     else return str;
          // }else return str;
          if (numTrimmedByZeros === numStr) return num;else if (sign + numTrimmedByZeros === numStr) return num;else return str;
        }
        if (trimmedStr === numStr) return num;else if (trimmedStr === sign + numStr) return num;
        // else{
        //     //number with +/- sign
        //     trimmedStr.test(/[-+][0-9]);

        // }
        return str;
      }
      // else if(!eNotation && trimmedStr && trimmedStr !== Number(trimmedStr) ) return str;
    } else {
      //non-numeric string
      return str;
    }
  }
}

/**
 * 
 * @param {string} numStr without leading zeros
 * @returns 
 */
function trimZeros(numStr) {
  if (numStr && numStr.indexOf(".") !== -1) {
    //float
    numStr = numStr.replace(/0+$/, ""); //remove ending zeros
    if (numStr === ".") numStr = "0";else if (numStr[0] === ".") numStr = "0" + numStr;else if (numStr[numStr.length - 1] === ".") numStr = numStr.substr(0, numStr.length - 1);
    return numStr;
  }
  return numStr;
}
module.exports = toNumber;

},{"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.number.parse-float.js":598,"core-js/modules/es.number.parse-int.js":599,"core-js/modules/es.object.assign.js":601,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.string.replace.js":629,"core-js/modules/es.string.search.js":630,"core-js/modules/es.string.trim.js":634}],734:[function(require,module,exports){
arguments[4][415][0].apply(exports,arguments)
},{"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.fill.js":571,"dup":415}],735:[function(require,module,exports){
// Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9

'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.number.constructor.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.array-buffer.constructor.js");
require("core-js/modules/es.array-buffer.slice.js");
require("core-js/modules/es.array-buffer.is-view.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.map.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.set.js");
require("core-js/modules/es.weak-map.js");
require("core-js/modules/es.weak-set.js");
require("core-js/modules/es.typed-array.uint8-array.js");
require("core-js/modules/es.typed-array.copy-within.js");
require("core-js/modules/es.typed-array.every.js");
require("core-js/modules/es.typed-array.fill.js");
require("core-js/modules/es.typed-array.filter.js");
require("core-js/modules/es.typed-array.find.js");
require("core-js/modules/es.typed-array.find-index.js");
require("core-js/modules/es.typed-array.for-each.js");
require("core-js/modules/es.typed-array.includes.js");
require("core-js/modules/es.typed-array.index-of.js");
require("core-js/modules/es.typed-array.iterator.js");
require("core-js/modules/es.typed-array.join.js");
require("core-js/modules/es.typed-array.last-index-of.js");
require("core-js/modules/es.typed-array.map.js");
require("core-js/modules/es.typed-array.reduce.js");
require("core-js/modules/es.typed-array.reduce-right.js");
require("core-js/modules/es.typed-array.reverse.js");
require("core-js/modules/es.typed-array.set.js");
require("core-js/modules/es.typed-array.slice.js");
require("core-js/modules/es.typed-array.some.js");
require("core-js/modules/es.typed-array.sort.js");
require("core-js/modules/es.typed-array.subarray.js");
require("core-js/modules/es.typed-array.to-locale-string.js");
require("core-js/modules/es.typed-array.to-string.js");
var isArgumentsObject = require('is-arguments');
var isGeneratorFunction = require('is-generator-function');
var whichTypedArray = require('which-typed-array');
var isTypedArray = require('is-typed-array');
function uncurryThis(f) {
  return f.call.bind(f);
}
var BigIntSupported = typeof BigInt !== 'undefined';
var SymbolSupported = typeof Symbol !== 'undefined';
var ObjectToString = uncurryThis(Object.prototype.toString);
var numberValue = uncurryThis(Number.prototype.valueOf);
var stringValue = uncurryThis(String.prototype.valueOf);
var booleanValue = uncurryThis(Boolean.prototype.valueOf);
if (BigIntSupported) {
  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
}
if (SymbolSupported) {
  var symbolValue = uncurryThis(Symbol.prototype.valueOf);
}
function checkBoxedPrimitive(value, prototypeValueOf) {
  if ((0, _typeof2.default)(value) !== 'object') {
    return false;
  }
  try {
    prototypeValueOf(value);
    return true;
  } catch (e) {
    return false;
  }
}
exports.isArgumentsObject = isArgumentsObject;
exports.isGeneratorFunction = isGeneratorFunction;
exports.isTypedArray = isTypedArray;

// Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
function isPromise(input) {
  return typeof Promise !== 'undefined' && input instanceof Promise || input !== null && (0, _typeof2.default)(input) === 'object' && typeof input.then === 'function' && typeof input.catch === 'function';
}
exports.isPromise = isPromise;
function isArrayBufferView(value) {
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    return ArrayBuffer.isView(value);
  }
  return isTypedArray(value) || isDataView(value);
}
exports.isArrayBufferView = isArrayBufferView;
function isUint8Array(value) {
  return whichTypedArray(value) === 'Uint8Array';
}
exports.isUint8Array = isUint8Array;
function isUint8ClampedArray(value) {
  return whichTypedArray(value) === 'Uint8ClampedArray';
}
exports.isUint8ClampedArray = isUint8ClampedArray;
function isUint16Array(value) {
  return whichTypedArray(value) === 'Uint16Array';
}
exports.isUint16Array = isUint16Array;
function isUint32Array(value) {
  return whichTypedArray(value) === 'Uint32Array';
}
exports.isUint32Array = isUint32Array;
function isInt8Array(value) {
  return whichTypedArray(value) === 'Int8Array';
}
exports.isInt8Array = isInt8Array;
function isInt16Array(value) {
  return whichTypedArray(value) === 'Int16Array';
}
exports.isInt16Array = isInt16Array;
function isInt32Array(value) {
  return whichTypedArray(value) === 'Int32Array';
}
exports.isInt32Array = isInt32Array;
function isFloat32Array(value) {
  return whichTypedArray(value) === 'Float32Array';
}
exports.isFloat32Array = isFloat32Array;
function isFloat64Array(value) {
  return whichTypedArray(value) === 'Float64Array';
}
exports.isFloat64Array = isFloat64Array;
function isBigInt64Array(value) {
  return whichTypedArray(value) === 'BigInt64Array';
}
exports.isBigInt64Array = isBigInt64Array;
function isBigUint64Array(value) {
  return whichTypedArray(value) === 'BigUint64Array';
}
exports.isBigUint64Array = isBigUint64Array;
function isMapToString(value) {
  return ObjectToString(value) === '[object Map]';
}
isMapToString.working = typeof Map !== 'undefined' && isMapToString(new Map());
function isMap(value) {
  if (typeof Map === 'undefined') {
    return false;
  }
  return isMapToString.working ? isMapToString(value) : value instanceof Map;
}
exports.isMap = isMap;
function isSetToString(value) {
  return ObjectToString(value) === '[object Set]';
}
isSetToString.working = typeof Set !== 'undefined' && isSetToString(new Set());
function isSet(value) {
  if (typeof Set === 'undefined') {
    return false;
  }
  return isSetToString.working ? isSetToString(value) : value instanceof Set;
}
exports.isSet = isSet;
function isWeakMapToString(value) {
  return ObjectToString(value) === '[object WeakMap]';
}
isWeakMapToString.working = typeof WeakMap !== 'undefined' && isWeakMapToString(new WeakMap());
function isWeakMap(value) {
  if (typeof WeakMap === 'undefined') {
    return false;
  }
  return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
}
exports.isWeakMap = isWeakMap;
function isWeakSetToString(value) {
  return ObjectToString(value) === '[object WeakSet]';
}
isWeakSetToString.working = typeof WeakSet !== 'undefined' && isWeakSetToString(new WeakSet());
function isWeakSet(value) {
  return isWeakSetToString(value);
}
exports.isWeakSet = isWeakSet;
function isArrayBufferToString(value) {
  return ObjectToString(value) === '[object ArrayBuffer]';
}
isArrayBufferToString.working = typeof ArrayBuffer !== 'undefined' && isArrayBufferToString(new ArrayBuffer());
function isArrayBuffer(value) {
  if (typeof ArrayBuffer === 'undefined') {
    return false;
  }
  return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
}
exports.isArrayBuffer = isArrayBuffer;
function isDataViewToString(value) {
  return ObjectToString(value) === '[object DataView]';
}
isDataViewToString.working = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined' && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
function isDataView(value) {
  if (typeof DataView === 'undefined') {
    return false;
  }
  return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
}
exports.isDataView = isDataView;

// Store a copy of SharedArrayBuffer in case it's deleted elsewhere
var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
function isSharedArrayBufferToString(value) {
  return ObjectToString(value) === '[object SharedArrayBuffer]';
}
function isSharedArrayBuffer(value) {
  if (typeof SharedArrayBufferCopy === 'undefined') {
    return false;
  }
  if (typeof isSharedArrayBufferToString.working === 'undefined') {
    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
  }
  return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
}
exports.isSharedArrayBuffer = isSharedArrayBuffer;
function isAsyncFunction(value) {
  return ObjectToString(value) === '[object AsyncFunction]';
}
exports.isAsyncFunction = isAsyncFunction;
function isMapIterator(value) {
  return ObjectToString(value) === '[object Map Iterator]';
}
exports.isMapIterator = isMapIterator;
function isSetIterator(value) {
  return ObjectToString(value) === '[object Set Iterator]';
}
exports.isSetIterator = isSetIterator;
function isGeneratorObject(value) {
  return ObjectToString(value) === '[object Generator]';
}
exports.isGeneratorObject = isGeneratorObject;
function isWebAssemblyCompiledModule(value) {
  return ObjectToString(value) === '[object WebAssembly.Module]';
}
exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
function isNumberObject(value) {
  return checkBoxedPrimitive(value, numberValue);
}
exports.isNumberObject = isNumberObject;
function isStringObject(value) {
  return checkBoxedPrimitive(value, stringValue);
}
exports.isStringObject = isStringObject;
function isBooleanObject(value) {
  return checkBoxedPrimitive(value, booleanValue);
}
exports.isBooleanObject = isBooleanObject;
function isBigIntObject(value) {
  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
}
exports.isBigIntObject = isBigIntObject;
function isSymbolObject(value) {
  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
}
exports.isSymbolObject = isSymbolObject;
function isBoxedPrimitive(value) {
  return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
}
exports.isBoxedPrimitive = isBoxedPrimitive;
function isAnyArrayBuffer(value) {
  return typeof Uint8Array !== 'undefined' && (isArrayBuffer(value) || isSharedArrayBuffer(value));
}
exports.isAnyArrayBuffer = isAnyArrayBuffer;
['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function (method) {
  Object.defineProperty(exports, method, {
    enumerable: false,
    value: function value() {
      throw new Error(method + ' is not supported in userland');
    }
  });
});

},{"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array-buffer.constructor.js":566,"core-js/modules/es.array-buffer.is-view.js":567,"core-js/modules/es.array-buffer.slice.js":568,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.map.js":587,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.promise.js":614,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.set.js":621,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.js":638,"core-js/modules/es.typed-array.copy-within.js":641,"core-js/modules/es.typed-array.every.js":642,"core-js/modules/es.typed-array.fill.js":643,"core-js/modules/es.typed-array.filter.js":644,"core-js/modules/es.typed-array.find-index.js":645,"core-js/modules/es.typed-array.find.js":646,"core-js/modules/es.typed-array.for-each.js":649,"core-js/modules/es.typed-array.includes.js":650,"core-js/modules/es.typed-array.index-of.js":651,"core-js/modules/es.typed-array.iterator.js":655,"core-js/modules/es.typed-array.join.js":656,"core-js/modules/es.typed-array.last-index-of.js":657,"core-js/modules/es.typed-array.map.js":658,"core-js/modules/es.typed-array.reduce-right.js":659,"core-js/modules/es.typed-array.reduce.js":660,"core-js/modules/es.typed-array.reverse.js":661,"core-js/modules/es.typed-array.set.js":662,"core-js/modules/es.typed-array.slice.js":663,"core-js/modules/es.typed-array.some.js":664,"core-js/modules/es.typed-array.sort.js":665,"core-js/modules/es.typed-array.subarray.js":666,"core-js/modules/es.typed-array.to-locale-string.js":667,"core-js/modules/es.typed-array.to-string.js":668,"core-js/modules/es.typed-array.uint8-array.js":671,"core-js/modules/es.weak-map.js":673,"core-js/modules/es.weak-set.js":674,"core-js/modules/web.dom-collections.iterator.js":677,"is-arguments":720,"is-generator-function":721,"is-typed-array":722,"which-typed-array":752}],736:[function(require,module,exports){
(function (process){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.object.get-own-property-descriptors.js");
require("core-js/modules/es.object.keys.js");
require("core-js/modules/es.object.get-own-property-descriptor.js");
require("core-js/modules/es.array.join.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.number.constructor.js");
require("core-js/modules/es.regexp.constructor.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/web.dom-collections.for-each.js");
require("core-js/modules/es.object.get-own-property-names.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.map.js");
require("core-js/modules/es.string.match.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.object.set-prototype-of.js");
require("core-js/modules/es.object.get-prototype-of.js");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
  var keys = Object.keys(obj);
  var descriptors = {};
  for (var i = 0; i < keys.length; i++) {
    descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
  }
  return descriptors;
};
var formatRegExp = /%[sdj%]/g;
exports.format = function (f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }
  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function (x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s':
        return String(args[i++]);
      case '%d':
        return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};

// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function (fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function () {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
};
var debugs = {};
var debugEnvRegex = /^$/;
if (process.env.NODE_DEBUG) {
  var debugEnv = process.env.NODE_DEBUG;
  debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&').replace(/\*/g, '.*').replace(/,/g, '$|^').toUpperCase();
  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
}
exports.debuglog = function (set) {
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (debugEnvRegex.test(set)) {
      var pid = process.pid;
      debugs[set] = function () {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function () {};
    }
  }
  return debugs[set];
};

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;

// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold': [1, 22],
  'italic': [3, 23],
  'underline': [4, 24],
  'inverse': [7, 27],
  'white': [37, 39],
  'grey': [90, 39],
  'black': [30, 39],
  'blue': [34, 39],
  'cyan': [36, 39],
  'green': [32, 39],
  'magenta': [35, 39],
  'red': [31, 39],
  'yellow': [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};
function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];
  if (style) {
    return "\x1B[" + inspect.colors[style][0] + 'm' + str + "\x1B[" + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}
function stylizeNoColor(str, styleType) {
  return str;
}
function arrayToHash(array) {
  var hash = {};
  array.forEach(function (val, idx) {
    hash[val] = true;
  });
  return hash;
}
function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect && value && isFunction(value.inspect) &&
  // Filter out the util module, it's inspect function is special
  value.inspect !== exports.inspect &&
  // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);
  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }
  var base = '',
    array = false,
    braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }
  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }
  ctx.seen.push(value);
  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function (key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value) {
  if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value)) return ctx.stylize('' + value, 'number');
  if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value)) return ctx.stylize('null', 'null');
}
function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function (key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || {
    value: value[key]
  };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function (line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function (line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }
  return name + ': ' + str;
}
function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function (prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);
  if (length > 60) {
    return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
  }
  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
exports.types = require('./support/types');
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;
function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;
function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;
function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;
function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;
function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;
function isSymbol(arg) {
  return (0, _typeof2.default)(arg) === 'symbol';
}
exports.isSymbol = isSymbol;
function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;
function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
exports.types.isRegExp = isRegExp;
function isObject(arg) {
  return (0, _typeof2.default)(arg) === 'object' && arg !== null;
}
exports.isObject = isObject;
function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
exports.types.isDate = isDate;
function isError(e) {
  return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;
exports.types.isNativeError = isError;
function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;
function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || (0, _typeof2.default)(arg) === 'symbol' ||
  // ES6 symbol
  typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;
exports.isBuffer = require('./support/isBuffer');
function objectToString(o) {
  return Object.prototype.toString.call(o);
}
function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}
var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}

// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function () {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};

/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');
exports._extend = function (origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;
  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;
exports.promisify = function promisify(original) {
  if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');
  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn,
      enumerable: false,
      writable: false,
      configurable: true
    });
    return fn;
  }
  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });
    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }
    return promise;
  }
  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn,
    enumerable: false,
    writable: false,
    configurable: true
  });
  return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
};
exports.promisify.custom = kCustomPromisifiedSymbol;
function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}
function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function cb() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args).then(function (ret) {
      process.nextTick(cb.bind(null, null, ret));
    }, function (rej) {
      process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
    });
  }
  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;

}).call(this)}).call(this,require('_process'))

},{"./support/isBuffer":734,"./support/types":735,"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"_process":732,"core-js/modules/es.array.join.js":578,"core-js/modules/es.array.map.js":579,"core-js/modules/es.function.name.js":584,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.get-own-property-descriptors.js":604,"core-js/modules/es.object.get-own-property-names.js":605,"core-js/modules/es.object.get-prototype-of.js":606,"core-js/modules/es.object.keys.js":609,"core-js/modules/es.object.set-prototype-of.js":611,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.promise.js":614,"core-js/modules/es.regexp.constructor.js":617,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.match.js":627,"core-js/modules/es.string.replace.js":629,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.js":638,"core-js/modules/web.dom-collections.for-each.js":676,"inherits":719}],737:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "v1", {
  enumerable: true,
  get: function get() {
    return _v.default;
  }
});
Object.defineProperty(exports, "v3", {
  enumerable: true,
  get: function get() {
    return _v2.default;
  }
});
Object.defineProperty(exports, "v4", {
  enumerable: true,
  get: function get() {
    return _v3.default;
  }
});
Object.defineProperty(exports, "v5", {
  enumerable: true,
  get: function get() {
    return _v4.default;
  }
});
Object.defineProperty(exports, "NIL", {
  enumerable: true,
  get: function get() {
    return _nil.default;
  }
});
Object.defineProperty(exports, "version", {
  enumerable: true,
  get: function get() {
    return _version.default;
  }
});
Object.defineProperty(exports, "validate", {
  enumerable: true,
  get: function get() {
    return _validate.default;
  }
});
Object.defineProperty(exports, "stringify", {
  enumerable: true,
  get: function get() {
    return _stringify.default;
  }
});
Object.defineProperty(exports, "parse", {
  enumerable: true,
  get: function get() {
    return _parse.default;
  }
});
var _v = _interopRequireDefault(require("./v1.js"));
var _v2 = _interopRequireDefault(require("./v3.js"));
var _v3 = _interopRequireDefault(require("./v4.js"));
var _v4 = _interopRequireDefault(require("./v5.js"));
var _nil = _interopRequireDefault(require("./nil.js"));
var _version = _interopRequireDefault(require("./version.js"));
var _validate = _interopRequireDefault(require("./validate.js"));
var _stringify = _interopRequireDefault(require("./stringify.js"));
var _parse = _interopRequireDefault(require("./parse.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

},{"./nil.js":739,"./parse.js":740,"./stringify.js":744,"./v1.js":745,"./v3.js":746,"./v4.js":748,"./v5.js":749,"./validate.js":750,"./version.js":751}],738:[function(require,module,exports){
"use strict";

require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array-buffer.slice.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.typed-array.uint8-array.js");
require("core-js/modules/es.typed-array.copy-within.js");
require("core-js/modules/es.typed-array.every.js");
require("core-js/modules/es.typed-array.fill.js");
require("core-js/modules/es.typed-array.filter.js");
require("core-js/modules/es.typed-array.find.js");
require("core-js/modules/es.typed-array.find-index.js");
require("core-js/modules/es.typed-array.for-each.js");
require("core-js/modules/es.typed-array.includes.js");
require("core-js/modules/es.typed-array.index-of.js");
require("core-js/modules/es.typed-array.iterator.js");
require("core-js/modules/es.typed-array.join.js");
require("core-js/modules/es.typed-array.last-index-of.js");
require("core-js/modules/es.typed-array.map.js");
require("core-js/modules/es.typed-array.reduce.js");
require("core-js/modules/es.typed-array.reduce-right.js");
require("core-js/modules/es.typed-array.reverse.js");
require("core-js/modules/es.typed-array.set.js");
require("core-js/modules/es.typed-array.slice.js");
require("core-js/modules/es.typed-array.some.js");
require("core-js/modules/es.typed-array.sort.js");
require("core-js/modules/es.typed-array.subarray.js");
require("core-js/modules/es.typed-array.to-locale-string.js");
require("core-js/modules/es.typed-array.to-string.js");
require("core-js/modules/es.typed-array.uint32-array.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
function md5(bytes) {
  if (typeof bytes === 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Uint8Array(msg.length);
    for (var i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */

function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = '0123456789abcdef';
  for (var i = 0; i < length32; i += 8) {
    var x = input[i >> 5] >>> i % 32 & 0xff;
    var hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
    output.push(hex);
  }
  return output;
}
/**
 * Calculate output length with padding and bit length
 */

function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */

function wordsToMd5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[getOutputLength(len) - 1] = len;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;
  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b, c, d];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */

function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));
  for (var i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
  }
  return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */

function safeAdd(x, y) {
  var lsw = (x & 0xffff) + (y & 0xffff);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */

function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */

function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var _default = md5;
exports.default = _default;

},{"core-js/modules/es.array-buffer.slice.js":568,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.typed-array.copy-within.js":641,"core-js/modules/es.typed-array.every.js":642,"core-js/modules/es.typed-array.fill.js":643,"core-js/modules/es.typed-array.filter.js":644,"core-js/modules/es.typed-array.find-index.js":645,"core-js/modules/es.typed-array.find.js":646,"core-js/modules/es.typed-array.for-each.js":649,"core-js/modules/es.typed-array.includes.js":650,"core-js/modules/es.typed-array.index-of.js":651,"core-js/modules/es.typed-array.iterator.js":655,"core-js/modules/es.typed-array.join.js":656,"core-js/modules/es.typed-array.last-index-of.js":657,"core-js/modules/es.typed-array.map.js":658,"core-js/modules/es.typed-array.reduce-right.js":659,"core-js/modules/es.typed-array.reduce.js":660,"core-js/modules/es.typed-array.reverse.js":661,"core-js/modules/es.typed-array.set.js":662,"core-js/modules/es.typed-array.slice.js":663,"core-js/modules/es.typed-array.some.js":664,"core-js/modules/es.typed-array.sort.js":665,"core-js/modules/es.typed-array.subarray.js":666,"core-js/modules/es.typed-array.to-locale-string.js":667,"core-js/modules/es.typed-array.to-string.js":668,"core-js/modules/es.typed-array.uint32-array.js":670,"core-js/modules/es.typed-array.uint8-array.js":671}],739:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = '00000000-0000-0000-0000-000000000000';
exports.default = _default;

},{}],740:[function(require,module,exports){
"use strict";

require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array-buffer.slice.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.typed-array.uint8-array.js");
require("core-js/modules/es.typed-array.copy-within.js");
require("core-js/modules/es.typed-array.every.js");
require("core-js/modules/es.typed-array.fill.js");
require("core-js/modules/es.typed-array.filter.js");
require("core-js/modules/es.typed-array.find.js");
require("core-js/modules/es.typed-array.find-index.js");
require("core-js/modules/es.typed-array.for-each.js");
require("core-js/modules/es.typed-array.includes.js");
require("core-js/modules/es.typed-array.index-of.js");
require("core-js/modules/es.typed-array.iterator.js");
require("core-js/modules/es.typed-array.join.js");
require("core-js/modules/es.typed-array.last-index-of.js");
require("core-js/modules/es.typed-array.map.js");
require("core-js/modules/es.typed-array.reduce.js");
require("core-js/modules/es.typed-array.reduce-right.js");
require("core-js/modules/es.typed-array.reverse.js");
require("core-js/modules/es.typed-array.set.js");
require("core-js/modules/es.typed-array.slice.js");
require("core-js/modules/es.typed-array.some.js");
require("core-js/modules/es.typed-array.sort.js");
require("core-js/modules/es.typed-array.subarray.js");
require("core-js/modules/es.typed-array.to-locale-string.js");
require("core-js/modules/es.typed-array.to-string.js");
require("core-js/modules/es.array.slice.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _validate = _interopRequireDefault(require("./validate.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
function parse(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }
  var v;
  var arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}
var _default = parse;
exports.default = _default;

},{"./validate.js":750,"core-js/modules/es.array-buffer.slice.js":568,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.typed-array.copy-within.js":641,"core-js/modules/es.typed-array.every.js":642,"core-js/modules/es.typed-array.fill.js":643,"core-js/modules/es.typed-array.filter.js":644,"core-js/modules/es.typed-array.find-index.js":645,"core-js/modules/es.typed-array.find.js":646,"core-js/modules/es.typed-array.for-each.js":649,"core-js/modules/es.typed-array.includes.js":650,"core-js/modules/es.typed-array.index-of.js":651,"core-js/modules/es.typed-array.iterator.js":655,"core-js/modules/es.typed-array.join.js":656,"core-js/modules/es.typed-array.last-index-of.js":657,"core-js/modules/es.typed-array.map.js":658,"core-js/modules/es.typed-array.reduce-right.js":659,"core-js/modules/es.typed-array.reduce.js":660,"core-js/modules/es.typed-array.reverse.js":661,"core-js/modules/es.typed-array.set.js":662,"core-js/modules/es.typed-array.slice.js":663,"core-js/modules/es.typed-array.some.js":664,"core-js/modules/es.typed-array.sort.js":665,"core-js/modules/es.typed-array.subarray.js":666,"core-js/modules/es.typed-array.to-locale-string.js":667,"core-js/modules/es.typed-array.to-string.js":668,"core-js/modules/es.typed-array.uint8-array.js":671}],741:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
exports.default = _default;

},{}],742:[function(require,module,exports){
"use strict";

require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array-buffer.slice.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.typed-array.uint8-array.js");
require("core-js/modules/es.typed-array.copy-within.js");
require("core-js/modules/es.typed-array.every.js");
require("core-js/modules/es.typed-array.fill.js");
require("core-js/modules/es.typed-array.filter.js");
require("core-js/modules/es.typed-array.find.js");
require("core-js/modules/es.typed-array.find-index.js");
require("core-js/modules/es.typed-array.for-each.js");
require("core-js/modules/es.typed-array.includes.js");
require("core-js/modules/es.typed-array.index-of.js");
require("core-js/modules/es.typed-array.iterator.js");
require("core-js/modules/es.typed-array.join.js");
require("core-js/modules/es.typed-array.last-index-of.js");
require("core-js/modules/es.typed-array.map.js");
require("core-js/modules/es.typed-array.reduce.js");
require("core-js/modules/es.typed-array.reduce-right.js");
require("core-js/modules/es.typed-array.reverse.js");
require("core-js/modules/es.typed-array.set.js");
require("core-js/modules/es.typed-array.slice.js");
require("core-js/modules/es.typed-array.some.js");
require("core-js/modules/es.typed-array.sort.js");
require("core-js/modules/es.typed-array.subarray.js");
require("core-js/modules/es.typed-array.to-locale-string.js");
require("core-js/modules/es.typed-array.to-string.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rng;
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }
  return getRandomValues(rnds8);
}

},{"core-js/modules/es.array-buffer.slice.js":568,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.typed-array.copy-within.js":641,"core-js/modules/es.typed-array.every.js":642,"core-js/modules/es.typed-array.fill.js":643,"core-js/modules/es.typed-array.filter.js":644,"core-js/modules/es.typed-array.find-index.js":645,"core-js/modules/es.typed-array.find.js":646,"core-js/modules/es.typed-array.for-each.js":649,"core-js/modules/es.typed-array.includes.js":650,"core-js/modules/es.typed-array.index-of.js":651,"core-js/modules/es.typed-array.iterator.js":655,"core-js/modules/es.typed-array.join.js":656,"core-js/modules/es.typed-array.last-index-of.js":657,"core-js/modules/es.typed-array.map.js":658,"core-js/modules/es.typed-array.reduce-right.js":659,"core-js/modules/es.typed-array.reduce.js":660,"core-js/modules/es.typed-array.reverse.js":661,"core-js/modules/es.typed-array.set.js":662,"core-js/modules/es.typed-array.slice.js":663,"core-js/modules/es.typed-array.some.js":664,"core-js/modules/es.typed-array.sort.js":665,"core-js/modules/es.typed-array.subarray.js":666,"core-js/modules/es.typed-array.to-locale-string.js":667,"core-js/modules/es.typed-array.to-string.js":668,"core-js/modules/es.typed-array.uint8-array.js":671}],743:[function(require,module,exports){
"use strict";

require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array-buffer.slice.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.typed-array.uint32-array.js");
require("core-js/modules/es.typed-array.copy-within.js");
require("core-js/modules/es.typed-array.every.js");
require("core-js/modules/es.typed-array.fill.js");
require("core-js/modules/es.typed-array.filter.js");
require("core-js/modules/es.typed-array.find.js");
require("core-js/modules/es.typed-array.find-index.js");
require("core-js/modules/es.typed-array.for-each.js");
require("core-js/modules/es.typed-array.includes.js");
require("core-js/modules/es.typed-array.index-of.js");
require("core-js/modules/es.typed-array.iterator.js");
require("core-js/modules/es.typed-array.join.js");
require("core-js/modules/es.typed-array.last-index-of.js");
require("core-js/modules/es.typed-array.map.js");
require("core-js/modules/es.typed-array.reduce.js");
require("core-js/modules/es.typed-array.reduce-right.js");
require("core-js/modules/es.typed-array.reverse.js");
require("core-js/modules/es.typed-array.set.js");
require("core-js/modules/es.typed-array.slice.js");
require("core-js/modules/es.typed-array.some.js");
require("core-js/modules/es.typed-array.sort.js");
require("core-js/modules/es.typed-array.subarray.js");
require("core-js/modules/es.typed-array.to-locale-string.js");
require("core-js/modules/es.typed-array.to-string.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
  if (typeof bytes === 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = [];
    for (var i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(0x80);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);
  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);
    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
    }
    M[_i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;
  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);
    for (var t = 0; t < 16; ++t) {
      W[t] = M[_i2][t];
    }
    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }
    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];
    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}
var _default = sha1;
exports.default = _default;

},{"core-js/modules/es.array-buffer.slice.js":568,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.typed-array.copy-within.js":641,"core-js/modules/es.typed-array.every.js":642,"core-js/modules/es.typed-array.fill.js":643,"core-js/modules/es.typed-array.filter.js":644,"core-js/modules/es.typed-array.find-index.js":645,"core-js/modules/es.typed-array.find.js":646,"core-js/modules/es.typed-array.for-each.js":649,"core-js/modules/es.typed-array.includes.js":650,"core-js/modules/es.typed-array.index-of.js":651,"core-js/modules/es.typed-array.iterator.js":655,"core-js/modules/es.typed-array.join.js":656,"core-js/modules/es.typed-array.last-index-of.js":657,"core-js/modules/es.typed-array.map.js":658,"core-js/modules/es.typed-array.reduce-right.js":659,"core-js/modules/es.typed-array.reduce.js":660,"core-js/modules/es.typed-array.reverse.js":661,"core-js/modules/es.typed-array.set.js":662,"core-js/modules/es.typed-array.slice.js":663,"core-js/modules/es.typed-array.some.js":664,"core-js/modules/es.typed-array.sort.js":665,"core-js/modules/es.typed-array.subarray.js":666,"core-js/modules/es.typed-array.to-locale-string.js":667,"core-js/modules/es.typed-array.to-string.js":668,"core-js/modules/es.typed-array.uint32-array.js":670}],744:[function(require,module,exports){
"use strict";

require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _validate = _interopRequireDefault(require("./validate.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}
function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }
  return uuid;
}
var _default = stringify;
exports.default = _default;

},{"./validate.js":750,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.regexp.to-string.js":620}],745:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _rng = _interopRequireDefault(require("./rng.js"));
var _stringify = _interopRequireDefault(require("./stringify.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
var _nodeId;
var _clockseq; // Previous uuid creation time

var _lastMSecs = 0;
var _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || new Array(16);
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || _rng.default)();
    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.

  var msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval

  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested

  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf || (0, _stringify.default)(b);
}
var _default = v1;
exports.default = _default;

},{"./rng.js":742,"./stringify.js":744}],746:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _v = _interopRequireDefault(require("./v35.js"));
var _md = _interopRequireDefault(require("./md5.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var v3 = (0, _v.default)('v3', 0x30, _md.default);
var _default = v3;
exports.default = _default;

},{"./md5.js":738,"./v35.js":747}],747:[function(require,module,exports){
"use strict";

require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array-buffer.slice.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.typed-array.uint8-array.js");
require("core-js/modules/es.typed-array.copy-within.js");
require("core-js/modules/es.typed-array.every.js");
require("core-js/modules/es.typed-array.fill.js");
require("core-js/modules/es.typed-array.filter.js");
require("core-js/modules/es.typed-array.find.js");
require("core-js/modules/es.typed-array.find-index.js");
require("core-js/modules/es.typed-array.for-each.js");
require("core-js/modules/es.typed-array.includes.js");
require("core-js/modules/es.typed-array.index-of.js");
require("core-js/modules/es.typed-array.iterator.js");
require("core-js/modules/es.typed-array.join.js");
require("core-js/modules/es.typed-array.last-index-of.js");
require("core-js/modules/es.typed-array.map.js");
require("core-js/modules/es.typed-array.reduce.js");
require("core-js/modules/es.typed-array.reduce-right.js");
require("core-js/modules/es.typed-array.reverse.js");
require("core-js/modules/es.typed-array.set.js");
require("core-js/modules/es.typed-array.slice.js");
require("core-js/modules/es.typed-array.some.js");
require("core-js/modules/es.typed-array.sort.js");
require("core-js/modules/es.typed-array.subarray.js");
require("core-js/modules/es.typed-array.to-locale-string.js");
require("core-js/modules/es.typed-array.to-string.js");
require("core-js/modules/es.function.name.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.URL = exports.DNS = void 0;
var _stringify = _interopRequireDefault(require("./stringify.js"));
var _parse = _interopRequireDefault(require("./parse.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  var bytes = [];
  for (var i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.DNS = DNS;
var URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
exports.URL = URL;
function _default(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }
    if (typeof namespace === 'string') {
      namespace = (0, _parse.default)(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`

    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;
    if (buf) {
      offset = offset || 0;
      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return (0, _stringify.default)(bytes);
  } // Function#name is not settable on some platforms (#270)

  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support

  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

},{"./parse.js":740,"./stringify.js":744,"core-js/modules/es.array-buffer.slice.js":568,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.function.name.js":584,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.typed-array.copy-within.js":641,"core-js/modules/es.typed-array.every.js":642,"core-js/modules/es.typed-array.fill.js":643,"core-js/modules/es.typed-array.filter.js":644,"core-js/modules/es.typed-array.find-index.js":645,"core-js/modules/es.typed-array.find.js":646,"core-js/modules/es.typed-array.for-each.js":649,"core-js/modules/es.typed-array.includes.js":650,"core-js/modules/es.typed-array.index-of.js":651,"core-js/modules/es.typed-array.iterator.js":655,"core-js/modules/es.typed-array.join.js":656,"core-js/modules/es.typed-array.last-index-of.js":657,"core-js/modules/es.typed-array.map.js":658,"core-js/modules/es.typed-array.reduce-right.js":659,"core-js/modules/es.typed-array.reduce.js":660,"core-js/modules/es.typed-array.reverse.js":661,"core-js/modules/es.typed-array.set.js":662,"core-js/modules/es.typed-array.slice.js":663,"core-js/modules/es.typed-array.some.js":664,"core-js/modules/es.typed-array.sort.js":665,"core-js/modules/es.typed-array.subarray.js":666,"core-js/modules/es.typed-array.to-locale-string.js":667,"core-js/modules/es.typed-array.to-string.js":668,"core-js/modules/es.typed-array.uint8-array.js":671}],748:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _rng = _interopRequireDefault(require("./rng.js"));
var _stringify = _interopRequireDefault(require("./stringify.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return (0, _stringify.default)(rnds);
}
var _default = v4;
exports.default = _default;

},{"./rng.js":742,"./stringify.js":744}],749:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _v = _interopRequireDefault(require("./v35.js"));
var _sha = _interopRequireDefault(require("./sha1.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var v5 = (0, _v.default)('v5', 0x50, _sha.default);
var _default = v5;
exports.default = _default;

},{"./sha1.js":743,"./v35.js":747}],750:[function(require,module,exports){
"use strict";

require("core-js/modules/es.regexp.exec.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _regex = _interopRequireDefault(require("./regex.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
function validate(uuid) {
  return typeof uuid === 'string' && _regex.default.test(uuid);
}
var _default = validate;
exports.default = _default;

},{"./regex.js":741,"core-js/modules/es.regexp.exec.js":618}],751:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _validate = _interopRequireDefault(require("./validate.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
function version(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }
  return parseInt(uuid.substr(14, 1), 16);
}
var _default = version;
exports.default = _default;

},{"./validate.js":750}],752:[function(require,module,exports){
(function (global){(function (){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.symbol.to-string-tag.js");
require("core-js/modules/es.json.to-string-tag.js");
require("core-js/modules/es.math.to-string-tag.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.object.get-prototype-of.js");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var forEach = require('foreach');
var availableTypedArrays = require('available-typed-arrays');
var callBound = require('es-abstract/helpers/callBound');
var $toString = callBound('Object.prototype.toString');
var hasSymbols = require('has-symbols')();
var hasToStringTag = hasSymbols && (0, _typeof2.default)(Symbol.toStringTag) === 'symbol';
var typedArrays = availableTypedArrays();
var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) {
  forEach(typedArrays, function (typedArray) {
    if (typeof global[typedArray] === 'function') {
      var arr = new global[typedArray]();
      if (!(Symbol.toStringTag in arr)) {
        throw new EvalError('this engine has support for Symbol.toStringTag, but ' + typedArray + ' does not have the property! Please report this.');
      }
      var proto = getPrototypeOf(arr);
      var descriptor = gOPD(proto, Symbol.toStringTag);
      if (!descriptor) {
        var superProto = getPrototypeOf(proto);
        descriptor = gOPD(superProto, Symbol.toStringTag);
      }
      toStrTags[typedArray] = descriptor.get;
    }
  });
}
var tryTypedArrays = function tryAllTypedArrays(value) {
  var foundName = false;
  forEach(toStrTags, function (getter, typedArray) {
    if (!foundName) {
      try {
        var name = getter.call(value);
        if (name === typedArray) {
          foundName = name;
        }
      } catch (e) {}
    }
  });
  return foundName;
};
var isTypedArray = require('is-typed-array');
module.exports = function whichTypedArray(value) {
  if (!isTypedArray(value)) {
    return false;
  }
  if (!hasToStringTag) {
    return $slice($toString(value), 8, -1);
  }
  return tryTypedArrays(value);
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"available-typed-arrays":418,"core-js/modules/es.json.to-string-tag.js":586,"core-js/modules/es.math.to-string-tag.js":591,"core-js/modules/es.object.get-prototype-of.js":606,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.js":638,"core-js/modules/es.symbol.to-string-tag.js":640,"es-abstract/helpers/callBound":755,"es-abstract/helpers/getOwnPropertyDescriptor":756,"foreach":712,"has-symbols":715,"is-typed-array":722}],753:[function(require,module,exports){
arguments[4][723][0].apply(exports,arguments)
},{"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array-buffer.constructor.js":566,"core-js/modules/es.array-buffer.slice.js":568,"core-js/modules/es.array.iterator.js":577,"core-js/modules/es.map.js":587,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.object.get-own-property-descriptor.js":603,"core-js/modules/es.object.get-prototype-of.js":606,"core-js/modules/es.object.keys.js":609,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.promise.js":614,"core-js/modules/es.regexp.constructor.js":617,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.set.js":621,"core-js/modules/es.string.iterator.js":626,"core-js/modules/es.string.replace.js":629,"core-js/modules/es.symbol.async-iterator.js":635,"core-js/modules/es.symbol.description.js":636,"core-js/modules/es.symbol.iterator.js":637,"core-js/modules/es.symbol.js":638,"core-js/modules/es.typed-array.copy-within.js":641,"core-js/modules/es.typed-array.every.js":642,"core-js/modules/es.typed-array.fill.js":643,"core-js/modules/es.typed-array.filter.js":644,"core-js/modules/es.typed-array.find-index.js":645,"core-js/modules/es.typed-array.find.js":646,"core-js/modules/es.typed-array.float32-array.js":647,"core-js/modules/es.typed-array.float64-array.js":648,"core-js/modules/es.typed-array.for-each.js":649,"core-js/modules/es.typed-array.includes.js":650,"core-js/modules/es.typed-array.index-of.js":651,"core-js/modules/es.typed-array.int16-array.js":652,"core-js/modules/es.typed-array.int32-array.js":653,"core-js/modules/es.typed-array.int8-array.js":654,"core-js/modules/es.typed-array.iterator.js":655,"core-js/modules/es.typed-array.join.js":656,"core-js/modules/es.typed-array.last-index-of.js":657,"core-js/modules/es.typed-array.map.js":658,"core-js/modules/es.typed-array.reduce-right.js":659,"core-js/modules/es.typed-array.reduce.js":660,"core-js/modules/es.typed-array.reverse.js":661,"core-js/modules/es.typed-array.set.js":662,"core-js/modules/es.typed-array.slice.js":663,"core-js/modules/es.typed-array.some.js":664,"core-js/modules/es.typed-array.sort.js":665,"core-js/modules/es.typed-array.subarray.js":666,"core-js/modules/es.typed-array.to-locale-string.js":667,"core-js/modules/es.typed-array.to-string.js":668,"core-js/modules/es.typed-array.uint16-array.js":669,"core-js/modules/es.typed-array.uint32-array.js":670,"core-js/modules/es.typed-array.uint8-array.js":671,"core-js/modules/es.typed-array.uint8-clamped-array.js":672,"core-js/modules/es.weak-map.js":673,"core-js/modules/es.weak-set.js":674,"core-js/modules/web.dom-collections.iterator.js":677,"dup":723,"function-bind":714,"has-symbols":715}],754:[function(require,module,exports){
arguments[4][724][0].apply(exports,arguments)
},{"../GetIntrinsic":753,"dup":724,"function-bind":714}],755:[function(require,module,exports){
arguments[4][725][0].apply(exports,arguments)
},{"../GetIntrinsic":753,"./callBind":754,"dup":725}],756:[function(require,module,exports){
arguments[4][726][0].apply(exports,arguments)
},{"../GetIntrinsic":753,"dup":726}],757:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.array.concat.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.array.join.js");
require("core-js/modules/es.array.filter.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.number.constructor.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.string.starts-with.js");
require("core-js/modules/es.string.split.js");
require("core-js/modules/es.array.map.js");
/*
 * xpath.js
 *
 * An XPath 1.0 library for JavaScript.
 *
 * Cameron McCormack <cam (at) mcc.id.au>
 *
 * This work is licensed under the MIT License.
 *
 * Revision 20: April 26, 2011
 *   Fixed a typo resulting in FIRST_ORDERED_NODE_TYPE results being wrong,
 *   thanks to <shi_a009 (at) hotmail.com>.
 *
 * Revision 19: November 29, 2005
 *   Nodesets now store their nodes in a height balanced tree, increasing
 *   performance for the common case of selecting nodes in document order,
 *   thanks to Sbastien Cramatte <contact (at) zeninteractif.com>.
 *   AVL tree code adapted from Raimund Neumann <rnova (at) gmx.net>.
 *
 * Revision 18: October 27, 2005
 *   DOM 3 XPath support.  Caveats:
 *     - namespace prefixes aren't resolved in XPathEvaluator.createExpression,
 *       but in XPathExpression.evaluate.
 *     - XPathResult.invalidIteratorState is not implemented.
 *
 * Revision 17: October 25, 2005
 *   Some core XPath function fixes and a patch to avoid crashing certain
 *   versions of MSXML in PathExpr.prototype.getOwnerElement, thanks to
 *   Sbastien Cramatte <contact (at) zeninteractif.com>.
 *
 * Revision 16: September 22, 2005
 *   Workarounds for some IE 5.5 deficiencies.
 *   Fixed problem with prefix node tests on attribute nodes.
 *
 * Revision 15: May 21, 2005
 *   Fixed problem with QName node tests on elements with an xmlns="...".
 *
 * Revision 14: May 19, 2005
 *   Fixed QName node tests on attribute node regression.
 *
 * Revision 13: May 3, 2005
 *   Node tests are case insensitive now if working in an HTML DOM.
 *
 * Revision 12: April 26, 2005
 *   Updated licence.  Slight code changes to enable use of Dean
 *   Edwards' script compression, http://dean.edwards.name/packer/ .
 *
 * Revision 11: April 23, 2005
 *   Fixed bug with 'and' and 'or' operators, fix thanks to
 *   Sandy McArthur <sandy (at) mcarthur.org>.
 *
 * Revision 10: April 15, 2005
 *   Added support for a virtual root node, supposedly helpful for
 *   implementing XForms.  Fixed problem with QName node tests and
 *   the parent axis.
 *
 * Revision 9: March 17, 2005
 *   Namespace resolver tweaked so using the document node as the context
 *   for namespace lookups is equivalent to using the document element.
 *
 * Revision 8: February 13, 2005
 *   Handle implicit declaration of 'xmlns' namespace prefix.
 *   Fixed bug when comparing nodesets.
 *   Instance data can now be associated with a FunctionResolver, and
 *     workaround for MSXML not supporting 'localName' and 'getElementById',
 *     thanks to Grant Gongaware.
 *   Fix a few problems when the context node is the root node.
 *
 * Revision 7: February 11, 2005
 *   Default namespace resolver fix from Grant Gongaware
 *   <grant (at) gongaware.com>.
 *
 * Revision 6: February 10, 2005
 *   Fixed bug in 'number' function.
 *
 * Revision 5: February 9, 2005
 *   Fixed bug where text nodes not getting converted to string values.
 *
 * Revision 4: January 21, 2005
 *   Bug in 'name' function, fix thanks to Bill Edney.
 *   Fixed incorrect processing of namespace nodes.
 *   Fixed NamespaceResolver to resolve 'xml' namespace.
 *   Implemented union '|' operator.
 *
 * Revision 3: January 14, 2005
 *   Fixed bug with nodeset comparisons, bug lexing < and >.
 *
 * Revision 2: October 26, 2004
 *   QName node test namespace handling fixed.  Few other bug fixes.
 *
 * Revision 1: August 13, 2004
 *   Bug fixes from William J. Edney <bedney (at) technicalpursuit.com>.
 *   Added minimal licence.
 *
 * Initial version: June 14, 2004
 */

// non-node wrapper
var xpath = typeof exports === 'undefined' ? {} : exports;
(function (exports) {
  "use strict";

  // functional helpers
  function curry(func) {
    var slice = Array.prototype.slice,
      totalargs = func.length,
      partial = function partial(args, fn) {
        return function () {
          return fn.apply(this, args.concat(slice.call(arguments)));
        };
      },
      fn = function fn() {
        var args = slice.call(arguments);
        return args.length < totalargs ? partial(args, fn) : func.apply(this, slice.apply(arguments, [0, totalargs]));
      };
    return fn;
  }
  var forEach = function forEach(f, xs) {
    for (var i = 0; i < xs.length; i += 1) {
      f(xs[i], i, xs);
    }
  };
  var reduce = function reduce(f, seed, xs) {
    var acc = seed;
    forEach(function (x, i) {
      acc = f(acc, x, i);
    }, xs);
    return acc;
  };
  var map = function map(f, xs) {
    var mapped = new Array(xs.length);
    forEach(function (x, i) {
      mapped[i] = f(x);
    }, xs);
    return mapped;
  };
  var filter = function filter(f, xs) {
    var filtered = [];
    forEach(function (x, i) {
      if (f(x, i)) {
        filtered.push(x);
      }
    }, xs);
    return filtered;
  };
  var includes = function includes(values, value) {
    for (var i = 0; i < values.length; i += 1) {
      if (values[i] === value) {
        return true;
      }
    }
    return false;
  };
  function always(value) {
    return function () {
      return value;
    };
  }
  function toString(x) {
    return x.toString();
  }
  var join = function join(s, xs) {
    return xs.join(s);
  };
  var wrap = function wrap(pref, suf, str) {
    return pref + str + suf;
  };
  var prototypeConcat = Array.prototype.concat;

  // .apply() fails above a certain number of arguments - https://github.com/goto100/xpath/pull/98
  var MAX_ARGUMENT_LENGTH = 32767;
  function flatten(arr) {
    var result = [];
    for (var start = 0; start < arr.length; start += MAX_ARGUMENT_LENGTH) {
      var chunk = arr.slice(start, start + MAX_ARGUMENT_LENGTH);
      result = prototypeConcat.apply(result, chunk);
    }
    return result;
  }
  function assign(target, varArgs) {
    // .length of function is 2
    var to = Object(target);
    for (var index = 1; index < arguments.length; index++) {
      var nextSource = arguments[index];
      if (nextSource != null) {
        // Skip over if undefined or null
        for (var nextKey in nextSource) {
          // Avoid bugs when hasOwnProperty is shadowed
          if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
    return to;
  }

  // XPathParser ///////////////////////////////////////////////////////////////

  XPathParser.prototype = new Object();
  XPathParser.prototype.constructor = XPathParser;
  XPathParser.superclass = Object.prototype;
  function XPathParser() {
    this.init();
  }
  XPathParser.prototype.init = function () {
    this.reduceActions = [];
    this.reduceActions[3] = function (rhs) {
      return new OrOperation(rhs[0], rhs[2]);
    };
    this.reduceActions[5] = function (rhs) {
      return new AndOperation(rhs[0], rhs[2]);
    };
    this.reduceActions[7] = function (rhs) {
      return new EqualsOperation(rhs[0], rhs[2]);
    };
    this.reduceActions[8] = function (rhs) {
      return new NotEqualOperation(rhs[0], rhs[2]);
    };
    this.reduceActions[10] = function (rhs) {
      return new LessThanOperation(rhs[0], rhs[2]);
    };
    this.reduceActions[11] = function (rhs) {
      return new GreaterThanOperation(rhs[0], rhs[2]);
    };
    this.reduceActions[12] = function (rhs) {
      return new LessThanOrEqualOperation(rhs[0], rhs[2]);
    };
    this.reduceActions[13] = function (rhs) {
      return new GreaterThanOrEqualOperation(rhs[0], rhs[2]);
    };
    this.reduceActions[15] = function (rhs) {
      return new PlusOperation(rhs[0], rhs[2]);
    };
    this.reduceActions[16] = function (rhs) {
      return new MinusOperation(rhs[0], rhs[2]);
    };
    this.reduceActions[18] = function (rhs) {
      return new MultiplyOperation(rhs[0], rhs[2]);
    };
    this.reduceActions[19] = function (rhs) {
      return new DivOperation(rhs[0], rhs[2]);
    };
    this.reduceActions[20] = function (rhs) {
      return new ModOperation(rhs[0], rhs[2]);
    };
    this.reduceActions[22] = function (rhs) {
      return new UnaryMinusOperation(rhs[1]);
    };
    this.reduceActions[24] = function (rhs) {
      return new BarOperation(rhs[0], rhs[2]);
    };
    this.reduceActions[25] = function (rhs) {
      return new PathExpr(undefined, undefined, rhs[0]);
    };
    this.reduceActions[27] = function (rhs) {
      rhs[0].locationPath = rhs[2];
      return rhs[0];
    };
    this.reduceActions[28] = function (rhs) {
      rhs[0].locationPath = rhs[2];
      rhs[0].locationPath.steps.unshift(new Step(Step.DESCENDANTORSELF, NodeTest.nodeTest, []));
      return rhs[0];
    };
    this.reduceActions[29] = function (rhs) {
      return new PathExpr(rhs[0], [], undefined);
    };
    this.reduceActions[30] = function (rhs) {
      if (Utilities.instance_of(rhs[0], PathExpr)) {
        if (rhs[0].filterPredicates == undefined) {
          rhs[0].filterPredicates = [];
        }
        rhs[0].filterPredicates.push(rhs[1]);
        return rhs[0];
      } else {
        return new PathExpr(rhs[0], [rhs[1]], undefined);
      }
    };
    this.reduceActions[32] = function (rhs) {
      return rhs[1];
    };
    this.reduceActions[33] = function (rhs) {
      return new XString(rhs[0]);
    };
    this.reduceActions[34] = function (rhs) {
      return new XNumber(rhs[0]);
    };
    this.reduceActions[36] = function (rhs) {
      return new FunctionCall(rhs[0], []);
    };
    this.reduceActions[37] = function (rhs) {
      return new FunctionCall(rhs[0], rhs[2]);
    };
    this.reduceActions[38] = function (rhs) {
      return [rhs[0]];
    };
    this.reduceActions[39] = function (rhs) {
      rhs[2].unshift(rhs[0]);
      return rhs[2];
    };
    this.reduceActions[43] = function (rhs) {
      return new LocationPath(true, []);
    };
    this.reduceActions[44] = function (rhs) {
      rhs[1].absolute = true;
      return rhs[1];
    };
    this.reduceActions[46] = function (rhs) {
      return new LocationPath(false, [rhs[0]]);
    };
    this.reduceActions[47] = function (rhs) {
      rhs[0].steps.push(rhs[2]);
      return rhs[0];
    };
    this.reduceActions[49] = function (rhs) {
      return new Step(rhs[0], rhs[1], []);
    };
    this.reduceActions[50] = function (rhs) {
      return new Step(Step.CHILD, rhs[0], []);
    };
    this.reduceActions[51] = function (rhs) {
      return new Step(rhs[0], rhs[1], rhs[2]);
    };
    this.reduceActions[52] = function (rhs) {
      return new Step(Step.CHILD, rhs[0], rhs[1]);
    };
    this.reduceActions[54] = function (rhs) {
      return [rhs[0]];
    };
    this.reduceActions[55] = function (rhs) {
      rhs[1].unshift(rhs[0]);
      return rhs[1];
    };
    this.reduceActions[56] = function (rhs) {
      if (rhs[0] == "ancestor") {
        return Step.ANCESTOR;
      } else if (rhs[0] == "ancestor-or-self") {
        return Step.ANCESTORORSELF;
      } else if (rhs[0] == "attribute") {
        return Step.ATTRIBUTE;
      } else if (rhs[0] == "child") {
        return Step.CHILD;
      } else if (rhs[0] == "descendant") {
        return Step.DESCENDANT;
      } else if (rhs[0] == "descendant-or-self") {
        return Step.DESCENDANTORSELF;
      } else if (rhs[0] == "following") {
        return Step.FOLLOWING;
      } else if (rhs[0] == "following-sibling") {
        return Step.FOLLOWINGSIBLING;
      } else if (rhs[0] == "namespace") {
        return Step.NAMESPACE;
      } else if (rhs[0] == "parent") {
        return Step.PARENT;
      } else if (rhs[0] == "preceding") {
        return Step.PRECEDING;
      } else if (rhs[0] == "preceding-sibling") {
        return Step.PRECEDINGSIBLING;
      } else if (rhs[0] == "self") {
        return Step.SELF;
      }
      return -1;
    };
    this.reduceActions[57] = function (rhs) {
      return Step.ATTRIBUTE;
    };
    this.reduceActions[59] = function (rhs) {
      if (rhs[0] == "comment") {
        return NodeTest.commentTest;
      } else if (rhs[0] == "text") {
        return NodeTest.textTest;
      } else if (rhs[0] == "processing-instruction") {
        return NodeTest.anyPiTest;
      } else if (rhs[0] == "node") {
        return NodeTest.nodeTest;
      }
      return new NodeTest(-1, undefined);
    };
    this.reduceActions[60] = function (rhs) {
      return new NodeTest.PITest(rhs[2]);
    };
    this.reduceActions[61] = function (rhs) {
      return rhs[1];
    };
    this.reduceActions[63] = function (rhs) {
      rhs[1].absolute = true;
      rhs[1].steps.unshift(new Step(Step.DESCENDANTORSELF, NodeTest.nodeTest, []));
      return rhs[1];
    };
    this.reduceActions[64] = function (rhs) {
      rhs[0].steps.push(new Step(Step.DESCENDANTORSELF, NodeTest.nodeTest, []));
      rhs[0].steps.push(rhs[2]);
      return rhs[0];
    };
    this.reduceActions[65] = function (rhs) {
      return new Step(Step.SELF, NodeTest.nodeTest, []);
    };
    this.reduceActions[66] = function (rhs) {
      return new Step(Step.PARENT, NodeTest.nodeTest, []);
    };
    this.reduceActions[67] = function (rhs) {
      return new VariableReference(rhs[1]);
    };
    this.reduceActions[68] = function (rhs) {
      return NodeTest.nameTestAny;
    };
    this.reduceActions[69] = function (rhs) {
      return new NodeTest.NameTestPrefixAny(rhs[0].split(':')[0]);
    };
    this.reduceActions[70] = function (rhs) {
      return new NodeTest.NameTestQName(rhs[0]);
    };
  };
  XPathParser.actionTable = [" s s        sssssssss    s ss  s  ss", "                 s                  ", "r  rrrrrrrrr         rrrrrrr rr  r  ", "                rrrrr               ", " s s        sssssssss    s ss  s  ss", "rs  rrrrrrrr s  sssssrrrrrr  rrs rs ", " s s        sssssssss    s ss  s  ss", "                            s       ", "                            s       ", "r  rrrrrrrrr         rrrrrrr rr rr  ", "r  rrrrrrrrr         rrrrrrr rr rr  ", "r  rrrrrrrrr         rrrrrrr rr rr  ", "r  rrrrrrrrr         rrrrrrr rr rr  ", "r  rrrrrrrrr         rrrrrrr rr rr  ", "  s                                 ", "                            s       ", " s           s  sssss          s  s ", "r  rrrrrrrrr         rrrrrrr rr  r  ", "a                                   ", "r       s                    rr  r  ", "r      sr                    rr  r  ", "r   s  rr            s       rr  r  ", "r   rssrr            rss     rr  r  ", "r   rrrrr            rrrss   rr  r  ", "r   rrrrrsss         rrrrr   rr  r  ", "r   rrrrrrrr         rrrrr   rr  r  ", "r   rrrrrrrr         rrrrrs  rr  r  ", "r   rrrrrrrr         rrrrrr  rr  r  ", "r   rrrrrrrr         rrrrrr  rr  r  ", "r  srrrrrrrr         rrrrrrs rr sr  ", "r  srrrrrrrr         rrrrrrs rr  r  ", "r  rrrrrrrrr         rrrrrrr rr rr  ", "r  rrrrrrrrr         rrrrrrr rr rr  ", "r  rrrrrrrrr         rrrrrrr rr rr  ", "r   rrrrrrrr         rrrrrr  rr  r  ", "r   rrrrrrrr         rrrrrr  rr  r  ", "r  rrrrrrrrr         rrrrrrr rr  r  ", "r  rrrrrrrrr         rrrrrrr rr  r  ", "                sssss               ", "r  rrrrrrrrr         rrrrrrr rr sr  ", "r  rrrrrrrrr         rrrrrrr rr  r  ", "r  rrrrrrrrr         rrrrrrr rr rr  ", "r  rrrrrrrrr         rrrrrrr rr rr  ", "                             s      ", "r  srrrrrrrr         rrrrrrs rr  r  ", "r   rrrrrrrr         rrrrr   rr  r  ", "              s                     ", "                             s      ", "                rrrrr               ", " s s        sssssssss    s sss s  ss", "r  srrrrrrrr         rrrrrrs rr  r  ", " s s        sssssssss    s ss  s  ss", " s s        sssssssss    s ss  s  ss", " s s        sssssssss    s ss  s  ss", " s s        sssssssss    s ss  s  ss", " s s        sssssssss    s ss  s  ss", " s s        sssssssss    s ss  s  ss", " s s        sssssssss    s ss  s  ss", " s s        sssssssss    s ss  s  ss", " s s        sssssssss    s ss  s  ss", " s s        sssssssss    s ss  s  ss", " s s        sssssssss    s ss  s  ss", " s s        sssssssss    s ss  s  ss", " s s        sssssssss    s ss  s  ss", " s s        sssssssss      ss  s  ss", " s s        sssssssss    s ss  s  ss", " s           s  sssss          s  s ", " s           s  sssss          s  s ", "r  rrrrrrrrr         rrrrrrr rr rr  ", " s           s  sssss          s  s ", " s           s  sssss          s  s ", "r  rrrrrrrrr         rrrrrrr rr sr  ", "r  rrrrrrrrr         rrrrrrr rr sr  ", "r  rrrrrrrrr         rrrrrrr rr  r  ", "r  rrrrrrrrr         rrrrrrr rr rr  ", "                             s      ", "r  rrrrrrrrr         rrrrrrr rr rr  ", "r  rrrrrrrrr         rrrrrrr rr rr  ", "                             rr     ", "                             s      ", "                             rs     ", "r      sr                    rr  r  ", "r   s  rr            s       rr  r  ", "r   rssrr            rss     rr  r  ", "r   rssrr            rss     rr  r  ", "r   rrrrr            rrrss   rr  r  ", "r   rrrrr            rrrss   rr  r  ", "r   rrrrr            rrrss   rr  r  ", "r   rrrrr            rrrss   rr  r  ", "r   rrrrrsss         rrrrr   rr  r  ", "r   rrrrrsss         rrrrr   rr  r  ", "r   rrrrrrrr         rrrrr   rr  r  ", "r   rrrrrrrr         rrrrr   rr  r  ", "r   rrrrrrrr         rrrrr   rr  r  ", "r   rrrrrrrr         rrrrrr  rr  r  ", "                                 r  ", "                                 s  ", "r  srrrrrrrr         rrrrrrs rr  r  ", "r  srrrrrrrr         rrrrrrs rr  r  ", "r  rrrrrrrrr         rrrrrrr rr  r  ", "r  rrrrrrrrr         rrrrrrr rr  r  ", "r  rrrrrrrrr         rrrrrrr rr  r  ", "r  rrrrrrrrr         rrrrrrr rr  r  ", "r  rrrrrrrrr         rrrrrrr rr rr  ", "r  rrrrrrrrr         rrrrrrr rr rr  ", " s s        sssssssss    s ss  s  ss", "r  rrrrrrrrr         rrrrrrr rr rr  ", "                             r      "];
  XPathParser.actionTableNumber = [" 1 0        /.-,+*)('    & %$  #  \"!", "                 J                  ", "a  aaaaaaaaa         aaaaaaa aa  a  ", "                YYYYY               ", " 1 0        /.-,+*)('    & %$  #  \"!", "K1  KKKKKKKK .  +*)('KKKKKK  KK# K\" ", " 1 0        /.-,+*)('    & %$  #  \"!", "                            N       ", "                            O       ", "e  eeeeeeeee         eeeeeee ee ee  ", "f  fffffffff         fffffff ff ff  ", "d  ddddddddd         ddddddd dd dd  ", "B  BBBBBBBBB         BBBBBBB BB BB  ", "A  AAAAAAAAA         AAAAAAA AA AA  ", "  P                                 ", "                            Q       ", " 1           .  +*)('          #  \" ", "b  bbbbbbbbb         bbbbbbb bb  b  ", "                                    ", "!       S                    !!  !  ", "\"      T\"                    \"\"  \"  ", "$   V  $$            U       $$  $  ", "&   &ZY&&            &XW     &&  &  ", ")   )))))            )))\\[   ))  )  ", ".   ....._^]         .....   ..  .  ", "1   11111111         11111   11  1  ", "5   55555555         55555`  55  5  ", "7   77777777         777777  77  7  ", "9   99999999         999999  99  9  ", ":  c::::::::         ::::::b :: a:  ", "I  fIIIIIIII         IIIIIIe II  I  ", "=  =========         ======= == ==  ", "?  ?????????         ??????? ?? ??  ", "C  CCCCCCCCC         CCCCCCC CC CC  ", "J   JJJJJJJJ         JJJJJJ  JJ  J  ", "M   MMMMMMMM         MMMMMM  MM  M  ", "N  NNNNNNNNN         NNNNNNN NN  N  ", "P  PPPPPPPPP         PPPPPPP PP  P  ", "                +*)('               ", "R  RRRRRRRRR         RRRRRRR RR aR  ", "U  UUUUUUUUU         UUUUUUU UU  U  ", "Z  ZZZZZZZZZ         ZZZZZZZ ZZ ZZ  ", "c  ccccccccc         ccccccc cc cc  ", "                             j      ", "L  fLLLLLLLL         LLLLLLe LL  L  ", "6   66666666         66666   66  6  ", "              k                     ", "                             l      ", "                XXXXX               ", " 1 0        /.-,+*)('    & %$m #  \"!", "_  f________         ______e __  _  ", " 1 0        /.-,+*)('    & %$  #  \"!", " 1 0        /.-,+*)('    & %$  #  \"!", " 1 0        /.-,+*)('    & %$  #  \"!", " 1 0        /.-,+*)('    & %$  #  \"!", " 1 0        /.-,+*)('    & %$  #  \"!", " 1 0        /.-,+*)('    & %$  #  \"!", " 1 0        /.-,+*)('    & %$  #  \"!", " 1 0        /.-,+*)('    & %$  #  \"!", " 1 0        /.-,+*)('    & %$  #  \"!", " 1 0        /.-,+*)('    & %$  #  \"!", " 1 0        /.-,+*)('    & %$  #  \"!", " 1 0        /.-,+*)('    & %$  #  \"!", " 1 0        /.-,+*)('    & %$  #  \"!", " 1 0        /.-,+*)('      %$  #  \"!", " 1 0        /.-,+*)('    & %$  #  \"!", " 1           .  +*)('          #  \" ", " 1           .  +*)('          #  \" ", ">  >>>>>>>>>         >>>>>>> >> >>  ", " 1           .  +*)('          #  \" ", " 1           .  +*)('          #  \" ", "Q  QQQQQQQQQ         QQQQQQQ QQ aQ  ", "V  VVVVVVVVV         VVVVVVV VV aV  ", "T  TTTTTTTTT         TTTTTTT TT  T  ", "@  @@@@@@@@@         @@@@@@@ @@ @@  ", "                             \x87      ", "[  [[[[[[[[[         [[[[[[[ [[ [[  ", "D  DDDDDDDDD         DDDDDDD DD DD  ", "                             HH     ", "                             \x88      ", "                             F\x89     ", "#      T#                    ##  #  ", "%   V  %%            U       %%  %  ", "'   'ZY''            'XW     ''  '  ", "(   (ZY((            (XW     ((  (  ", "+   +++++            +++\\[   ++  +  ", "*   *****            ***\\[   **  *  ", "-   -----            ---\\[   --  -  ", ",   ,,,,,            ,,,\\[   ,,  ,  ", "0   00000_^]         00000   00  0  ", "/   /////_^]         /////   //  /  ", "2   22222222         22222   22  2  ", "3   33333333         33333   33  3  ", "4   44444444         44444   44  4  ", "8   88888888         888888  88  8  ", "                                 ^  ", "                                 \x8a  ", ";  f;;;;;;;;         ;;;;;;e ;;  ;  ", "<  f<<<<<<<<         <<<<<<e <<  <  ", "O  OOOOOOOOO         OOOOOOO OO  O  ", "`  `````````         ``````` ``  `  ", "S  SSSSSSSSS         SSSSSSS SS  S  ", "W  WWWWWWWWW         WWWWWWW WW  W  ", "\\  \\\\\\\\\\\\\\\\\\         \\\\\\\\\\\\\\ \\\\ \\\\  ", "E  EEEEEEEEE         EEEEEEE EE EE  ", " 1 0        /.-,+*)('    & %$  #  \"!", "]  ]]]]]]]]]         ]]]]]]] ]] ]]  ", "                             G      "];
  XPathParser.gotoTable = ["3456789:;<=>?@ AB  CDEFGH IJ ", "                             ", "                             ", "                             ", "L456789:;<=>?@ AB  CDEFGH IJ ", "            M        EFGH IJ ", "       N;<=>?@ AB  CDEFGH IJ ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "            S        EFGH IJ ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "              e              ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                        h  J ", "              i          j   ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "o456789:;<=>?@ ABpqCDEFGH IJ ", "                             ", "  r6789:;<=>?@ AB  CDEFGH IJ ", "   s789:;<=>?@ AB  CDEFGH IJ ", "    t89:;<=>?@ AB  CDEFGH IJ ", "    u89:;<=>?@ AB  CDEFGH IJ ", "     v9:;<=>?@ AB  CDEFGH IJ ", "     w9:;<=>?@ AB  CDEFGH IJ ", "     x9:;<=>?@ AB  CDEFGH IJ ", "     y9:;<=>?@ AB  CDEFGH IJ ", "      z:;<=>?@ AB  CDEFGH IJ ", "      {:;<=>?@ AB  CDEFGH IJ ", "       |;<=>?@ AB  CDEFGH IJ ", "       };<=>?@ AB  CDEFGH IJ ", "       ~;<=>?@ AB  CDEFGH IJ ", "         \x7f=>?@ AB  CDEFGH IJ ", "\x80456789:;<=>?@ AB  CDEFGH IJ\x81", "            \x82        EFGH IJ ", "            \x83        EFGH IJ ", "                             ", "                     \x84 GH IJ ", "                     \x85 GH IJ ", "              i          \x86   ", "              i          \x87   ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "                             ", "o456789:;<=>?@ AB\x8cqCDEFGH IJ ", "                             ", "                             "];
  XPathParser.productions = [[1, 1, 2], [2, 1, 3], [3, 1, 4], [3, 3, 3, -9, 4], [4, 1, 5], [4, 3, 4, -8, 5], [5, 1, 6], [5, 3, 5, -22, 6], [5, 3, 5, -5, 6], [6, 1, 7], [6, 3, 6, -23, 7], [6, 3, 6, -24, 7], [6, 3, 6, -6, 7], [6, 3, 6, -7, 7], [7, 1, 8], [7, 3, 7, -25, 8], [7, 3, 7, -26, 8], [8, 1, 9], [8, 3, 8, -12, 9], [8, 3, 8, -11, 9], [8, 3, 8, -10, 9], [9, 1, 10], [9, 2, -26, 9], [10, 1, 11], [10, 3, 10, -27, 11], [11, 1, 12], [11, 1, 13], [11, 3, 13, -28, 14], [11, 3, 13, -4, 14], [13, 1, 15], [13, 2, 13, 16], [15, 1, 17], [15, 3, -29, 2, -30], [15, 1, -15], [15, 1, -16], [15, 1, 18], [18, 3, -13, -29, -30], [18, 4, -13, -29, 19, -30], [19, 1, 20], [19, 3, 20, -31, 19], [20, 1, 2], [12, 1, 14], [12, 1, 21], [21, 1, -28], [21, 2, -28, 14], [21, 1, 22], [14, 1, 23], [14, 3, 14, -28, 23], [14, 1, 24], [23, 2, 25, 26], [23, 1, 26], [23, 3, 25, 26, 27], [23, 2, 26, 27], [23, 1, 28], [27, 1, 16], [27, 2, 16, 27], [25, 2, -14, -3], [25, 1, -32], [26, 1, 29], [26, 3, -20, -29, -30], [26, 4, -21, -29, -15, -30], [16, 3, -33, 30, -34], [30, 1, 2], [22, 2, -4, 14], [24, 3, 14, -4, 23], [28, 1, -35], [28, 1, -2], [17, 2, -36, -18], [29, 1, -17], [29, 1, -19], [29, 1, -18]];
  XPathParser.DOUBLEDOT = 2;
  XPathParser.DOUBLECOLON = 3;
  XPathParser.DOUBLESLASH = 4;
  XPathParser.NOTEQUAL = 5;
  XPathParser.LESSTHANOREQUAL = 6;
  XPathParser.GREATERTHANOREQUAL = 7;
  XPathParser.AND = 8;
  XPathParser.OR = 9;
  XPathParser.MOD = 10;
  XPathParser.DIV = 11;
  XPathParser.MULTIPLYOPERATOR = 12;
  XPathParser.FUNCTIONNAME = 13;
  XPathParser.AXISNAME = 14;
  XPathParser.LITERAL = 15;
  XPathParser.NUMBER = 16;
  XPathParser.ASTERISKNAMETEST = 17;
  XPathParser.QNAME = 18;
  XPathParser.NCNAMECOLONASTERISK = 19;
  XPathParser.NODETYPE = 20;
  XPathParser.PROCESSINGINSTRUCTIONWITHLITERAL = 21;
  XPathParser.EQUALS = 22;
  XPathParser.LESSTHAN = 23;
  XPathParser.GREATERTHAN = 24;
  XPathParser.PLUS = 25;
  XPathParser.MINUS = 26;
  XPathParser.BAR = 27;
  XPathParser.SLASH = 28;
  XPathParser.LEFTPARENTHESIS = 29;
  XPathParser.RIGHTPARENTHESIS = 30;
  XPathParser.COMMA = 31;
  XPathParser.AT = 32;
  XPathParser.LEFTBRACKET = 33;
  XPathParser.RIGHTBRACKET = 34;
  XPathParser.DOT = 35;
  XPathParser.DOLLAR = 36;
  XPathParser.prototype.tokenize = function (s1) {
    var types = [];
    var values = [];
    var s = s1 + '\0';
    var pos = 0;
    var c = s.charAt(pos++);
    while (1) {
      while (c == ' ' || c == '\t' || c == '\r' || c == '\n') {
        c = s.charAt(pos++);
      }
      if (c == '\0' || pos >= s.length) {
        break;
      }
      if (c == '(') {
        types.push(XPathParser.LEFTPARENTHESIS);
        values.push(c);
        c = s.charAt(pos++);
        continue;
      }
      if (c == ')') {
        types.push(XPathParser.RIGHTPARENTHESIS);
        values.push(c);
        c = s.charAt(pos++);
        continue;
      }
      if (c == '[') {
        types.push(XPathParser.LEFTBRACKET);
        values.push(c);
        c = s.charAt(pos++);
        continue;
      }
      if (c == ']') {
        types.push(XPathParser.RIGHTBRACKET);
        values.push(c);
        c = s.charAt(pos++);
        continue;
      }
      if (c == '@') {
        types.push(XPathParser.AT);
        values.push(c);
        c = s.charAt(pos++);
        continue;
      }
      if (c == ',') {
        types.push(XPathParser.COMMA);
        values.push(c);
        c = s.charAt(pos++);
        continue;
      }
      if (c == '|') {
        types.push(XPathParser.BAR);
        values.push(c);
        c = s.charAt(pos++);
        continue;
      }
      if (c == '+') {
        types.push(XPathParser.PLUS);
        values.push(c);
        c = s.charAt(pos++);
        continue;
      }
      if (c == '-') {
        types.push(XPathParser.MINUS);
        values.push(c);
        c = s.charAt(pos++);
        continue;
      }
      if (c == '=') {
        types.push(XPathParser.EQUALS);
        values.push(c);
        c = s.charAt(pos++);
        continue;
      }
      if (c == '$') {
        types.push(XPathParser.DOLLAR);
        values.push(c);
        c = s.charAt(pos++);
        continue;
      }
      if (c == '.') {
        c = s.charAt(pos++);
        if (c == '.') {
          types.push(XPathParser.DOUBLEDOT);
          values.push("..");
          c = s.charAt(pos++);
          continue;
        }
        if (c >= '0' && c <= '9') {
          var number = "." + c;
          c = s.charAt(pos++);
          while (c >= '0' && c <= '9') {
            number += c;
            c = s.charAt(pos++);
          }
          types.push(XPathParser.NUMBER);
          values.push(number);
          continue;
        }
        types.push(XPathParser.DOT);
        values.push('.');
        continue;
      }
      if (c == '\'' || c == '"') {
        var delimiter = c;
        var literal = "";
        while (pos < s.length && (c = s.charAt(pos)) !== delimiter) {
          literal += c;
          pos += 1;
        }
        if (c !== delimiter) {
          throw XPathException.fromMessage("Unterminated string literal: " + delimiter + literal);
        }
        pos += 1;
        types.push(XPathParser.LITERAL);
        values.push(literal);
        c = s.charAt(pos++);
        continue;
      }
      if (c >= '0' && c <= '9') {
        var number = c;
        c = s.charAt(pos++);
        while (c >= '0' && c <= '9') {
          number += c;
          c = s.charAt(pos++);
        }
        if (c == '.') {
          if (s.charAt(pos) >= '0' && s.charAt(pos) <= '9') {
            number += c;
            number += s.charAt(pos++);
            c = s.charAt(pos++);
            while (c >= '0' && c <= '9') {
              number += c;
              c = s.charAt(pos++);
            }
          }
        }
        types.push(XPathParser.NUMBER);
        values.push(number);
        continue;
      }
      if (c == '*') {
        if (types.length > 0) {
          var last = types[types.length - 1];
          if (last != XPathParser.AT && last != XPathParser.DOUBLECOLON && last != XPathParser.LEFTPARENTHESIS && last != XPathParser.LEFTBRACKET && last != XPathParser.AND && last != XPathParser.OR && last != XPathParser.MOD && last != XPathParser.DIV && last != XPathParser.MULTIPLYOPERATOR && last != XPathParser.SLASH && last != XPathParser.DOUBLESLASH && last != XPathParser.BAR && last != XPathParser.PLUS && last != XPathParser.MINUS && last != XPathParser.EQUALS && last != XPathParser.NOTEQUAL && last != XPathParser.LESSTHAN && last != XPathParser.LESSTHANOREQUAL && last != XPathParser.GREATERTHAN && last != XPathParser.GREATERTHANOREQUAL) {
            types.push(XPathParser.MULTIPLYOPERATOR);
            values.push(c);
            c = s.charAt(pos++);
            continue;
          }
        }
        types.push(XPathParser.ASTERISKNAMETEST);
        values.push(c);
        c = s.charAt(pos++);
        continue;
      }
      if (c == ':') {
        if (s.charAt(pos) == ':') {
          types.push(XPathParser.DOUBLECOLON);
          values.push("::");
          pos++;
          c = s.charAt(pos++);
          continue;
        }
      }
      if (c == '/') {
        c = s.charAt(pos++);
        if (c == '/') {
          types.push(XPathParser.DOUBLESLASH);
          values.push("//");
          c = s.charAt(pos++);
          continue;
        }
        types.push(XPathParser.SLASH);
        values.push('/');
        continue;
      }
      if (c == '!') {
        if (s.charAt(pos) == '=') {
          types.push(XPathParser.NOTEQUAL);
          values.push("!=");
          pos++;
          c = s.charAt(pos++);
          continue;
        }
      }
      if (c == '<') {
        if (s.charAt(pos) == '=') {
          types.push(XPathParser.LESSTHANOREQUAL);
          values.push("<=");
          pos++;
          c = s.charAt(pos++);
          continue;
        }
        types.push(XPathParser.LESSTHAN);
        values.push('<');
        c = s.charAt(pos++);
        continue;
      }
      if (c == '>') {
        if (s.charAt(pos) == '=') {
          types.push(XPathParser.GREATERTHANOREQUAL);
          values.push(">=");
          pos++;
          c = s.charAt(pos++);
          continue;
        }
        types.push(XPathParser.GREATERTHAN);
        values.push('>');
        c = s.charAt(pos++);
        continue;
      }
      if (c == '_' || Utilities.isLetter(c.charCodeAt(0))) {
        var name = c;
        c = s.charAt(pos++);
        while (Utilities.isNCNameChar(c.charCodeAt(0))) {
          name += c;
          c = s.charAt(pos++);
        }
        if (types.length > 0) {
          var last = types[types.length - 1];
          if (last != XPathParser.AT && last != XPathParser.DOUBLECOLON && last != XPathParser.LEFTPARENTHESIS && last != XPathParser.LEFTBRACKET && last != XPathParser.AND && last != XPathParser.OR && last != XPathParser.MOD && last != XPathParser.DIV && last != XPathParser.MULTIPLYOPERATOR && last != XPathParser.SLASH && last != XPathParser.DOUBLESLASH && last != XPathParser.BAR && last != XPathParser.PLUS && last != XPathParser.MINUS && last != XPathParser.EQUALS && last != XPathParser.NOTEQUAL && last != XPathParser.LESSTHAN && last != XPathParser.LESSTHANOREQUAL && last != XPathParser.GREATERTHAN && last != XPathParser.GREATERTHANOREQUAL) {
            if (name == "and") {
              types.push(XPathParser.AND);
              values.push(name);
              continue;
            }
            if (name == "or") {
              types.push(XPathParser.OR);
              values.push(name);
              continue;
            }
            if (name == "mod") {
              types.push(XPathParser.MOD);
              values.push(name);
              continue;
            }
            if (name == "div") {
              types.push(XPathParser.DIV);
              values.push(name);
              continue;
            }
          }
        }
        if (c == ':') {
          if (s.charAt(pos) == '*') {
            types.push(XPathParser.NCNAMECOLONASTERISK);
            values.push(name + ":*");
            pos++;
            c = s.charAt(pos++);
            continue;
          }
          if (s.charAt(pos) == '_' || Utilities.isLetter(s.charCodeAt(pos))) {
            name += ':';
            c = s.charAt(pos++);
            while (Utilities.isNCNameChar(c.charCodeAt(0))) {
              name += c;
              c = s.charAt(pos++);
            }
            if (c == '(') {
              types.push(XPathParser.FUNCTIONNAME);
              values.push(name);
              continue;
            }
            types.push(XPathParser.QNAME);
            values.push(name);
            continue;
          }
          if (s.charAt(pos) == ':') {
            types.push(XPathParser.AXISNAME);
            values.push(name);
            continue;
          }
        }
        if (c == '(') {
          if (name == "comment" || name == "text" || name == "node") {
            types.push(XPathParser.NODETYPE);
            values.push(name);
            continue;
          }
          if (name == "processing-instruction") {
            if (s.charAt(pos) == ')') {
              types.push(XPathParser.NODETYPE);
            } else {
              types.push(XPathParser.PROCESSINGINSTRUCTIONWITHLITERAL);
            }
            values.push(name);
            continue;
          }
          types.push(XPathParser.FUNCTIONNAME);
          values.push(name);
          continue;
        }
        types.push(XPathParser.QNAME);
        values.push(name);
        continue;
      }
      throw new Error("Unexpected character " + c);
    }
    types.push(1);
    values.push("[EOF]");
    return [types, values];
  };
  XPathParser.SHIFT = 's';
  XPathParser.REDUCE = 'r';
  XPathParser.ACCEPT = 'a';
  XPathParser.prototype.parse = function (s) {
    var types;
    var values;
    var res = this.tokenize(s);
    if (res == undefined) {
      return undefined;
    }
    types = res[0];
    values = res[1];
    var tokenPos = 0;
    var state = [];
    var tokenType = [];
    var tokenValue = [];
    var s;
    var a;
    var t;
    state.push(0);
    tokenType.push(1);
    tokenValue.push("_S");
    a = types[tokenPos];
    t = values[tokenPos++];
    while (1) {
      s = state[state.length - 1];
      switch (XPathParser.actionTable[s].charAt(a - 1)) {
        case XPathParser.SHIFT:
          tokenType.push(-a);
          tokenValue.push(t);
          state.push(XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32);
          a = types[tokenPos];
          t = values[tokenPos++];
          break;
        case XPathParser.REDUCE:
          var num = XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][1];
          var rhs = [];
          for (var i = 0; i < num; i++) {
            tokenType.pop();
            rhs.unshift(tokenValue.pop());
            state.pop();
          }
          var s_ = state[state.length - 1];
          tokenType.push(XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][0]);
          if (this.reduceActions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32] == undefined) {
            tokenValue.push(rhs[0]);
          } else {
            tokenValue.push(this.reduceActions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32](rhs));
          }
          state.push(XPathParser.gotoTable[s_].charCodeAt(XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][0] - 2) - 33);
          break;
        case XPathParser.ACCEPT:
          return new XPath(tokenValue.pop());
        default:
          throw new Error("XPath parse error");
      }
    }
  };

  // XPath /////////////////////////////////////////////////////////////////////

  XPath.prototype = new Object();
  XPath.prototype.constructor = XPath;
  XPath.superclass = Object.prototype;
  function XPath(e) {
    this.expression = e;
  }
  XPath.prototype.toString = function () {
    return this.expression.toString();
  };
  function setIfUnset(obj, prop, value) {
    if (!(prop in obj)) {
      obj[prop] = value;
    }
  }
  XPath.prototype.evaluate = function (c) {
    c.contextNode = c.expressionContextNode;
    c.contextSize = 1;
    c.contextPosition = 1;

    // [2017-11-25] Removed usage of .implementation.hasFeature() since it does
    //              not reliably detect HTML DOMs (always returns false in xmldom and true in browsers)
    if (c.isHtml) {
      setIfUnset(c, 'caseInsensitive', true);
      setIfUnset(c, 'allowAnyNamespaceForNoPrefix', true);
    }
    setIfUnset(c, 'caseInsensitive', false);
    return this.expression.evaluate(c);
  };
  XPath.XML_NAMESPACE_URI = "http://www.w3.org/XML/1998/namespace";
  XPath.XMLNS_NAMESPACE_URI = "http://www.w3.org/2000/xmlns/";

  // Expression ////////////////////////////////////////////////////////////////

  Expression.prototype = new Object();
  Expression.prototype.constructor = Expression;
  Expression.superclass = Object.prototype;
  function Expression() {}
  Expression.prototype.init = function () {};
  Expression.prototype.toString = function () {
    return "<Expression>";
  };
  Expression.prototype.evaluate = function (c) {
    throw new Error("Could not evaluate expression.");
  };

  // UnaryOperation ////////////////////////////////////////////////////////////

  UnaryOperation.prototype = new Expression();
  UnaryOperation.prototype.constructor = UnaryOperation;
  UnaryOperation.superclass = Expression.prototype;
  function UnaryOperation(rhs) {
    if (arguments.length > 0) {
      this.init(rhs);
    }
  }
  UnaryOperation.prototype.init = function (rhs) {
    this.rhs = rhs;
  };

  // UnaryMinusOperation ///////////////////////////////////////////////////////

  UnaryMinusOperation.prototype = new UnaryOperation();
  UnaryMinusOperation.prototype.constructor = UnaryMinusOperation;
  UnaryMinusOperation.superclass = UnaryOperation.prototype;
  function UnaryMinusOperation(rhs) {
    if (arguments.length > 0) {
      this.init(rhs);
    }
  }
  UnaryMinusOperation.prototype.init = function (rhs) {
    UnaryMinusOperation.superclass.init.call(this, rhs);
  };
  UnaryMinusOperation.prototype.evaluate = function (c) {
    return this.rhs.evaluate(c).number().negate();
  };
  UnaryMinusOperation.prototype.toString = function () {
    return "-" + this.rhs.toString();
  };

  // BinaryOperation ///////////////////////////////////////////////////////////

  BinaryOperation.prototype = new Expression();
  BinaryOperation.prototype.constructor = BinaryOperation;
  BinaryOperation.superclass = Expression.prototype;
  function BinaryOperation(lhs, rhs) {
    if (arguments.length > 0) {
      this.init(lhs, rhs);
    }
  }
  BinaryOperation.prototype.init = function (lhs, rhs) {
    this.lhs = lhs;
    this.rhs = rhs;
  };

  // OrOperation ///////////////////////////////////////////////////////////////

  OrOperation.prototype = new BinaryOperation();
  OrOperation.prototype.constructor = OrOperation;
  OrOperation.superclass = BinaryOperation.prototype;
  function OrOperation(lhs, rhs) {
    if (arguments.length > 0) {
      this.init(lhs, rhs);
    }
  }
  OrOperation.prototype.init = function (lhs, rhs) {
    OrOperation.superclass.init.call(this, lhs, rhs);
  };
  OrOperation.prototype.toString = function () {
    return "(" + this.lhs.toString() + " or " + this.rhs.toString() + ")";
  };
  OrOperation.prototype.evaluate = function (c) {
    var b = this.lhs.evaluate(c).bool();
    if (b.booleanValue()) {
      return b;
    }
    return this.rhs.evaluate(c).bool();
  };

  // AndOperation //////////////////////////////////////////////////////////////

  AndOperation.prototype = new BinaryOperation();
  AndOperation.prototype.constructor = AndOperation;
  AndOperation.superclass = BinaryOperation.prototype;
  function AndOperation(lhs, rhs) {
    if (arguments.length > 0) {
      this.init(lhs, rhs);
    }
  }
  AndOperation.prototype.init = function (lhs, rhs) {
    AndOperation.superclass.init.call(this, lhs, rhs);
  };
  AndOperation.prototype.toString = function () {
    return "(" + this.lhs.toString() + " and " + this.rhs.toString() + ")";
  };
  AndOperation.prototype.evaluate = function (c) {
    var b = this.lhs.evaluate(c).bool();
    if (!b.booleanValue()) {
      return b;
    }
    return this.rhs.evaluate(c).bool();
  };

  // EqualsOperation ///////////////////////////////////////////////////////////

  EqualsOperation.prototype = new BinaryOperation();
  EqualsOperation.prototype.constructor = EqualsOperation;
  EqualsOperation.superclass = BinaryOperation.prototype;
  function EqualsOperation(lhs, rhs) {
    if (arguments.length > 0) {
      this.init(lhs, rhs);
    }
  }
  EqualsOperation.prototype.init = function (lhs, rhs) {
    EqualsOperation.superclass.init.call(this, lhs, rhs);
  };
  EqualsOperation.prototype.toString = function () {
    return "(" + this.lhs.toString() + " = " + this.rhs.toString() + ")";
  };
  EqualsOperation.prototype.evaluate = function (c) {
    return this.lhs.evaluate(c).equals(this.rhs.evaluate(c));
  };

  // NotEqualOperation /////////////////////////////////////////////////////////

  NotEqualOperation.prototype = new BinaryOperation();
  NotEqualOperation.prototype.constructor = NotEqualOperation;
  NotEqualOperation.superclass = BinaryOperation.prototype;
  function NotEqualOperation(lhs, rhs) {
    if (arguments.length > 0) {
      this.init(lhs, rhs);
    }
  }
  NotEqualOperation.prototype.init = function (lhs, rhs) {
    NotEqualOperation.superclass.init.call(this, lhs, rhs);
  };
  NotEqualOperation.prototype.toString = function () {
    return "(" + this.lhs.toString() + " != " + this.rhs.toString() + ")";
  };
  NotEqualOperation.prototype.evaluate = function (c) {
    return this.lhs.evaluate(c).notequal(this.rhs.evaluate(c));
  };

  // LessThanOperation /////////////////////////////////////////////////////////

  LessThanOperation.prototype = new BinaryOperation();
  LessThanOperation.prototype.constructor = LessThanOperation;
  LessThanOperation.superclass = BinaryOperation.prototype;
  function LessThanOperation(lhs, rhs) {
    if (arguments.length > 0) {
      this.init(lhs, rhs);
    }
  }
  LessThanOperation.prototype.init = function (lhs, rhs) {
    LessThanOperation.superclass.init.call(this, lhs, rhs);
  };
  LessThanOperation.prototype.evaluate = function (c) {
    return this.lhs.evaluate(c).lessthan(this.rhs.evaluate(c));
  };
  LessThanOperation.prototype.toString = function () {
    return "(" + this.lhs.toString() + " < " + this.rhs.toString() + ")";
  };

  // GreaterThanOperation //////////////////////////////////////////////////////

  GreaterThanOperation.prototype = new BinaryOperation();
  GreaterThanOperation.prototype.constructor = GreaterThanOperation;
  GreaterThanOperation.superclass = BinaryOperation.prototype;
  function GreaterThanOperation(lhs, rhs) {
    if (arguments.length > 0) {
      this.init(lhs, rhs);
    }
  }
  GreaterThanOperation.prototype.init = function (lhs, rhs) {
    GreaterThanOperation.superclass.init.call(this, lhs, rhs);
  };
  GreaterThanOperation.prototype.evaluate = function (c) {
    return this.lhs.evaluate(c).greaterthan(this.rhs.evaluate(c));
  };
  GreaterThanOperation.prototype.toString = function () {
    return "(" + this.lhs.toString() + " > " + this.rhs.toString() + ")";
  };

  // LessThanOrEqualOperation //////////////////////////////////////////////////

  LessThanOrEqualOperation.prototype = new BinaryOperation();
  LessThanOrEqualOperation.prototype.constructor = LessThanOrEqualOperation;
  LessThanOrEqualOperation.superclass = BinaryOperation.prototype;
  function LessThanOrEqualOperation(lhs, rhs) {
    if (arguments.length > 0) {
      this.init(lhs, rhs);
    }
  }
  LessThanOrEqualOperation.prototype.init = function (lhs, rhs) {
    LessThanOrEqualOperation.superclass.init.call(this, lhs, rhs);
  };
  LessThanOrEqualOperation.prototype.evaluate = function (c) {
    return this.lhs.evaluate(c).lessthanorequal(this.rhs.evaluate(c));
  };
  LessThanOrEqualOperation.prototype.toString = function () {
    return "(" + this.lhs.toString() + " <= " + this.rhs.toString() + ")";
  };

  // GreaterThanOrEqualOperation ///////////////////////////////////////////////

  GreaterThanOrEqualOperation.prototype = new BinaryOperation();
  GreaterThanOrEqualOperation.prototype.constructor = GreaterThanOrEqualOperation;
  GreaterThanOrEqualOperation.superclass = BinaryOperation.prototype;
  function GreaterThanOrEqualOperation(lhs, rhs) {
    if (arguments.length > 0) {
      this.init(lhs, rhs);
    }
  }
  GreaterThanOrEqualOperation.prototype.init = function (lhs, rhs) {
    GreaterThanOrEqualOperation.superclass.init.call(this, lhs, rhs);
  };
  GreaterThanOrEqualOperation.prototype.evaluate = function (c) {
    return this.lhs.evaluate(c).greaterthanorequal(this.rhs.evaluate(c));
  };
  GreaterThanOrEqualOperation.prototype.toString = function () {
    return "(" + this.lhs.toString() + " >= " + this.rhs.toString() + ")";
  };

  // PlusOperation /////////////////////////////////////////////////////////////

  PlusOperation.prototype = new BinaryOperation();
  PlusOperation.prototype.constructor = PlusOperation;
  PlusOperation.superclass = BinaryOperation.prototype;
  function PlusOperation(lhs, rhs) {
    if (arguments.length > 0) {
      this.init(lhs, rhs);
    }
  }
  PlusOperation.prototype.init = function (lhs, rhs) {
    PlusOperation.superclass.init.call(this, lhs, rhs);
  };
  PlusOperation.prototype.evaluate = function (c) {
    return this.lhs.evaluate(c).number().plus(this.rhs.evaluate(c).number());
  };
  PlusOperation.prototype.toString = function () {
    return "(" + this.lhs.toString() + " + " + this.rhs.toString() + ")";
  };

  // MinusOperation ////////////////////////////////////////////////////////////

  MinusOperation.prototype = new BinaryOperation();
  MinusOperation.prototype.constructor = MinusOperation;
  MinusOperation.superclass = BinaryOperation.prototype;
  function MinusOperation(lhs, rhs) {
    if (arguments.length > 0) {
      this.init(lhs, rhs);
    }
  }
  MinusOperation.prototype.init = function (lhs, rhs) {
    MinusOperation.superclass.init.call(this, lhs, rhs);
  };
  MinusOperation.prototype.evaluate = function (c) {
    return this.lhs.evaluate(c).number().minus(this.rhs.evaluate(c).number());
  };
  MinusOperation.prototype.toString = function () {
    return "(" + this.lhs.toString() + " - " + this.rhs.toString() + ")";
  };

  // MultiplyOperation /////////////////////////////////////////////////////////

  MultiplyOperation.prototype = new BinaryOperation();
  MultiplyOperation.prototype.constructor = MultiplyOperation;
  MultiplyOperation.superclass = BinaryOperation.prototype;
  function MultiplyOperation(lhs, rhs) {
    if (arguments.length > 0) {
      this.init(lhs, rhs);
    }
  }
  MultiplyOperation.prototype.init = function (lhs, rhs) {
    MultiplyOperation.superclass.init.call(this, lhs, rhs);
  };
  MultiplyOperation.prototype.evaluate = function (c) {
    return this.lhs.evaluate(c).number().multiply(this.rhs.evaluate(c).number());
  };
  MultiplyOperation.prototype.toString = function () {
    return "(" + this.lhs.toString() + " * " + this.rhs.toString() + ")";
  };

  // DivOperation //////////////////////////////////////////////////////////////

  DivOperation.prototype = new BinaryOperation();
  DivOperation.prototype.constructor = DivOperation;
  DivOperation.superclass = BinaryOperation.prototype;
  function DivOperation(lhs, rhs) {
    if (arguments.length > 0) {
      this.init(lhs, rhs);
    }
  }
  DivOperation.prototype.init = function (lhs, rhs) {
    DivOperation.superclass.init.call(this, lhs, rhs);
  };
  DivOperation.prototype.evaluate = function (c) {
    return this.lhs.evaluate(c).number().div(this.rhs.evaluate(c).number());
  };
  DivOperation.prototype.toString = function () {
    return "(" + this.lhs.toString() + " div " + this.rhs.toString() + ")";
  };

  // ModOperation //////////////////////////////////////////////////////////////

  ModOperation.prototype = new BinaryOperation();
  ModOperation.prototype.constructor = ModOperation;
  ModOperation.superclass = BinaryOperation.prototype;
  function ModOperation(lhs, rhs) {
    if (arguments.length > 0) {
      this.init(lhs, rhs);
    }
  }
  ModOperation.prototype.init = function (lhs, rhs) {
    ModOperation.superclass.init.call(this, lhs, rhs);
  };
  ModOperation.prototype.evaluate = function (c) {
    return this.lhs.evaluate(c).number().mod(this.rhs.evaluate(c).number());
  };
  ModOperation.prototype.toString = function () {
    return "(" + this.lhs.toString() + " mod " + this.rhs.toString() + ")";
  };

  // BarOperation //////////////////////////////////////////////////////////////

  BarOperation.prototype = new BinaryOperation();
  BarOperation.prototype.constructor = BarOperation;
  BarOperation.superclass = BinaryOperation.prototype;
  function BarOperation(lhs, rhs) {
    if (arguments.length > 0) {
      this.init(lhs, rhs);
    }
  }
  BarOperation.prototype.init = function (lhs, rhs) {
    BarOperation.superclass.init.call(this, lhs, rhs);
  };
  BarOperation.prototype.evaluate = function (c) {
    return this.lhs.evaluate(c).nodeset().union(this.rhs.evaluate(c).nodeset());
  };
  BarOperation.prototype.toString = function () {
    return map(toString, [this.lhs, this.rhs]).join(' | ');
  };

  // PathExpr //////////////////////////////////////////////////////////////////

  PathExpr.prototype = new Expression();
  PathExpr.prototype.constructor = PathExpr;
  PathExpr.superclass = Expression.prototype;
  function PathExpr(filter, filterPreds, locpath) {
    if (arguments.length > 0) {
      this.init(filter, filterPreds, locpath);
    }
  }
  PathExpr.prototype.init = function (filter, filterPreds, locpath) {
    PathExpr.superclass.init.call(this);
    this.filter = filter;
    this.filterPredicates = filterPreds;
    this.locationPath = locpath;
  };

  /**
   * Returns the topmost node of the tree containing node
   */
  function findRoot(node) {
    while (node && node.parentNode) {
      node = node.parentNode;
    }
    return node;
  }
  PathExpr.applyPredicates = function (predicates, c, nodes) {
    if (predicates.length === 0) {
      return nodes;
    }
    var ctx = c.extend({});
    return reduce(function (inNodes, pred) {
      ctx.contextSize = inNodes.length;
      return filter(function (node, i) {
        ctx.contextNode = node;
        ctx.contextPosition = i + 1;
        return PathExpr.predicateMatches(pred, ctx);
      }, inNodes);
    }, nodes, predicates);
  };
  PathExpr.getRoot = function (xpc, nodes) {
    var firstNode = nodes[0];
    if (firstNode.nodeType === 9 /*Node.DOCUMENT_NODE*/) {
      return firstNode;
    }
    if (xpc.virtualRoot) {
      return xpc.virtualRoot;
    }
    var ownerDoc = firstNode.ownerDocument;
    if (ownerDoc) {
      return ownerDoc;
    }

    // IE 5.5 doesn't have ownerDocument?
    var n = firstNode;
    while (n.parentNode != null) {
      n = n.parentNode;
    }
    return n;
  };
  PathExpr.applyStep = function (step, xpc, node) {
    var self = this;
    var newNodes = [];
    xpc.contextNode = node;
    switch (step.axis) {
      case Step.ANCESTOR:
        // look at all the ancestor nodes
        if (xpc.contextNode === xpc.virtualRoot) {
          break;
        }
        var m;
        if (xpc.contextNode.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {
          m = PathExpr.getOwnerElement(xpc.contextNode);
        } else {
          m = xpc.contextNode.parentNode;
        }
        while (m != null) {
          if (step.nodeTest.matches(m, xpc)) {
            newNodes.push(m);
          }
          if (m === xpc.virtualRoot) {
            break;
          }
          m = m.parentNode;
        }
        break;
      case Step.ANCESTORORSELF:
        // look at all the ancestor nodes and the current node
        for (var m = xpc.contextNode; m != null; m = m.nodeType == 2 /*Node.ATTRIBUTE_NODE*/ ? PathExpr.getOwnerElement(m) : m.parentNode) {
          if (step.nodeTest.matches(m, xpc)) {
            newNodes.push(m);
          }
          if (m === xpc.virtualRoot) {
            break;
          }
        }
        break;
      case Step.ATTRIBUTE:
        // look at the attributes
        var nnm = xpc.contextNode.attributes;
        if (nnm != null) {
          for (var k = 0; k < nnm.length; k++) {
            var m = nnm.item(k);
            if (step.nodeTest.matches(m, xpc)) {
              newNodes.push(m);
            }
          }
        }
        break;
      case Step.CHILD:
        // look at all child elements
        for (var m = xpc.contextNode.firstChild; m != null; m = m.nextSibling) {
          if (step.nodeTest.matches(m, xpc)) {
            newNodes.push(m);
          }
        }
        break;
      case Step.DESCENDANT:
        // look at all descendant nodes
        var st = [xpc.contextNode.firstChild];
        while (st.length > 0) {
          for (var m = st.pop(); m != null;) {
            if (step.nodeTest.matches(m, xpc)) {
              newNodes.push(m);
            }
            if (m.firstChild != null) {
              st.push(m.nextSibling);
              m = m.firstChild;
            } else {
              m = m.nextSibling;
            }
          }
        }
        break;
      case Step.DESCENDANTORSELF:
        // look at self
        if (step.nodeTest.matches(xpc.contextNode, xpc)) {
          newNodes.push(xpc.contextNode);
        }
        // look at all descendant nodes
        var st = [xpc.contextNode.firstChild];
        while (st.length > 0) {
          for (var m = st.pop(); m != null;) {
            if (step.nodeTest.matches(m, xpc)) {
              newNodes.push(m);
            }
            if (m.firstChild != null) {
              st.push(m.nextSibling);
              m = m.firstChild;
            } else {
              m = m.nextSibling;
            }
          }
        }
        break;
      case Step.FOLLOWING:
        if (xpc.contextNode === xpc.virtualRoot) {
          break;
        }
        var st = [];
        if (xpc.contextNode.firstChild != null) {
          st.unshift(xpc.contextNode.firstChild);
        } else {
          st.unshift(xpc.contextNode.nextSibling);
        }
        for (var m = xpc.contextNode.parentNode; m != null && m.nodeType != 9 /*Node.DOCUMENT_NODE*/ && m !== xpc.virtualRoot; m = m.parentNode) {
          st.unshift(m.nextSibling);
        }
        do {
          for (var m = st.pop(); m != null;) {
            if (step.nodeTest.matches(m, xpc)) {
              newNodes.push(m);
            }
            if (m.firstChild != null) {
              st.push(m.nextSibling);
              m = m.firstChild;
            } else {
              m = m.nextSibling;
            }
          }
        } while (st.length > 0);
        break;
      case Step.FOLLOWINGSIBLING:
        if (xpc.contextNode === xpc.virtualRoot) {
          break;
        }
        for (var m = xpc.contextNode.nextSibling; m != null; m = m.nextSibling) {
          if (step.nodeTest.matches(m, xpc)) {
            newNodes.push(m);
          }
        }
        break;
      case Step.NAMESPACE:
        var n = {};
        if (xpc.contextNode.nodeType == 1 /*Node.ELEMENT_NODE*/) {
          n["xml"] = XPath.XML_NAMESPACE_URI;
          n["xmlns"] = XPath.XMLNS_NAMESPACE_URI;
          for (var m = xpc.contextNode; m != null && m.nodeType == 1 /*Node.ELEMENT_NODE*/; m = m.parentNode) {
            for (var k = 0; k < m.attributes.length; k++) {
              var attr = m.attributes.item(k);
              var nm = String(attr.name);
              if (nm == "xmlns") {
                if (n[""] == undefined) {
                  n[""] = attr.value;
                }
              } else if (nm.length > 6 && nm.substring(0, 6) == "xmlns:") {
                var pre = nm.substring(6, nm.length);
                if (n[pre] == undefined) {
                  n[pre] = attr.value;
                }
              }
            }
          }
          for (var pre in n) {
            var nsn = new XPathNamespace(pre, n[pre], xpc.contextNode);
            if (step.nodeTest.matches(nsn, xpc)) {
              newNodes.push(nsn);
            }
          }
        }
        break;
      case Step.PARENT:
        m = null;
        if (xpc.contextNode !== xpc.virtualRoot) {
          if (xpc.contextNode.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {
            m = PathExpr.getOwnerElement(xpc.contextNode);
          } else {
            m = xpc.contextNode.parentNode;
          }
        }
        if (m != null && step.nodeTest.matches(m, xpc)) {
          newNodes.push(m);
        }
        break;
      case Step.PRECEDING:
        var st;
        if (xpc.virtualRoot != null) {
          st = [xpc.virtualRoot];
        } else {
          // cannot rely on .ownerDocument because the node may be in a document fragment
          st = [findRoot(xpc.contextNode)];
        }
        outer: while (st.length > 0) {
          for (var m = st.pop(); m != null;) {
            if (m == xpc.contextNode) {
              break outer;
            }
            if (step.nodeTest.matches(m, xpc)) {
              newNodes.unshift(m);
            }
            if (m.firstChild != null) {
              st.push(m.nextSibling);
              m = m.firstChild;
            } else {
              m = m.nextSibling;
            }
          }
        }
        break;
      case Step.PRECEDINGSIBLING:
        if (xpc.contextNode === xpc.virtualRoot) {
          break;
        }
        for (var m = xpc.contextNode.previousSibling; m != null; m = m.previousSibling) {
          if (step.nodeTest.matches(m, xpc)) {
            newNodes.push(m);
          }
        }
        break;
      case Step.SELF:
        if (step.nodeTest.matches(xpc.contextNode, xpc)) {
          newNodes.push(xpc.contextNode);
        }
        break;
      default:
    }
    return newNodes;
  };
  function applyStepWithPredicates(step, xpc, node) {
    return PathExpr.applyPredicates(step.predicates, xpc, PathExpr.applyStep(step, xpc, node));
  }
  function applyStepToNodes(context, nodes, step) {
    return flatten(map(applyStepWithPredicates.bind(null, step, context), nodes));
  }
  PathExpr.applySteps = function (steps, xpc, nodes) {
    return reduce(applyStepToNodes.bind(null, xpc), nodes, steps);
  };
  PathExpr.prototype.applyFilter = function (c, xpc) {
    if (!this.filter) {
      return {
        nodes: [c.contextNode]
      };
    }
    var ns = this.filter.evaluate(c);
    if (!Utilities.instance_of(ns, XNodeSet)) {
      if (this.filterPredicates != null && this.filterPredicates.length > 0 || this.locationPath != null) {
        throw new Error("Path expression filter must evaluate to a nodeset if predicates or location path are used");
      }
      return {
        nonNodes: ns
      };
    }
    return {
      nodes: PathExpr.applyPredicates(this.filterPredicates || [], xpc, ns.toUnsortedArray())
    };
  };
  PathExpr.applyLocationPath = function (locationPath, xpc, nodes) {
    if (!locationPath) {
      return nodes;
    }
    var startNodes = locationPath.absolute ? [PathExpr.getRoot(xpc, nodes)] : nodes;
    return PathExpr.applySteps(locationPath.steps, xpc, startNodes);
  };
  PathExpr.prototype.evaluate = function (c) {
    var xpc = assign(new XPathContext(), c);
    var filterResult = this.applyFilter(c, xpc);
    if ('nonNodes' in filterResult) {
      return filterResult.nonNodes;
    }
    var ns = new XNodeSet();
    ns.addArray(PathExpr.applyLocationPath(this.locationPath, xpc, filterResult.nodes));
    return ns;
  };
  PathExpr.predicateMatches = function (pred, c) {
    var res = pred.evaluate(c);
    return Utilities.instance_of(res, XNumber) ? c.contextPosition === res.numberValue() : res.booleanValue();
  };
  PathExpr.predicateString = function (predicate) {
    return wrap('[', ']', predicate.toString());
  };
  PathExpr.predicatesString = function (predicates) {
    return join('', map(PathExpr.predicateString, predicates));
  };
  PathExpr.prototype.toString = function () {
    if (this.filter != undefined) {
      var filterStr = toString(this.filter);
      if (Utilities.instance_of(this.filter, XString)) {
        return wrap("'", "'", filterStr);
      }
      if (this.filterPredicates != undefined && this.filterPredicates.length) {
        return wrap('(', ')', filterStr) + PathExpr.predicatesString(this.filterPredicates);
      }
      if (this.locationPath != undefined) {
        return filterStr + (this.locationPath.absolute ? '' : '/') + toString(this.locationPath);
      }
      return filterStr;
    }
    return toString(this.locationPath);
  };
  PathExpr.getOwnerElement = function (n) {
    // DOM 2 has ownerElement
    if (n.ownerElement) {
      return n.ownerElement;
    }
    // DOM 1 Internet Explorer can use selectSingleNode (ironically)
    try {
      if (n.selectSingleNode) {
        return n.selectSingleNode("..");
      }
    } catch (e) {}
    // Other DOM 1 implementations must use this egregious search
    var doc = n.nodeType == 9 /*Node.DOCUMENT_NODE*/ ? n : n.ownerDocument;
    var elts = doc.getElementsByTagName("*");
    for (var i = 0; i < elts.length; i++) {
      var elt = elts.item(i);
      var nnm = elt.attributes;
      for (var j = 0; j < nnm.length; j++) {
        var an = nnm.item(j);
        if (an === n) {
          return elt;
        }
      }
    }
    return null;
  };

  // LocationPath //////////////////////////////////////////////////////////////

  LocationPath.prototype = new Object();
  LocationPath.prototype.constructor = LocationPath;
  LocationPath.superclass = Object.prototype;
  function LocationPath(abs, steps) {
    if (arguments.length > 0) {
      this.init(abs, steps);
    }
  }
  LocationPath.prototype.init = function (abs, steps) {
    this.absolute = abs;
    this.steps = steps;
  };
  LocationPath.prototype.toString = function () {
    return (this.absolute ? '/' : '') + map(toString, this.steps).join('/');
  };

  // Step //////////////////////////////////////////////////////////////////////

  Step.prototype = new Object();
  Step.prototype.constructor = Step;
  Step.superclass = Object.prototype;
  function Step(axis, nodetest, preds) {
    if (arguments.length > 0) {
      this.init(axis, nodetest, preds);
    }
  }
  Step.prototype.init = function (axis, nodetest, preds) {
    this.axis = axis;
    this.nodeTest = nodetest;
    this.predicates = preds;
  };
  Step.prototype.toString = function () {
    return Step.STEPNAMES[this.axis] + "::" + this.nodeTest.toString() + PathExpr.predicatesString(this.predicates);
  };
  Step.ANCESTOR = 0;
  Step.ANCESTORORSELF = 1;
  Step.ATTRIBUTE = 2;
  Step.CHILD = 3;
  Step.DESCENDANT = 4;
  Step.DESCENDANTORSELF = 5;
  Step.FOLLOWING = 6;
  Step.FOLLOWINGSIBLING = 7;
  Step.NAMESPACE = 8;
  Step.PARENT = 9;
  Step.PRECEDING = 10;
  Step.PRECEDINGSIBLING = 11;
  Step.SELF = 12;
  Step.STEPNAMES = reduce(function (acc, x) {
    return acc[x[0]] = x[1], acc;
  }, {}, [[Step.ANCESTOR, 'ancestor'], [Step.ANCESTORORSELF, 'ancestor-or-self'], [Step.ATTRIBUTE, 'attribute'], [Step.CHILD, 'child'], [Step.DESCENDANT, 'descendant'], [Step.DESCENDANTORSELF, 'descendant-or-self'], [Step.FOLLOWING, 'following'], [Step.FOLLOWINGSIBLING, 'following-sibling'], [Step.NAMESPACE, 'namespace'], [Step.PARENT, 'parent'], [Step.PRECEDING, 'preceding'], [Step.PRECEDINGSIBLING, 'preceding-sibling'], [Step.SELF, 'self']]);

  // NodeTest //////////////////////////////////////////////////////////////////

  NodeTest.prototype = new Object();
  NodeTest.prototype.constructor = NodeTest;
  NodeTest.superclass = Object.prototype;
  function NodeTest(type, value) {
    if (arguments.length > 0) {
      this.init(type, value);
    }
  }
  NodeTest.prototype.init = function (type, value) {
    this.type = type;
    this.value = value;
  };
  NodeTest.prototype.toString = function () {
    return "<unknown nodetest type>";
  };
  NodeTest.prototype.matches = function (n, xpc) {
    console.warn('unknown node test type');
  };
  NodeTest.NAMETESTANY = 0;
  NodeTest.NAMETESTPREFIXANY = 1;
  NodeTest.NAMETESTQNAME = 2;
  NodeTest.COMMENT = 3;
  NodeTest.TEXT = 4;
  NodeTest.PI = 5;
  NodeTest.NODE = 6;
  NodeTest.isNodeType = function (types) {
    return function (node) {
      return includes(types, node.nodeType);
    };
  };
  NodeTest.makeNodeTestType = function (type, members, ctor) {
    var newType = ctor || function () {};
    newType.prototype = new NodeTest(type);
    newType.prototype.constructor = newType;
    assign(newType.prototype, members);
    return newType;
  };
  // create invariant node test for certain node types
  NodeTest.makeNodeTypeTest = function (type, nodeTypes, stringVal) {
    return new (NodeTest.makeNodeTestType(type, {
      matches: NodeTest.isNodeType(nodeTypes),
      toString: always(stringVal)
    }))();
  };
  NodeTest.hasPrefix = function (node) {
    return node.prefix || (node.nodeName || node.tagName).indexOf(':') !== -1;
  };
  NodeTest.isElementOrAttribute = NodeTest.isNodeType([1, 2]);
  NodeTest.nameSpaceMatches = function (prefix, xpc, n) {
    var nNamespace = n.namespaceURI || '';
    if (!prefix) {
      return !nNamespace || xpc.allowAnyNamespaceForNoPrefix && !NodeTest.hasPrefix(n);
    }
    var ns = xpc.namespaceResolver.getNamespace(prefix, xpc.expressionContextNode);
    if (ns == null) {
      throw new Error("Cannot resolve QName " + prefix);
    }
    return ns === nNamespace;
  };
  NodeTest.localNameMatches = function (localName, xpc, n) {
    var nLocalName = n.localName || n.nodeName;
    return xpc.caseInsensitive ? localName.toLowerCase() === nLocalName.toLowerCase() : localName === nLocalName;
  };
  NodeTest.NameTestPrefixAny = NodeTest.makeNodeTestType(NodeTest.NAMETESTPREFIXANY, {
    matches: function matches(n, xpc) {
      return NodeTest.isElementOrAttribute(n) && NodeTest.nameSpaceMatches(this.prefix, xpc, n);
    },
    toString: function toString() {
      return this.prefix + ":*";
    }
  }, function NameTestPrefixAny(prefix) {
    this.prefix = prefix;
  });
  NodeTest.NameTestQName = NodeTest.makeNodeTestType(NodeTest.NAMETESTQNAME, {
    matches: function matches(n, xpc) {
      return NodeTest.isNodeType([1, 2, XPathNamespace.XPATH_NAMESPACE_NODE])(n) && NodeTest.nameSpaceMatches(this.prefix, xpc, n) && NodeTest.localNameMatches(this.localName, xpc, n);
    },
    toString: function toString() {
      return this.name;
    }
  }, function NameTestQName(name) {
    var nameParts = name.split(':');
    this.name = name;
    this.prefix = nameParts.length > 1 ? nameParts[0] : null;
    this.localName = nameParts[nameParts.length > 1 ? 1 : 0];
  });
  NodeTest.PITest = NodeTest.makeNodeTestType(NodeTest.PI, {
    matches: function matches(n, xpc) {
      return NodeTest.isNodeType([7])(n) && (n.target || n.nodeName) === this.name;
    },
    toString: function toString() {
      return wrap('processing-instruction("', '")', this.name);
    }
  }, function (name) {
    this.name = name;
  });

  // singletons

  // elements, attributes, namespaces
  NodeTest.nameTestAny = NodeTest.makeNodeTypeTest(NodeTest.NAMETESTANY, [1, 2, XPathNamespace.XPATH_NAMESPACE_NODE], '*');
  // text, cdata
  NodeTest.textTest = NodeTest.makeNodeTypeTest(NodeTest.TEXT, [3, 4], 'text()');
  NodeTest.commentTest = NodeTest.makeNodeTypeTest(NodeTest.COMMENT, [8], 'comment()');
  // elements, attributes, text, cdata, PIs, comments, document nodes
  NodeTest.nodeTest = NodeTest.makeNodeTypeTest(NodeTest.NODE, [1, 2, 3, 4, 7, 8, 9], 'node()');
  NodeTest.anyPiTest = NodeTest.makeNodeTypeTest(NodeTest.PI, [7], 'processing-instruction()');

  // VariableReference /////////////////////////////////////////////////////////

  VariableReference.prototype = new Expression();
  VariableReference.prototype.constructor = VariableReference;
  VariableReference.superclass = Expression.prototype;
  function VariableReference(v) {
    if (arguments.length > 0) {
      this.init(v);
    }
  }
  VariableReference.prototype.init = function (v) {
    this.variable = v;
  };
  VariableReference.prototype.toString = function () {
    return "$" + this.variable;
  };
  VariableReference.prototype.evaluate = function (c) {
    var parts = Utilities.resolveQName(this.variable, c.namespaceResolver, c.contextNode, false);
    if (parts[0] == null) {
      throw new Error("Cannot resolve QName " + fn);
    }
    var result = c.variableResolver.getVariable(parts[1], parts[0]);
    if (!result) {
      throw XPathException.fromMessage("Undeclared variable: " + this.toString());
    }
    return result;
  };

  // FunctionCall //////////////////////////////////////////////////////////////

  FunctionCall.prototype = new Expression();
  FunctionCall.prototype.constructor = FunctionCall;
  FunctionCall.superclass = Expression.prototype;
  function FunctionCall(fn, args) {
    if (arguments.length > 0) {
      this.init(fn, args);
    }
  }
  FunctionCall.prototype.init = function (fn, args) {
    this.functionName = fn;
    this.arguments = args;
  };
  FunctionCall.prototype.toString = function () {
    var s = this.functionName + "(";
    for (var i = 0; i < this.arguments.length; i++) {
      if (i > 0) {
        s += ", ";
      }
      s += this.arguments[i].toString();
    }
    return s + ")";
  };
  FunctionCall.prototype.evaluate = function (c) {
    var f = FunctionResolver.getFunctionFromContext(this.functionName, c);
    if (!f) {
      throw new Error("Unknown function " + this.functionName);
    }
    var a = [c].concat(this.arguments);
    return f.apply(c.functionResolver.thisArg, a);
  };

  // Operators /////////////////////////////////////////////////////////////////

  var Operators = new Object();
  Operators.equals = function (l, r) {
    return l.equals(r);
  };
  Operators.notequal = function (l, r) {
    return l.notequal(r);
  };
  Operators.lessthan = function (l, r) {
    return l.lessthan(r);
  };
  Operators.greaterthan = function (l, r) {
    return l.greaterthan(r);
  };
  Operators.lessthanorequal = function (l, r) {
    return l.lessthanorequal(r);
  };
  Operators.greaterthanorequal = function (l, r) {
    return l.greaterthanorequal(r);
  };

  // XString ///////////////////////////////////////////////////////////////////

  XString.prototype = new Expression();
  XString.prototype.constructor = XString;
  XString.superclass = Expression.prototype;
  function XString(s) {
    if (arguments.length > 0) {
      this.init(s);
    }
  }
  XString.prototype.init = function (s) {
    this.str = String(s);
  };
  XString.prototype.toString = function () {
    return this.str;
  };
  XString.prototype.evaluate = function (c) {
    return this;
  };
  XString.prototype.string = function () {
    return this;
  };
  XString.prototype.number = function () {
    return new XNumber(this.str);
  };
  XString.prototype.bool = function () {
    return new XBoolean(this.str);
  };
  XString.prototype.nodeset = function () {
    throw new Error("Cannot convert string to nodeset");
  };
  XString.prototype.stringValue = function () {
    return this.str;
  };
  XString.prototype.numberValue = function () {
    return this.number().numberValue();
  };
  XString.prototype.booleanValue = function () {
    return this.bool().booleanValue();
  };
  XString.prototype.equals = function (r) {
    if (Utilities.instance_of(r, XBoolean)) {
      return this.bool().equals(r);
    }
    if (Utilities.instance_of(r, XNumber)) {
      return this.number().equals(r);
    }
    if (Utilities.instance_of(r, XNodeSet)) {
      return r.compareWithString(this, Operators.equals);
    }
    return new XBoolean(this.str == r.str);
  };
  XString.prototype.notequal = function (r) {
    if (Utilities.instance_of(r, XBoolean)) {
      return this.bool().notequal(r);
    }
    if (Utilities.instance_of(r, XNumber)) {
      return this.number().notequal(r);
    }
    if (Utilities.instance_of(r, XNodeSet)) {
      return r.compareWithString(this, Operators.notequal);
    }
    return new XBoolean(this.str != r.str);
  };
  XString.prototype.lessthan = function (r) {
    return this.number().lessthan(r);
  };
  XString.prototype.greaterthan = function (r) {
    return this.number().greaterthan(r);
  };
  XString.prototype.lessthanorequal = function (r) {
    return this.number().lessthanorequal(r);
  };
  XString.prototype.greaterthanorequal = function (r) {
    return this.number().greaterthanorequal(r);
  };

  // XNumber ///////////////////////////////////////////////////////////////////

  XNumber.prototype = new Expression();
  XNumber.prototype.constructor = XNumber;
  XNumber.superclass = Expression.prototype;
  function XNumber(n) {
    if (arguments.length > 0) {
      this.init(n);
    }
  }
  XNumber.prototype.init = function (n) {
    this.num = typeof n === "string" ? this.parse(n) : Number(n);
  };
  XNumber.prototype.numberFormat = /^\s*-?[0-9]*\.?[0-9]+\s*$/;
  XNumber.prototype.parse = function (s) {
    // XPath representation of numbers is more restrictive than what Number() or parseFloat() allow
    return this.numberFormat.test(s) ? parseFloat(s) : Number.NaN;
  };
  function padSmallNumber(numberStr) {
    var parts = numberStr.split('e-');
    var base = parts[0].replace('.', '');
    var exponent = Number(parts[1]);
    for (var i = 0; i < exponent - 1; i += 1) {
      base = '0' + base;
    }
    return '0.' + base;
  }
  function padLargeNumber(numberStr) {
    var parts = numberStr.split('e');
    var base = parts[0].replace('.', '');
    var exponent = Number(parts[1]);
    var zerosToAppend = exponent + 1 - base.length;
    for (var i = 0; i < zerosToAppend; i += 1) {
      base += '0';
    }
    return base;
  }
  XNumber.prototype.toString = function () {
    var strValue = this.num.toString();
    if (strValue.indexOf('e-') !== -1) {
      return padSmallNumber(strValue);
    }
    if (strValue.indexOf('e') !== -1) {
      return padLargeNumber(strValue);
    }
    return strValue;
  };
  XNumber.prototype.evaluate = function (c) {
    return this;
  };
  XNumber.prototype.string = function () {
    return new XString(this.toString());
  };
  XNumber.prototype.number = function () {
    return this;
  };
  XNumber.prototype.bool = function () {
    return new XBoolean(this.num);
  };
  XNumber.prototype.nodeset = function () {
    throw new Error("Cannot convert number to nodeset");
  };
  XNumber.prototype.stringValue = function () {
    return this.string().stringValue();
  };
  XNumber.prototype.numberValue = function () {
    return this.num;
  };
  XNumber.prototype.booleanValue = function () {
    return this.bool().booleanValue();
  };
  XNumber.prototype.negate = function () {
    return new XNumber(-this.num);
  };
  XNumber.prototype.equals = function (r) {
    if (Utilities.instance_of(r, XBoolean)) {
      return this.bool().equals(r);
    }
    if (Utilities.instance_of(r, XString)) {
      return this.equals(r.number());
    }
    if (Utilities.instance_of(r, XNodeSet)) {
      return r.compareWithNumber(this, Operators.equals);
    }
    return new XBoolean(this.num == r.num);
  };
  XNumber.prototype.notequal = function (r) {
    if (Utilities.instance_of(r, XBoolean)) {
      return this.bool().notequal(r);
    }
    if (Utilities.instance_of(r, XString)) {
      return this.notequal(r.number());
    }
    if (Utilities.instance_of(r, XNodeSet)) {
      return r.compareWithNumber(this, Operators.notequal);
    }
    return new XBoolean(this.num != r.num);
  };
  XNumber.prototype.lessthan = function (r) {
    if (Utilities.instance_of(r, XNodeSet)) {
      return r.compareWithNumber(this, Operators.greaterthan);
    }
    if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
      return this.lessthan(r.number());
    }
    return new XBoolean(this.num < r.num);
  };
  XNumber.prototype.greaterthan = function (r) {
    if (Utilities.instance_of(r, XNodeSet)) {
      return r.compareWithNumber(this, Operators.lessthan);
    }
    if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
      return this.greaterthan(r.number());
    }
    return new XBoolean(this.num > r.num);
  };
  XNumber.prototype.lessthanorequal = function (r) {
    if (Utilities.instance_of(r, XNodeSet)) {
      return r.compareWithNumber(this, Operators.greaterthanorequal);
    }
    if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
      return this.lessthanorequal(r.number());
    }
    return new XBoolean(this.num <= r.num);
  };
  XNumber.prototype.greaterthanorequal = function (r) {
    if (Utilities.instance_of(r, XNodeSet)) {
      return r.compareWithNumber(this, Operators.lessthanorequal);
    }
    if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
      return this.greaterthanorequal(r.number());
    }
    return new XBoolean(this.num >= r.num);
  };
  XNumber.prototype.plus = function (r) {
    return new XNumber(this.num + r.num);
  };
  XNumber.prototype.minus = function (r) {
    return new XNumber(this.num - r.num);
  };
  XNumber.prototype.multiply = function (r) {
    return new XNumber(this.num * r.num);
  };
  XNumber.prototype.div = function (r) {
    return new XNumber(this.num / r.num);
  };
  XNumber.prototype.mod = function (r) {
    return new XNumber(this.num % r.num);
  };

  // XBoolean //////////////////////////////////////////////////////////////////

  XBoolean.prototype = new Expression();
  XBoolean.prototype.constructor = XBoolean;
  XBoolean.superclass = Expression.prototype;
  function XBoolean(b) {
    if (arguments.length > 0) {
      this.init(b);
    }
  }
  XBoolean.prototype.init = function (b) {
    this.b = Boolean(b);
  };
  XBoolean.prototype.toString = function () {
    return this.b.toString();
  };
  XBoolean.prototype.evaluate = function (c) {
    return this;
  };
  XBoolean.prototype.string = function () {
    return new XString(this.b);
  };
  XBoolean.prototype.number = function () {
    return new XNumber(this.b);
  };
  XBoolean.prototype.bool = function () {
    return this;
  };
  XBoolean.prototype.nodeset = function () {
    throw new Error("Cannot convert boolean to nodeset");
  };
  XBoolean.prototype.stringValue = function () {
    return this.string().stringValue();
  };
  XBoolean.prototype.numberValue = function () {
    return this.number().numberValue();
  };
  XBoolean.prototype.booleanValue = function () {
    return this.b;
  };
  XBoolean.prototype.not = function () {
    return new XBoolean(!this.b);
  };
  XBoolean.prototype.equals = function (r) {
    if (Utilities.instance_of(r, XString) || Utilities.instance_of(r, XNumber)) {
      return this.equals(r.bool());
    }
    if (Utilities.instance_of(r, XNodeSet)) {
      return r.compareWithBoolean(this, Operators.equals);
    }
    return new XBoolean(this.b == r.b);
  };
  XBoolean.prototype.notequal = function (r) {
    if (Utilities.instance_of(r, XString) || Utilities.instance_of(r, XNumber)) {
      return this.notequal(r.bool());
    }
    if (Utilities.instance_of(r, XNodeSet)) {
      return r.compareWithBoolean(this, Operators.notequal);
    }
    return new XBoolean(this.b != r.b);
  };
  XBoolean.prototype.lessthan = function (r) {
    return this.number().lessthan(r);
  };
  XBoolean.prototype.greaterthan = function (r) {
    return this.number().greaterthan(r);
  };
  XBoolean.prototype.lessthanorequal = function (r) {
    return this.number().lessthanorequal(r);
  };
  XBoolean.prototype.greaterthanorequal = function (r) {
    return this.number().greaterthanorequal(r);
  };
  XBoolean.true_ = new XBoolean(true);
  XBoolean.false_ = new XBoolean(false);

  // AVLTree ///////////////////////////////////////////////////////////////////

  AVLTree.prototype = new Object();
  AVLTree.prototype.constructor = AVLTree;
  AVLTree.superclass = Object.prototype;
  function AVLTree(n) {
    this.init(n);
  }
  AVLTree.prototype.init = function (n) {
    this.left = null;
    this.right = null;
    this.node = n;
    this.depth = 1;
  };
  AVLTree.prototype.balance = function () {
    var ldepth = this.left == null ? 0 : this.left.depth;
    var rdepth = this.right == null ? 0 : this.right.depth;
    if (ldepth > rdepth + 1) {
      // LR or LL rotation
      var lldepth = this.left.left == null ? 0 : this.left.left.depth;
      var lrdepth = this.left.right == null ? 0 : this.left.right.depth;
      if (lldepth < lrdepth) {
        // LR rotation consists of a RR rotation of the left child
        this.left.rotateRR();
        // plus a LL rotation of this node, which happens anyway
      }

      this.rotateLL();
    } else if (ldepth + 1 < rdepth) {
      // RR or RL rorarion
      var rrdepth = this.right.right == null ? 0 : this.right.right.depth;
      var rldepth = this.right.left == null ? 0 : this.right.left.depth;
      if (rldepth > rrdepth) {
        // RR rotation consists of a LL rotation of the right child
        this.right.rotateLL();
        // plus a RR rotation of this node, which happens anyway
      }

      this.rotateRR();
    }
  };
  AVLTree.prototype.rotateLL = function () {
    // the left side is too long => rotate from the left (_not_ leftwards)
    var nodeBefore = this.node;
    var rightBefore = this.right;
    this.node = this.left.node;
    this.right = this.left;
    this.left = this.left.left;
    this.right.left = this.right.right;
    this.right.right = rightBefore;
    this.right.node = nodeBefore;
    this.right.updateInNewLocation();
    this.updateInNewLocation();
  };
  AVLTree.prototype.rotateRR = function () {
    // the right side is too long => rotate from the right (_not_ rightwards)
    var nodeBefore = this.node;
    var leftBefore = this.left;
    this.node = this.right.node;
    this.left = this.right;
    this.right = this.right.right;
    this.left.right = this.left.left;
    this.left.left = leftBefore;
    this.left.node = nodeBefore;
    this.left.updateInNewLocation();
    this.updateInNewLocation();
  };
  AVLTree.prototype.updateInNewLocation = function () {
    this.getDepthFromChildren();
  };
  AVLTree.prototype.getDepthFromChildren = function () {
    this.depth = this.node == null ? 0 : 1;
    if (this.left != null) {
      this.depth = this.left.depth + 1;
    }
    if (this.right != null && this.depth <= this.right.depth) {
      this.depth = this.right.depth + 1;
    }
  };
  function nodeOrder(n1, n2) {
    if (n1 === n2) {
      return 0;
    }
    if (n1.compareDocumentPosition) {
      var cpos = n1.compareDocumentPosition(n2);
      if (cpos & 0x01) {
        // not in the same document; return an arbitrary result (is there a better way to do this)
        return 1;
      }
      if (cpos & 0x0A) {
        // n2 precedes or contains n1
        return 1;
      }
      if (cpos & 0x14) {
        // n2 follows or is contained by n1
        return -1;
      }
      return 0;
    }
    var d1 = 0,
      d2 = 0;
    for (var m1 = n1; m1 != null; m1 = m1.parentNode || m1.ownerElement) {
      d1++;
    }
    for (var m2 = n2; m2 != null; m2 = m2.parentNode || m2.ownerElement) {
      d2++;
    }

    // step up to same depth
    if (d1 > d2) {
      while (d1 > d2) {
        n1 = n1.parentNode || n1.ownerElement;
        d1--;
      }
      if (n1 === n2) {
        return 1;
      }
    } else if (d2 > d1) {
      while (d2 > d1) {
        n2 = n2.parentNode || n2.ownerElement;
        d2--;
      }
      if (n1 === n2) {
        return -1;
      }
    }
    var n1Par = n1.parentNode || n1.ownerElement,
      n2Par = n2.parentNode || n2.ownerElement;

    // find common parent
    while (n1Par !== n2Par) {
      n1 = n1Par;
      n2 = n2Par;
      n1Par = n1.parentNode || n1.ownerElement;
      n2Par = n2.parentNode || n2.ownerElement;
    }
    var n1isAttr = Utilities.isAttribute(n1);
    var n2isAttr = Utilities.isAttribute(n2);
    if (n1isAttr && !n2isAttr) {
      return -1;
    }
    if (!n1isAttr && n2isAttr) {
      return 1;
    }
    if (n1Par) {
      var cn = n1isAttr ? n1Par.attributes : n1Par.childNodes,
        len = cn.length;
      for (var i = 0; i < len; i += 1) {
        var n = cn[i];
        if (n === n1) {
          return -1;
        }
        if (n === n2) {
          return 1;
        }
      }
    }
    throw new Error('Unexpected: could not determine node order');
  }
  AVLTree.prototype.add = function (n) {
    if (n === this.node) {
      return false;
    }
    var o = nodeOrder(n, this.node);
    var ret = false;
    if (o == -1) {
      if (this.left == null) {
        this.left = new AVLTree(n);
        ret = true;
      } else {
        ret = this.left.add(n);
        if (ret) {
          this.balance();
        }
      }
    } else if (o == 1) {
      if (this.right == null) {
        this.right = new AVLTree(n);
        ret = true;
      } else {
        ret = this.right.add(n);
        if (ret) {
          this.balance();
        }
      }
    }
    if (ret) {
      this.getDepthFromChildren();
    }
    return ret;
  };

  // XNodeSet //////////////////////////////////////////////////////////////////

  XNodeSet.prototype = new Expression();
  XNodeSet.prototype.constructor = XNodeSet;
  XNodeSet.superclass = Expression.prototype;
  function XNodeSet() {
    this.init();
  }
  XNodeSet.prototype.init = function () {
    this.tree = null;
    this.nodes = [];
    this.size = 0;
  };
  XNodeSet.prototype.toString = function () {
    var p = this.first();
    if (p == null) {
      return "";
    }
    return this.stringForNode(p);
  };
  XNodeSet.prototype.evaluate = function (c) {
    return this;
  };
  XNodeSet.prototype.string = function () {
    return new XString(this.toString());
  };
  XNodeSet.prototype.stringValue = function () {
    return this.toString();
  };
  XNodeSet.prototype.number = function () {
    return new XNumber(this.string());
  };
  XNodeSet.prototype.numberValue = function () {
    return Number(this.string());
  };
  XNodeSet.prototype.bool = function () {
    return new XBoolean(this.booleanValue());
  };
  XNodeSet.prototype.booleanValue = function () {
    return !!this.size;
  };
  XNodeSet.prototype.nodeset = function () {
    return this;
  };
  XNodeSet.prototype.stringForNode = function (n) {
    if (n.nodeType == 9 /*Node.DOCUMENT_NODE*/ || n.nodeType == 1 /*Node.ELEMENT_NODE */ || n.nodeType === 11 /*Node.DOCUMENT_FRAGMENT*/) {
      return this.stringForContainerNode(n);
    }
    if (n.nodeType === 2 /* Node.ATTRIBUTE_NODE */) {
      return n.value || n.nodeValue;
    }
    if (n.isNamespaceNode) {
      return n.namespace;
    }
    return n.nodeValue;
  };
  XNodeSet.prototype.stringForContainerNode = function (n) {
    var s = "";
    for (var n2 = n.firstChild; n2 != null; n2 = n2.nextSibling) {
      var nt = n2.nodeType;
      //  Element,    Text,       CDATA,      Document,   Document Fragment
      if (nt === 1 || nt === 3 || nt === 4 || nt === 9 || nt === 11) {
        s += this.stringForNode(n2);
      }
    }
    return s;
  };
  XNodeSet.prototype.buildTree = function () {
    if (!this.tree && this.nodes.length) {
      this.tree = new AVLTree(this.nodes[0]);
      for (var i = 1; i < this.nodes.length; i += 1) {
        this.tree.add(this.nodes[i]);
      }
    }
    return this.tree;
  };
  XNodeSet.prototype.first = function () {
    var p = this.buildTree();
    if (p == null) {
      return null;
    }
    while (p.left != null) {
      p = p.left;
    }
    return p.node;
  };
  XNodeSet.prototype.add = function (n) {
    for (var i = 0; i < this.nodes.length; i += 1) {
      if (n === this.nodes[i]) {
        return;
      }
    }
    this.tree = null;
    this.nodes.push(n);
    this.size += 1;
  };
  XNodeSet.prototype.addArray = function (ns) {
    var self = this;
    forEach(function (x) {
      self.add(x);
    }, ns);
  };

  /**
   * Returns an array of the node set's contents in document order
   */
  XNodeSet.prototype.toArray = function () {
    var a = [];
    this.toArrayRec(this.buildTree(), a);
    return a;
  };
  XNodeSet.prototype.toArrayRec = function (t, a) {
    if (t != null) {
      this.toArrayRec(t.left, a);
      a.push(t.node);
      this.toArrayRec(t.right, a);
    }
  };

  /**
   * Returns an array of the node set's contents in arbitrary order
   */
  XNodeSet.prototype.toUnsortedArray = function () {
    return this.nodes.slice();
  };
  XNodeSet.prototype.compareWithString = function (r, o) {
    var a = this.toUnsortedArray();
    for (var i = 0; i < a.length; i++) {
      var n = a[i];
      var l = new XString(this.stringForNode(n));
      var res = o(l, r);
      if (res.booleanValue()) {
        return res;
      }
    }
    return new XBoolean(false);
  };
  XNodeSet.prototype.compareWithNumber = function (r, o) {
    var a = this.toUnsortedArray();
    for (var i = 0; i < a.length; i++) {
      var n = a[i];
      var l = new XNumber(this.stringForNode(n));
      var res = o(l, r);
      if (res.booleanValue()) {
        return res;
      }
    }
    return new XBoolean(false);
  };
  XNodeSet.prototype.compareWithBoolean = function (r, o) {
    return o(this.bool(), r);
  };
  XNodeSet.prototype.compareWithNodeSet = function (r, o) {
    var arr = this.toUnsortedArray();
    var oInvert = function oInvert(lop, rop) {
      return o(rop, lop);
    };
    for (var i = 0; i < arr.length; i++) {
      var l = new XString(this.stringForNode(arr[i]));
      var res = r.compareWithString(l, oInvert);
      if (res.booleanValue()) {
        return res;
      }
    }
    return new XBoolean(false);
  };
  XNodeSet.compareWith = curry(function (o, r) {
    if (Utilities.instance_of(r, XString)) {
      return this.compareWithString(r, o);
    }
    if (Utilities.instance_of(r, XNumber)) {
      return this.compareWithNumber(r, o);
    }
    if (Utilities.instance_of(r, XBoolean)) {
      return this.compareWithBoolean(r, o);
    }
    return this.compareWithNodeSet(r, o);
  });
  XNodeSet.prototype.equals = XNodeSet.compareWith(Operators.equals);
  XNodeSet.prototype.notequal = XNodeSet.compareWith(Operators.notequal);
  XNodeSet.prototype.lessthan = XNodeSet.compareWith(Operators.lessthan);
  XNodeSet.prototype.greaterthan = XNodeSet.compareWith(Operators.greaterthan);
  XNodeSet.prototype.lessthanorequal = XNodeSet.compareWith(Operators.lessthanorequal);
  XNodeSet.prototype.greaterthanorequal = XNodeSet.compareWith(Operators.greaterthanorequal);
  XNodeSet.prototype.union = function (r) {
    var ns = new XNodeSet();
    ns.addArray(this.toUnsortedArray());
    ns.addArray(r.toUnsortedArray());
    return ns;
  };

  // XPathNamespace ////////////////////////////////////////////////////////////

  XPathNamespace.prototype = new Object();
  XPathNamespace.prototype.constructor = XPathNamespace;
  XPathNamespace.superclass = Object.prototype;
  function XPathNamespace(pre, ns, p) {
    this.isXPathNamespace = true;
    this.ownerDocument = p.ownerDocument;
    this.nodeName = "#namespace";
    this.prefix = pre;
    this.localName = pre;
    this.namespaceURI = ns;
    this.nodeValue = ns;
    this.ownerElement = p;
    this.nodeType = XPathNamespace.XPATH_NAMESPACE_NODE;
  }
  XPathNamespace.prototype.toString = function () {
    return "{ \"" + this.prefix + "\", \"" + this.namespaceURI + "\" }";
  };

  // XPathContext //////////////////////////////////////////////////////////////

  XPathContext.prototype = new Object();
  XPathContext.prototype.constructor = XPathContext;
  XPathContext.superclass = Object.prototype;
  function XPathContext(vr, nr, fr) {
    this.variableResolver = vr != null ? vr : new VariableResolver();
    this.namespaceResolver = nr != null ? nr : new NamespaceResolver();
    this.functionResolver = fr != null ? fr : new FunctionResolver();
  }
  XPathContext.prototype.extend = function (newProps) {
    return assign(new XPathContext(), this, newProps);
  };

  // VariableResolver //////////////////////////////////////////////////////////

  VariableResolver.prototype = new Object();
  VariableResolver.prototype.constructor = VariableResolver;
  VariableResolver.superclass = Object.prototype;
  function VariableResolver() {}
  VariableResolver.prototype.getVariable = function (ln, ns) {
    return null;
  };

  // FunctionResolver //////////////////////////////////////////////////////////

  FunctionResolver.prototype = new Object();
  FunctionResolver.prototype.constructor = FunctionResolver;
  FunctionResolver.superclass = Object.prototype;
  function FunctionResolver(thisArg) {
    this.thisArg = thisArg != null ? thisArg : Functions;
    this.functions = new Object();
    this.addStandardFunctions();
  }
  FunctionResolver.prototype.addStandardFunctions = function () {
    this.functions["{}last"] = Functions.last;
    this.functions["{}position"] = Functions.position;
    this.functions["{}count"] = Functions.count;
    this.functions["{}id"] = Functions.id;
    this.functions["{}local-name"] = Functions.localName;
    this.functions["{}namespace-uri"] = Functions.namespaceURI;
    this.functions["{}name"] = Functions.name;
    this.functions["{}string"] = Functions.string;
    this.functions["{}concat"] = Functions.concat;
    this.functions["{}starts-with"] = Functions.startsWith;
    this.functions["{}contains"] = Functions.contains;
    this.functions["{}substring-before"] = Functions.substringBefore;
    this.functions["{}substring-after"] = Functions.substringAfter;
    this.functions["{}substring"] = Functions.substring;
    this.functions["{}string-length"] = Functions.stringLength;
    this.functions["{}normalize-space"] = Functions.normalizeSpace;
    this.functions["{}translate"] = Functions.translate;
    this.functions["{}boolean"] = Functions.boolean_;
    this.functions["{}not"] = Functions.not;
    this.functions["{}true"] = Functions.true_;
    this.functions["{}false"] = Functions.false_;
    this.functions["{}lang"] = Functions.lang;
    this.functions["{}number"] = Functions.number;
    this.functions["{}sum"] = Functions.sum;
    this.functions["{}floor"] = Functions.floor;
    this.functions["{}ceiling"] = Functions.ceiling;
    this.functions["{}round"] = Functions.round;
  };
  FunctionResolver.prototype.addFunction = function (ns, ln, f) {
    this.functions["{" + ns + "}" + ln] = f;
  };
  FunctionResolver.getFunctionFromContext = function (qName, context) {
    var parts = Utilities.resolveQName(qName, context.namespaceResolver, context.contextNode, false);
    if (parts[0] === null) {
      throw new Error("Cannot resolve QName " + name);
    }
    return context.functionResolver.getFunction(parts[1], parts[0]);
  };
  FunctionResolver.prototype.getFunction = function (localName, namespace) {
    return this.functions["{" + namespace + "}" + localName];
  };

  // NamespaceResolver /////////////////////////////////////////////////////////

  NamespaceResolver.prototype = new Object();
  NamespaceResolver.prototype.constructor = NamespaceResolver;
  NamespaceResolver.superclass = Object.prototype;
  function NamespaceResolver() {}
  NamespaceResolver.prototype.getNamespace = function (prefix, n) {
    if (prefix == "xml") {
      return XPath.XML_NAMESPACE_URI;
    } else if (prefix == "xmlns") {
      return XPath.XMLNS_NAMESPACE_URI;
    }
    if (n.nodeType == 9 /*Node.DOCUMENT_NODE*/) {
      n = n.documentElement;
    } else if (n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {
      n = PathExpr.getOwnerElement(n);
    } else if (n.nodeType != 1 /*Node.ELEMENT_NODE*/) {
      n = n.parentNode;
    }
    while (n != null && n.nodeType == 1 /*Node.ELEMENT_NODE*/) {
      var nnm = n.attributes;
      for (var i = 0; i < nnm.length; i++) {
        var a = nnm.item(i);
        var aname = a.name || a.nodeName;
        if (aname === "xmlns" && prefix === "" || aname === "xmlns:" + prefix) {
          return String(a.value || a.nodeValue);
        }
      }
      n = n.parentNode;
    }
    return null;
  };

  // Functions /////////////////////////////////////////////////////////////////

  var Functions = new Object();
  Functions.last = function (c) {
    if (arguments.length != 1) {
      throw new Error("Function last expects ()");
    }
    return new XNumber(c.contextSize);
  };
  Functions.position = function (c) {
    if (arguments.length != 1) {
      throw new Error("Function position expects ()");
    }
    return new XNumber(c.contextPosition);
  };
  Functions.count = function () {
    var c = arguments[0];
    var ns;
    if (arguments.length != 2 || !Utilities.instance_of(ns = arguments[1].evaluate(c), XNodeSet)) {
      throw new Error("Function count expects (node-set)");
    }
    return new XNumber(ns.size);
  };
  Functions.id = function () {
    var c = arguments[0];
    var id;
    if (arguments.length != 2) {
      throw new Error("Function id expects (object)");
    }
    id = arguments[1].evaluate(c);
    if (Utilities.instance_of(id, XNodeSet)) {
      id = id.toArray().join(" ");
    } else {
      id = id.stringValue();
    }
    var ids = id.split(/[\x0d\x0a\x09\x20]+/);
    var count = 0;
    var ns = new XNodeSet();
    var doc = c.contextNode.nodeType == 9 /*Node.DOCUMENT_NODE*/ ? c.contextNode : c.contextNode.ownerDocument;
    for (var i = 0; i < ids.length; i++) {
      var n;
      if (doc.getElementById) {
        n = doc.getElementById(ids[i]);
      } else {
        n = Utilities.getElementById(doc, ids[i]);
      }
      if (n != null) {
        ns.add(n);
        count++;
      }
    }
    return ns;
  };
  Functions.localName = function (c, eNode) {
    var n;
    if (arguments.length == 1) {
      n = c.contextNode;
    } else if (arguments.length == 2) {
      n = eNode.evaluate(c).first();
    } else {
      throw new Error("Function local-name expects (node-set?)");
    }
    if (n == null) {
      return new XString("");
    }
    return new XString(n.localName ||
    //  standard elements and attributes
    n.baseName ||
    //  IE
    n.target ||
    //  processing instructions
    n.nodeName ||
    //  DOM1 elements
    "" //  fallback
    );
  };

  Functions.namespaceURI = function () {
    var c = arguments[0];
    var n;
    if (arguments.length == 1) {
      n = c.contextNode;
    } else if (arguments.length == 2) {
      n = arguments[1].evaluate(c).first();
    } else {
      throw new Error("Function namespace-uri expects (node-set?)");
    }
    if (n == null) {
      return new XString("");
    }
    return new XString(n.namespaceURI);
  };
  Functions.name = function () {
    var c = arguments[0];
    var n;
    if (arguments.length == 1) {
      n = c.contextNode;
    } else if (arguments.length == 2) {
      n = arguments[1].evaluate(c).first();
    } else {
      throw new Error("Function name expects (node-set?)");
    }
    if (n == null) {
      return new XString("");
    }
    if (n.nodeType == 1 /*Node.ELEMENT_NODE*/) {
      return new XString(n.nodeName);
    } else if (n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {
      return new XString(n.name || n.nodeName);
    } else if (n.nodeType === 7 /*Node.PROCESSING_INSTRUCTION_NODE*/) {
      return new XString(n.target || n.nodeName);
    } else if (n.localName == null) {
      return new XString("");
    } else {
      return new XString(n.localName);
    }
  };
  Functions.string = function () {
    var c = arguments[0];
    if (arguments.length == 1) {
      return new XString(XNodeSet.prototype.stringForNode(c.contextNode));
    } else if (arguments.length == 2) {
      return arguments[1].evaluate(c).string();
    }
    throw new Error("Function string expects (object?)");
  };
  Functions.concat = function (c) {
    if (arguments.length < 3) {
      throw new Error("Function concat expects (string, string[, string]*)");
    }
    var s = "";
    for (var i = 1; i < arguments.length; i++) {
      s += arguments[i].evaluate(c).stringValue();
    }
    return new XString(s);
  };
  Functions.startsWith = function () {
    var c = arguments[0];
    if (arguments.length != 3) {
      throw new Error("Function startsWith expects (string, string)");
    }
    var s1 = arguments[1].evaluate(c).stringValue();
    var s2 = arguments[2].evaluate(c).stringValue();
    return new XBoolean(s1.substring(0, s2.length) == s2);
  };
  Functions.contains = function () {
    var c = arguments[0];
    if (arguments.length != 3) {
      throw new Error("Function contains expects (string, string)");
    }
    var s1 = arguments[1].evaluate(c).stringValue();
    var s2 = arguments[2].evaluate(c).stringValue();
    return new XBoolean(s1.indexOf(s2) !== -1);
  };
  Functions.substringBefore = function () {
    var c = arguments[0];
    if (arguments.length != 3) {
      throw new Error("Function substring-before expects (string, string)");
    }
    var s1 = arguments[1].evaluate(c).stringValue();
    var s2 = arguments[2].evaluate(c).stringValue();
    return new XString(s1.substring(0, s1.indexOf(s2)));
  };
  Functions.substringAfter = function () {
    var c = arguments[0];
    if (arguments.length != 3) {
      throw new Error("Function substring-after expects (string, string)");
    }
    var s1 = arguments[1].evaluate(c).stringValue();
    var s2 = arguments[2].evaluate(c).stringValue();
    if (s2.length == 0) {
      return new XString(s1);
    }
    var i = s1.indexOf(s2);
    if (i == -1) {
      return new XString("");
    }
    return new XString(s1.substring(i + s2.length));
  };
  Functions.substring = function () {
    var c = arguments[0];
    if (!(arguments.length == 3 || arguments.length == 4)) {
      throw new Error("Function substring expects (string, number, number?)");
    }
    var s = arguments[1].evaluate(c).stringValue();
    var n1 = Math.round(arguments[2].evaluate(c).numberValue()) - 1;
    var n2 = arguments.length == 4 ? n1 + Math.round(arguments[3].evaluate(c).numberValue()) : undefined;
    return new XString(s.substring(n1, n2));
  };
  Functions.stringLength = function () {
    var c = arguments[0];
    var s;
    if (arguments.length == 1) {
      s = XNodeSet.prototype.stringForNode(c.contextNode);
    } else if (arguments.length == 2) {
      s = arguments[1].evaluate(c).stringValue();
    } else {
      throw new Error("Function string-length expects (string?)");
    }
    return new XNumber(s.length);
  };
  Functions.normalizeSpace = function () {
    var c = arguments[0];
    var s;
    if (arguments.length == 1) {
      s = XNodeSet.prototype.stringForNode(c.contextNode);
    } else if (arguments.length == 2) {
      s = arguments[1].evaluate(c).stringValue();
    } else {
      throw new Error("Function normalize-space expects (string?)");
    }
    var i = 0;
    var j = s.length - 1;
    while (Utilities.isSpace(s.charCodeAt(j))) {
      j--;
    }
    var t = "";
    while (i <= j && Utilities.isSpace(s.charCodeAt(i))) {
      i++;
    }
    while (i <= j) {
      if (Utilities.isSpace(s.charCodeAt(i))) {
        t += " ";
        while (i <= j && Utilities.isSpace(s.charCodeAt(i))) {
          i++;
        }
      } else {
        t += s.charAt(i);
        i++;
      }
    }
    return new XString(t);
  };
  Functions.translate = function (c, eValue, eFrom, eTo) {
    if (arguments.length != 4) {
      throw new Error("Function translate expects (string, string, string)");
    }
    var value = eValue.evaluate(c).stringValue();
    var from = eFrom.evaluate(c).stringValue();
    var to = eTo.evaluate(c).stringValue();
    var cMap = reduce(function (acc, ch, i) {
      if (!(ch in acc)) {
        acc[ch] = i > to.length ? '' : to[i];
      }
      return acc;
    }, {}, from);
    var t = join('', map(function (ch) {
      return ch in cMap ? cMap[ch] : ch;
    }, value));
    return new XString(t);
  };
  Functions.boolean_ = function () {
    var c = arguments[0];
    if (arguments.length != 2) {
      throw new Error("Function boolean expects (object)");
    }
    return arguments[1].evaluate(c).bool();
  };
  Functions.not = function (c, eValue) {
    if (arguments.length != 2) {
      throw new Error("Function not expects (object)");
    }
    return eValue.evaluate(c).bool().not();
  };
  Functions.true_ = function () {
    if (arguments.length != 1) {
      throw new Error("Function true expects ()");
    }
    return XBoolean.true_;
  };
  Functions.false_ = function () {
    if (arguments.length != 1) {
      throw new Error("Function false expects ()");
    }
    return XBoolean.false_;
  };
  Functions.lang = function () {
    var c = arguments[0];
    if (arguments.length != 2) {
      throw new Error("Function lang expects (string)");
    }
    var lang;
    for (var n = c.contextNode; n != null && n.nodeType != 9 /*Node.DOCUMENT_NODE*/; n = n.parentNode) {
      var a = n.getAttributeNS(XPath.XML_NAMESPACE_URI, "lang");
      if (a != null) {
        lang = String(a);
        break;
      }
    }
    if (lang == null) {
      return XBoolean.false_;
    }
    var s = arguments[1].evaluate(c).stringValue();
    return new XBoolean(lang.substring(0, s.length) == s && (lang.length == s.length || lang.charAt(s.length) == '-'));
  };
  Functions.number = function () {
    var c = arguments[0];
    if (!(arguments.length == 1 || arguments.length == 2)) {
      throw new Error("Function number expects (object?)");
    }
    if (arguments.length == 1) {
      return new XNumber(XNodeSet.prototype.stringForNode(c.contextNode));
    }
    return arguments[1].evaluate(c).number();
  };
  Functions.sum = function () {
    var c = arguments[0];
    var ns;
    if (arguments.length != 2 || !Utilities.instance_of(ns = arguments[1].evaluate(c), XNodeSet)) {
      throw new Error("Function sum expects (node-set)");
    }
    ns = ns.toUnsortedArray();
    var n = 0;
    for (var i = 0; i < ns.length; i++) {
      n += new XNumber(XNodeSet.prototype.stringForNode(ns[i])).numberValue();
    }
    return new XNumber(n);
  };
  Functions.floor = function () {
    var c = arguments[0];
    if (arguments.length != 2) {
      throw new Error("Function floor expects (number)");
    }
    return new XNumber(Math.floor(arguments[1].evaluate(c).numberValue()));
  };
  Functions.ceiling = function () {
    var c = arguments[0];
    if (arguments.length != 2) {
      throw new Error("Function ceiling expects (number)");
    }
    return new XNumber(Math.ceil(arguments[1].evaluate(c).numberValue()));
  };
  Functions.round = function () {
    var c = arguments[0];
    if (arguments.length != 2) {
      throw new Error("Function round expects (number)");
    }
    return new XNumber(Math.round(arguments[1].evaluate(c).numberValue()));
  };

  // Utilities /////////////////////////////////////////////////////////////////

  var Utilities = new Object();
  Utilities.isAttribute = function (val) {
    return val && (val.nodeType === 2 || val.ownerElement);
  };
  Utilities.splitQName = function (qn) {
    var i = qn.indexOf(":");
    if (i == -1) {
      return [null, qn];
    }
    return [qn.substring(0, i), qn.substring(i + 1)];
  };
  Utilities.resolveQName = function (qn, nr, n, useDefault) {
    var parts = Utilities.splitQName(qn);
    if (parts[0] != null) {
      parts[0] = nr.getNamespace(parts[0], n);
    } else {
      if (useDefault) {
        parts[0] = nr.getNamespace("", n);
        if (parts[0] == null) {
          parts[0] = "";
        }
      } else {
        parts[0] = "";
      }
    }
    return parts;
  };
  Utilities.isSpace = function (c) {
    return c == 0x9 || c == 0xd || c == 0xa || c == 0x20;
  };
  Utilities.isLetter = function (c) {
    return c >= 0x0041 && c <= 0x005A || c >= 0x0061 && c <= 0x007A || c >= 0x00C0 && c <= 0x00D6 || c >= 0x00D8 && c <= 0x00F6 || c >= 0x00F8 && c <= 0x00FF || c >= 0x0100 && c <= 0x0131 || c >= 0x0134 && c <= 0x013E || c >= 0x0141 && c <= 0x0148 || c >= 0x014A && c <= 0x017E || c >= 0x0180 && c <= 0x01C3 || c >= 0x01CD && c <= 0x01F0 || c >= 0x01F4 && c <= 0x01F5 || c >= 0x01FA && c <= 0x0217 || c >= 0x0250 && c <= 0x02A8 || c >= 0x02BB && c <= 0x02C1 || c == 0x0386 || c >= 0x0388 && c <= 0x038A || c == 0x038C || c >= 0x038E && c <= 0x03A1 || c >= 0x03A3 && c <= 0x03CE || c >= 0x03D0 && c <= 0x03D6 || c == 0x03DA || c == 0x03DC || c == 0x03DE || c == 0x03E0 || c >= 0x03E2 && c <= 0x03F3 || c >= 0x0401 && c <= 0x040C || c >= 0x040E && c <= 0x044F || c >= 0x0451 && c <= 0x045C || c >= 0x045E && c <= 0x0481 || c >= 0x0490 && c <= 0x04C4 || c >= 0x04C7 && c <= 0x04C8 || c >= 0x04CB && c <= 0x04CC || c >= 0x04D0 && c <= 0x04EB || c >= 0x04EE && c <= 0x04F5 || c >= 0x04F8 && c <= 0x04F9 || c >= 0x0531 && c <= 0x0556 || c == 0x0559 || c >= 0x0561 && c <= 0x0586 || c >= 0x05D0 && c <= 0x05EA || c >= 0x05F0 && c <= 0x05F2 || c >= 0x0621 && c <= 0x063A || c >= 0x0641 && c <= 0x064A || c >= 0x0671 && c <= 0x06B7 || c >= 0x06BA && c <= 0x06BE || c >= 0x06C0 && c <= 0x06CE || c >= 0x06D0 && c <= 0x06D3 || c == 0x06D5 || c >= 0x06E5 && c <= 0x06E6 || c >= 0x0905 && c <= 0x0939 || c == 0x093D || c >= 0x0958 && c <= 0x0961 || c >= 0x0985 && c <= 0x098C || c >= 0x098F && c <= 0x0990 || c >= 0x0993 && c <= 0x09A8 || c >= 0x09AA && c <= 0x09B0 || c == 0x09B2 || c >= 0x09B6 && c <= 0x09B9 || c >= 0x09DC && c <= 0x09DD || c >= 0x09DF && c <= 0x09E1 || c >= 0x09F0 && c <= 0x09F1 || c >= 0x0A05 && c <= 0x0A0A || c >= 0x0A0F && c <= 0x0A10 || c >= 0x0A13 && c <= 0x0A28 || c >= 0x0A2A && c <= 0x0A30 || c >= 0x0A32 && c <= 0x0A33 || c >= 0x0A35 && c <= 0x0A36 || c >= 0x0A38 && c <= 0x0A39 || c >= 0x0A59 && c <= 0x0A5C || c == 0x0A5E || c >= 0x0A72 && c <= 0x0A74 || c >= 0x0A85 && c <= 0x0A8B || c == 0x0A8D || c >= 0x0A8F && c <= 0x0A91 || c >= 0x0A93 && c <= 0x0AA8 || c >= 0x0AAA && c <= 0x0AB0 || c >= 0x0AB2 && c <= 0x0AB3 || c >= 0x0AB5 && c <= 0x0AB9 || c == 0x0ABD || c == 0x0AE0 || c >= 0x0B05 && c <= 0x0B0C || c >= 0x0B0F && c <= 0x0B10 || c >= 0x0B13 && c <= 0x0B28 || c >= 0x0B2A && c <= 0x0B30 || c >= 0x0B32 && c <= 0x0B33 || c >= 0x0B36 && c <= 0x0B39 || c == 0x0B3D || c >= 0x0B5C && c <= 0x0B5D || c >= 0x0B5F && c <= 0x0B61 || c >= 0x0B85 && c <= 0x0B8A || c >= 0x0B8E && c <= 0x0B90 || c >= 0x0B92 && c <= 0x0B95 || c >= 0x0B99 && c <= 0x0B9A || c == 0x0B9C || c >= 0x0B9E && c <= 0x0B9F || c >= 0x0BA3 && c <= 0x0BA4 || c >= 0x0BA8 && c <= 0x0BAA || c >= 0x0BAE && c <= 0x0BB5 || c >= 0x0BB7 && c <= 0x0BB9 || c >= 0x0C05 && c <= 0x0C0C || c >= 0x0C0E && c <= 0x0C10 || c >= 0x0C12 && c <= 0x0C28 || c >= 0x0C2A && c <= 0x0C33 || c >= 0x0C35 && c <= 0x0C39 || c >= 0x0C60 && c <= 0x0C61 || c >= 0x0C85 && c <= 0x0C8C || c >= 0x0C8E && c <= 0x0C90 || c >= 0x0C92 && c <= 0x0CA8 || c >= 0x0CAA && c <= 0x0CB3 || c >= 0x0CB5 && c <= 0x0CB9 || c == 0x0CDE || c >= 0x0CE0 && c <= 0x0CE1 || c >= 0x0D05 && c <= 0x0D0C || c >= 0x0D0E && c <= 0x0D10 || c >= 0x0D12 && c <= 0x0D28 || c >= 0x0D2A && c <= 0x0D39 || c >= 0x0D60 && c <= 0x0D61 || c >= 0x0E01 && c <= 0x0E2E || c == 0x0E30 || c >= 0x0E32 && c <= 0x0E33 || c >= 0x0E40 && c <= 0x0E45 || c >= 0x0E81 && c <= 0x0E82 || c == 0x0E84 || c >= 0x0E87 && c <= 0x0E88 || c == 0x0E8A || c == 0x0E8D || c >= 0x0E94 && c <= 0x0E97 || c >= 0x0E99 && c <= 0x0E9F || c >= 0x0EA1 && c <= 0x0EA3 || c == 0x0EA5 || c == 0x0EA7 || c >= 0x0EAA && c <= 0x0EAB || c >= 0x0EAD && c <= 0x0EAE || c == 0x0EB0 || c >= 0x0EB2 && c <= 0x0EB3 || c == 0x0EBD || c >= 0x0EC0 && c <= 0x0EC4 || c >= 0x0F40 && c <= 0x0F47 || c >= 0x0F49 && c <= 0x0F69 || c >= 0x10A0 && c <= 0x10C5 || c >= 0x10D0 && c <= 0x10F6 || c == 0x1100 || c >= 0x1102 && c <= 0x1103 || c >= 0x1105 && c <= 0x1107 || c == 0x1109 || c >= 0x110B && c <= 0x110C || c >= 0x110E && c <= 0x1112 || c == 0x113C || c == 0x113E || c == 0x1140 || c == 0x114C || c == 0x114E || c == 0x1150 || c >= 0x1154 && c <= 0x1155 || c == 0x1159 || c >= 0x115F && c <= 0x1161 || c == 0x1163 || c == 0x1165 || c == 0x1167 || c == 0x1169 || c >= 0x116D && c <= 0x116E || c >= 0x1172 && c <= 0x1173 || c == 0x1175 || c == 0x119E || c == 0x11A8 || c == 0x11AB || c >= 0x11AE && c <= 0x11AF || c >= 0x11B7 && c <= 0x11B8 || c == 0x11BA || c >= 0x11BC && c <= 0x11C2 || c == 0x11EB || c == 0x11F0 || c == 0x11F9 || c >= 0x1E00 && c <= 0x1E9B || c >= 0x1EA0 && c <= 0x1EF9 || c >= 0x1F00 && c <= 0x1F15 || c >= 0x1F18 && c <= 0x1F1D || c >= 0x1F20 && c <= 0x1F45 || c >= 0x1F48 && c <= 0x1F4D || c >= 0x1F50 && c <= 0x1F57 || c == 0x1F59 || c == 0x1F5B || c == 0x1F5D || c >= 0x1F5F && c <= 0x1F7D || c >= 0x1F80 && c <= 0x1FB4 || c >= 0x1FB6 && c <= 0x1FBC || c == 0x1FBE || c >= 0x1FC2 && c <= 0x1FC4 || c >= 0x1FC6 && c <= 0x1FCC || c >= 0x1FD0 && c <= 0x1FD3 || c >= 0x1FD6 && c <= 0x1FDB || c >= 0x1FE0 && c <= 0x1FEC || c >= 0x1FF2 && c <= 0x1FF4 || c >= 0x1FF6 && c <= 0x1FFC || c == 0x2126 || c >= 0x212A && c <= 0x212B || c == 0x212E || c >= 0x2180 && c <= 0x2182 || c >= 0x3041 && c <= 0x3094 || c >= 0x30A1 && c <= 0x30FA || c >= 0x3105 && c <= 0x312C || c >= 0xAC00 && c <= 0xD7A3 || c >= 0x4E00 && c <= 0x9FA5 || c == 0x3007 || c >= 0x3021 && c <= 0x3029;
  };
  Utilities.isNCNameChar = function (c) {
    return c >= 0x0030 && c <= 0x0039 || c >= 0x0660 && c <= 0x0669 || c >= 0x06F0 && c <= 0x06F9 || c >= 0x0966 && c <= 0x096F || c >= 0x09E6 && c <= 0x09EF || c >= 0x0A66 && c <= 0x0A6F || c >= 0x0AE6 && c <= 0x0AEF || c >= 0x0B66 && c <= 0x0B6F || c >= 0x0BE7 && c <= 0x0BEF || c >= 0x0C66 && c <= 0x0C6F || c >= 0x0CE6 && c <= 0x0CEF || c >= 0x0D66 && c <= 0x0D6F || c >= 0x0E50 && c <= 0x0E59 || c >= 0x0ED0 && c <= 0x0ED9 || c >= 0x0F20 && c <= 0x0F29 || c == 0x002E || c == 0x002D || c == 0x005F || Utilities.isLetter(c) || c >= 0x0300 && c <= 0x0345 || c >= 0x0360 && c <= 0x0361 || c >= 0x0483 && c <= 0x0486 || c >= 0x0591 && c <= 0x05A1 || c >= 0x05A3 && c <= 0x05B9 || c >= 0x05BB && c <= 0x05BD || c == 0x05BF || c >= 0x05C1 && c <= 0x05C2 || c == 0x05C4 || c >= 0x064B && c <= 0x0652 || c == 0x0670 || c >= 0x06D6 && c <= 0x06DC || c >= 0x06DD && c <= 0x06DF || c >= 0x06E0 && c <= 0x06E4 || c >= 0x06E7 && c <= 0x06E8 || c >= 0x06EA && c <= 0x06ED || c >= 0x0901 && c <= 0x0903 || c == 0x093C || c >= 0x093E && c <= 0x094C || c == 0x094D || c >= 0x0951 && c <= 0x0954 || c >= 0x0962 && c <= 0x0963 || c >= 0x0981 && c <= 0x0983 || c == 0x09BC || c == 0x09BE || c == 0x09BF || c >= 0x09C0 && c <= 0x09C4 || c >= 0x09C7 && c <= 0x09C8 || c >= 0x09CB && c <= 0x09CD || c == 0x09D7 || c >= 0x09E2 && c <= 0x09E3 || c == 0x0A02 || c == 0x0A3C || c == 0x0A3E || c == 0x0A3F || c >= 0x0A40 && c <= 0x0A42 || c >= 0x0A47 && c <= 0x0A48 || c >= 0x0A4B && c <= 0x0A4D || c >= 0x0A70 && c <= 0x0A71 || c >= 0x0A81 && c <= 0x0A83 || c == 0x0ABC || c >= 0x0ABE && c <= 0x0AC5 || c >= 0x0AC7 && c <= 0x0AC9 || c >= 0x0ACB && c <= 0x0ACD || c >= 0x0B01 && c <= 0x0B03 || c == 0x0B3C || c >= 0x0B3E && c <= 0x0B43 || c >= 0x0B47 && c <= 0x0B48 || c >= 0x0B4B && c <= 0x0B4D || c >= 0x0B56 && c <= 0x0B57 || c >= 0x0B82 && c <= 0x0B83 || c >= 0x0BBE && c <= 0x0BC2 || c >= 0x0BC6 && c <= 0x0BC8 || c >= 0x0BCA && c <= 0x0BCD || c == 0x0BD7 || c >= 0x0C01 && c <= 0x0C03 || c >= 0x0C3E && c <= 0x0C44 || c >= 0x0C46 && c <= 0x0C48 || c >= 0x0C4A && c <= 0x0C4D || c >= 0x0C55 && c <= 0x0C56 || c >= 0x0C82 && c <= 0x0C83 || c >= 0x0CBE && c <= 0x0CC4 || c >= 0x0CC6 && c <= 0x0CC8 || c >= 0x0CCA && c <= 0x0CCD || c >= 0x0CD5 && c <= 0x0CD6 || c >= 0x0D02 && c <= 0x0D03 || c >= 0x0D3E && c <= 0x0D43 || c >= 0x0D46 && c <= 0x0D48 || c >= 0x0D4A && c <= 0x0D4D || c == 0x0D57 || c == 0x0E31 || c >= 0x0E34 && c <= 0x0E3A || c >= 0x0E47 && c <= 0x0E4E || c == 0x0EB1 || c >= 0x0EB4 && c <= 0x0EB9 || c >= 0x0EBB && c <= 0x0EBC || c >= 0x0EC8 && c <= 0x0ECD || c >= 0x0F18 && c <= 0x0F19 || c == 0x0F35 || c == 0x0F37 || c == 0x0F39 || c == 0x0F3E || c == 0x0F3F || c >= 0x0F71 && c <= 0x0F84 || c >= 0x0F86 && c <= 0x0F8B || c >= 0x0F90 && c <= 0x0F95 || c == 0x0F97 || c >= 0x0F99 && c <= 0x0FAD || c >= 0x0FB1 && c <= 0x0FB7 || c == 0x0FB9 || c >= 0x20D0 && c <= 0x20DC || c == 0x20E1 || c >= 0x302A && c <= 0x302F || c == 0x3099 || c == 0x309A || c == 0x00B7 || c == 0x02D0 || c == 0x02D1 || c == 0x0387 || c == 0x0640 || c == 0x0E46 || c == 0x0EC6 || c == 0x3005 || c >= 0x3031 && c <= 0x3035 || c >= 0x309D && c <= 0x309E || c >= 0x30FC && c <= 0x30FE;
  };
  Utilities.coalesceText = function (n) {
    for (var m = n.firstChild; m != null; m = m.nextSibling) {
      if (m.nodeType == 3 /*Node.TEXT_NODE*/ || m.nodeType == 4 /*Node.CDATA_SECTION_NODE*/) {
        var s = m.nodeValue;
        var first = m;
        m = m.nextSibling;
        while (m != null && (m.nodeType == 3 /*Node.TEXT_NODE*/ || m.nodeType == 4 /*Node.CDATA_SECTION_NODE*/)) {
          s += m.nodeValue;
          var del = m;
          m = m.nextSibling;
          del.parentNode.removeChild(del);
        }
        if (first.nodeType == 4 /*Node.CDATA_SECTION_NODE*/) {
          var p = first.parentNode;
          if (first.nextSibling == null) {
            p.removeChild(first);
            p.appendChild(p.ownerDocument.createTextNode(s));
          } else {
            var next = first.nextSibling;
            p.removeChild(first);
            p.insertBefore(p.ownerDocument.createTextNode(s), next);
          }
        } else {
          first.nodeValue = s;
        }
        if (m == null) {
          break;
        }
      } else if (m.nodeType == 1 /*Node.ELEMENT_NODE*/) {
        Utilities.coalesceText(m);
      }
    }
  };
  Utilities.instance_of = function (o, c) {
    while (o != null) {
      if (o.constructor === c) {
        return true;
      }
      if (o === Object) {
        return false;
      }
      o = o.constructor.superclass;
    }
    return false;
  };
  Utilities.getElementById = function (n, id) {
    // Note that this does not check the DTD to check for actual
    // attributes of type ID, so this may be a bit wrong.
    if (n.nodeType == 1 /*Node.ELEMENT_NODE*/) {
      if (n.getAttribute("id") == id || n.getAttributeNS(null, "id") == id) {
        return n;
      }
    }
    for (var m = n.firstChild; m != null; m = m.nextSibling) {
      var res = Utilities.getElementById(m, id);
      if (res != null) {
        return res;
      }
    }
    return null;
  };

  // XPathException ////////////////////////////////////////////////////////////

  var XPathException = function () {
    function getMessage(code, exception) {
      var msg = exception ? ": " + exception.toString() : "";
      switch (code) {
        case XPathException.INVALID_EXPRESSION_ERR:
          return "Invalid expression" + msg;
        case XPathException.TYPE_ERR:
          return "Type error" + msg;
      }
      return null;
    }
    function XPathException(code, error, message) {
      var err = Error.call(this, getMessage(code, error) || message);
      err.code = code;
      err.exception = error;
      return err;
    }
    XPathException.prototype = Object.create(Error.prototype);
    XPathException.prototype.constructor = XPathException;
    XPathException.superclass = Error;
    XPathException.prototype.toString = function () {
      return this.message;
    };
    XPathException.fromMessage = function (message, error) {
      return new XPathException(null, error, message);
    };
    XPathException.INVALID_EXPRESSION_ERR = 51;
    XPathException.TYPE_ERR = 52;
    return XPathException;
  }();

  // XPathExpression ///////////////////////////////////////////////////////////

  XPathExpression.prototype = {};
  XPathExpression.prototype.constructor = XPathExpression;
  XPathExpression.superclass = Object.prototype;
  function XPathExpression(e, r, p) {
    this.xpath = p.parse(e);
    this.context = new XPathContext();
    this.context.namespaceResolver = new XPathNSResolverWrapper(r);
  }
  XPathExpression.getOwnerDocument = function (n) {
    return n.nodeType === 9 /*Node.DOCUMENT_NODE*/ ? n : n.ownerDocument;
  };
  XPathExpression.detectHtmlDom = function (n) {
    if (!n) {
      return false;
    }
    var doc = XPathExpression.getOwnerDocument(n);
    try {
      return doc.implementation.hasFeature("HTML", "2.0");
    } catch (e) {
      return true;
    }
  };
  XPathExpression.prototype.evaluate = function (n, t, res) {
    this.context.expressionContextNode = n;
    // backward compatibility - no reliable way to detect whether the DOM is HTML, but
    // this library has been using this method up until now, so we will continue to use it
    // ONLY when using an XPathExpression
    this.context.caseInsensitive = XPathExpression.detectHtmlDom(n);
    var result = this.xpath.evaluate(this.context);
    return new XPathResult(result, t);
  };

  // XPathNSResolverWrapper ////////////////////////////////////////////////////

  XPathNSResolverWrapper.prototype = {};
  XPathNSResolverWrapper.prototype.constructor = XPathNSResolverWrapper;
  XPathNSResolverWrapper.superclass = Object.prototype;
  function XPathNSResolverWrapper(r) {
    this.xpathNSResolver = r;
  }
  XPathNSResolverWrapper.prototype.getNamespace = function (prefix, n) {
    if (this.xpathNSResolver == null) {
      return null;
    }
    return this.xpathNSResolver.lookupNamespaceURI(prefix);
  };

  // NodeXPathNSResolver ///////////////////////////////////////////////////////

  NodeXPathNSResolver.prototype = {};
  NodeXPathNSResolver.prototype.constructor = NodeXPathNSResolver;
  NodeXPathNSResolver.superclass = Object.prototype;
  function NodeXPathNSResolver(n) {
    this.node = n;
    this.namespaceResolver = new NamespaceResolver();
  }
  NodeXPathNSResolver.prototype.lookupNamespaceURI = function (prefix) {
    return this.namespaceResolver.getNamespace(prefix, this.node);
  };

  // XPathResult ///////////////////////////////////////////////////////////////

  XPathResult.prototype = {};
  XPathResult.prototype.constructor = XPathResult;
  XPathResult.superclass = Object.prototype;
  function XPathResult(v, t) {
    if (t == XPathResult.ANY_TYPE) {
      if (v.constructor === XString) {
        t = XPathResult.STRING_TYPE;
      } else if (v.constructor === XNumber) {
        t = XPathResult.NUMBER_TYPE;
      } else if (v.constructor === XBoolean) {
        t = XPathResult.BOOLEAN_TYPE;
      } else if (v.constructor === XNodeSet) {
        t = XPathResult.UNORDERED_NODE_ITERATOR_TYPE;
      }
    }
    this.resultType = t;
    switch (t) {
      case XPathResult.NUMBER_TYPE:
        this.numberValue = v.numberValue();
        return;
      case XPathResult.STRING_TYPE:
        this.stringValue = v.stringValue();
        return;
      case XPathResult.BOOLEAN_TYPE:
        this.booleanValue = v.booleanValue();
        return;
      case XPathResult.ANY_UNORDERED_NODE_TYPE:
      case XPathResult.FIRST_ORDERED_NODE_TYPE:
        if (v.constructor === XNodeSet) {
          this.singleNodeValue = v.first();
          return;
        }
        break;
      case XPathResult.UNORDERED_NODE_ITERATOR_TYPE:
      case XPathResult.ORDERED_NODE_ITERATOR_TYPE:
        if (v.constructor === XNodeSet) {
          this.invalidIteratorState = false;
          this.nodes = v.toArray();
          this.iteratorIndex = 0;
          return;
        }
        break;
      case XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE:
      case XPathResult.ORDERED_NODE_SNAPSHOT_TYPE:
        if (v.constructor === XNodeSet) {
          this.nodes = v.toArray();
          this.snapshotLength = this.nodes.length;
          return;
        }
        break;
    }
    throw new XPathException(XPathException.TYPE_ERR);
  }
  ;
  XPathResult.prototype.iterateNext = function () {
    if (this.resultType != XPathResult.UNORDERED_NODE_ITERATOR_TYPE && this.resultType != XPathResult.ORDERED_NODE_ITERATOR_TYPE) {
      throw new XPathException(XPathException.TYPE_ERR);
    }
    return this.nodes[this.iteratorIndex++];
  };
  XPathResult.prototype.snapshotItem = function (i) {
    if (this.resultType != XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE && this.resultType != XPathResult.ORDERED_NODE_SNAPSHOT_TYPE) {
      throw new XPathException(XPathException.TYPE_ERR);
    }
    return this.nodes[i];
  };
  XPathResult.ANY_TYPE = 0;
  XPathResult.NUMBER_TYPE = 1;
  XPathResult.STRING_TYPE = 2;
  XPathResult.BOOLEAN_TYPE = 3;
  XPathResult.UNORDERED_NODE_ITERATOR_TYPE = 4;
  XPathResult.ORDERED_NODE_ITERATOR_TYPE = 5;
  XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE = 6;
  XPathResult.ORDERED_NODE_SNAPSHOT_TYPE = 7;
  XPathResult.ANY_UNORDERED_NODE_TYPE = 8;
  XPathResult.FIRST_ORDERED_NODE_TYPE = 9;

  // DOM 3 XPath support ///////////////////////////////////////////////////////

  function installDOM3XPathSupport(doc, p) {
    doc.createExpression = function (e, r) {
      try {
        return new XPathExpression(e, r, p);
      } catch (e) {
        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, e);
      }
    };
    doc.createNSResolver = function (n) {
      return new NodeXPathNSResolver(n);
    };
    doc.evaluate = function (e, cn, r, t, res) {
      if (t < 0 || t > 9) {
        throw {
          code: 0,
          toString: function toString() {
            return "Request type not supported";
          }
        };
      }
      return doc.createExpression(e, r, p).evaluate(cn, t, res);
    };
  }
  ;

  // ---------------------------------------------------------------------------

  // Install DOM 3 XPath support for the current document.
  try {
    var shouldInstall = true;
    try {
      if (document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("XPath", null)) {
        shouldInstall = false;
      }
    } catch (e) {}
    if (shouldInstall) {
      installDOM3XPathSupport(document, new XPathParser());
    }
  } catch (e) {}

  // ---------------------------------------------------------------------------
  // exports for node.js

  installDOM3XPathSupport(exports, new XPathParser());
  (function () {
    var parser = new XPathParser();
    var defaultNSResolver = new NamespaceResolver();
    var defaultFunctionResolver = new FunctionResolver();
    var defaultVariableResolver = new VariableResolver();
    function makeNSResolverFromFunction(func) {
      return {
        getNamespace: function getNamespace(prefix, node) {
          var ns = func(prefix, node);
          return ns || defaultNSResolver.getNamespace(prefix, node);
        }
      };
    }
    function makeNSResolverFromObject(obj) {
      return makeNSResolverFromFunction(obj.getNamespace.bind(obj));
    }
    function makeNSResolverFromMap(map) {
      return makeNSResolverFromFunction(function (prefix) {
        return map[prefix];
      });
    }
    function makeNSResolver(resolver) {
      if (resolver && typeof resolver.getNamespace === "function") {
        return makeNSResolverFromObject(resolver);
      }
      if (typeof resolver === "function") {
        return makeNSResolverFromFunction(resolver);
      }

      // assume prefix -> uri mapping
      if ((0, _typeof2.default)(resolver) === "object") {
        return makeNSResolverFromMap(resolver);
      }
      return defaultNSResolver;
    }

    /** Converts native JavaScript types to their XPath library equivalent */
    function convertValue(value) {
      if (value === null || typeof value === "undefined" || value instanceof XString || value instanceof XBoolean || value instanceof XNumber || value instanceof XNodeSet) {
        return value;
      }
      switch ((0, _typeof2.default)(value)) {
        case "string":
          return new XString(value);
        case "boolean":
          return new XBoolean(value);
        case "number":
          return new XNumber(value);
      }

      // assume node(s)
      var ns = new XNodeSet();
      ns.addArray([].concat(value));
      return ns;
    }
    function makeEvaluator(func) {
      return function (context) {
        var args = Array.prototype.slice.call(arguments, 1).map(function (arg) {
          return arg.evaluate(context);
        });
        var result = func.apply(this, [].concat(context, args));
        return convertValue(result);
      };
    }
    function makeFunctionResolverFromFunction(func) {
      return {
        getFunction: function getFunction(name, namespace) {
          var found = func(name, namespace);
          if (found) {
            return makeEvaluator(found);
          }
          return defaultFunctionResolver.getFunction(name, namespace);
        }
      };
    }
    function makeFunctionResolverFromObject(obj) {
      return makeFunctionResolverFromFunction(obj.getFunction.bind(obj));
    }
    function makeFunctionResolverFromMap(map) {
      return makeFunctionResolverFromFunction(function (name) {
        return map[name];
      });
    }
    function makeFunctionResolver(resolver) {
      if (resolver && typeof resolver.getFunction === "function") {
        return makeFunctionResolverFromObject(resolver);
      }
      if (typeof resolver === "function") {
        return makeFunctionResolverFromFunction(resolver);
      }

      // assume map
      if ((0, _typeof2.default)(resolver) === "object") {
        return makeFunctionResolverFromMap(resolver);
      }
      return defaultFunctionResolver;
    }
    function makeVariableResolverFromFunction(func) {
      return {
        getVariable: function getVariable(name, namespace) {
          var value = func(name, namespace);
          return convertValue(value);
        }
      };
    }
    function makeVariableResolver(resolver) {
      if (resolver) {
        if (typeof resolver.getVariable === "function") {
          return makeVariableResolverFromFunction(resolver.getVariable.bind(resolver));
        }
        if (typeof resolver === "function") {
          return makeVariableResolverFromFunction(resolver);
        }

        // assume map
        if ((0, _typeof2.default)(resolver) === "object") {
          return makeVariableResolverFromFunction(function (name) {
            return resolver[name];
          });
        }
      }
      return defaultVariableResolver;
    }
    function copyIfPresent(prop, dest, source) {
      if (prop in source) {
        dest[prop] = source[prop];
      }
    }
    function makeContext(options) {
      var context = new XPathContext();
      if (options) {
        context.namespaceResolver = makeNSResolver(options.namespaces);
        context.functionResolver = makeFunctionResolver(options.functions);
        context.variableResolver = makeVariableResolver(options.variables);
        context.expressionContextNode = options.node;
        copyIfPresent('allowAnyNamespaceForNoPrefix', context, options);
        copyIfPresent('isHtml', context, options);
      } else {
        context.namespaceResolver = defaultNSResolver;
      }
      return context;
    }
    function _evaluate(parsedExpression, options) {
      var context = makeContext(options);
      return parsedExpression.evaluate(context);
    }
    var evaluatorPrototype = {
      evaluate: function evaluate(options) {
        return _evaluate(this.expression, options);
      },
      evaluateNumber: function evaluateNumber(options) {
        return this.evaluate(options).numberValue();
      },
      evaluateString: function evaluateString(options) {
        return this.evaluate(options).stringValue();
      },
      evaluateBoolean: function evaluateBoolean(options) {
        return this.evaluate(options).booleanValue();
      },
      evaluateNodeSet: function evaluateNodeSet(options) {
        return this.evaluate(options).nodeset();
      },
      select: function select(options) {
        return this.evaluateNodeSet(options).toArray();
      },
      select1: function select1(options) {
        return this.select(options)[0];
      }
    };
    function parse(xpath) {
      var parsed = parser.parse(xpath);
      return Object.create(evaluatorPrototype, {
        expression: {
          value: parsed
        }
      });
    }
    exports.parse = parse;
  })();
  assign(exports, {
    XPath: XPath,
    XPathParser: XPathParser,
    XPathResult: XPathResult,
    Step: Step,
    PathExpr: PathExpr,
    NodeTest: NodeTest,
    LocationPath: LocationPath,
    OrOperation: OrOperation,
    AndOperation: AndOperation,
    BarOperation: BarOperation,
    EqualsOperation: EqualsOperation,
    NotEqualOperation: NotEqualOperation,
    LessThanOperation: LessThanOperation,
    GreaterThanOperation: GreaterThanOperation,
    LessThanOrEqualOperation: LessThanOrEqualOperation,
    GreaterThanOrEqualOperation: GreaterThanOrEqualOperation,
    PlusOperation: PlusOperation,
    MinusOperation: MinusOperation,
    MultiplyOperation: MultiplyOperation,
    DivOperation: DivOperation,
    ModOperation: ModOperation,
    UnaryMinusOperation: UnaryMinusOperation,
    FunctionCall: FunctionCall,
    VariableReference: VariableReference,
    XPathContext: XPathContext,
    XNodeSet: XNodeSet,
    XBoolean: XBoolean,
    XString: XString,
    XNumber: XNumber,
    NamespaceResolver: NamespaceResolver,
    FunctionResolver: FunctionResolver,
    VariableResolver: VariableResolver,
    Utilities: Utilities
  });

  // helper
  exports.select = function (e, doc, single) {
    return exports.selectWithResolver(e, doc, null, single);
  };
  exports.useNamespaces = function (mappings) {
    var resolver = {
      mappings: mappings || {},
      lookupNamespaceURI: function lookupNamespaceURI(prefix) {
        return this.mappings[prefix];
      }
    };
    return function (e, doc, single) {
      return exports.selectWithResolver(e, doc, resolver, single);
    };
  };
  exports.selectWithResolver = function (e, doc, resolver, single) {
    var expression = new XPathExpression(e, resolver, new XPathParser());
    var type = XPathResult.ANY_TYPE;
    var result = expression.evaluate(doc, type, null);
    if (result.resultType == XPathResult.STRING_TYPE) {
      result = result.stringValue;
    } else if (result.resultType == XPathResult.NUMBER_TYPE) {
      result = result.numberValue;
    } else if (result.resultType == XPathResult.BOOLEAN_TYPE) {
      result = result.booleanValue;
    } else {
      result = result.nodes;
      if (single) {
        result = result[0];
      }
    }
    return result;
  };
  exports.select1 = function (e, doc) {
    return exports.select(e, doc, true);
  };

  // end non-node wrapper
})(xpath);

},{"@babel/runtime/helpers/interopRequireDefault":237,"@babel/runtime/helpers/typeof":252,"core-js/modules/es.array.concat.js":569,"core-js/modules/es.array.filter.js":572,"core-js/modules/es.array.join.js":578,"core-js/modules/es.array.map.js":579,"core-js/modules/es.array.slice.js":580,"core-js/modules/es.function.name.js":584,"core-js/modules/es.number.constructor.js":593,"core-js/modules/es.object.to-string.js":612,"core-js/modules/es.promise.js":614,"core-js/modules/es.regexp.exec.js":618,"core-js/modules/es.regexp.to-string.js":620,"core-js/modules/es.string.replace.js":629,"core-js/modules/es.string.split.js":631,"core-js/modules/es.string.starts-with.js":632}]},{},[1])(1)
});
//# sourceMappingURL=browser.js.map
