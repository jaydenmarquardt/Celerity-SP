import { AssignFrom, CopyFrom } from "@pnp/core";
import { _GraphInstance, graphInvokableFactory, GraphQueryable, graphPost, graphPut, graphDelete, } from "../graphqueryable.js";
import { InjectHeaders, body } from "@pnp/queryable";
/**
 * Describes a resumable upload session
 *
 */
export class _ResumableUpload extends _GraphInstance {
    /** Get the status of teh Resumable Upload URL */
    get status() {
        return GraphQueryable(this);
    }
    /** Upload a chunk of the file
    * @param byteLength - number - the length of the byte array
    * @param buffer - any - the buffer to upload
    * @param contentRange - string (Optional) - the content range to upload e.g. `bytes 0-311/312`
    */
    async upload(byteLength, buffer, contentRange) {
        const range = contentRange || `bytes 0-${byteLength - 1}/${byteLength}`;
        return graphPut(this, { body: buffer, headers: { "Content-Length": byteLength.toString(), "Content-Range": range } });
    }
    /** Cancel the Resumable Upload */
    async cancel() {
        return graphDelete(this, body(null));
    }
}
export const ResumableUpload = graphInvokableFactory(_ResumableUpload);
export async function getUploadSession(resuableUploadOptions) {
    const create = resuableUploadOptions.create != null ? resuableUploadOptions.create : true;
    const url = this.toRequestUrl();
    const q = GraphQueryable(`${url}${(create) ? `:/${resuableUploadOptions.item.name}:/` : ""}createUploadSession`).using(AssignFrom(this));
    if (resuableUploadOptions.eTag) {
        const header = {};
        header[resuableUploadOptions.eTagMatch || "If-Match"] = resuableUploadOptions.eTag;
        q.using(InjectHeaders(header));
    }
    const postBody = {};
    if (resuableUploadOptions.conflictBehavior || resuableUploadOptions.item) {
        Object.defineProperty(postBody, "item", { value: {}, writable: true });
        if (resuableUploadOptions.item) {
            postBody.item = resuableUploadOptions.item;
        }
        postBody.item["@microsoft.graph.conflictBehavior"] = resuableUploadOptions.conflictBehavior || "rename";
    }
    if (resuableUploadOptions.deferCommit) {
        Object.defineProperty(postBody, "deferCommit", { value: resuableUploadOptions.deferCommit });
    }
    // Create the upload session
    const session = await graphPost(q, body(postBody));
    // Create a new queryable for the upload session
    const uploadQueryable = GraphQueryable(session.uploadUrl).using(CopyFrom(this, "replace", (k) => /(pre|init|send|parse|post|data)/i.test(k)));
    const resumableUpload = ResumableUpload(uploadQueryable);
    return { session, resumableUpload };
}
//# sourceMappingURL=resumableUpload.js.map