import { __decorate } from "tslib";
import { GraphCollection, _GraphInstance, _GraphCollection, graphInvokableFactory, GraphQueryable, graphPatch, graphPost, graphPut, graphDelete, GraphInstance, } from "../graphqueryable.js";
import { combine } from "@pnp/core";
import { defaultPath, getById, deleteable, updateable, hasDelta } from "../decorators.js";
import { body, BlobParse, CacheNever, InjectHeaders } from "@pnp/queryable";
import { driveItemUpload } from "./funcs.js";
import { getUploadSession } from "./resumableUpload.js";
/**
 * Describes a Drive instance
 *
 */
let _Drive = class _Drive extends _GraphInstance {
    /**
     * Method for retrieving the root folder of a drive.
     * @returns IRoot
     */
    get root() {
        return Root(this);
    }
    /**
     * Method for retrieving recently accessed drive items by the user.
     * @returns IDriveItems
     */
    get recent() {
        return DriveItems(this, "recent");
    }
    /**
     * Method for retrieving drive items shared with the user.
     * @param options - ISharingWithMeOptions (Optional)
     * @returns IDriveItems
     */
    async sharedWithMe(options = null) {
        const q = DriveItems(this, "sharedWithMe");
        if ((options === null || options === void 0 ? void 0 : options.allowExternal) != null) {
            q.query.set("allowexternal", options === null || options === void 0 ? void 0 : options.allowExternal.toString());
        }
        return q();
    }
    /**
     * Method for retrieving a drive item by id.
     * @param id - string - the drive item id to retrieve
     * @returns IDriveItem
     */
    getItemById(id) {
        return DriveItem(this, combine("items", id));
    }
    /**
     * Method for retrieving drive items the user is following.
     * @returns IDriveItems
     */
    get following() {
        return DriveItems(this, "following");
    }
    /**
     * Get DriveItems by Path
     * @param path string, partial path to folder must not contain a leading or trailing "/" e.g. folderA/folderB/folderC
     * @returns IDriveItems
     */
    getItemsByPath(path) {
        return DriveItems(this, combine("root:/", `${path}:/children`));
    }
    /**
     * Get DriveItem by Path
     * @param path string, partial path to folder must not contain a leading or trailing "/" e.g. folderA/folderB/fileName.txt
     * @returns IDriveItems
     */
    getItemByPath(path) {
        return DriveItem(this, combine("root:/", `${path}:`));
    }
};
_Drive = __decorate([
    defaultPath("drive")
], _Drive);
export { _Drive };
export const Drive = graphInvokableFactory(_Drive);
/**
 * Describes a collection of Drive objects
 *
 */
let _Drives = class _Drives extends _GraphCollection {
};
_Drives = __decorate([
    defaultPath("drives"),
    getById(Drive)
], _Drives);
export { _Drives };
export const Drives = graphInvokableFactory(_Drives);
/**
 * Describes a Root instance
 *
 */
let _Root = class _Root extends _GraphInstance {
    /**
     * Method for retrieving children of a folder drive item.
     * @returns IDriveItems
     */
    get children() {
        return DriveItems(this, "children");
    }
    /**
     * Search drive for items matching the query
     * @param query string, search parameter
     * @returns IGraphCollection
     */
    search(query) {
        return GraphCollection(this, `search(q='${query}')`);
    }
    /**
     * Method for retrieving thumbnails of the drive items.
     * @returns IGraphCollection
     */
    get thumbnails() {
        return GraphInstance(this, "thumbnails");
    }
    /**
     * Method for uploading a new file, or updating the contents of an existing file.
     * @param fileOptions - IFileOptions object
     * @returns IDriveItem
     */
    async upload(fileOptions) {
        return Reflect.apply(driveItemUpload, this, [fileOptions]);
    }
};
_Root = __decorate([
    defaultPath("root"),
    hasDelta()
], _Root);
export { _Root };
export const Root = graphInvokableFactory(_Root);
/**
 * Describes a Drive Item instance
 *
 */
let _DriveItem = class _DriveItem extends _GraphInstance {
    /**
     * Method for retrieving children of a folder drive item.
     * @returns IDriveItems
     */
    get children() {
        return DriveItems(this, "children");
    }
    get items() {
        return DriveItems(this, "items");
    }
    /**
     * Method for retrieving thumbnails of the drive items.
     * @returns Microsoft Graph - ThumbnailSet
     */
    get thumbnails() {
        return GraphCollection(this, "thumbnails");
    }
    /**
     * Method for retrieving the versions of a drive item.
     * @returns IDriveItemVersionInfo
     */
    get versions() {
        return GraphCollection(this, "versions");
    }
    /**
     * Method for moving a file to a new location and/or name.
     * @param moveOptions - IItemOptions object
     * @returns string - the URL where the new file is located
     */
    async moveItem(moveOptions) {
        return graphPatch(this, body(moveOptions));
    }
    /**
     * Method for retrieving the contents of a drive item.
     * @returns Blob
     */
    async getContent() {
        const info = await this();
        const query = GraphQueryable([this, info["@microsoft.graph.downloadUrl"]], null)
            .using(BlobParse())
            .using(CacheNever());
        query.on.pre(async (url, init, result) => {
            init.responseType = "arraybuffer";
            return [url, init, result];
        });
        return query();
    }
    /**
     * Method for copying a file to a new location and/or name.
     * @param copyOptions - IItemOptions
     * @returns string, the URL where the new file is located
     */
    async copyItem(copyOptions) {
        const creator = DriveItem(this, "copy").using((instance) => {
            instance.on.parse(async (url, response, result) => {
                result = response.headers.has("location") ? response.headers : response;
                return [url, response, result];
            });
            return instance;
        });
        const data = await graphPost(creator, body(copyOptions));
        let result = null;
        if (data.has("location")) {
            result = data.get("location");
        }
        return result;
    }
    /**
     * Method for converting the format of a drive item.
     * @param format - string - "pdf" is only option
     * @returns Blob - content of the converted file
     */
    async convertContent(format) {
        const query = GraphQueryable(this, `content?format=${format}`)
            .using(BlobParse())
            .using(CacheNever());
        query.on.pre(async (url, init, result) => {
            init.responseType = "arraybuffer";
            return [url, init, result];
        });
        return query();
    }
    /**
     * Method for getting a temporary preview image of a drive item.
     * @returns Microsoft Graph - DriveItem
     */
    async follow() {
        return await graphPost(DriveItem(this, "follow"), body(null));
    }
    /**
     * Method for getting a temporary preview image of a drive item.
     * @returns void
     */
    async unfollow() {
        return await graphPost(DriveItem(this, "unfollow"), body(null));
    }
    /**
     * Method for uploading a new file, or updating the contents of an existing file.
     * @param fileOptions - IFileUploadOptions object
     * @returns Microsoft Graph - DriveItem
     */
    async upload(fileOptions) {
        return Reflect.apply(driveItemUpload, this, [fileOptions]);
    }
    /**
     * Method for uploading a new file, or updating the contents of an existing file.
     * @param resuableUploadOptions - IResumableUploadOptions object
     * @returns session: Microsoft Graph - UploadSession, resumableUpload: IResumableUpload
     */
    async createUploadSession(resuableUploadOptions) {
        return Reflect.apply(getUploadSession, this, [resuableUploadOptions]);
    }
    /**
     * Method for getting a temporary preview image of a drive item.
     * @param previewOptions - IPreviewOptions (Optional)
     * @returns Microsoft Graph - DriveItemPreview
     */
    async preview(previewOptions) {
        return graphPost(DriveItem(this, "preview"), body(previewOptions));
    }
    /**
     * Method for permanently deleting a driveItem by using its ID.
     * @returns void
     */
    async permanentDelete() {
        return graphPost(DriveItem(this, "permanentDelete"), body(null));
    }
    /**
     * Method for permanently deleting a driveItem by using its ID.
     * @param label: ISensitivityLabel
     * @returns string - long running operation status URL
     */
    async assignSensitivityLabel(label) {
        const data = await graphPost(DriveItem(this, "assignSensitivityLabel"), body(label));
        let result = null;
        if (data.has("location")) {
            result = data.get("location");
        }
        return result;
    }
    /**
     * Method for permanently deleting a driveItem by using its ID.
     * @returns Microsoft Graph - ExtractSensitivityLabelsResult
     */
    async extractSensitivityLabels() {
        return graphPost(DriveItem(this, "extractSensitivityLabels"), body(null));
    }
    /**
     * Method for retrieving the retention label of the drive item.
     * @returns Microsoft Graph - ItemRetentionLabel
     */
    retentionLabel() {
        return GraphQueryable(this, "retentionLabel");
    }
    /**
     * Method for locking/unlocking a record of the drive item.
     * @returns Microsoft Graph - ItemRetentionLabel
     */
    async recordLocked(locked) {
        const postBody = {
            retentionSettings: {
                "isRecordLocked": locked,
            },
        };
        return graphPatch(DriveItem(this, "retentionLabel"), body(postBody));
    }
    /**
     * Method for deleting a retention label from a driveItem.
     * @returns void
     */
    async removeRetentionLabel() {
        return graphDelete(DriveItem(this, "retentionLabel"));
    }
    /**
     * Method for updating a retention label on a driveItem.
     * @returns Microsoft Graph - ItemRetentionLabel
     */
    async updateRetentionLabel(name) {
        const postBody = { name };
        return graphPatch(DriveItem(this, "retentionLabel"), body(postBody));
    }
};
_DriveItem = __decorate([
    deleteable(),
    updateable()
], _DriveItem);
export { _DriveItem };
export const DriveItem = graphInvokableFactory(_DriveItem);
/**
 * Describes a collection of Drive Item objects
 *
 */
let _DriveItems = class _DriveItems extends _GraphCollection {
    /**
     * Adds a file to this collection of drive items.
     * This method allows more control for conflict behavior and affecting other properties of the DriveItem than the .upload method.
     * For more upload options please see the .upload method on DriveItem.
     * @param fileInfo - IDriveItemAdd
     * @returns Microsoft Graph - DriveItem
     */
    async add(fileInfo) {
        const postBody = {
            name: fileInfo.filename,
            file: fileInfo.driveItem || {},
            "@microsoft.graph.conflictBehavior": fileInfo.conflictBehavior || "rename",
        };
        const driveItem = await graphPost(this, body(postBody));
        const q = DriveItem([this, `${combine("drives", driveItem.parentReference.driveId, "items", driveItem.id)}`], "content");
        q.using(InjectHeaders({
            "Content-Type": fileInfo.contentType || "application/json",
        }));
        return await graphPut(q, { body: fileInfo.content });
    }
    /**
     * Adds a folder to this collection of drive items.
     * @param folderInfo - an object of type IDriveItemAddFolder specifying the properties of the new folder
     * @returns Microsoft Graph - DriveItem
     */
    async addFolder(folderInfo) {
        const postBody = {
            name: folderInfo.name,
            folder: folderInfo.driveItem || {},
            "@microsoft.graph.conflictBehavior": folderInfo.conflictBehavior || "rename",
        };
        return await graphPost(this, body(postBody));
    }
};
_DriveItems = __decorate([
    getById(DriveItem)
], _DriveItems);
export { _DriveItems };
export const DriveItems = graphInvokableFactory(_DriveItems);
//# sourceMappingURL=types.js.map