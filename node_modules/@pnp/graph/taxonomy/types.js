import { __decorate } from "tslib";
import { addable, defaultPath, deleteable, getById, updateable } from "../../graph/decorators.js";
import { _GraphInstance, graphInvokableFactory, _GraphCollection } from "../graphqueryable.js";
/**
 * Describes a collection of Form objects
 *
 */
let _TermStore = class _TermStore extends _GraphInstance {
    /**
     * Gets the term groups associated with this tenant
     */
    get groups() {
        return TermGroups(this);
    }
    /**
     * Gets the term sets associated with this tenant
     */
    get sets() {
        return TermSets(this);
    }
};
_TermStore = __decorate([
    defaultPath("termstore"),
    updateable()
], _TermStore);
export { _TermStore };
export const TermStore = graphInvokableFactory(_TermStore);
let _TermGroup = class _TermGroup extends _GraphInstance {
    /**
     * Gets the term sets associated with this tenant
     */
    get sets() {
        return TermSets(this, "sets");
    }
};
_TermGroup = __decorate([
    deleteable()
], _TermGroup);
export { _TermGroup };
export const TermGroup = graphInvokableFactory(_TermGroup);
let _TermGroups = class _TermGroups extends _GraphCollection {
};
_TermGroups = __decorate([
    defaultPath("groups"),
    getById(TermGroup),
    addable()
], _TermGroups);
export { _TermGroups };
export const TermGroups = graphInvokableFactory(_TermGroups);
let _TermSet = class _TermSet extends _GraphInstance {
    /**
     * Gets all the terms in this set
     */
    get terms() {
        return Terms(this);
    }
    get children() {
        return Children(this);
    }
    get relations() {
        return Relations(this);
    }
    getTermById(id) {
        return Term(this, `terms/${id}`);
    }
    /**
     * Gets all the direct children of the current termset as a tree, however is not ordered based on the SP sorting info
     *
     * @returns Array of children for this item
     */
    async getAllChildrenAsTree(props) {
        const visitor = async (source, parent) => {
            const children = await source.children.select(...selects)();
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                const orderedTerm = {
                    children: [],
                    defaultLabel: child.labels.find(l => l.isDefault).name,
                    ...child,
                };
                parent.push(orderedTerm);
                await visitor(this.getTermById(child.id), orderedTerm.children);
            }
        };
        let selects = ["*"];
        if (props === null || props === void 0 ? void 0 : props.retrieveProperties) {
            // graph does not let us wildcard + select properties
            selects = ["id", "labels", "createdDateTime", "lastModifiedDateTime", "labels", "descriptions", "properties"];
        }
        const tree = [];
        await visitor(this, tree);
        return tree;
    }
};
_TermSet = __decorate([
    deleteable(),
    updateable()
], _TermSet);
export { _TermSet };
export const TermSet = graphInvokableFactory(_TermSet);
let _TermSets = class _TermSets extends _GraphCollection {
};
_TermSets = __decorate([
    defaultPath("sets"),
    getById(TermSet),
    addable()
], _TermSets);
export { _TermSets };
export const TermSets = graphInvokableFactory(_TermSets);
let _Children = class _Children extends _GraphCollection {
};
_Children = __decorate([
    defaultPath("children"),
    addable()
], _Children);
export { _Children };
export const Children = graphInvokableFactory(_Children);
let _Term = class _Term extends _GraphInstance {
    get children() {
        return Children(this);
    }
    get relations() {
        return Relations(this);
    }
    get set() {
        return TermSet(this, "set");
    }
};
_Term = __decorate([
    updateable(),
    deleteable()
], _Term);
export { _Term };
export const Term = graphInvokableFactory(_Term);
let _Terms = class _Terms extends _GraphCollection {
};
_Terms = __decorate([
    defaultPath("terms"),
    getById(Term)
], _Terms);
export { _Terms };
export const Terms = graphInvokableFactory(_Terms);
let _Relations = class _Relations extends _GraphCollection {
};
_Relations = __decorate([
    defaultPath("relations"),
    addable()
], _Relations);
export { _Relations };
export const Relations = graphInvokableFactory(_Relations);
//# sourceMappingURL=types.js.map