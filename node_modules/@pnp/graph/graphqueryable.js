import { isArray, objectDefinedNotNull } from "@pnp/core";
import { Queryable, queryableFactory, op, get, post, patch, del, put } from "@pnp/queryable";
import { ConsistencyLevel } from "./behaviors/consistency-level.js";
import { Paged } from "./behaviors/paged.js";
export const graphInvokableFactory = (f) => {
    return queryableFactory(f);
};
/**
 * Queryable Base Class
 *
 */
export class _GraphQueryable extends Queryable {
    /**
     * Creates a new instance of the Queryable class
     *
     * @constructor
     * @param base A string or Queryable that should form the base part of the url
     *
     */
    constructor(base, path) {
        super(base, path);
        // we need to use the graph implementation to handle our special encoding
        this._query = new GraphQueryParams();
        if (typeof base === "string") {
            this.parentUrl = base;
        }
        else if (isArray(base)) {
            this.parentUrl = base[0].toUrl();
        }
        else {
            this.parentUrl = base.toUrl();
        }
    }
    /**
     * Choose which fields to return
     *
     * @param selects One or more fields to return
     */
    select(...selects) {
        if (selects.length > 0) {
            this.query.set("$select", selects.join(","));
        }
        return this;
    }
    /**
     * Expands fields such as lookups to get additional data
     *
     * @param expands The Fields for which to expand the values
     */
    expand(...expands) {
        if (expands.length > 0) {
            this.query.set("$expand", expands.join(","));
        }
        return this;
    }
    /**
     * Gets a parent for this instance as specified
     *
     * @param factory The contructor for the class to create
     */
    getParent(factory, base = this.parentUrl, path) {
        if (typeof base === "string") {
            // we need to ensure the parent has observers, even if we are rebasing the url (#2435)
            base = [this, base];
        }
        return new factory(base, path);
    }
}
export const GraphQueryable = graphInvokableFactory(_GraphQueryable);
/**
 * Represents a REST collection which can be filtered, paged, and selected
 *
 */
export class _GraphCollection extends _GraphQueryable {
    /**
     *
     * @param filter The string representing the filter query
     */
    filter(filter) {
        this.query.set("$filter", filter);
        return this;
    }
    /**
     * Orders based on the supplied fields
     *
     * @param orderby The name of the field on which to sort
     * @param ascending If false DESC is appended, otherwise ASC (default)
     */
    orderBy(orderBy, ascending = true) {
        var _a;
        const o = "$orderby";
        const query = ((_a = this.query.get(o)) === null || _a === void 0 ? void 0 : _a.split(",")) || [];
        query.push(`${orderBy} ${ascending ? "asc" : "desc"}`);
        this.query.set(o, query.join(","));
        return this;
    }
    /**
     * Limits the query to only return the specified number of items
     *
     * @param top The query row limit
     */
    top(top) {
        this.query.set("$top", top.toString());
        return this;
    }
    /**
     * Skips a set number of items in the return set
     *
     * @param num Number of items to skip
     */
    skip(num) {
        this.query.set("$skip", num.toString());
        return this;
    }
    /**
     * Skips a set number of items in the return set
     *
     * @param num Number of items to skip
     */
    search(query) {
        this.using(ConsistencyLevel());
        this.query.set("$search", query);
        return this;
    }
    /**
     * 	To request second and subsequent pages of Graph data
     */
    skipToken(token) {
        this.query.set("$skiptoken", token);
        return this;
    }
    [Symbol.asyncIterator]() {
        const q = GraphCollection(this).using(Paged(), ConsistencyLevel());
        const queryParams = ["$search", "$top", "$select", "$expand", "$filter", "$orderby"];
        for (let i = 0; i < queryParams.length; i++) {
            const param = this.query.get(queryParams[i]);
            if (objectDefinedNotNull(param)) {
                q.query.set(queryParams[i], param);
            }
        }
        return {
            _next: q,
            async next() {
                if (this._next === null) {
                    return { done: true, value: undefined };
                }
                const result = await this._next();
                if (result.hasNext) {
                    this._next = GraphCollection([this._next, result.nextLink]);
                    return { done: false, value: result.value };
                }
                else {
                    this._next = null;
                    return { done: false, value: result.value };
                }
            },
        };
    }
}
export const GraphCollection = graphInvokableFactory(_GraphCollection);
/**
 * Represents an instance that can be selected
 *
 */
export class _GraphInstance extends _GraphQueryable {
}
export const GraphInstance = graphInvokableFactory(_GraphInstance);
export const graphGet = (o, init) => {
    return op(o, get, init);
};
export const graphPost = (o, init) => {
    return op(o, post, init);
};
export const graphDelete = (o, init) => {
    return op(o, del, init);
};
export const graphPatch = (o, init) => {
    return op(o, patch, init);
};
export const graphPut = (o, init) => {
    return op(o, put, init);
};
class GraphQueryParams extends Map {
    toString() {
        const params = new URLSearchParams();
        const literals = [];
        for (const item of this) {
            // and here is where we add some "enhanced" parsing as we get issues.
            if (/\/any\(.*?\)/i.test(item[1])) {
                literals.push(`${item[0]}=${item[1]}`);
            }
            else {
                params.append(item[0], item[1]);
            }
        }
        literals.push(params.toString());
        return literals.join("&");
    }
}
//# sourceMappingURL=graphqueryable.js.map