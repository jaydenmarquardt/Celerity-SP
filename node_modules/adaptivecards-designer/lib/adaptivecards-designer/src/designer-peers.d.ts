import * as Adaptive from "adaptivecards";
import { DraggableElement } from "./draggable-element";
import { PeerCommand } from "./peer-command";
import { CardDesignerSurface, DesignContext } from "./card-designer-surface";
import { DesignerPeerTreeItem } from "./designer-peer-treeitem";
import { Rect, IPoint } from "./miscellaneous";
export declare abstract class DesignerPeerInplaceEditor {
    onClose: (applyChanges: boolean) => void;
    abstract initialize(): any;
    abstract applyChanges(): any;
    abstract render(): HTMLElement;
}
export declare abstract class CardElementPeerInplaceEditor<TCardElement extends Adaptive.CardElement> extends DesignerPeerInplaceEditor {
    readonly cardElement: TCardElement;
    constructor(cardElement: TCardElement);
}
export declare class DesignerPeerRegistrationBase {
    private _iconClass?;
    readonly category: string;
    constructor(category: string, iconClass?: string);
    get iconClass(): string;
}
export declare class DesignerPeerRegistration<TSource, TPeer> extends DesignerPeerRegistrationBase {
    readonly sourceType: TSource;
    peerType: TPeer;
    constructor(sourceType: TSource, peerType: TPeer, category: string, iconClass?: string);
}
export declare class PropertySheetCategory {
    readonly name: string;
    static readonly DefaultCategory = "__defaultCategory";
    static readonly LayoutCategory = "Layout";
    static readonly StyleCategory = "Style";
    static readonly SelectionAction = "Selection action";
    static readonly InlineAction = "Inline action";
    static readonly Validation = "Validation";
    static readonly Refresh = "Refresh";
    private _entries;
    constructor(name: string);
    render(container: Adaptive.Container, context: PropertySheetContext, displayCategoryName: boolean): void;
    add(...entries: PropertySheetEntry[]): void;
    remove(...entries: PropertySheetEntry[]): void;
    getEntryAt(index: number): PropertySheetEntry;
    get length(): number;
}
export declare class PropertySheet {
    readonly displayCategoryNames: boolean;
    private _categories;
    constructor(displayCategoryNames?: boolean);
    add(categoryName: string, ...entries: PropertySheetEntry[]): void;
    addActionProperties(targetVersion: Adaptive.Version, peer: DesignerPeer, action: Adaptive.Action, category: string, excludeProperties?: PropertySheetEntry[]): void;
    remove(...entries: PropertySheetEntry[]): void;
    render(container: Adaptive.Container, context: PropertySheetContext): void;
}
export declare class PropertySheetContext {
    readonly designContext: DesignContext;
    readonly peer: DesignerPeer;
    private _target;
    constructor(designContext: DesignContext, peer: DesignerPeer, target?: object);
    get target(): object;
}
export declare abstract class PropertySheetEntry {
    readonly targetVersion: Adaptive.TargetVersion;
    abstract render(context: PropertySheetContext): Adaptive.CardElement;
    constructor(targetVersion: Adaptive.TargetVersion);
}
export declare class SubPropertySheetEntry {
    readonly targetVersion: Adaptive.TargetVersion;
    readonly target: object;
    readonly propertySheet: PropertySheet;
    render(context: PropertySheetContext): Adaptive.CardElement;
    constructor(targetVersion: Adaptive.TargetVersion, target: object, propertySheet: PropertySheet);
}
export declare class CustomPropertySheetEntry extends PropertySheetEntry {
    readonly targetVersion: Adaptive.TargetVersion;
    readonly onRender: (context: PropertySheetContext) => Adaptive.CardElement;
    render(context: PropertySheetContext): Adaptive.CardElement;
    constructor(targetVersion: Adaptive.TargetVersion, onRender: (context: PropertySheetContext) => Adaptive.CardElement);
}
export interface IPropertySheetEditorCommand {
    id?: string;
    caption: string;
    altText?: string;
    expanded?: boolean;
    onExecute: (sender: SingleInputPropertyEditor, clickedElement: HTMLElement) => void;
}
export declare abstract class SingleInputPropertyEditor extends PropertySheetEntry {
    readonly targetVersion: Adaptive.TargetVersion;
    readonly propertyName: string;
    readonly label: string;
    readonly causesPropertySheetRefresh: boolean;
    protected abstract createInput(context: PropertySheetContext): Adaptive.Input;
    protected getPropertyValue(context: PropertySheetContext): any;
    protected setPropertyValue(context: PropertySheetContext, value: string): void;
    protected getAdditionalCommands(context: PropertySheetContext): IPropertySheetEditorCommand[];
    render(context: PropertySheetContext): Adaptive.CardElement;
    constructor(targetVersion: Adaptive.TargetVersion, propertyName: string, label: string, causesPropertySheetRefresh?: boolean);
}
export declare class BaseStringPropertyEditor extends SingleInputPropertyEditor {
    readonly targetVersion: Adaptive.TargetVersion;
    readonly propertyName: string;
    readonly label: string;
    readonly allowBinding: boolean;
    readonly isMultiline: boolean;
    readonly causesPropertySheetRefresh: boolean;
    protected placeHolder: string;
    protected createInput(context: PropertySheetContext): Adaptive.Input;
    constructor(targetVersion: Adaptive.TargetVersion, propertyName: string, label: string, allowBinding?: boolean, isMultiline?: boolean, causesPropertySheetRefresh?: boolean);
}
export declare class StringPropertyEditor extends BaseStringPropertyEditor {
    protected getAdditionalCommands(context: PropertySheetContext): IPropertySheetEditorCommand[];
}
export declare class StringArrayPropertyEditor extends BaseStringPropertyEditor {
    readonly targetVersion: Adaptive.TargetVersion;
    readonly propertyName: string;
    readonly label: string;
    readonly allowBinding: boolean;
    readonly isMultiline: boolean;
    readonly causesPropertySheetRefresh: boolean;
    protected getPropertyValue(context: PropertySheetContext): any;
    protected setPropertyValue(context: PropertySheetContext, value: string): void;
    constructor(targetVersion: Adaptive.TargetVersion, propertyName: string, label: string, allowBinding?: boolean, isMultiline?: boolean, causesPropertySheetRefresh?: boolean);
}
export declare class NumberPropertyEditor extends SingleInputPropertyEditor {
    readonly targetVersion: Adaptive.TargetVersion;
    readonly propertyName: string;
    readonly label: string;
    readonly defaultValue: number | undefined;
    readonly causesPropertySheetRefresh: boolean;
    protected _input: Adaptive.NumberInput;
    protected setPropertyValue(context: PropertySheetContext, value: string): void;
    protected createInput(context: PropertySheetContext): Adaptive.Input;
    constructor(targetVersion: Adaptive.TargetVersion, propertyName: string, label: string, defaultValue?: number | undefined, causesPropertySheetRefresh?: boolean);
}
export declare class ObjectPropertyEditor extends StringPropertyEditor {
    protected getPropertyValue(context: PropertySheetContext): any;
    protected setPropertyValue(context: PropertySheetContext, value: string): void;
}
export declare class CustomCardObjectPropertyEditor extends StringPropertyEditor {
    protected getPropertyValue(context: PropertySheetContext): any;
    protected setPropertyValue(context: PropertySheetContext, value: string): void;
}
export declare class BooleanPropertyEditor extends SingleInputPropertyEditor {
    protected getPropertyValue(context: PropertySheetContext): any;
    protected setPropertyValue(context: PropertySheetContext, value: string): void;
    protected createInput(context: PropertySheetContext): Adaptive.Input;
}
export interface IVersionedChoice {
    targetVersion: Adaptive.TargetVersion;
    name: string;
    value: string;
}
export declare class ChoicePropertyEditor extends SingleInputPropertyEditor {
    readonly targetVersion: Adaptive.TargetVersion;
    readonly propertyName: string;
    readonly label: string;
    readonly choices: IVersionedChoice[];
    readonly causesPropertySheetRefresh: boolean;
    readonly isNullable: boolean;
    protected getPropertyValue(context: PropertySheetContext): any;
    protected setPropertyValue(context: PropertySheetContext, value: string): void;
    protected createInput(context: PropertySheetContext): Adaptive.Input;
    constructor(targetVersion: Adaptive.TargetVersion, propertyName: string, label: string, choices: IVersionedChoice[], causesPropertySheetRefresh?: boolean, isNullable?: boolean);
}
export declare class ContainerStylePropertyEditor extends ChoicePropertyEditor {
    readonly targetVersion: Adaptive.TargetVersion;
    readonly propertyName: string;
    readonly label: string;
    protected getPropertyValue(context: PropertySheetContext): any;
    protected setPropertyValue(context: PropertySheetContext, value: string): void;
    constructor(targetVersion: Adaptive.TargetVersion, propertyName: string, label: string);
}
export declare class NullableBooleanPropertyEditor extends ChoicePropertyEditor {
    readonly targetVersion: Adaptive.TargetVersion;
    readonly propertyName: string;
    readonly label: string;
    protected getPropertyValue(context: PropertySheetContext): any;
    protected setPropertyValue(context: PropertySheetContext, value: string): void;
    constructor(targetVersion: Adaptive.TargetVersion, propertyName: string, label: string);
}
export declare class ColumnWidthPropertyEditor extends ChoicePropertyEditor {
    protected getPropertyValue(context: PropertySheetContext): any;
    protected setPropertyValue(context: PropertySheetContext, value: string): void;
}
export declare class HeightPropertyEditor extends ChoicePropertyEditor {
    protected setPropertyValue(context: PropertySheetContext, value: string): void;
}
export declare class SizeAndUnitPropertyEditor extends NumberPropertyEditor {
    readonly targetVersion: Adaptive.TargetVersion;
    readonly propertyName: string;
    readonly label: string;
    readonly sizeUnit: Adaptive.SizeUnit;
    readonly defaultValue: number | undefined;
    readonly causesPropertySheetRefresh: boolean;
    protected getPropertyValue(context: PropertySheetContext): any;
    protected setPropertyValue(context: PropertySheetContext, value: string): void;
    constructor(targetVersion: Adaptive.TargetVersion, propertyName: string, label: string, sizeUnit: Adaptive.SizeUnit, defaultValue?: number | undefined, causesPropertySheetRefresh?: boolean);
}
export declare class CarouselTimerPropertyEditor extends NumberPropertyEditor {
    protected setPropertyValue(context: PropertySheetContext, value: string): void;
}
export declare class ActionPropertyEditor extends SingleInputPropertyEditor {
    readonly targetVersion: Adaptive.TargetVersion;
    readonly propertyName: string;
    readonly label: string;
    readonly forbiddenActionTypes: string[];
    readonly causesPropertySheetRefresh: boolean;
    protected getPropertyValue(context: PropertySheetContext): any;
    protected setPropertyValue(context: PropertySheetContext, value: string): void;
    protected createInput(context: PropertySheetContext): Adaptive.Input;
    constructor(targetVersion: Adaptive.TargetVersion, propertyName: string, label: string, forbiddenActionTypes?: string[], causesPropertySheetRefresh?: boolean);
}
export declare class CompoundPropertyEditor extends PropertySheetEntry {
    readonly targetVersion: Adaptive.TargetVersion;
    readonly propertyName: string;
    readonly entries: PropertySheetEntry[];
    readonly initializeProperty?: () => object;
    render(context: PropertySheetContext): Adaptive.CardElement;
    constructor(targetVersion: Adaptive.TargetVersion, propertyName: string, entries?: PropertySheetEntry[], initializeProperty?: () => object);
}
export declare class EnumPropertyEditor extends SingleInputPropertyEditor {
    readonly targetVersion: Adaptive.TargetVersion;
    readonly propertyName: string;
    readonly label: string;
    readonly enumType: {
        [s: number]: string;
    };
    readonly causesPropertySheetRefresh: boolean;
    readonly isNullable: boolean;
    protected getPropertyValue(context: PropertySheetContext): any;
    protected setPropertyValue(context: PropertySheetContext, value: string): void;
    protected createInput(context: PropertySheetContext): Adaptive.Input;
    constructor(targetVersion: Adaptive.TargetVersion, propertyName: string, label: string, enumType: {
        [s: number]: string;
    }, causesPropertySheetRefresh?: boolean, isNullable?: boolean);
}
declare class NameValuePairPropertyEditor extends PropertySheetEntry {
    readonly targetVersion: Adaptive.TargetVersion;
    readonly collectionPropertyName: string;
    readonly namePropertyName: string;
    readonly valuePropertyName: string;
    readonly createCollectionItem: (name: string, value: string) => any;
    readonly namePropertyLabel: string;
    readonly valuePropertyLabel: string;
    readonly addButtonTitle: string;
    readonly messageIfEmpty: string;
    private collectionChanged;
    render(context: PropertySheetContext): Adaptive.CardElement;
    constructor(targetVersion: Adaptive.TargetVersion, collectionPropertyName: string, namePropertyName: string, valuePropertyName: string, createCollectionItem: (name: string, value: string) => any, namePropertyLabel?: string, valuePropertyLabel?: string, addButtonTitle?: string, messageIfEmpty?: string);
}
declare type NameAndValue = {
    name: string;
    value?: string;
};
declare type InnerPropertiesDictionary = {
    [name: string]: NameAndValue;
};
declare class InnerStructPropertyEditor extends PropertySheetEntry {
    readonly targetVersion: Adaptive.TargetVersion;
    readonly collectionPropertyName: string;
    readonly innerPropertiesDefaults: InnerPropertiesDictionary;
    readonly createCollectionItem: (innerProperties: InnerPropertiesDictionary) => any;
    readonly addButtonTitle: string;
    readonly messageIfEmpty: string;
    private collectionChanged;
    render(context: PropertySheetContext): Adaptive.CardElement;
    constructor(targetVersion: Adaptive.TargetVersion, collectionPropertyName: string, innerPropertiesDefaults: InnerPropertiesDictionary, createCollectionItem: (innerProperties: InnerPropertiesDictionary) => any, addButtonTitle?: string, messageIfEmpty?: string);
}
export declare abstract class DesignerPeer extends DraggableElement {
    static readonly idProperty: StringPropertyEditor;
    static onPopulatePropertySheet?: (sender: DesignerPeer, propertySheet: PropertySheet) => void;
    private _parent;
    private _cardObject;
    private _children;
    private _isSelected;
    private _inplaceEditorOverlay;
    private _inplaceEditor;
    private _insertAfterNeighbor;
    private _parentCarouselPagePeer;
    private closeInplaceEditor;
    private tryOpenInplaceEditor;
    protected click(e: MouseEvent): void;
    protected doubleClick(e: MouseEvent): void;
    protected isContainer(): boolean;
    protected getToolTip(): string;
    protected internalAddCommands(context: DesignContext, commands: Array<PeerCommand>): void;
    protected internalRender(): HTMLElement;
    protected internalUpdateCssStyles(): void;
    protected peerAdded(newPeer: DesignerPeer): void;
    protected peerRemoved(peer: DesignerPeer): void;
    protected internalUpdateLayout(): void;
    protected createInplaceEditor(): DesignerPeerInplaceEditor;
    protected internalGetTreeItemText(): string;
    protected abstract internalRemove(): boolean;
    readonly registration: DesignerPeerRegistrationBase;
    readonly designerSurface: CardDesignerSurface;
    readonly treeItem: DesignerPeerTreeItem;
    onParentChanged: (sender: DesignerPeer) => void;
    onSelectedChanged: (sender: DesignerPeer) => void;
    onChanged: (sender: DesignerPeer, updatePropertySheet: boolean) => void;
    onPeerRemoved: (sender: DesignerPeer) => void;
    onPeerAdded: (sender: DesignerPeer, newPeer: DesignerPeer) => void;
    constructor(parent: DesignerPeer, designerSurface: CardDesignerSurface, registration: DesignerPeerRegistrationBase, cardObject: Adaptive.CardObject);
    abstract getBoundingRect(): Rect;
    abstract getCardObjectBoundingRect(): Rect;
    getCardObject(): Adaptive.CardObject;
    updateChildren(): void;
    changed(updatePropertySheet: boolean): void;
    getTreeItemText(): string;
    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
    canDrop(peer: DesignerPeer): boolean;
    canBeRemoved(): boolean;
    tryDrop(peer: DesignerPeer, insertionPoint: IPoint): boolean;
    tryAdd(peer: DesignerPeer): boolean;
    insertChild(peer: DesignerPeer, index?: number): void;
    removeChild(peer: DesignerPeer): void;
    getChildCount(): number;
    getChildAt(index: number): DesignerPeer;
    getCommands(context: DesignContext, promoteParentCommands?: boolean): Array<PeerCommand>;
    remove(onlyFromCard: boolean, removeChildren: boolean): boolean;
    addElementsToDesignerSurface(designerSurface: HTMLElement, neighbor?: HTMLElement): HTMLElement;
    removeElementsFromDesignerSurface(processChildren?: boolean): void;
    buildPropertySheetCard(context: DesignContext): Adaptive.AdaptiveCard;
    scrollIntoView(): void;
    private updateParentCarouselPagePeer;
    get isTreeItemExpandedByDefault(): boolean;
    get parent(): DesignerPeer;
    set parent(value: DesignerPeer);
    get isSelected(): boolean;
    set isSelected(value: boolean);
    get insertAfterNeighbor(): boolean;
    set insertAfterNeighbor(insertAfterNeighbor: boolean);
    get children(): Array<DesignerPeer>;
    get parentCarouselPagePeer(): CarouselPagePeer | undefined;
}
export declare class ActionPeer extends DesignerPeer {
    static readonly titleProperty: StringPropertyEditor;
    static readonly modeProperty: ChoicePropertyEditor;
    static readonly styleProperty: ChoicePropertyEditor;
    static readonly iconUrlProperty: StringPropertyEditor;
    static readonly tooltipProperty: StringPropertyEditor;
    static readonly isEnabledProperty: BooleanPropertyEditor;
    protected doubleClick(e: MouseEvent): void;
    protected internalRemove(): boolean;
    constructor(parent: DesignerPeer, designerSurface: CardDesignerSurface, registration: DesignerPeerRegistrationBase, action: Adaptive.Action);
    protected internalGetTreeItemText(): string;
    protected internalUpdateLayout(): void;
    isDraggable(): boolean;
    getBoundingRect(): Rect;
    getCardObjectBoundingRect(): Rect;
    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
    get action(): Adaptive.Action;
}
export declare abstract class TypedActionPeer<TAction extends Adaptive.Action> extends ActionPeer {
    constructor(parent: DesignerPeer, designerSurface: CardDesignerSurface, registration: DesignerPeerRegistrationBase, action: TAction);
    get action(): TAction;
}
export declare class HttpActionPeer extends TypedActionPeer<Adaptive.HttpAction> {
    static readonly ignoreInputValidationProperty: BooleanPropertyEditor;
    static readonly methodProperty: ChoicePropertyEditor;
    static readonly urlProperty: StringPropertyEditor;
    static readonly bodyProperty: StringPropertyEditor;
    static readonly headersProperty: NameValuePairPropertyEditor;
    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
}
export declare abstract class BaseSubmitActionPeer<TAction extends Adaptive.SubmitAction> extends TypedActionPeer<TAction> {
    static readonly dataProperty: ObjectPropertyEditor;
    static readonly associatedInputsProperty: ChoicePropertyEditor;
    static readonly disabledUnlessAssociatedInputsChangeProperty: BooleanPropertyEditor;
    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
}
export declare class SubmitActionPeer extends BaseSubmitActionPeer<Adaptive.SubmitAction> {
}
export declare class ExecuteActionPeer extends BaseSubmitActionPeer<Adaptive.ExecuteAction> {
    static readonly verbProperty: StringPropertyEditor;
    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
}
export declare class OpenUrlActionPeer extends TypedActionPeer<Adaptive.OpenUrlAction> {
    static readonly urlProperty: StringPropertyEditor;
    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
}
export declare class ShowCardActionPeer extends TypedActionPeer<Adaptive.ShowCardAction> {
    protected getToolTip(): string;
}
export declare class ToggleVisibilityActionPeer extends TypedActionPeer<Adaptive.ToggleVisibilityAction> {
}
export declare class CardElementPeer extends DesignerPeer {
    static readonly dataContextProperty: CustomCardObjectPropertyEditor;
    static readonly whenProperty: CustomCardObjectPropertyEditor;
    static readonly idProperty: StringPropertyEditor;
    static readonly isVisibleProperty: BooleanPropertyEditor;
    static readonly spacingProperty: EnumPropertyEditor;
    static readonly separatorProperty: BooleanPropertyEditor;
    static readonly horizontalAlignmentProperty: EnumPropertyEditor;
    static readonly heightProperty: HeightPropertyEditor;
    protected insertElementAfter(newElement: Adaptive.CardElement): void;
    protected internalRemove(): boolean;
    protected internalUpdateCssStyles(): void;
    constructor(parent: DesignerPeer, designerSurface: CardDesignerSurface, registration: DesignerPeerRegistrationBase, cardElement: Adaptive.CardElement, initializeCardElement?: boolean);
    findCardElementChild(element: Adaptive.CardElement): CardElementPeer | undefined;
    findActionChild(action: Adaptive.Action): ActionPeer | undefined;
    updateChildren(initializeCardElement?: boolean): void;
    getTreeItemText(): string;
    initializeCardElement(): void;
    canDrop(peer: DesignerPeer): boolean;
    tryDrop(peer: DesignerPeer, insertionPoint: IPoint): boolean;
    tryAdd(peer: DesignerPeer): boolean;
    getBoundingRect(): Rect;
    getCardObjectBoundingRect(): Rect;
    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
    get cardElement(): Adaptive.CardElement;
    isVisible(): boolean;
    bringCardElementIntoView(): boolean;
}
export declare abstract class TypedCardElementPeer<TCardElement extends Adaptive.CardElement> extends CardElementPeer {
    constructor(parent: DesignerPeer, designerSurface: CardDesignerSurface, registration: DesignerPeerRegistrationBase, cardElement: TCardElement, initializeCardElement?: boolean);
    get cardElement(): TCardElement;
}
export declare class AdaptiveCardPeer extends TypedCardElementPeer<Adaptive.AdaptiveCard> {
    static readonly langProperty: StringPropertyEditor;
    static readonly fallbackTextProperty: StringPropertyEditor;
    static readonly speakProperty: StringPropertyEditor;
    static readonly refreshProperty: CompoundPropertyEditor;
    protected addAction(action: Adaptive.Action): void;
    protected internalRemove(): boolean;
    protected internalAddCommands(context: DesignContext, commands: Array<PeerCommand>): void;
    isDraggable(): boolean;
    canBeRemoved(): boolean;
    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
}
export declare class ColumnPeer extends TypedCardElementPeer<Adaptive.Column> {
    private static readonly pixelWidthProperty;
    private static readonly weightProperty;
    static readonly widthProperty: ColumnWidthPropertyEditor;
    protected isContainer(): boolean;
    protected internalGetTreeItemText(): string;
    isDraggable(): boolean;
    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
}
export declare class ColumnSetPeer extends TypedCardElementPeer<Adaptive.ColumnSet> {
    protected isContainer(): boolean;
    protected internalAddCommands(context: DesignContext, commands: Array<PeerCommand>): void;
    protected internalGetTreeItemText(): string;
    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
    canDrop(peer: DesignerPeer): boolean;
}
export declare class ContainerPeer extends TypedCardElementPeer<Adaptive.Container> {
    static readonly selectActionProperty: ActionPropertyEditor;
    static readonly minHeightProperty: NumberPropertyEditor;
    static readonly verticalContentAlignmentProperty: EnumPropertyEditor;
    static readonly styleProperty: ContainerStylePropertyEditor;
    static readonly bleedProperty: BooleanPropertyEditor;
    static readonly backgroundImageProperty: CompoundPropertyEditor;
    static readonly rtlProperty: BooleanPropertyEditor;
    protected isContainer(): boolean;
    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
}
export declare class ActionSetPeer extends TypedCardElementPeer<Adaptive.AdaptiveCard> {
    protected addAction(action: Adaptive.Action): void;
    protected internalAddCommands(context: DesignContext, commands: Array<PeerCommand>): void;
}
export declare class ImageSetPeer extends TypedCardElementPeer<Adaptive.ImageSet> {
    static readonly ImageSizeProperty: EnumPropertyEditor;
    protected internalAddCommands(context: DesignContext, commands: Array<PeerCommand>): void;
    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
}
export declare class ImagePeer extends TypedCardElementPeer<Adaptive.Image> {
    static readonly urlProperty: StringPropertyEditor;
    static readonly altTextProperty: StringPropertyEditor;
    static readonly sizeProperty: EnumPropertyEditor;
    static readonly pixelWidthProperty: NumberPropertyEditor;
    static readonly pixelHeightProperty: NumberPropertyEditor;
    static readonly styleProperty: EnumPropertyEditor;
    static readonly backgroundColorProperty: StringPropertyEditor;
    private get isParentImageSet();
    protected internalAddCommands(context: DesignContext, commands: Array<PeerCommand>): void;
    isDraggable(): boolean;
    getBoundingRect(): Rect;
    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
}
export declare class MediaPeer extends TypedCardElementPeer<Adaptive.Media> {
    static readonly altTextProperty: StringPropertyEditor;
    static readonly posterUrlProperty: StringPropertyEditor;
    static readonly sourcesProperty: InnerStructPropertyEditor;
    static readonly captionSourcesProperty: InnerStructPropertyEditor;
    protected internalGetTreeItemText(): string;
    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
}
export declare class FactSetPeer extends TypedCardElementPeer<Adaptive.FactSet> {
    static readonly factsProperty: NameValuePairPropertyEditor;
    protected internalGetTreeItemText(): string;
    initializeCardElement(): void;
    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
}
export declare abstract class InputPeer<TInput extends Adaptive.Input> extends TypedCardElementPeer<TInput> {
    static readonly labelProperty: StringPropertyEditor;
    static readonly isRequiredProperty: BooleanPropertyEditor;
    static readonly errorMessageProperty: StringPropertyEditor;
    protected internalGetTreeItemText(): string;
    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
}
export declare class TextInputPeer extends InputPeer<Adaptive.TextInput> {
    static readonly defaultValueProperty: StringPropertyEditor;
    static readonly placeholderProperty: StringPropertyEditor;
    static readonly isMultilineProperty: BooleanPropertyEditor;
    static readonly styleProperty: EnumPropertyEditor;
    static readonly maxLengthProperty: NumberPropertyEditor;
    static readonly inlineActionProperty: ActionPropertyEditor;
    static readonly regexProperty: StringPropertyEditor;
    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
    initializeCardElement(): void;
}
export declare class NumberInputPeer extends InputPeer<Adaptive.NumberInput> {
    static readonly defaultValueProperty: NumberPropertyEditor;
    static readonly placeholderProperty: StringPropertyEditor;
    static readonly minProperty: NumberPropertyEditor;
    static readonly maxProperty: NumberPropertyEditor;
    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
    initializeCardElement(): void;
}
export declare class DateInputPeer extends InputPeer<Adaptive.DateInput> {
    static readonly defaultValueProperty: StringPropertyEditor;
    static readonly minProperty: StringPropertyEditor;
    static readonly maxProperty: StringPropertyEditor;
    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
}
export declare class TimeInputPeer extends InputPeer<Adaptive.TimeInput> {
    static readonly defaultValueProperty: StringPropertyEditor;
    static readonly minProperty: StringPropertyEditor;
    static readonly maxProperty: StringPropertyEditor;
    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
}
export declare class ToggleInputPeer extends InputPeer<Adaptive.ToggleInput> {
    static readonly defaultValueProperty: StringPropertyEditor;
    static readonly titleProperty: StringPropertyEditor;
    static readonly valueOnProperty: StringPropertyEditor;
    static readonly valueOffProperty: StringPropertyEditor;
    static readonly wrapProperty: BooleanPropertyEditor;
    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
    initializeCardElement(): void;
}
export declare class ChoiceSetInputPeer extends InputPeer<Adaptive.ChoiceSetInput> {
    static readonly defaultValueProperty: StringPropertyEditor;
    static readonly placeholderProperty: StringPropertyEditor;
    static readonly isMultiselectProperty: BooleanPropertyEditor;
    static readonly styleProperty: ChoicePropertyEditor;
    static readonly wrapProperty: BooleanPropertyEditor;
    static readonly choicesProperty: NameValuePairPropertyEditor;
    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
    initializeCardElement(): void;
}
export declare class TextBlockPeer extends TypedCardElementPeer<Adaptive.TextBlock> {
    static readonly textProperty: StringPropertyEditor;
    static readonly wrapProperty: BooleanPropertyEditor;
    static readonly maxLinesProperty: NumberPropertyEditor;
    static readonly fontTypeProperty: EnumPropertyEditor;
    static readonly sizeProperty: EnumPropertyEditor;
    static readonly weightProperty: EnumPropertyEditor;
    static readonly colorProperty: EnumPropertyEditor;
    static readonly subtleProperty: NullableBooleanPropertyEditor;
    static readonly styleProperty: ChoicePropertyEditor;
    protected createInplaceEditor(): DesignerPeerInplaceEditor;
    protected internalGetTreeItemText(): string;
    protected internalAddCommands(context: DesignContext, commands: Array<PeerCommand>): void;
    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
    getToolTip(): string;
    initializeCardElement(): void;
}
export declare class RichTextBlockPeer extends TypedCardElementPeer<Adaptive.RichTextBlock> {
    protected internalGetTreeItemText(): string;
    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
    initializeCardElement(): void;
}
export declare class TableCellPeer extends ContainerPeer {
    canBeRemoved(): boolean;
    isDraggable(): boolean;
}
export declare class TableRowPeer extends TypedCardElementPeer<Adaptive.TableRow> {
    static readonly horizontalCellContentAlignmentProperty: EnumPropertyEditor;
    static readonly verticalCellContentAlignmentProperty: EnumPropertyEditor;
    protected isContainer(): boolean;
    isDraggable(): boolean;
    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
    get isTreeItemExpandedByDefault(): boolean;
}
declare class TableColumnsPropertyEditor extends PropertySheetEntry {
    private columnsChanged;
    render(context: PropertySheetContext): Adaptive.CardElement;
}
export declare class TablePeer extends TypedCardElementPeer<Adaptive.Table> {
    static readonly firstRowAsHeadersProperty: BooleanPropertyEditor;
    static readonly cellSpacingProperty: NumberPropertyEditor;
    static readonly showGridLinesProperty: BooleanPropertyEditor;
    static readonly gridStyleProperty: ContainerStylePropertyEditor;
    static readonly horizontalCellContentAlignmentProperty: EnumPropertyEditor;
    static readonly verticalCellContentAlignmentProperty: EnumPropertyEditor;
    static readonly columnsProperty: TableColumnsPropertyEditor;
    protected isContainer(): boolean;
    protected internalAddCommands(context: DesignContext, commands: Array<PeerCommand>): void;
    initializeCardElement(): void;
    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
}
export declare class CarouselPeer extends ContainerPeer {
    static readonly timerProperty: CarouselTimerPropertyEditor;
    static readonly initialPageProperty: NumberPropertyEditor;
    protected internalAddCommands(context: DesignContext, commands: Array<PeerCommand>): void;
    initializeCardElement(): void;
    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
    canDrop(peer: DesignerPeer): boolean;
}
export declare class CarouselPagePeer extends ContainerPeer {
    private _pageOffset;
    isDraggable(): boolean;
    getBoundingRect(): Rect;
    peerInCorrectLocation(currentLocation: IPoint): boolean;
    isVisible(): boolean;
    bringCardElementIntoView(): boolean;
    canDrop(peer: DesignerPeer): boolean;
    get pageOffset(): number;
}
export {};
