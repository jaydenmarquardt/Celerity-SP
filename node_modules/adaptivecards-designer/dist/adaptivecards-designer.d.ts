declare module 'adaptivecards-designer/containers/host-container' {
	import { CardObjectRegistry, CardElement, Action, HostConfig, SerializationContext, Version } from 'adaptivecards-designer/adaptivecards';
	export enum ColorTheme {
	    Light = "Light",
	    Dark = "Dark"
	}
	export abstract class HostContainer {
	    private _cardHost;
	    private _elementsRegistry;
	    private _actionsRegistry;
	    readonly name: string;
	    constructor(name: string);
	    abstract renderTo(hostElement: HTMLElement): any;
	    abstract getCurrentStyleSheet(): string;
	    initialize(): void;
	    createSerializationContext(targetVersion: Version): SerializationContext;
	    getBackgroundColor(): string;
	    parseElement(element: CardElement, source: any, context: SerializationContext): void;
	    anchorClicked(element: CardElement, anchor: HTMLAnchorElement): boolean;
	    getHostConfig(): HostConfig;
	    requiresOverflowStyling(): boolean;
	    adjustStyleForBackground(): void;
	    supportsActionBar: boolean;
	    get cardHost(): HTMLElement;
	    get isFixedHeight(): boolean;
	    get elementsRegistry(): CardObjectRegistry<CardElement>;
	    get actionsRegistry(): CardObjectRegistry<Action>;
	    get targetVersion(): Version;
	    get enableDeviceEmulation(): boolean;
	    get supportsMultipleSizes(): boolean;
	    static get supportedContainerThemes(): string[];
	    get supportsMultipleThemes(): boolean;
	    set colorTheme(value: ColorTheme);
	}

}
declare module 'adaptivecards-designer/containers/single-theme-host-container' {
	import { HostContainer } from 'adaptivecards-designer/containers/host-container';
	export abstract class SingleThemeHostContainer extends HostContainer {
	    private _styleSheet;
	    constructor(name: string, styleSheet: string);
	    getCurrentStyleSheet(): string;
	}

}
declare module 'adaptivecards-designer/containers/default/default-container' {
	import { SingleThemeHostContainer } from 'adaptivecards-designer/containers/single-theme-host-container';
	export class DefaultContainer extends SingleThemeHostContainer {
	    renderTo(hostElement: HTMLElement): void;
	}

}
declare module 'adaptivecards-designer/containers/multi-theme-host-container' {
	import * as Adaptive from 'adaptivecards-designer/adaptivecards';
	import { HostContainer } from 'adaptivecards-designer/containers/host-container';
	export enum ColorTheme {
	    Light = "Light",
	    Dark = "Dark"
	}
	export abstract class MultiThemeHostContainer extends HostContainer {
	    private _colorTheme;
	    private _cssFileName;
	    private _hostConfigLight;
	    private _hostConfigDark;
	    private _lightBackground;
	    private _darkBackground;
	    constructor(name: string, cssFileName: string, hostConfigLight: any, hostConfigDark: any, lightBackground: string, darkBackground: string);
	    getCurrentStyleSheet(): string;
	    getHostConfig(): Adaptive.HostConfig;
	    getBackgroundColor(): string;
	    set colorTheme(value: ColorTheme);
	    get supportsMultipleThemes(): boolean;
	}

}
declare module 'adaptivecards-designer/containers/widget/widget-container' {
	import * as Adaptive from 'adaptivecards-designer/adaptivecards';
	import { MultiThemeHostContainer } from 'adaptivecards-designer/containers/multi-theme-host-container';
	export enum ContainerSize {
	    Small = "Small",
	    Medium = "Medium",
	    Large = "Large"
	}
	export class WidgetContainer extends MultiThemeHostContainer {
	    private _containerSize;
	    private _outerFrame;
	    constructor(size: ContainerSize);
	    static readonly widgetPadding: number;
	    initialize(): void;
	    renderTo(hostElement: HTMLElement): void;
	    requiresOverflowStyling(): boolean;
	    private applyWidgetOverflowStyling;
	    private addCardElementsWrapper;
	    adjustStyleForBackground(): void;
	    get targetVersion(): Adaptive.Version;
	    get isFixedHeight(): boolean;
	    set containerSize(value: ContainerSize);
	    get supportsMultipleSizes(): boolean;
	    static get supportedContainerSizes(): string[];
	}

}
declare module 'adaptivecards-designer/containers/bf-image/bf-image-container' {
	import * as Adaptive from 'adaptivecards-designer/adaptivecards';
	import { SingleThemeHostContainer } from 'adaptivecards-designer/containers/single-theme-host-container';
	export class BotFrameworkContainer extends SingleThemeHostContainer {
	    renderTo(hostElement: HTMLElement): void;
	    getHostConfig(): Adaptive.HostConfig;
	    get enableDeviceEmulation(): boolean;
	}

}
declare module 'adaptivecards-designer/containers/cortana-classic/cortana-classic-container' {
	import * as Adaptive from 'adaptivecards-designer/adaptivecards';
	import { SingleThemeHostContainer } from 'adaptivecards-designer/containers/single-theme-host-container';
	export class CortanaClassicContainer extends SingleThemeHostContainer {
	    renderTo(hostElement: HTMLElement): void;
	    getHostConfig(): Adaptive.HostConfig;
	}

}
declare module 'adaptivecards-designer/containers/cortana/cortana-container' {
	import * as Adaptive from 'adaptivecards-designer/adaptivecards';
	import { MultiThemeHostContainer } from 'adaptivecards-designer/containers/multi-theme-host-container';
	export class CortanaContainer extends MultiThemeHostContainer {
	    constructor();
	    renderTo(hostElement: HTMLElement): void;
	    get targetVersion(): Adaptive.Version;
	    get enableDeviceEmulation(): boolean;
	}

}
declare module 'adaptivecards-designer/containers/notifications/toast-container' {
	import * as Adaptive from 'adaptivecards-designer/adaptivecards';
	import { SingleThemeHostContainer } from 'adaptivecards-designer/containers/single-theme-host-container';
	export class ToastContainer extends SingleThemeHostContainer {
	    renderTo(hostElement: HTMLElement): void;
	    getHostConfig(): Adaptive.HostConfig;
	}

}
declare module 'adaptivecards-designer/containers/outlook/outlook-container' {
	import * as Adaptive from 'adaptivecards-designer/adaptivecards';
	import { SingleThemeHostContainer } from 'adaptivecards-designer/containers/single-theme-host-container';
	export class OutlookContainer extends SingleThemeHostContainer {
	    constructor(name: string, styleSheet: string);
	    renderTo(hostElement: HTMLElement): void;
	    initialize(): void;
	    private parsePadding;
	    parseElement(element: Adaptive.CardElement, source: any, context: Adaptive.SerializationContext): void;
	    anchorClicked(element: Adaptive.CardElement, anchor: HTMLAnchorElement): boolean;
	    getHostConfig(): Adaptive.HostConfig;
	    get targetVersion(): Adaptive.Version;
	    get enableDeviceEmulation(): boolean;
	}

}
declare module 'adaptivecards-designer/containers/skype/skype-container' {
	import * as Adaptive from 'adaptivecards-designer/adaptivecards';
	import { SingleThemeHostContainer } from 'adaptivecards-designer/containers/single-theme-host-container';
	export class SkypeContainer extends SingleThemeHostContainer {
	    renderTo(hostElement: HTMLElement): void;
	    getHostConfig(): Adaptive.HostConfig;
	}

}
declare module 'adaptivecards-designer/containers/teams/teams-container' {
	import * as Adaptive from 'adaptivecards-designer/adaptivecards';
	import { MultiThemeHostContainer } from 'adaptivecards-designer/containers/multi-theme-host-container';
	export class TeamsContainer extends MultiThemeHostContainer {
	    constructor();
	    renderTo(hostElement: HTMLElement): void;
	    get targetVersion(): Adaptive.Version;
	    get enableDeviceEmulation(): boolean;
	}

}
declare module 'adaptivecards-designer/containers/timeline/timeline-container' {
	import * as Adaptive from 'adaptivecards-designer/adaptivecards';
	import { SingleThemeHostContainer } from 'adaptivecards-designer/containers/single-theme-host-container';
	export class TimelineContainer extends SingleThemeHostContainer {
	    initialize(): void;
	    renderTo(hostElement: HTMLElement): void;
	    getHostConfig(): Adaptive.HostConfig;
	    get isFixedHeight(): boolean;
	}

}
declare module 'adaptivecards-designer/containers/webchat/webchat-container' {
	import * as Adaptive from 'adaptivecards-designer/adaptivecards';
	import { SingleThemeHostContainer } from 'adaptivecards-designer/containers/single-theme-host-container';
	export class WebChatContainer extends SingleThemeHostContainer {
	    renderTo(hostElement: HTMLElement): void;
	    getHostConfig(): Adaptive.HostConfig;
	    get targetVersion(): Adaptive.Version;
	}

}
declare module 'adaptivecards-designer/containers/viva-connections/viva-connections-container' {
	import * as Adaptive from 'adaptivecards-designer/adaptivecards';
	import { MultiThemeHostContainer } from 'adaptivecards-designer/containers/multi-theme-host-container';
	export class VivaConnectionsContainer extends MultiThemeHostContainer {
	    constructor();
	    renderTo(hostElement: HTMLElement): void;
	    get targetVersion(): Adaptive.Version;
	}

}
declare module 'adaptivecards-designer/containers/federated-search/federated-search-container' {
	import * as Adaptive from 'adaptivecards-designer/adaptivecards';
	import { SingleThemeHostContainer } from 'adaptivecards-designer/containers/single-theme-host-container';
	export class FederatedSearchContainer extends SingleThemeHostContainer {
	    constructor(name: string, styleSheet: string);
	    renderTo(hostElement: HTMLElement): void;
	    initialize(): void;
	    getHostConfig(): Adaptive.HostConfig;
	    get targetVersion(): Adaptive.Version;
	    get enableDeviceEmulation(): boolean;
	}

}
declare module 'adaptivecards-designer/containers/index' {
	export * from 'adaptivecards-designer/containers/host-container';
	export * from 'adaptivecards-designer/containers/default/default-container';
	export * from 'adaptivecards-designer/containers/widget/widget-container';
	export * from 'adaptivecards-designer/containers/bf-image/bf-image-container';
	export * from 'adaptivecards-designer/containers/cortana-classic/cortana-classic-container';
	export * from 'adaptivecards-designer/containers/cortana/cortana-container';
	export * from 'adaptivecards-designer/containers/notifications/toast-container';
	export * from 'adaptivecards-designer/containers/outlook/outlook-container';
	export * from 'adaptivecards-designer/containers/skype/skype-container';
	export * from 'adaptivecards-designer/containers/teams/teams-container';
	export * from 'adaptivecards-designer/containers/timeline/timeline-container';
	export * from 'adaptivecards-designer/containers/webchat/webchat-container';
	export * from 'adaptivecards-designer/containers/viva-connections/viva-connections-container';
	export * from 'adaptivecards-designer/containers/federated-search/federated-search-container';

}
declare module 'adaptivecards-designer/device-emulation' {
	export abstract class DeviceEmulation {
	    readonly name: string;
	    readonly maxWidth: string | undefined;
	    constructor(name: string, maxWidth: string | undefined);
	}

}
declare module 'adaptivecards-designer/strings' {
	export class Strings {
	    static readonly toolboxes: {
	        toolPalette: {
	            title: string;
	        };
	        cardEditor: {
	            title: string;
	        };
	        sampleDataEditor: {
	            title: string;
	        };
	        sampleHostDataEditor: {
	            title: string;
	        };
	        propertySheet: {
	            title: string;
	            commands: {
	                bindData: {
	                    displayText: () => string;
	                    accessibleText: (propertyLabel: string) => string;
	                };
	            };
	        };
	        cardStructure: {
	            title: string;
	        };
	        dataStructure: {
	            title: string;
	        };
	    };
	    static loadingEditor: string;
	    static readonly widgetOverflowWarning: string;
	}

}
declare module 'adaptivecards-designer/shared' {
	import * as Adaptive from 'adaptivecards-designer/adaptivecards';
	export class GlobalSettings {
	    static enableDataBindingSupport: boolean;
	    static showDataStructureToolbox: boolean;
	    static showSampleDataEditorToolbox: boolean;
	    static showSampleHostDataEditorToolbox: boolean;
	    static showVersionPicker: boolean;
	    static selectedHostContainerControlsTargetVersion: boolean;
	    static showTargetVersionMismatchWarning: boolean;
	    static supportedTargetVersions: Adaptive.Version[];
	}

}
declare module 'adaptivecards-designer/data' {
	export type ValueType = "String" | "Boolean" | "Number" | "Array" | "Object";
	export interface IStringData {
	    valueType: "String";
	    sampleValue?: string;
	}
	export interface INumberData {
	    valueType: "Number";
	    sampleValue?: number;
	}
	export interface IBooleanData {
	    valueType: "Boolean";
	    sampleValue?: boolean;
	}
	export interface IArrayData {
	    valueType: "Array";
	    itemType: IData;
	}
	export interface IObjectData {
	    valueType: "Object";
	    fields: IField[];
	}
	export type IData = IStringData | IBooleanData | INumberData | IArrayData | IObjectData;
	export interface IDataField {
	    name: string;
	    displayName: string;
	}
	export interface IStringField extends IDataField, IStringData {
	}
	export interface INumberField extends IDataField, INumberData {
	}
	export interface IBooleanField extends IDataField, IBooleanData {
	}
	export interface IObjectField extends IDataField, IObjectData {
	}
	export interface IArrayField extends IDataField, IArrayData {
	}
	export type IField = IStringField | INumberField | IBooleanField | IObjectField | IArrayField;
	export abstract class DataType {
	    readonly owner: FieldDefinition;
	    static parse(parent: FieldDefinition, data: IData): DataType;
	    static deriveFrom(parent: FieldDefinition, value: any): DataType;
	    constructor(owner: FieldDefinition);
	    abstract generateSampleData(): any;
	    getChildFields(): FieldDefinition[];
	    qualifyFieldName(fieldName: string, fieldIsLeaf: boolean): string;
	    abstract get valueType(): ValueType;
	    get isCollection(): boolean;
	}
	export class ValueTypeData<T extends string | number | boolean> extends DataType {
	    readonly owner: FieldDefinition;
	    readonly defaultSampleValue: T;
	    private _sampleValue;
	    constructor(owner: FieldDefinition, defaultSampleValue: T, sampleValue?: T);
	    generateSampleData(): T;
	    get sampleValue(): T;
	    get valueType(): ValueType;
	}
	export class ArrayData extends DataType {
	    readonly owner: FieldDefinition;
	    static parse(parent: FieldDefinition, data: IArrayData): ArrayData;
	    static deriveFrom(parent: FieldDefinition, input: object): ArrayData;
	    dataType: DataType;
	    constructor(owner: FieldDefinition);
	    generateSampleData(): any;
	    getChildFields(): FieldDefinition[];
	    qualifyFieldName(fieldName: string, fieldIsLeaf: boolean): string;
	    get isCollection(): boolean;
	    get valueType(): ValueType;
	}
	export class ObjectData extends DataType {
	    readonly owner: FieldDefinition;
	    static parse(parent: FieldDefinition, data: IObjectData): ObjectData;
	    static deriveFrom(parent: FieldDefinition, input: object): ObjectData;
	    readonly fields: FieldDefinition[];
	    constructor(owner: FieldDefinition);
	    generateSampleData(): any;
	    getChildFields(): FieldDefinition[];
	    get valueType(): ValueType;
	}
	export class FieldDefinition {
	    readonly parent: FieldDefinition;
	    static parse(data: IData): FieldDefinition;
	    static deriveFrom(input: any): FieldDefinition;
	    private _displayName;
	    name: string;
	    dataType: DataType;
	    constructor(parent: FieldDefinition);
	    asExpression(): string;
	    getPath(asLeaf?: boolean): string;
	    qualifiedName(asLeaf: boolean): string;
	    get displayName(): string;
	    set displayName(value: string);
	    get children(): FieldDefinition[];
	    get isCollection(): boolean;
	    get valueType(): string;
	}

}
declare module 'adaptivecards-designer/miscellaneous' {
	import * as Adaptive from 'adaptivecards-designer/adaptivecards';
	export interface IPoint {
	    x: number;
	    y: number;
	}
	export class Rect {
	    top: number;
	    right: number;
	    bottom: number;
	    left: number;
	    constructor(top?: number, right?: number, bottom?: number, left?: number);
	    union(otherRect: Rect): void;
	    isInside(point: IPoint): boolean;
	    get width(): number;
	    get height(): number;
	}
	export class Utils {
	    static isAbsoluteUrl(urlString: string): boolean;
	    static joinPaths(...args: string[]): string;
	    static adjustPointForScroll(position: IPoint): IPoint;
	}
	export var defaultHostConfig: Adaptive.HostConfig;

}
declare module 'adaptivecards-designer/draggable-element' {
	export const DRAG_THRESHOLD = 10;
	export abstract class DraggableElement {
	    private _renderedElement;
	    private _isPointerOver;
	    private _isPointerDown;
	    private _lastClickedPoint;
	    private _dragging;
	    private releasePointerCapture;
	    protected get isPointerOver(): boolean;
	    protected set isPointerOver(value: boolean);
	    protected startDrag(): void;
	    protected pointerDown(e: PointerEvent): void;
	    protected pointerUp(e: PointerEvent): void;
	    protected pointerMove(e: PointerEvent): void;
	    protected click(e: MouseEvent): void;
	    protected doubleClick(e: MouseEvent): void;
	    protected internalUpdateCssStyles(): void;
	    protected internalUpdateLayout(): void;
	    protected getDragSourceElement(): HTMLElement;
	    protected abstract internalRender(): HTMLElement;
	    onStartDrag: (sender: DraggableElement) => void;
	    onEndDrag: (sender: DraggableElement) => void;
	    onClick: (sender: DraggableElement) => void;
	    onDoubleClick: (sender: DraggableElement) => void;
	    isDraggable(): boolean;
	    endDrag(): void;
	    updateLayout(): void;
	    render(): HTMLElement;
	    focus(): void;
	    get renderedElement(): HTMLElement;
	    get dragging(): boolean;
	    set dragging(value: boolean);
	}

}
declare module 'adaptivecards-designer/base-tree-item' {
	import { DraggableElement } from 'adaptivecards-designer/draggable-element';
	export abstract class BaseTreeItem extends DraggableElement {
	    private static collapsedIconClass;
	    private static expandedIconClass;
	    private _isExpanded;
	    private _isSelected;
	    private _rootElement;
	    private _treeItemElement;
	    private _expandCollapseElement;
	    private _childContainerElement;
	    private needsToBeScrolled;
	    private setIsSelected;
	    protected abstract getLabelText(): string;
	    protected click(e: MouseEvent): void;
	    protected getIconClass(): string;
	    protected getAdditionalText(): string;
	    protected getAdditionalTextClass(): string;
	    protected getIndentationLevelIncrement(): number;
	    protected getDragSourceElement(): HTMLElement;
	    protected selectedChanged(scrollIntoView: boolean): void;
	    private getExpandCollapseAriaText;
	    protected internalRender(): HTMLElement;
	    protected _level: number;
	    onSelectedChange: (sender: BaseTreeItem) => void;
	    constructor(isExpanded?: boolean);
	    abstract getChildCount(): number;
	    abstract getChildAt(index: number): BaseTreeItem;
	    updateLayout(): void;
	    expand(): void;
	    collpase(): void;
	    isDraggable(): boolean;
	    get level(): number;
	    get isSelected(): boolean;
	    set isSelected(value: boolean);
	}

}
declare module 'adaptivecards-designer/tree-view' {
	import { BaseTreeItem } from 'adaptivecards-designer/base-tree-item';
	export class TreeView {
	    readonly rootItem: BaseTreeItem;
	    private _selectedItem;
	    private setupTreeItemEvents;
	    protected selectedItemChanged(): void;
	    focus(): void;
	    render(): HTMLElement;
	    onSelectedItemChanged: (sender: TreeView) => void;
	    constructor(rootItem: BaseTreeItem);
	    get selectedItem(): BaseTreeItem;
	    set selectedItem(value: BaseTreeItem);
	}

}
declare module 'adaptivecards-designer/data-treeitem' {
	import { BaseTreeItem } from 'adaptivecards-designer/base-tree-item';
	import * as Data from 'adaptivecards-designer/data';
	export class DataTreeItem extends BaseTreeItem {
	    private _children;
	    private buildChildList;
	    protected getLabelText(): string;
	    protected getAdditionalText(): string;
	    protected getAdditionalTextClass(): string;
	    readonly field: Data.FieldDefinition;
	    constructor(field: Data.FieldDefinition);
	    isDraggable(): boolean;
	    getChildCount(): number;
	    getChildAt(index: number): DataTreeItem;
	}

}
declare module 'adaptivecards-designer/field-picker' {
	import * as Controls from 'adaptivecards-designer/adaptivecards-controls';
	import { FieldDefinition } from 'adaptivecards-designer/data';
	export class FieldPicker extends Controls.PopupControl {
	    readonly dataStructure: FieldDefinition;
	    private _selectedField;
	    private _treeView;
	    protected renderContent(): HTMLElement;
	    /**
	     * @inheritdoc
	     */
	    render(rootElementBounds: ClientRect): HTMLElement;
	    constructor(dataStructure: FieldDefinition);
	    /**
	     * @inheritdoc
	     */
	    focus(): void;
	    keyDown(e: KeyboardEvent): void;
	    get selectedField(): FieldDefinition;
	}

}
declare module 'adaptivecards-designer/peer-command' {
	export class PeerCommand {
	    private _renderedElement;
	    protected internalRender(): HTMLElement;
	    name: string;
	    alwaysShowName: boolean;
	    toolTip: string;
	    iconClass: string;
	    isPromotable: boolean;
	    showInPropertySheet: boolean;
	    execute: (command: PeerCommand, clickedElement: HTMLElement) => void;
	    constructor(init?: Partial<PeerCommand>);
	    render(): HTMLElement;
	    get renderedElement(): HTMLElement;
	}

}
declare module 'adaptivecards-designer/designer-peer-treeitem' {
	import { BaseTreeItem } from 'adaptivecards-designer/base-tree-item';
	import { DesignerPeer } from 'adaptivecards-designer/designer-peers';
	export class DesignerPeerTreeItem extends BaseTreeItem {
	    private computeLevel;
	    protected getIconClass(): string;
	    protected getLabelText(): string;
	    protected getAdditionalText(): string;
	    protected selectedChanged(scrollIntoView: boolean): void;
	    readonly owner: DesignerPeer;
	    constructor(owner: DesignerPeer, isExpanded?: boolean);
	    getChildCount(): number;
	    getChildAt(index: number): BaseTreeItem;
	    protected click(e: MouseEvent): void;
	}

}
declare module 'adaptivecards-designer/designer-peers' {
	import * as Adaptive from 'adaptivecards-designer/adaptivecards';
	import { DraggableElement } from 'adaptivecards-designer/draggable-element';
	import { PeerCommand } from 'adaptivecards-designer/peer-command';
	import { CardDesignerSurface, DesignContext } from 'adaptivecards-designer/card-designer-surface';
	import { DesignerPeerTreeItem } from 'adaptivecards-designer/designer-peer-treeitem';
	import { Rect, IPoint } from 'adaptivecards-designer/miscellaneous';
	export abstract class DesignerPeerInplaceEditor {
	    onClose: (applyChanges: boolean) => void;
	    abstract initialize(): any;
	    abstract applyChanges(): any;
	    abstract render(): HTMLElement;
	}
	export abstract class CardElementPeerInplaceEditor<TCardElement extends Adaptive.CardElement> extends DesignerPeerInplaceEditor {
	    readonly cardElement: TCardElement;
	    constructor(cardElement: TCardElement);
	}
	export class DesignerPeerRegistrationBase {
	    private _iconClass?;
	    readonly category: string;
	    constructor(category: string, iconClass?: string);
	    get iconClass(): string;
	}
	export class DesignerPeerRegistration<TSource, TPeer> extends DesignerPeerRegistrationBase {
	    readonly sourceType: TSource;
	    peerType: TPeer;
	    constructor(sourceType: TSource, peerType: TPeer, category: string, iconClass?: string);
	}
	export class PropertySheetCategory {
	    readonly name: string;
	    static readonly DefaultCategory = "__defaultCategory";
	    static readonly LayoutCategory = "Layout";
	    static readonly StyleCategory = "Style";
	    static readonly SelectionAction = "Selection action";
	    static readonly InlineAction = "Inline action";
	    static readonly Validation = "Validation";
	    static readonly Refresh = "Refresh";
	    private _entries;
	    constructor(name: string);
	    render(container: Adaptive.Container, context: PropertySheetContext, displayCategoryName: boolean): void;
	    add(...entries: PropertySheetEntry[]): void;
	    remove(...entries: PropertySheetEntry[]): void;
	    getEntryAt(index: number): PropertySheetEntry;
	    get length(): number;
	}
	export class PropertySheet {
	    readonly displayCategoryNames: boolean;
	    private _categories;
	    constructor(displayCategoryNames?: boolean);
	    add(categoryName: string, ...entries: PropertySheetEntry[]): void;
	    addActionProperties(targetVersion: Adaptive.Version, peer: DesignerPeer, action: Adaptive.Action, category: string, excludeProperties?: PropertySheetEntry[]): void;
	    remove(...entries: PropertySheetEntry[]): void;
	    render(container: Adaptive.Container, context: PropertySheetContext): void;
	}
	export class PropertySheetContext {
	    readonly designContext: DesignContext;
	    readonly peer: DesignerPeer;
	    private _target;
	    constructor(designContext: DesignContext, peer: DesignerPeer, target?: object);
	    get target(): object;
	}
	export abstract class PropertySheetEntry {
	    readonly targetVersion: Adaptive.TargetVersion;
	    abstract render(context: PropertySheetContext): Adaptive.CardElement;
	    constructor(targetVersion: Adaptive.TargetVersion);
	}
	export class SubPropertySheetEntry {
	    readonly targetVersion: Adaptive.TargetVersion;
	    readonly target: object;
	    readonly propertySheet: PropertySheet;
	    render(context: PropertySheetContext): Adaptive.CardElement;
	    constructor(targetVersion: Adaptive.TargetVersion, target: object, propertySheet: PropertySheet);
	}
	export class CustomPropertySheetEntry extends PropertySheetEntry {
	    readonly targetVersion: Adaptive.TargetVersion;
	    readonly onRender: (context: PropertySheetContext) => Adaptive.CardElement;
	    render(context: PropertySheetContext): Adaptive.CardElement;
	    constructor(targetVersion: Adaptive.TargetVersion, onRender: (context: PropertySheetContext) => Adaptive.CardElement);
	}
	export interface IPropertySheetEditorCommand {
	    id?: string;
	    caption: string;
	    altText?: string;
	    expanded?: boolean;
	    onExecute: (sender: SingleInputPropertyEditor, clickedElement: HTMLElement) => void;
	}
	export abstract class SingleInputPropertyEditor extends PropertySheetEntry {
	    readonly targetVersion: Adaptive.TargetVersion;
	    readonly propertyName: string;
	    readonly label: string;
	    readonly causesPropertySheetRefresh: boolean;
	    protected abstract createInput(context: PropertySheetContext): Adaptive.Input;
	    protected getPropertyValue(context: PropertySheetContext): any;
	    protected setPropertyValue(context: PropertySheetContext, value: string): void;
	    protected getAdditionalCommands(context: PropertySheetContext): IPropertySheetEditorCommand[];
	    render(context: PropertySheetContext): Adaptive.CardElement;
	    constructor(targetVersion: Adaptive.TargetVersion, propertyName: string, label: string, causesPropertySheetRefresh?: boolean);
	}
	export class BaseStringPropertyEditor extends SingleInputPropertyEditor {
	    readonly targetVersion: Adaptive.TargetVersion;
	    readonly propertyName: string;
	    readonly label: string;
	    readonly allowBinding: boolean;
	    readonly isMultiline: boolean;
	    readonly causesPropertySheetRefresh: boolean;
	    protected placeHolder: string;
	    protected createInput(context: PropertySheetContext): Adaptive.Input;
	    constructor(targetVersion: Adaptive.TargetVersion, propertyName: string, label: string, allowBinding?: boolean, isMultiline?: boolean, causesPropertySheetRefresh?: boolean);
	}
	export class StringPropertyEditor extends BaseStringPropertyEditor {
	    protected getAdditionalCommands(context: PropertySheetContext): IPropertySheetEditorCommand[];
	}
	export class StringArrayPropertyEditor extends BaseStringPropertyEditor {
	    readonly targetVersion: Adaptive.TargetVersion;
	    readonly propertyName: string;
	    readonly label: string;
	    readonly allowBinding: boolean;
	    readonly isMultiline: boolean;
	    readonly causesPropertySheetRefresh: boolean;
	    protected getPropertyValue(context: PropertySheetContext): any;
	    protected setPropertyValue(context: PropertySheetContext, value: string): void;
	    constructor(targetVersion: Adaptive.TargetVersion, propertyName: string, label: string, allowBinding?: boolean, isMultiline?: boolean, causesPropertySheetRefresh?: boolean);
	}
	export class NumberPropertyEditor extends SingleInputPropertyEditor {
	    readonly targetVersion: Adaptive.TargetVersion;
	    readonly propertyName: string;
	    readonly label: string;
	    readonly defaultValue: number | undefined;
	    readonly causesPropertySheetRefresh: boolean;
	    protected _input: Adaptive.NumberInput;
	    protected setPropertyValue(context: PropertySheetContext, value: string): void;
	    protected createInput(context: PropertySheetContext): Adaptive.Input;
	    constructor(targetVersion: Adaptive.TargetVersion, propertyName: string, label: string, defaultValue?: number | undefined, causesPropertySheetRefresh?: boolean);
	}
	export class ObjectPropertyEditor extends StringPropertyEditor {
	    protected getPropertyValue(context: PropertySheetContext): any;
	    protected setPropertyValue(context: PropertySheetContext, value: string): void;
	}
	export class CustomCardObjectPropertyEditor extends StringPropertyEditor {
	    protected getPropertyValue(context: PropertySheetContext): any;
	    protected setPropertyValue(context: PropertySheetContext, value: string): void;
	}
	export class BooleanPropertyEditor extends SingleInputPropertyEditor {
	    protected getPropertyValue(context: PropertySheetContext): any;
	    protected setPropertyValue(context: PropertySheetContext, value: string): void;
	    protected createInput(context: PropertySheetContext): Adaptive.Input;
	}
	export interface IVersionedChoice {
	    targetVersion: Adaptive.TargetVersion;
	    name: string;
	    value: string;
	}
	export class ChoicePropertyEditor extends SingleInputPropertyEditor {
	    readonly targetVersion: Adaptive.TargetVersion;
	    readonly propertyName: string;
	    readonly label: string;
	    readonly choices: IVersionedChoice[];
	    readonly causesPropertySheetRefresh: boolean;
	    readonly isNullable: boolean;
	    protected getPropertyValue(context: PropertySheetContext): any;
	    protected setPropertyValue(context: PropertySheetContext, value: string): void;
	    protected createInput(context: PropertySheetContext): Adaptive.Input;
	    constructor(targetVersion: Adaptive.TargetVersion, propertyName: string, label: string, choices: IVersionedChoice[], causesPropertySheetRefresh?: boolean, isNullable?: boolean);
	}
	export class ContainerStylePropertyEditor extends ChoicePropertyEditor {
	    readonly targetVersion: Adaptive.TargetVersion;
	    readonly propertyName: string;
	    readonly label: string;
	    protected getPropertyValue(context: PropertySheetContext): any;
	    protected setPropertyValue(context: PropertySheetContext, value: string): void;
	    constructor(targetVersion: Adaptive.TargetVersion, propertyName: string, label: string);
	}
	export class NullableBooleanPropertyEditor extends ChoicePropertyEditor {
	    readonly targetVersion: Adaptive.TargetVersion;
	    readonly propertyName: string;
	    readonly label: string;
	    protected getPropertyValue(context: PropertySheetContext): any;
	    protected setPropertyValue(context: PropertySheetContext, value: string): void;
	    constructor(targetVersion: Adaptive.TargetVersion, propertyName: string, label: string);
	}
	export class ColumnWidthPropertyEditor extends ChoicePropertyEditor {
	    protected getPropertyValue(context: PropertySheetContext): any;
	    protected setPropertyValue(context: PropertySheetContext, value: string): void;
	}
	export class HeightPropertyEditor extends ChoicePropertyEditor {
	    protected setPropertyValue(context: PropertySheetContext, value: string): void;
	}
	export class SizeAndUnitPropertyEditor extends NumberPropertyEditor {
	    readonly targetVersion: Adaptive.TargetVersion;
	    readonly propertyName: string;
	    readonly label: string;
	    readonly sizeUnit: Adaptive.SizeUnit;
	    readonly defaultValue: number | undefined;
	    readonly causesPropertySheetRefresh: boolean;
	    protected getPropertyValue(context: PropertySheetContext): any;
	    protected setPropertyValue(context: PropertySheetContext, value: string): void;
	    constructor(targetVersion: Adaptive.TargetVersion, propertyName: string, label: string, sizeUnit: Adaptive.SizeUnit, defaultValue?: number | undefined, causesPropertySheetRefresh?: boolean);
	}
	export class CarouselTimerPropertyEditor extends NumberPropertyEditor {
	    protected setPropertyValue(context: PropertySheetContext, value: string): void;
	}
	export class ActionPropertyEditor extends SingleInputPropertyEditor {
	    readonly targetVersion: Adaptive.TargetVersion;
	    readonly propertyName: string;
	    readonly label: string;
	    readonly forbiddenActionTypes: string[];
	    readonly causesPropertySheetRefresh: boolean;
	    protected getPropertyValue(context: PropertySheetContext): any;
	    protected setPropertyValue(context: PropertySheetContext, value: string): void;
	    protected createInput(context: PropertySheetContext): Adaptive.Input;
	    constructor(targetVersion: Adaptive.TargetVersion, propertyName: string, label: string, forbiddenActionTypes?: string[], causesPropertySheetRefresh?: boolean);
	}
	export class CompoundPropertyEditor extends PropertySheetEntry {
	    readonly targetVersion: Adaptive.TargetVersion;
	    readonly propertyName: string;
	    readonly entries: PropertySheetEntry[];
	    readonly initializeProperty?: () => object;
	    render(context: PropertySheetContext): Adaptive.CardElement;
	    constructor(targetVersion: Adaptive.TargetVersion, propertyName: string, entries?: PropertySheetEntry[], initializeProperty?: () => object);
	}
	export class EnumPropertyEditor extends SingleInputPropertyEditor {
	    readonly targetVersion: Adaptive.TargetVersion;
	    readonly propertyName: string;
	    readonly label: string;
	    readonly enumType: {
	        [s: number]: string;
	    };
	    readonly causesPropertySheetRefresh: boolean;
	    readonly isNullable: boolean;
	    protected getPropertyValue(context: PropertySheetContext): any;
	    protected setPropertyValue(context: PropertySheetContext, value: string): void;
	    protected createInput(context: PropertySheetContext): Adaptive.Input;
	    constructor(targetVersion: Adaptive.TargetVersion, propertyName: string, label: string, enumType: {
	        [s: number]: string;
	    }, causesPropertySheetRefresh?: boolean, isNullable?: boolean);
	} class NameValuePairPropertyEditor extends PropertySheetEntry {
	    readonly targetVersion: Adaptive.TargetVersion;
	    readonly collectionPropertyName: string;
	    readonly namePropertyName: string;
	    readonly valuePropertyName: string;
	    readonly createCollectionItem: (name: string, value: string) => any;
	    readonly namePropertyLabel: string;
	    readonly valuePropertyLabel: string;
	    readonly addButtonTitle: string;
	    readonly messageIfEmpty: string;
	    private collectionChanged;
	    render(context: PropertySheetContext): Adaptive.CardElement;
	    constructor(targetVersion: Adaptive.TargetVersion, collectionPropertyName: string, namePropertyName: string, valuePropertyName: string, createCollectionItem: (name: string, value: string) => any, namePropertyLabel?: string, valuePropertyLabel?: string, addButtonTitle?: string, messageIfEmpty?: string);
	} type NameAndValue = {
	    name: string;
	    value?: string;
	}; type InnerPropertiesDictionary = {
	    [name: string]: NameAndValue;
	}; class InnerStructPropertyEditor extends PropertySheetEntry {
	    readonly targetVersion: Adaptive.TargetVersion;
	    readonly collectionPropertyName: string;
	    readonly innerPropertiesDefaults: InnerPropertiesDictionary;
	    readonly createCollectionItem: (innerProperties: InnerPropertiesDictionary) => any;
	    readonly addButtonTitle: string;
	    readonly messageIfEmpty: string;
	    private collectionChanged;
	    render(context: PropertySheetContext): Adaptive.CardElement;
	    constructor(targetVersion: Adaptive.TargetVersion, collectionPropertyName: string, innerPropertiesDefaults: InnerPropertiesDictionary, createCollectionItem: (innerProperties: InnerPropertiesDictionary) => any, addButtonTitle?: string, messageIfEmpty?: string);
	}
	export abstract class DesignerPeer extends DraggableElement {
	    static readonly idProperty: StringPropertyEditor;
	    static onPopulatePropertySheet?: (sender: DesignerPeer, propertySheet: PropertySheet) => void;
	    private _parent;
	    private _cardObject;
	    private _children;
	    private _isSelected;
	    private _inplaceEditorOverlay;
	    private _inplaceEditor;
	    private _insertAfterNeighbor;
	    private _parentCarouselPagePeer;
	    private closeInplaceEditor;
	    private tryOpenInplaceEditor;
	    protected click(e: MouseEvent): void;
	    protected doubleClick(e: MouseEvent): void;
	    protected isContainer(): boolean;
	    protected getToolTip(): string;
	    protected internalAddCommands(context: DesignContext, commands: Array<PeerCommand>): void;
	    protected internalRender(): HTMLElement;
	    protected internalUpdateCssStyles(): void;
	    protected peerAdded(newPeer: DesignerPeer): void;
	    protected peerRemoved(peer: DesignerPeer): void;
	    protected internalUpdateLayout(): void;
	    protected createInplaceEditor(): DesignerPeerInplaceEditor;
	    protected internalGetTreeItemText(): string;
	    protected abstract internalRemove(): boolean;
	    readonly registration: DesignerPeerRegistrationBase;
	    readonly designerSurface: CardDesignerSurface;
	    readonly treeItem: DesignerPeerTreeItem;
	    onParentChanged: (sender: DesignerPeer) => void;
	    onSelectedChanged: (sender: DesignerPeer) => void;
	    onChanged: (sender: DesignerPeer, updatePropertySheet: boolean) => void;
	    onPeerRemoved: (sender: DesignerPeer) => void;
	    onPeerAdded: (sender: DesignerPeer, newPeer: DesignerPeer) => void;
	    constructor(parent: DesignerPeer, designerSurface: CardDesignerSurface, registration: DesignerPeerRegistrationBase, cardObject: Adaptive.CardObject);
	    abstract getBoundingRect(): Rect;
	    abstract getCardObjectBoundingRect(): Rect;
	    getCardObject(): Adaptive.CardObject;
	    updateChildren(): void;
	    changed(updatePropertySheet: boolean): void;
	    getTreeItemText(): string;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	    canDrop(peer: DesignerPeer): boolean;
	    canBeRemoved(): boolean;
	    tryDrop(peer: DesignerPeer, insertionPoint: IPoint): boolean;
	    tryAdd(peer: DesignerPeer): boolean;
	    insertChild(peer: DesignerPeer, index?: number): void;
	    removeChild(peer: DesignerPeer): void;
	    getChildCount(): number;
	    getChildAt(index: number): DesignerPeer;
	    getCommands(context: DesignContext, promoteParentCommands?: boolean): Array<PeerCommand>;
	    remove(onlyFromCard: boolean, removeChildren: boolean): boolean;
	    addElementsToDesignerSurface(designerSurface: HTMLElement, neighbor?: HTMLElement): HTMLElement;
	    removeElementsFromDesignerSurface(processChildren?: boolean): void;
	    buildPropertySheetCard(context: DesignContext): Adaptive.AdaptiveCard;
	    scrollIntoView(): void;
	    private updateParentCarouselPagePeer;
	    get isTreeItemExpandedByDefault(): boolean;
	    get parent(): DesignerPeer;
	    set parent(value: DesignerPeer);
	    get isSelected(): boolean;
	    set isSelected(value: boolean);
	    get insertAfterNeighbor(): boolean;
	    set insertAfterNeighbor(insertAfterNeighbor: boolean);
	    get children(): Array<DesignerPeer>;
	    get parentCarouselPagePeer(): CarouselPagePeer | undefined;
	}
	export class ActionPeer extends DesignerPeer {
	    static readonly titleProperty: StringPropertyEditor;
	    static readonly modeProperty: ChoicePropertyEditor;
	    static readonly styleProperty: ChoicePropertyEditor;
	    static readonly iconUrlProperty: StringPropertyEditor;
	    static readonly tooltipProperty: StringPropertyEditor;
	    static readonly isEnabledProperty: BooleanPropertyEditor;
	    protected doubleClick(e: MouseEvent): void;
	    protected internalRemove(): boolean;
	    constructor(parent: DesignerPeer, designerSurface: CardDesignerSurface, registration: DesignerPeerRegistrationBase, action: Adaptive.Action);
	    protected internalGetTreeItemText(): string;
	    protected internalUpdateLayout(): void;
	    isDraggable(): boolean;
	    getBoundingRect(): Rect;
	    getCardObjectBoundingRect(): Rect;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	    get action(): Adaptive.Action;
	}
	export abstract class TypedActionPeer<TAction extends Adaptive.Action> extends ActionPeer {
	    constructor(parent: DesignerPeer, designerSurface: CardDesignerSurface, registration: DesignerPeerRegistrationBase, action: TAction);
	    get action(): TAction;
	}
	export class HttpActionPeer extends TypedActionPeer<Adaptive.HttpAction> {
	    static readonly ignoreInputValidationProperty: BooleanPropertyEditor;
	    static readonly methodProperty: ChoicePropertyEditor;
	    static readonly urlProperty: StringPropertyEditor;
	    static readonly bodyProperty: StringPropertyEditor;
	    static readonly headersProperty: NameValuePairPropertyEditor;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	}
	export abstract class BaseSubmitActionPeer<TAction extends Adaptive.SubmitAction> extends TypedActionPeer<TAction> {
	    static readonly dataProperty: ObjectPropertyEditor;
	    static readonly associatedInputsProperty: ChoicePropertyEditor;
	    static readonly disabledUnlessAssociatedInputsChangeProperty: BooleanPropertyEditor;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	}
	export class SubmitActionPeer extends BaseSubmitActionPeer<Adaptive.SubmitAction> {
	}
	export class ExecuteActionPeer extends BaseSubmitActionPeer<Adaptive.ExecuteAction> {
	    static readonly verbProperty: StringPropertyEditor;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	}
	export class OpenUrlActionPeer extends TypedActionPeer<Adaptive.OpenUrlAction> {
	    static readonly urlProperty: StringPropertyEditor;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	}
	export class ShowCardActionPeer extends TypedActionPeer<Adaptive.ShowCardAction> {
	    protected getToolTip(): string;
	}
	export class ToggleVisibilityActionPeer extends TypedActionPeer<Adaptive.ToggleVisibilityAction> {
	}
	export class CardElementPeer extends DesignerPeer {
	    static readonly dataContextProperty: CustomCardObjectPropertyEditor;
	    static readonly whenProperty: CustomCardObjectPropertyEditor;
	    static readonly idProperty: StringPropertyEditor;
	    static readonly isVisibleProperty: BooleanPropertyEditor;
	    static readonly spacingProperty: EnumPropertyEditor;
	    static readonly separatorProperty: BooleanPropertyEditor;
	    static readonly horizontalAlignmentProperty: EnumPropertyEditor;
	    static readonly heightProperty: HeightPropertyEditor;
	    protected insertElementAfter(newElement: Adaptive.CardElement): void;
	    protected internalRemove(): boolean;
	    protected internalUpdateCssStyles(): void;
	    constructor(parent: DesignerPeer, designerSurface: CardDesignerSurface, registration: DesignerPeerRegistrationBase, cardElement: Adaptive.CardElement, initializeCardElement?: boolean);
	    findCardElementChild(element: Adaptive.CardElement): CardElementPeer | undefined;
	    findActionChild(action: Adaptive.Action): ActionPeer | undefined;
	    updateChildren(initializeCardElement?: boolean): void;
	    getTreeItemText(): string;
	    initializeCardElement(): void;
	    canDrop(peer: DesignerPeer): boolean;
	    tryDrop(peer: DesignerPeer, insertionPoint: IPoint): boolean;
	    tryAdd(peer: DesignerPeer): boolean;
	    getBoundingRect(): Rect;
	    getCardObjectBoundingRect(): Rect;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	    get cardElement(): Adaptive.CardElement;
	    isVisible(): boolean;
	    bringCardElementIntoView(): boolean;
	}
	export abstract class TypedCardElementPeer<TCardElement extends Adaptive.CardElement> extends CardElementPeer {
	    constructor(parent: DesignerPeer, designerSurface: CardDesignerSurface, registration: DesignerPeerRegistrationBase, cardElement: TCardElement, initializeCardElement?: boolean);
	    get cardElement(): TCardElement;
	}
	export class AdaptiveCardPeer extends TypedCardElementPeer<Adaptive.AdaptiveCard> {
	    static readonly langProperty: StringPropertyEditor;
	    static readonly fallbackTextProperty: StringPropertyEditor;
	    static readonly speakProperty: StringPropertyEditor;
	    static readonly refreshProperty: CompoundPropertyEditor;
	    protected addAction(action: Adaptive.Action): void;
	    protected internalRemove(): boolean;
	    protected internalAddCommands(context: DesignContext, commands: Array<PeerCommand>): void;
	    isDraggable(): boolean;
	    canBeRemoved(): boolean;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	}
	export class ColumnPeer extends TypedCardElementPeer<Adaptive.Column> {
	    private static readonly pixelWidthProperty;
	    private static readonly weightProperty;
	    static readonly widthProperty: ColumnWidthPropertyEditor;
	    protected isContainer(): boolean;
	    protected internalGetTreeItemText(): string;
	    isDraggable(): boolean;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	}
	export class ColumnSetPeer extends TypedCardElementPeer<Adaptive.ColumnSet> {
	    protected isContainer(): boolean;
	    protected internalAddCommands(context: DesignContext, commands: Array<PeerCommand>): void;
	    protected internalGetTreeItemText(): string;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	    canDrop(peer: DesignerPeer): boolean;
	}
	export class ContainerPeer extends TypedCardElementPeer<Adaptive.Container> {
	    static readonly selectActionProperty: ActionPropertyEditor;
	    static readonly minHeightProperty: NumberPropertyEditor;
	    static readonly verticalContentAlignmentProperty: EnumPropertyEditor;
	    static readonly styleProperty: ContainerStylePropertyEditor;
	    static readonly bleedProperty: BooleanPropertyEditor;
	    static readonly backgroundImageProperty: CompoundPropertyEditor;
	    static readonly rtlProperty: BooleanPropertyEditor;
	    protected isContainer(): boolean;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	}
	export class ActionSetPeer extends TypedCardElementPeer<Adaptive.AdaptiveCard> {
	    protected addAction(action: Adaptive.Action): void;
	    protected internalAddCommands(context: DesignContext, commands: Array<PeerCommand>): void;
	}
	export class ImageSetPeer extends TypedCardElementPeer<Adaptive.ImageSet> {
	    static readonly ImageSizeProperty: EnumPropertyEditor;
	    protected internalAddCommands(context: DesignContext, commands: Array<PeerCommand>): void;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	}
	export class ImagePeer extends TypedCardElementPeer<Adaptive.Image> {
	    static readonly urlProperty: StringPropertyEditor;
	    static readonly altTextProperty: StringPropertyEditor;
	    static readonly sizeProperty: EnumPropertyEditor;
	    static readonly pixelWidthProperty: NumberPropertyEditor;
	    static readonly pixelHeightProperty: NumberPropertyEditor;
	    static readonly styleProperty: EnumPropertyEditor;
	    static readonly backgroundColorProperty: StringPropertyEditor;
	    private get isParentImageSet();
	    protected internalAddCommands(context: DesignContext, commands: Array<PeerCommand>): void;
	    isDraggable(): boolean;
	    getBoundingRect(): Rect;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	}
	export class MediaPeer extends TypedCardElementPeer<Adaptive.Media> {
	    static readonly altTextProperty: StringPropertyEditor;
	    static readonly posterUrlProperty: StringPropertyEditor;
	    static readonly sourcesProperty: InnerStructPropertyEditor;
	    static readonly captionSourcesProperty: InnerStructPropertyEditor;
	    protected internalGetTreeItemText(): string;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	}
	export class FactSetPeer extends TypedCardElementPeer<Adaptive.FactSet> {
	    static readonly factsProperty: NameValuePairPropertyEditor;
	    protected internalGetTreeItemText(): string;
	    initializeCardElement(): void;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	}
	export abstract class InputPeer<TInput extends Adaptive.Input> extends TypedCardElementPeer<TInput> {
	    static readonly labelProperty: StringPropertyEditor;
	    static readonly isRequiredProperty: BooleanPropertyEditor;
	    static readonly errorMessageProperty: StringPropertyEditor;
	    protected internalGetTreeItemText(): string;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	}
	export class TextInputPeer extends InputPeer<Adaptive.TextInput> {
	    static readonly defaultValueProperty: StringPropertyEditor;
	    static readonly placeholderProperty: StringPropertyEditor;
	    static readonly isMultilineProperty: BooleanPropertyEditor;
	    static readonly styleProperty: EnumPropertyEditor;
	    static readonly maxLengthProperty: NumberPropertyEditor;
	    static readonly inlineActionProperty: ActionPropertyEditor;
	    static readonly regexProperty: StringPropertyEditor;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	    initializeCardElement(): void;
	}
	export class NumberInputPeer extends InputPeer<Adaptive.NumberInput> {
	    static readonly defaultValueProperty: NumberPropertyEditor;
	    static readonly placeholderProperty: StringPropertyEditor;
	    static readonly minProperty: NumberPropertyEditor;
	    static readonly maxProperty: NumberPropertyEditor;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	    initializeCardElement(): void;
	}
	export class DateInputPeer extends InputPeer<Adaptive.DateInput> {
	    static readonly defaultValueProperty: StringPropertyEditor;
	    static readonly minProperty: StringPropertyEditor;
	    static readonly maxProperty: StringPropertyEditor;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	}
	export class TimeInputPeer extends InputPeer<Adaptive.TimeInput> {
	    static readonly defaultValueProperty: StringPropertyEditor;
	    static readonly minProperty: StringPropertyEditor;
	    static readonly maxProperty: StringPropertyEditor;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	}
	export class ToggleInputPeer extends InputPeer<Adaptive.ToggleInput> {
	    static readonly defaultValueProperty: StringPropertyEditor;
	    static readonly titleProperty: StringPropertyEditor;
	    static readonly valueOnProperty: StringPropertyEditor;
	    static readonly valueOffProperty: StringPropertyEditor;
	    static readonly wrapProperty: BooleanPropertyEditor;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	    initializeCardElement(): void;
	}
	export class ChoiceSetInputPeer extends InputPeer<Adaptive.ChoiceSetInput> {
	    static readonly defaultValueProperty: StringPropertyEditor;
	    static readonly placeholderProperty: StringPropertyEditor;
	    static readonly isMultiselectProperty: BooleanPropertyEditor;
	    static readonly styleProperty: ChoicePropertyEditor;
	    static readonly wrapProperty: BooleanPropertyEditor;
	    static readonly choicesProperty: NameValuePairPropertyEditor;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	    initializeCardElement(): void;
	}
	export class TextBlockPeer extends TypedCardElementPeer<Adaptive.TextBlock> {
	    static readonly textProperty: StringPropertyEditor;
	    static readonly wrapProperty: BooleanPropertyEditor;
	    static readonly maxLinesProperty: NumberPropertyEditor;
	    static readonly fontTypeProperty: EnumPropertyEditor;
	    static readonly sizeProperty: EnumPropertyEditor;
	    static readonly weightProperty: EnumPropertyEditor;
	    static readonly colorProperty: EnumPropertyEditor;
	    static readonly subtleProperty: NullableBooleanPropertyEditor;
	    static readonly styleProperty: ChoicePropertyEditor;
	    protected createInplaceEditor(): DesignerPeerInplaceEditor;
	    protected internalGetTreeItemText(): string;
	    protected internalAddCommands(context: DesignContext, commands: Array<PeerCommand>): void;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	    getToolTip(): string;
	    initializeCardElement(): void;
	}
	export class RichTextBlockPeer extends TypedCardElementPeer<Adaptive.RichTextBlock> {
	    protected internalGetTreeItemText(): string;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	    initializeCardElement(): void;
	}
	export class TableCellPeer extends ContainerPeer {
	    canBeRemoved(): boolean;
	    isDraggable(): boolean;
	}
	export class TableRowPeer extends TypedCardElementPeer<Adaptive.TableRow> {
	    static readonly horizontalCellContentAlignmentProperty: EnumPropertyEditor;
	    static readonly verticalCellContentAlignmentProperty: EnumPropertyEditor;
	    protected isContainer(): boolean;
	    isDraggable(): boolean;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	    get isTreeItemExpandedByDefault(): boolean;
	} class TableColumnsPropertyEditor extends PropertySheetEntry {
	    private columnsChanged;
	    render(context: PropertySheetContext): Adaptive.CardElement;
	}
	export class TablePeer extends TypedCardElementPeer<Adaptive.Table> {
	    static readonly firstRowAsHeadersProperty: BooleanPropertyEditor;
	    static readonly cellSpacingProperty: NumberPropertyEditor;
	    static readonly showGridLinesProperty: BooleanPropertyEditor;
	    static readonly gridStyleProperty: ContainerStylePropertyEditor;
	    static readonly horizontalCellContentAlignmentProperty: EnumPropertyEditor;
	    static readonly verticalCellContentAlignmentProperty: EnumPropertyEditor;
	    static readonly columnsProperty: TableColumnsPropertyEditor;
	    protected isContainer(): boolean;
	    protected internalAddCommands(context: DesignContext, commands: Array<PeerCommand>): void;
	    initializeCardElement(): void;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	}
	export class CarouselPeer extends ContainerPeer {
	    static readonly timerProperty: CarouselTimerPropertyEditor;
	    static readonly initialPageProperty: NumberPropertyEditor;
	    protected internalAddCommands(context: DesignContext, commands: Array<PeerCommand>): void;
	    initializeCardElement(): void;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	    canDrop(peer: DesignerPeer): boolean;
	}
	export class CarouselPagePeer extends ContainerPeer {
	    private _pageOffset;
	    isDraggable(): boolean;
	    getBoundingRect(): Rect;
	    peerInCorrectLocation(currentLocation: IPoint): boolean;
	    isVisible(): boolean;
	    bringCardElementIntoView(): boolean;
	    canDrop(peer: DesignerPeer): boolean;
	    get pageOffset(): number;
	}
	export {};

}
declare module 'adaptivecards-designer/card-designer-surface' {
	import * as Adaptive from 'adaptivecards-designer/adaptivecards';
	import { IPoint } from 'adaptivecards-designer/miscellaneous';
	import * as DesignerPeers from 'adaptivecards-designer/designer-peers';
	import { HostContainer } from 'adaptivecards-designer/containers';
	import { FieldDefinition } from 'adaptivecards-designer/data';
	export enum BindingPreviewMode {
	    NoPreview = 0,
	    GeneratedData = 1,
	    SampleData = 2
	}
	export type CardElementType = {
	    new (): Adaptive.CardElement;
	};
	export type ActionType = {
	    new (): Adaptive.Action;
	};
	export type CardElementPeerType = {
	    new (parent: DesignerPeers.DesignerPeer, designerSurface: CardDesignerSurface, registration: DesignerPeers.DesignerPeerRegistrationBase, cardElement: Adaptive.CardElement, initializeCardElement?: boolean): DesignerPeers.CardElementPeer;
	};
	export type ActionPeerType = {
	    new (parent: DesignerPeers.DesignerPeer, designerSurface: CardDesignerSurface, registration: DesignerPeers.DesignerPeerRegistrationBase, action: Adaptive.Action): DesignerPeers.ActionPeer;
	};
	export abstract class DesignerPeerRegistry<TSource, TPeer> {
	    protected _items: Array<DesignerPeers.DesignerPeerRegistration<TSource, TPeer>>;
	    readonly defaultRegistration: DesignerPeers.DesignerPeerRegistrationBase;
	    constructor();
	    abstract reset(): any;
	    clear(): void;
	    findTypeRegistration(sourceType: TSource): DesignerPeers.DesignerPeerRegistration<TSource, TPeer>;
	    registerPeer(sourceType: TSource, peerType: TPeer, category: string, iconClass?: string): void;
	    unregisterPeer(sourceType: TSource): void;
	}
	export class CardElementPeerRegistry extends DesignerPeerRegistry<CardElementType, CardElementPeerType> {
	    reset(): void;
	    createPeerInstance(designerSurface: CardDesignerSurface, parent: DesignerPeers.DesignerPeer, cardElement: Adaptive.CardElement, initializeCardElement?: boolean): DesignerPeers.CardElementPeer;
	}
	export class ActionPeerRegistry extends DesignerPeerRegistry<ActionType, ActionPeerType> {
	    reset(): void;
	    createPeerInstance(designerSurface: CardDesignerSurface, parent: DesignerPeers.DesignerPeer, action: Adaptive.Action): DesignerPeers.ActionPeer;
	}
	export abstract class DesignContext {
	    abstract get hostContainer(): HostContainer;
	    abstract get targetVersion(): Adaptive.Version;
	    abstract get dataStructure(): FieldDefinition;
	    abstract get hostDataStructure(): FieldDefinition;
	    abstract get bindingPreviewMode(): BindingPreviewMode;
	    abstract get sampleData(): any;
	    abstract get sampleHostData(): any;
	}
	export class CardDesignerSurface {
	    readonly context: DesignContext;
	    static readonly cardElementPeerRegistry: CardElementPeerRegistry;
	    static readonly actionPeerRegistry: ActionPeerRegistry;
	    private _updateCount;
	    private _card;
	    private _allPeers;
	    private _rootPeer;
	    private _cardHost;
	    private _designerSurface;
	    private _selectedPeer;
	    private _draggedPeer;
	    private _dropTarget;
	    private _dragHandle;
	    private _removeCommandElement;
	    private _peerCommandsHostElement;
	    private _serializationContext;
	    private _isPreviewMode;
	    private _dragVisual?;
	    private _shouldPersistSelectedElement;
	    private _persistentSelectedPeer;
	    private _persistentSelectedCardElement;
	    private updatePeerCommandsLayout;
	    private setSelectedPeer;
	    private peerChanged;
	    private peerRemoved;
	    private generateCardToRender;
	    private renderCard;
	    private appendErrorMessage;
	    private addPeer;
	    private internalFindDropTarget;
	    private findCardElementPeer;
	    private findActionPeer;
	    private inlineCardExpanded;
	    private get card();
	    private setDraggedPeer;
	    constructor(context: DesignContext);
	    onCardValidated: (logEntries: Adaptive.IValidationEvent[]) => void;
	    onSelectedPeerChanged: (peer: DesignerPeers.DesignerPeer) => void;
	    onLayoutUpdated: (isFullRefresh: boolean) => void;
	    fixedHeightCard: boolean;
	    getDesignerSurfaceOffset(): IPoint;
	    findDropTarget(pointerPosition: IPoint, peer: DesignerPeers.DesignerPeer): DesignerPeers.DesignerPeer;
	    findPeer(cardObject: Adaptive.CardObject): DesignerPeers.DesignerPeer;
	    beginUpdate(): void;
	    endUpdate(renderCard: boolean): void;
	    render(): void;
	    getCardPayloadAsObject(): object;
	    setCardPayloadAsObject(payload: object): void;
	    setCardPayloadAsString(payload: string): void;
	    getBoundCardPayloadAsObject(): object;
	    updateLayout(isFullRefresh?: boolean): void;
	    removeSelected(): void;
	    onStartDrag: (sender: CardDesignerSurface) => void;
	    onEndDrag: (sender: CardDesignerSurface, wasCancelled: boolean) => void;
	    startDrag(peer: DesignerPeers.DesignerPeer): void;
	    endDrag(wasCancelled: boolean): void;
	    getPeerDOMNeighbor(peer: DesignerPeers.DesignerPeer): HTMLElement;
	    getLastPeerInContainer(parentContainer: DesignerPeers.DesignerPeer): DesignerPeers.DesignerPeer;
	    tryDrop(pointerPosition: IPoint, peer: DesignerPeers.DesignerPeer): boolean;
	    isPointerOver(x: number, y: number): boolean;
	    pageToClientCoordinates(x: number, y: number): IPoint;
	    get rootPeer(): DesignerPeers.DesignerPeer;
	    get selectedPeer(): DesignerPeers.DesignerPeer;
	    get draggedPeer(): DesignerPeers.DesignerPeer;
	    get isPreviewMode(): boolean;
	    set isPreviewMode(value: boolean);
	    set shouldPersistSelectedElement(shouldPersistSelectedElement: boolean);
	}

}
declare module 'adaptivecards-designer/constants' {
	export const otherTestPayload: string;
	export const defaultPayload: string;
	export const defaultTemplatePayload: string;
	export const defaultDataPayload: string;

}
declare module 'adaptivecards-designer/pic2card' {
	export class Pic2Card {
	    static pic2cardService: string;
	    static privacyLink: string;
	}

}
declare module 'adaptivecards-designer/downloader' {
	export class Downloader {
	    readonly url: string;
	    private _data;
	    private error;
	    private success;
	    onError: (sender: Downloader) => void;
	    onSuccess: (sender: Downloader) => void;
	    constructor(url: string);
	    download(): void;
	    get data(): string;
	}

}
declare module 'adaptivecards-designer/catalogue' {
	export class CatalogueEntry {
	    readonly displayName: string;
	    readonly cardPayloadUrl: string;
	    private _cardPayload;
	    private _cardPayloadDownloaded;
	    private _sampleData;
	    private _sampleDataDownloaded;
	    private _cardId;
	    private downloadCompleted;
	    sampleDataUrl?: string;
	    onDownloaded: (sender: CatalogueEntry) => void;
	    constructor(displayName: string, cardPayloadUrl: string, sampleDataUrl?: string, cardId?: string);
	    download(): void;
	    get cardPayloadDownloaded(): boolean;
	    get cardId(): string;
	    get cardPayload(): string;
	    get sampleDataDownloaded(): boolean;
	    get sampleData(): string;
	}
	export class SampleCatalogue {
	    private _entries;
	    private _isDownloaded;
	    private _url;
	    private downloaded;
	    private parse;
	    onDownloaded: (sender: SampleCatalogue) => void;
	    constructor(url?: string);
	    download(): void;
	    get isDownloaded(): boolean;
	    get entries(): CatalogueEntry[];
	    get url(): string;
	    set url(value: string);
	}

}
declare module 'adaptivecards-designer/dialog' {
	export class DialogButton {
	    caption: string;
	    onClick: (sender: DialogButton) => void;
	    constructor(caption: string);
	    render(): HTMLElement;
	    clicked(): void;
	}
	export abstract class Dialog {
	    private _overlayElement;
	    private _isOpen;
	    private _originalFocusedElement;
	    private _firstFocusableElement;
	    private _lastFocusableElement;
	    protected abstract renderContent(): HTMLElement;
	    onClose: (sender: Dialog) => void;
	    readonly closeButton: DialogButton;
	    buttons?: DialogButton[];
	    title: string;
	    width: string;
	    height: string;
	    preventLightDismissal: boolean;
	    constructor();
	    open(): void;
	    close(): void;
	}

}
declare module 'adaptivecards-designer/open-sample-dialog' {
	import { SampleCatalogue } from 'adaptivecards-designer/catalogue';
	import { Dialog } from 'adaptivecards-designer/dialog';
	export interface CardData {
	    cardPayload?: string;
	    sampleData?: string;
	    sampleHostData?: string;
	    thumbnail?: HTMLElement | (() => HTMLElement);
	} type CardDataCallback = (output: CardData) => any; type CardDataProvider = (callback?: CardDataCallback) => CardData | void;
	interface OpenSampleItemProps {
	    label: string;
	    onClick?: (ev: MouseEvent) => any;
	    onKeyEnterEvent?: (ev: KeyboardEvent) => any;
	    cardData?: CardData | CardDataProvider;
	}
	export interface OpenSampleDialogProps {
	    handlers?: (OpenSampleItemProps | null)[];
	    catalogue?: SampleCatalogue;
	}
	export class OpenSampleDialog extends Dialog {
	    readonly props: OpenSampleDialogProps;
	    private _listElements;
	    private _output;
	    private static _builtinItems;
	    constructor(props: OpenSampleDialogProps);
	    private renderSection;
	    protected renderContent(): HTMLElement;
	    get output(): CardData;
	}
	export {};

}
declare module 'adaptivecards-designer/open-json-schema-dialog' {
	import { Dialog, DialogButton } from 'adaptivecards-designer/dialog';
	import { CardData } from 'adaptivecards-designer/open-sample-dialog';
	export class OpenJsonSchemaDialog extends Dialog {
	    private _output;
	    private _previewContainer;
	    private _previewElement;
	    private _editor;
	    readonly submitButton: DialogButton;
	    constructor();
	    open(): void;
	    private renderPreview;
	    private refreshPreview;
	    private renderEditor;
	    protected renderContent(): HTMLElement;
	    get output(): CardData;
	}

}
declare module 'adaptivecards-designer/adaptive-card-schema' {
	export const adaptiveCardSchema: {
	    $schema: string;
	    id: string;
	    type: string;
	    title: string;
	    additionalProperties: boolean;
	    allOf: {
	        $ref: string;
	    }[];
	    properties: {
	        version: {
	            type: string;
	            description: string;
	        };
	        minVersion: {
	            type: string;
	            description: string;
	        };
	        fallbackText: {
	            type: string;
	            description: string;
	        };
	        speak: {
	            type: string;
	            description: string;
	        };
	    };
	    required: string[];
	    definitions: {
	        Action: {
	            anyOf: {
	                $ref: string;
	            }[];
	        };
	        "Action.OpenUrl": {
	            additionalProperties: boolean;
	            description: string;
	            properties: {
	                title: {
	                    type: string;
	                    description: string;
	                };
	                type: {
	                    type: string;
	                    description: string;
	                    enum: string[];
	                };
	                url: {
	                    type: string;
	                    description: string;
	                };
	            };
	            required: string[];
	            type: string;
	        };
	        "Action.ShowCard": {
	            type: string;
	            additionalProperties: boolean;
	            description: string;
	            properties: {
	                type: {
	                    type: string;
	                    description: string;
	                    enum: string[];
	                };
	                title: {
	                    type: string;
	                    description: string;
	                };
	                card: {
	                    $ref: string;
	                };
	            };
	            required: string[];
	        };
	        "Action.Submit": {
	            type: string;
	            additionalProperties: boolean;
	            description: string;
	            properties: {
	                type: {
	                    type: string;
	                    description: string;
	                    enum: string[];
	                };
	                title: {
	                    type: string;
	                    description: string;
	                };
	                data: {
	                    type: string[];
	                    description: string;
	                };
	            };
	            required: string[];
	        };
	        Actions: {
	            additionalItems: boolean;
	            items: {
	                $ref: string;
	            };
	            type: string;
	        };
	        AdaptiveCard: {
	            additionalProperties: boolean;
	            type: string;
	            description: string;
	            properties: {
	                type: {
	                    type: string;
	                    description: string;
	                    enum: string[];
	                };
	                actions: {
	                    description: string;
	                    $ref: string;
	                };
	                body: {
	                    type: string[];
	                    description: string;
	                    $ref: string;
	                };
	            };
	            required: string[];
	        };
	        CardElement: {
	            additionalProperties: boolean;
	            properties: {
	                type: {
	                    type: string;
	                };
	                id: {
	                    type: string;
	                    description: string;
	                };
	                spacing: {
	                    $ref: string;
	                };
	                separator: {
	                    type: string;
	                    description: string;
	                    default: boolean;
	                };
	            };
	            required: string[];
	        };
	        CardElements: {
	            type: string;
	            additionalItems: boolean;
	            items: {
	                anyOf: {
	                    $ref: string;
	                }[];
	            }[];
	        };
	        "Input.Choice": {
	            type: string;
	            description: string;
	            additionalProperties: boolean;
	            properties: {
	                type: {
	                    type: string;
	                    enum: string[];
	                };
	                title: {
	                    type: string;
	                    description: string;
	                };
	                value: {
	                    type: string;
	                    description: string;
	                };
	            };
	            required: string[];
	        };
	        ChoiceInputStyle: {
	            type: string;
	            description: string;
	            enum: string[];
	        };
	        Column: {
	            additionalProperties: boolean;
	            type: string;
	            description: string;
	            allOf: {
	                $ref: string;
	            }[];
	            properties: {
	                items: {
	                    description: string;
	                    $ref: string;
	                };
	                selectAction: {
	                    description: string;
	                    $ref: string;
	                };
	                width: {
	                    type: string[];
	                    description: string;
	                };
	                type: {
	                    type: string;
	                    description: string;
	                    enum: string[];
	                };
	            };
	            required: string[];
	        };
	        ColumnSet: {
	            additionalProperties: boolean;
	            type: string;
	            description: string;
	            allOf: {
	                $ref: string;
	            }[];
	            properties: {
	                columns: {
	                    type: string;
	                    description: string;
	                    items: {
	                        $ref: string;
	                    };
	                };
	                selectAction: {
	                    $ref: string;
	                    description: string;
	                };
	                type: {
	                    type: string;
	                    description: string;
	                    enum: string[];
	                };
	            };
	        };
	        Container: {
	            additionalProperties: boolean;
	            type: string;
	            description: string;
	            allOf: {
	                $ref: string;
	            }[];
	            properties: {
	                items: {
	                    description: string;
	                    $ref: string;
	                };
	                selectAction: {
	                    description: string;
	                    $ref: string;
	                };
	                style: {
	                    type: string;
	                    description: string;
	                    enum: string[];
	                };
	                type: {
	                    type: string;
	                    description: string;
	                    enum: string[];
	                };
	            };
	            required: string[];
	        };
	        Fact: {
	            additionalProperties: boolean;
	            type: string;
	            description: string;
	            properties: {
	                type: {
	                    type: string;
	                    enum: string[];
	                };
	                title: {
	                    type: string;
	                    description: string;
	                };
	                value: {
	                    type: string;
	                    description: string;
	                };
	            };
	            required: string[];
	        };
	        FactSet: {
	            additionalProperties: boolean;
	            type: string;
	            description: string;
	            allOf: {
	                $ref: string;
	            }[];
	            properties: {
	                facts: {
	                    type: string;
	                    description: string;
	                    items: {
	                        $ref: string;
	                    };
	                };
	                type: {
	                    type: string;
	                    description: string;
	                    enum: string[];
	                };
	            };
	            required: string[];
	        };
	        HorizontalAlignment: {
	            type: string;
	            description: string;
	            enum: string[];
	        };
	        Image: {
	            additionalProperties: boolean;
	            type: string;
	            description: string;
	            allOf: {
	                $ref: string;
	            }[];
	            properties: {
	                altText: {
	                    type: string;
	                    description: string;
	                };
	                horizontalAlignment: {
	                    $ref: string;
	                };
	                selectAction: {
	                    description: string;
	                    $ref: string;
	                };
	                size: {
	                    type: string;
	                    $ref: string;
	                };
	                style: {
	                    $ref: string;
	                };
	                type: {
	                    type: string;
	                    description: string;
	                    enum: string[];
	                };
	                url: {
	                    type: string;
	                    description: string;
	                };
	            };
	            required: string[];
	        };
	        ImageSet: {
	            additionalProperties: boolean;
	            type: string;
	            description: string;
	            allOf: {
	                $ref: string;
	            }[];
	            properties: {
	                images: {
	                    type: string;
	                    description: string;
	                    items: {
	                        $ref: string;
	                    };
	                };
	                imageSize: {
	                    $ref: string;
	                };
	                type: {
	                    type: string;
	                    description: string;
	                    enum: string[];
	                };
	            };
	            required: string[];
	        };
	        ImageSize: {
	            type: string;
	            description: string;
	            default: string;
	            enum: string[];
	        };
	        ImageStyle: {
	            type: string;
	            description: string;
	            enum: string[];
	        };
	        "Input.ChoiceSet": {
	            additionalProperties: boolean;
	            type: string;
	            description: string;
	            allOf: {
	                $ref: string;
	            }[];
	            properties: {
	                choices: {
	                    type: string;
	                    description: string;
	                    items: {
	                        $ref: string;
	                    };
	                };
	                id: {
	                    type: string;
	                    description: string;
	                };
	                isMultiSelect: {
	                    type: string;
	                    description: string;
	                    default: boolean;
	                };
	                style: {
	                    $ref: string;
	                };
	                type: {
	                    description: string;
	                    enum: string[];
	                    type: string;
	                };
	                value: {
	                    type: string;
	                    description: string;
	                };
	            };
	            required: string[];
	        };
	        "Input.Date": {
	            additionalProperties: boolean;
	            type: string;
	            description: string;
	            allOf: {
	                $ref: string;
	            }[];
	            properties: {
	                id: {
	                    type: string;
	                    description: string;
	                };
	                max: {
	                    type: string;
	                    description: string;
	                };
	                min: {
	                    type: string;
	                    description: string;
	                };
	                placeholder: {
	                    type: string;
	                    description: string;
	                };
	                type: {
	                    type: string;
	                    description: string;
	                    enum: string[];
	                };
	                value: {
	                    type: string;
	                    description: string;
	                };
	            };
	            required: string[];
	        };
	        "Input.Number": {
	            additionalProperties: boolean;
	            type: string;
	            description: string;
	            allOf: {
	                $ref: string;
	            }[];
	            properties: {
	                id: {
	                    type: string;
	                    description: string;
	                };
	                max: {
	                    type: string;
	                    description: string;
	                };
	                min: {
	                    type: string;
	                    description: string;
	                };
	                placeholder: {
	                    type: string;
	                    description: string;
	                };
	                type: {
	                    type: string;
	                    description: string;
	                    enum: string[];
	                };
	                value: {
	                    type: string;
	                    description: string;
	                };
	            };
	            required: string[];
	        };
	        "Input.Text": {
	            additionalProperties: boolean;
	            type: string;
	            description: string;
	            allOf: {
	                $ref: string;
	            }[];
	            properties: {
	                id: {
	                    type: string;
	                    description: string;
	                };
	                isMultiline: {
	                    type: string;
	                    description: string;
	                };
	                maxLength: {
	                    type: string;
	                    description: string;
	                };
	                placeholder: {
	                    type: string;
	                    description: string;
	                };
	                style: {
	                    $ref: string;
	                };
	                type: {
	                    type: string;
	                    description: string;
	                    enum: string[];
	                };
	                value: {
	                    type: string;
	                    description: string;
	                };
	            };
	            required: string[];
	        };
	        "Input.Time": {
	            additionalProperties: boolean;
	            type: string;
	            description: string;
	            allOf: {
	                $ref: string;
	            }[];
	            properties: {
	                id: {
	                    type: string;
	                    description: string;
	                };
	                max: {
	                    type: string;
	                    description: string;
	                };
	                min: {
	                    type: string;
	                    description: string;
	                };
	                placeholder: {
	                    type: string;
	                    description: string;
	                };
	                type: {
	                    type: string;
	                    description: string;
	                    enum: string[];
	                };
	                value: {
	                    type: string;
	                    description: string;
	                };
	            };
	            required: string[];
	        };
	        "Input.Toggle": {
	            additionalProperties: boolean;
	            type: string;
	            description: string;
	            allOf: {
	                $ref: string;
	            }[];
	            properties: {
	                id: {
	                    type: string;
	                    description: string;
	                };
	                title: {
	                    type: string;
	                    description: string;
	                };
	                type: {
	                    type: string;
	                    description: string;
	                    enum: string[];
	                };
	                value: {
	                    type: string;
	                    description: string;
	                };
	                valueOff: {
	                    type: string;
	                    description: string;
	                };
	                valueOn: {
	                    type: string;
	                    description: string;
	                };
	            };
	            required: string[];
	        };
	        TextBlock: {
	            additionalProperties: boolean;
	            type: string;
	            description: string;
	            allOf: {
	                $ref: string;
	            }[];
	            properties: {
	                color: {
	                    type: string;
	                    description: string;
	                    enum: string[];
	                };
	                horizontalAlignment: {
	                    $ref: string;
	                };
	                isSubtle: {
	                    type: string;
	                    description: string;
	                };
	                maxLines: {
	                    type: string;
	                    description: string;
	                };
	                size: {
	                    type: string;
	                    description: string;
	                    enum: string[];
	                };
	                text: {
	                    type: string;
	                    description: string;
	                };
	                type: {
	                    type: string;
	                    description: string;
	                    enum: string[];
	                };
	                weight: {
	                    type: string;
	                    description: string;
	                    enum: string[];
	                };
	                wrap: {
	                    type: string;
	                    description: string;
	                };
	            };
	            required: string[];
	        };
	        SeparatorStyle: {
	            type: string;
	            description: string;
	            properties: {
	                thickness: {
	                    type: string;
	                    description: string;
	                    enum: string[];
	                };
	                color: {
	                    type: string;
	                    description: string;
	                    enum: string[];
	                };
	            };
	        };
	        SpacingStyle: {
	            type: string;
	            description: string;
	            enum: string[];
	        };
	        TextInputStyle: {
	            type: string;
	            description: string;
	            enum: string[];
	        };
	    };
	};

}
declare module 'adaptivecards-designer/open-image-dialog' {
	import { Dialog } from 'adaptivecards-designer/dialog';
	export class FetchManager {
	    private pic2cardService;
	    private headers;
	    getSampleImages(): Promise<any>;
	    getPredictedData(imageContent: any, isTemplateBindingEnabled: any): Promise<any>;
	}
	export class OpenImageDialog extends Dialog {
	    private _renderedElement;
	    private _imageElement;
	    private _buttonContainer;
	    private _inputTemplate;
	    private _uploadedImage;
	    private _predictedCardJSON;
	    private fetchManager;
	    private isTemplateOptionChecked;
	    private allowedImageSize;
	    constructor();
	    private setContent;
	    private removeContent;
	    private renderTitle;
	    private renderTitleContent;
	    private renderUploadedImage;
	    private renderUploadButton;
	    private renderCheckbox;
	    private renderLabelText;
	    private checkFileSize;
	    private createFileButton;
	    private generateErrorText;
	    private onCardFailure;
	    createActionButton(): HTMLElement;
	    private loadSpinner;
	    private renderImage;
	    private renderUploadControl;
	    private renderUploadContainer;
	    private renderImageContainer;
	    private renderSampleTemplate;
	    protected renderContent(): HTMLElement;
	    get predictedCardJSON(): predictedCardJSON;
	}
	export class ImageItem {
	    readonly template: string;
	    readonly itemIndex: number;
	    constructor(template: string, itemIndex: number);
	    onClick: (template: string, sampleImageName: string) => void;
	    render(): HTMLElement;
	}
	export interface predictedCardJSON {
	    card: {};
	    data: {};
	}

}
declare module 'adaptivecards-designer/fullscreen-handler' {
	export class FullScreenHandler {
	    private fullScrerenChanged;
	    onFullScreenChanged: (isFullScreen: boolean) => void;
	    constructor();
	    enterFullScreen(): void;
	    exitFullScreen(): void;
	    toggleFullScreen(): void;
	    get isFullScreen(): boolean;
	}

}
declare module 'adaptivecards-designer/toolbar' {
	export enum ToolbarElementAlignment {
	    Left = 0,
	    Right = 1
	}
	export abstract class ToolbarElement {
	    private _renderedElement;
	    protected abstract internalRender(): HTMLElement;
	    protected internalUpdateLayout(): void;
	    readonly id: string;
	    isVisible: boolean;
	    separator: boolean;
	    label: string;
	    alignment: ToolbarElementAlignment;
	    constructor(id: string);
	    updateLayout(): void;
	    render(): HTMLElement;
	    get renderedElement(): HTMLElement;
	}
	export class ToolbarButton extends ToolbarElement {
	    private _caption;
	    private _displayCaption;
	    private _iconClass;
	    private _toolTip;
	    private _isEnabled;
	    private _allowToggle;
	    private _isToggled;
	    protected clicked(): void;
	    protected internalUpdateLayout(): void;
	    protected internalRender(): HTMLElement;
	    onClick: (sender: ToolbarButton) => void;
	    constructor(id: string, caption: string, iconClass: string, onClick?: (sender: ToolbarButton) => void);
	    get allowToggle(): boolean;
	    set allowToggle(value: boolean);
	    get isToggled(): boolean;
	    set isToggled(value: boolean);
	    get caption(): string;
	    set caption(value: string);
	    get displayCaption(): boolean;
	    set displayCaption(value: boolean);
	    get iconClass(): string;
	    set iconClass(value: string);
	    get toolTip(): string;
	    set toolTip(value: string);
	    get isEnabled(): boolean;
	    set isEnabled(value: boolean);
	}
	export interface IChoicePickerItem {
	    name: string;
	    value: string;
	}
	export class ToolbarChoicePicker extends ToolbarElement {
	    private _dropDown;
	    private _labelledById;
	    private _isEnabled;
	    private _isHidden;
	    protected internalRender(): HTMLElement;
	    protected internalUpdateLayout(): void;
	    onChanged: (sender: ToolbarChoicePicker) => void;
	    label: string;
	    choices: Array<IChoicePickerItem>;
	    width?: number;
	    get value(): string;
	    get selectedIndex(): number;
	    set selectedIndex(value: number);
	    get isEnabled(): boolean;
	    set isEnabled(value: boolean);
	    get isHidden(): boolean;
	    set isHidden(value: boolean);
	}
	export class Toolbar {
	    private _elements;
	    private _attachedTo;
	    private createSeparatorElement;
	    private renderElementsInto;
	    attachTo(element: HTMLElement): void;
	    addElement(element: ToolbarElement): void;
	    getElementById(elementId: string): ToolbarElement;
	    insertElementAfter(element: ToolbarElement, afterElementId: string): void;
	    insertElementBefore(element: ToolbarElement, beforeElementId: string): void;
	}

}
declare module 'adaptivecards-designer/tool-palette' {
	import * as Adaptive from 'adaptivecards-designer/adaptivecards';
	import { DraggableElement } from 'adaptivecards-designer/draggable-element';
	import { FieldDefinition } from 'adaptivecards-designer/data';
	import { DesignContext, CardDesignerSurface } from 'adaptivecards-designer/card-designer-surface';
	import { CardElementPeer, DesignerPeerRegistrationBase } from 'adaptivecards-designer/designer-peers';
	export abstract class BasePaletteItem extends DraggableElement {
	    protected abstract getText(): string;
	    protected abstract getIconClass(): string;
	    protected internalRender(): HTMLElement;
	    renderDragVisual(): HTMLElement;
	    abstract createPeer(context: DesignContext, designer: CardDesignerSurface): CardElementPeer;
	}
	export class ElementPaletteItem extends BasePaletteItem {
	    protected getText(): string;
	    protected getIconClass(): string;
	    readonly typeRegistration: Adaptive.ITypeRegistration<Adaptive.CardElement>;
	    readonly peerRegistration: DesignerPeerRegistrationBase;
	    constructor(typeRegistration: Adaptive.ITypeRegistration<Adaptive.CardElement>, peerRegistration: DesignerPeerRegistrationBase);
	    createPeer(context: DesignContext, designer: CardDesignerSurface): CardElementPeer;
	}
	export class DataPaletteItem extends BasePaletteItem {
	    readonly field: FieldDefinition;
	    protected getText(): string;
	    protected getIconClass(): string;
	    constructor(field: FieldDefinition);
	    createPeer(context: DesignContext, designer: CardDesignerSurface): CardElementPeer;
	}
	export abstract class CustomPaletteItem extends BasePaletteItem {
	    readonly category: string;
	    protected getIconClass(): string;
	    constructor(category: string);
	}
	export class SnippetPaletteItem extends CustomPaletteItem {
	    protected getText(): string;
	    readonly name: string;
	    snippet: object;
	    constructor(category: string, name: string);
	    createPeer(context: DesignContext, designer: CardDesignerSurface): CardElementPeer;
	}

}
declare module 'adaptivecards-designer/splitter' {
	export class Splitter {
	    private _isVertical;
	    private _isAttachedAfter;
	    private _sizedELement;
	    private _isPointerDown;
	    private _lastClickedOffset;
	    private resizeEnded;
	    private pointerDown;
	    private pointerMove;
	    private pointerUp;
	    onResizeEnded: (sender: Splitter) => void;
	    onResized: (sender: Splitter) => void;
	    readonly attachedTo: HTMLElement;
	    minimum: number;
	    constructor(attachedTo: HTMLElement, sizedElement: HTMLElement, isVertical?: boolean, isAttachedAfter?: boolean, minimumSize?: number);
	}

}
declare module 'adaptivecards-designer/settings-manager' {
	export interface ILoadSettingResult<T> {
	    succeeded: boolean;
	    value?: T;
	}
	export class SettingsManager {
	    private static _isLocalStorageAvailable;
	    private static determineIfStorageIsAvailable;
	    static trySaveSetting(name: string, value: string): void;
	    static tryLoadStringSetting(name: string): ILoadSettingResult<string>;
	    static tryLoadNumberSetting(name: string): ILoadSettingResult<number>;
	    static tryLoadBooleanSetting(name: string, defaultValue: boolean): ILoadSettingResult<boolean>;
	    static get isLocalStorageAvailable(): boolean;
	}

}
declare module 'adaptivecards-designer/tool-box' {
	export interface IToolboxCommand {
	    title: string;
	    iconClass: string;
	    execute: (sender: IToolboxCommand) => void;
	}
	export enum ToolboxOrientation {
	    Horizontal = 0,
	    Vertical = 1
	}
	export class Toolbox {
	    private _renderedElement;
	    private _headerRootElement;
	    private _headerIconElement;
	    private _expandCollapseButtonElement;
	    private _customCommandsHost;
	    private _contentHost;
	    private _isExpanded;
	    private _content;
	    private _stretch;
	    private _orientation;
	    private _isRestoring;
	    private _collapsedTabContainer;
	    private _isVisible;
	    private getDimensionSettingName;
	    private updateContent;
	    private toggled;
	    private updateVisibility;
	    private hideToolbox;
	    onToggled: (sender: Toolbox, saveState?: boolean) => void;
	    readonly id: string;
	    readonly title: string;
	    commands: Array<IToolboxCommand>;
	    constructor(id: string, title: string);
	    render(orientation: ToolboxOrientation, collapsedTabContainer: HTMLElement): void;
	    collapse(saveState?: boolean): void;
	    expand(): void;
	    toggle(): void;
	    getHeaderBoundingRect(): ClientRect;
	    saveState(): void;
	    restoreState(): void;
	    get orientation(): ToolboxOrientation;
	    get renderedElement(): HTMLElement;
	    get content(): HTMLElement;
	    set content(value: HTMLElement);
	    get isExpanded(): boolean;
	    get stretch(): boolean;
	    set stretch(value: boolean);
	    set isVisible(value: boolean);
	    get isVisible(): boolean;
	}

}
declare module 'adaptivecards-designer/side-panel' {
	import { Toolbox } from 'adaptivecards-designer/tool-box';
	export enum SidePanelAlignment {
	    Top = 0,
	    Right = 1,
	    Bottom = 2,
	    Left = 3
	}
	export class SidePanel {
	    private _attachedTo;
	    private _alignment;
	    private _collapsedTabContainer;
	    private _contentHost;
	    private _toolboxes;
	    private _isRestoring;
	    private updateLayout;
	    private computeToolboxSize;
	    private resized;
	    private toolboxResized;
	    private toolboxExpandedOrCollapsed;
	    private getDimensionSettingName;
	    private get isVertical();
	    onResized: (sender: SidePanel) => void;
	    onToolboxResized: (sender: SidePanel, toolbox: Toolbox) => void;
	    onToolboxExpandedOrCollapsed: (sender: SidePanel, toolbox: Toolbox) => void;
	    readonly id: any;
	    size?: number;
	    isResizable: boolean;
	    addToolbox(toolbox: Toolbox): void;
	    attachTo(attachTo: HTMLElement): void;
	    constructor(id: string, alignment: SidePanelAlignment, collapsedTabContainer: HTMLElement);
	    saveState(): void;
	    restoreState(): void;
	    get contentHost(): HTMLElement;
	}

}
declare module 'adaptivecards-designer/help-dialog' {
	import { Dialog } from 'adaptivecards-designer/dialog';
	export class HelpDialog extends Dialog {
	    private _renderedElement;
	    private _getShortcutRow;
	    protected renderContent(): HTMLElement;
	}

}
declare module 'adaptivecards-designer/card-designer' {
	import * as Adaptive from 'adaptivecards-designer/adaptivecards';
	import * as Designer from 'adaptivecards-designer/card-designer-surface';
	import { HostContainer } from 'adaptivecards-designer/containers/host-container';
	import { Toolbar } from 'adaptivecards-designer/toolbar';
	import { CustomPaletteItem } from 'adaptivecards-designer/tool-palette';
	import { Toolbox } from 'adaptivecards-designer/tool-box';
	import { FieldDefinition } from 'adaptivecards-designer/data';
	import { DeviceEmulation } from 'adaptivecards-designer/device-emulation';
	export class CardDesigner extends Designer.DesignContext {
	    private static internalProcessMarkdown;
	    static onProcessMarkdown: (text: string, result: Adaptive.IMarkdownProcessingResult) => void;
	    private static MAX_UNDO_STACK_SIZE;
	    private _isAttached;
	    private _cardEditor;
	    private _sampleDataEditor;
	    private _sampleHostDataEditor;
	    private _hostContainers;
	    private _deviceEmulations;
	    private _isMonacoEditorLoaded;
	    private _designerSurface;
	    private _designerHostElement;
	    private _draggedPaletteItem;
	    private _draggedElement;
	    private _currentMousePosition;
	    private _hostContainer;
	    private _deviceEmulation;
	    private _undoStack;
	    private _undoStackIndex;
	    private _startDragPayload;
	    private _toolPaletteToolbox;
	    private _propertySheetToolbox;
	    private _propertySheetCard;
	    private _treeViewToolbox;
	    private _jsonEditorsPanel;
	    private _cardEditorToolbox;
	    private _sampleDataEditorToolbox;
	    private _sampleHostDataEditorToolbox;
	    private _dataToolbox;
	    private _assetPath;
	    private _dataStructure;
	    private _hostDataStructure;
	    private _sampleData;
	    private _sampleHostData;
	    private _bindingPreviewMode;
	    private _customPeletteItems;
	    private _sampleCatalogue;
	    private togglePreview;
	    private buildTreeView;
	    private buildDataExplorer;
	    private buildPropertySheet;
	    private addPaletteItem;
	    private buildPalette;
	    private endDrag;
	    private renderErrorPaneElement;
	    private recreateDesignerSurface;
	    private activeHostContainerChanged;
	    private activeDeviceEmulationChanged;
	    private targetVersionChanged;
	    private updateToolboxLayout;
	    private updateJsonEditorsLayout;
	    private updateFullLayout;
	    private _jsonUpdateTimer;
	    private _cardUpdateTimer;
	    private _updateLayoutTimer;
	    private _cardPreventUpdate;
	    private _jsonPreventUpdate;
	    private cardPayloadChanged;
	    private _cardEditorUpdateCounter;
	    private beginCardEditorUpdate;
	    private endCardEditorUpdate;
	    private setCardPayload;
	    private setSampleDataPayload;
	    private setSampleHostDataPayload;
	    private updateJsonFromCard;
	    private scheduleUpdateJsonFromCard;
	    private getCurrentCardEditorPayload;
	    private getCurrentSampleDataEditorPayload;
	    private getCurrentSampleHostDataEditorPayload;
	    private updateCardFromJson;
	    private scheduleUpdateCardFromJson;
	    private _isEdgeHTML?;
	    private isEdgeHTML;
	    private scheduleLayoutUpdate;
	    private _targetVersion;
	    private _fullScreenHandler;
	    private _fullScreenButton;
	    private _hostContainerChoicePicker;
	    private _deviceEmulationChoicePicker;
	    private _versionChoicePicker;
	    private _undoButton;
	    private _redoButton;
	    private _newCardButton;
	    private _copyJSONButton;
	    private _togglePreviewButton;
	    private _helpButton;
	    private _preventRecursiveSetTargetVersion;
	    private _containerSizeChoicePicker;
	    private _containerThemeChoicePicker;
	    private prepareToolbar;
	    private launchJsonSchemaPopup;
	    private launchImagePopup;
	    private onResize;
	    private updateSampleData;
	    private updateSampleHostData;
	    private updateHostDataSizeProperty;
	    private updateHostDataThemeProperty;
	    private updateContainerSizeChoicePicker;
	    private updateContainerThemeChoicePicker;
	    private updateToolbar;
	    private addToUndoStack;
	    private handlePointerUp;
	    private handlePointerMove;
	    readonly toolbar: Toolbar;
	    lockDataStructure: boolean;
	    constructor(hostContainers?: Array<HostContainer>, deviceEmulations?: Array<DeviceEmulation>);
	    monacoModuleLoaded(monaco?: any): void;
	    attachTo(root: HTMLElement): void;
	    createAndAddSampleHostDataEditorToolbox(): void;
	    clearUndoStack(): void;
	    setCard(payload: object): void;
	    getCard(): object;
	    getBoundCard(): object;
	    undo(): void;
	    redo(): void;
	    showHelp(): void;
	    newCard(): void;
	    onCardPayloadChanged: (designer: CardDesigner) => void;
	    onCardValidated: (designer: CardDesigner, validationLogEntries: Adaptive.IValidationEvent[]) => void;
	    onActiveHostContainerChanged: (designer: CardDesigner) => void;
	    onTargetVersionChanged: (designer: CardDesigner) => void;
	    get targetVersion(): Adaptive.Version;
	    set targetVersion(value: Adaptive.Version);
	    get dataStructure(): FieldDefinition;
	    set dataStructure(value: FieldDefinition);
	    get hostDataStructure(): FieldDefinition;
	    set hostDataStructure(value: FieldDefinition);
	    get sampleData(): any;
	    set sampleData(value: any);
	    get sampleHostData(): any;
	    set sampleHostData(value: any);
	    get bindingPreviewMode(): Designer.BindingPreviewMode;
	    set bindingPreviewMode(value: Designer.BindingPreviewMode);
	    get hostContainer(): HostContainer;
	    set hostContainer(value: HostContainer);
	    get deviceEmulation(): DeviceEmulation;
	    set deviceEmulation(value: DeviceEmulation);
	    get canUndo(): boolean;
	    get canRedo(): boolean;
	    get designerSurface(): Designer.CardDesignerSurface;
	    get treeViewToolbox(): Toolbox;
	    get propertySheetToolbox(): Toolbox;
	    get jsonEditorToolbox(): Toolbox;
	    get toolPaletteToolbox(): Toolbox;
	    get dataToolbox(): Toolbox;
	    get assetPath(): string;
	    set assetPath(value: string);
	    get customPaletteItems(): CustomPaletteItem[];
	    set customPaletteItems(value: CustomPaletteItem[]);
	    get sampleCatalogueUrl(): string;
	    set sampleCatalogueUrl(value: string);
	}
	export module CardDesigner {
	    class ToolbarCommands {
	        static readonly HostAppPicker = "__hostAppPicker";
	        static readonly DeviceEmulationPicker = "__deviceEmulationPicker";
	        static readonly VersionPicker = "__versionPicker";
	        static readonly Undo = "__undoButton";
	        static readonly Redo = "__redoButton";
	        static readonly NewCard = "__newCardButton";
	        static readonly CopyJSON = "__copyJsonButton";
	        static readonly TogglePreview = "__togglePreviewButton";
	        static readonly Help = "__helpButton";
	        static readonly ContainerSizePicker = "__containerSizePicker";
	        static readonly ContainerThemePicker = "__containerThemePicker";
	    }
	}

}
declare module 'adaptivecards-designer/adaptivecards-designer-standalone' {
	export * from 'adaptivecards-designer/strings';
	export * from 'adaptivecards-designer/shared';
	export * from 'adaptivecards-designer/containers/host-container';
	export * from 'adaptivecards-designer/containers/default/default-container';
	export * from 'adaptivecards-designer/field-picker';
	export * from 'adaptivecards-designer/card-designer-surface';
	export * from 'adaptivecards-designer/card-designer';
	export * from 'adaptivecards-designer/constants';
	export * from 'adaptivecards-designer/draggable-element';
	export * from 'adaptivecards-designer/designer-peers';
	export * from 'adaptivecards-designer/peer-command';
	export * from 'adaptivecards-designer/miscellaneous';
	export * from 'adaptivecards-designer/settings-manager';
	export * from 'adaptivecards-designer/side-panel';
	export * from 'adaptivecards-designer/tool-box';
	export * from 'adaptivecards-designer/toolbar';
	export * from 'adaptivecards-designer/tool-palette';
	export * from 'adaptivecards-designer/splitter';
	export * from 'adaptivecards-designer/tree-view';
	export * from 'adaptivecards-designer/base-tree-item';
	export * from 'adaptivecards-designer/designer-peer-treeitem';
	export * from 'adaptivecards-designer/data';
	export * from 'adaptivecards-designer/catalogue';
	export * from 'adaptivecards-designer/containers/host-container';
	export * from 'adaptivecards-designer/containers/default/default-container';
	export * from 'adaptivecards-designer/pic2card';

}
declare module 'adaptivecards-designer/adaptivecards-designer' {
	import * as containers from 'adaptivecards-designer/containers';
	import { DeviceEmulation } from 'adaptivecards-designer/device-emulation';
	export * from 'adaptivecards-designer/adaptivecards-designer-standalone';
	export * from 'adaptivecards-designer/containers/index';
	export const defaultMicrosoftHosts: containers.HostContainer[];
	export const defaultMicrosoftDeviceEmulations: DeviceEmulation[];

}
